<rrxdescription hide="self">
<rrx4app>

<rrx namespace="JSONWebService" v="1.0.0">
	<com ref="Datacap.Libraries.JSONWebService.Actions" qi="Description of action library">
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="GetValuesfromJSON" qi="sample method declaration in RRX">
			<p name="URL" qi="Webservice URL name">
			</p>
			<p name="Input" qi="Input Field Name">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="Templates" v="8.0.0">
	<i ref="rrunner">
	</i>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['*********************************]]>
<![CDATA[
]]>
<![CDATA['template Actions]]>
<![CDATA[
]]>
<![CDATA['Templates.rrx]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' "Restricted Materials of IBM"]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' (c) Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version]]>
<![CDATA[
]]>
<![CDATA['  9.0.0 - 02/14/2011   Tom Stuart]]>
<![CDATA[
]]>
<![CDATA['        - Original Template RRX File]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['*********************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
	<f name="RemoveChildrenByStatus" access="public" qi="Delete child objects by status">
		<ap>
<![CDATA[
]]>
<![CDATA[   Status - the current status of the child objects you wish to delete]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[        This action, when placed on an object, will check the status of all child objects and delete the ones]]>
<![CDATA[
]]>
<![CDATA[from the current parent.  Note:if you delete pages, the images will still exist in the batch directory, but]]>
<![CDATA[
]]>
<![CDATA[the reference to them will be removed from the page file.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        RemoveChildrenByStatus(75)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[
]]>
<![CDATA[      Any level.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    Always TRUE ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<see>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</see>
		<p name="ChildStatus">
		</p>
		<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Your VBScript code goes here.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    RemoveChildrenByStatus = TRUE       'Actions must always return a TRUE or FALSE.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    for i = CurrentObj.NumOfChildren -1 to 0 step - 1]]>
<![CDATA[
]]>
<![CDATA[       if cLng(CurrentObj.GetChild(i).Status) = cLng(ChildStatus) then]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Deleting: " & CurrentObj.GetChild(i).Type)]]>
<![CDATA[
]]>
<![CDATA[          CurrentObj.DeleteChild(i)]]>
<![CDATA[
]]>
<![CDATA[       end if]]>
<![CDATA[
]]>
<![CDATA[    next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</g>
	</f>
	<f name="MoveBatchPageToPreviousDocument" access="public" qi="Take a batche's child pages and move them to a document structure">
		<ap>
<![CDATA[
]]>
<![CDATA[   NewDocumentType]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[        This action, when placed on a page that is a child of the batch level object, will move it in to the previous document structure, or create a new document structure if no previous document exists]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        MoveBatchPageToPreviousDocument(OtherDoc)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[
]]>
<![CDATA[      Page Level, but will execute only if the page's parent is the batch level object.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[    Always TRUE ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ret>
		<see>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</see>
		<p name="NewDocumentType">
		</p>
		<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Your VBScript code goes here.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Dim oNewDoc]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    MoveBatchPageToPreviousDocument = TRUE       'Actions must always return a TRUE or FALSE.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    if CurrentObj.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("This action is to be placed on page objects only.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If currentObj.Parent.ObjectType <> 0 then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("This action will only execute on pages that are not already assigned to a document.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    CurrentBatchIndex = CurrentObj.Parent.FindChildIndex(CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    Writelog("CurrentBatchIndex: " & cStr(CurrentBatchIndex) )]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    if CurrentBatchIndex = 0 then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Page was first child.  Creating a document at the start of the batch")]]>
<![CDATA[
]]>
<![CDATA[       Set oNewDoc = DCO.AddChild(1,Pilot.BatchID & ".added",0)]]>
<![CDATA[
]]>
<![CDATA[       Call CurrentObj.MoveIn(oNewDoc,0)]]>
<![CDATA[
]]>
<![CDATA[       oNewDoc.Type = NewDocumentType]]>
<![CDATA[
]]>
<![CDATA[       oNewDoc.Status = 0]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[    CurrentBatchIndex = CurrentBatchIndex -1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    While CurrentBatchIndex > -1]]>
<![CDATA[
]]>
<![CDATA[       if DCO.GetChild(CurrentBatchIndex).ObjectType = 1 then]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Detected a document at index: " & cStr(CurrentBatchIndex) )]]>
<![CDATA[
]]>
<![CDATA[          Call CurrentObj.MoveIn(DCO.GetChild(CurrentBatchIndex),-1) ]]>
<![CDATA[
]]>
<![CDATA[          Exit Function]]>
<![CDATA[
]]>
<![CDATA[       end if]]>
<![CDATA[
]]>
<![CDATA[       CurrentBatchIndex = CurrentBatchIndex -1]]>
<![CDATA[
]]>
<![CDATA[    wend ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    if CurrentBatchIndex = 0 then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Page was first child.  Creating a document at the start of the batch")]]>
<![CDATA[
]]>
<![CDATA[       Set oNewDoc = DCO.AddChild(1,Pilot.BatchID & ".added",0)]]>
<![CDATA[
]]>
<![CDATA[       Call CurrentObj.MoveIn(oNewDoc,0)]]>
<![CDATA[
]]>
<![CDATA[       oNewDoc.Type = NewDocumentType]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
		</g>
	</f>
</rrx><rrx namespace="EdelweissCustomActions" src="C:\Datacap\Edelweiss_N\dco_Edelweiss_N\rules\EdelweissCustomActions.dll">

<net ref="EdelweissCustomActions.SampleAction">
	<method name="ChangeDateFormat">
		<p name="outputformat" type="string" qi="This is a example string type.  Smart parameters are supported.">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      Any additional parameter information can be placed here.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Date Re formation]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ChangeDateFormat("MM/DD/YYYY")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This is the action example.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Field level Only.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="GetBetweenWorddata">
		<p name="from" type="string" qi="This is a example string type.  Smart parameters are not supported.">
		</p>
		<p name="To" type="string" qi="This is a example string type.  Smart parameters are not supported.">
		</p>
	</method>
</net>
</rrx>
</rrx4app><rrx4all>

<rrx namespace="Barcode_X" v="9.0.0.21" qi="All actions in this library have been deprecated and should be replaced with corresponding actions from the barcode_p library.">
	<i ref="rrunner">
	</i>
	<i ref="recog_shared">
	</i>
	<i ref="barcode_p">
	</i>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' barcode_x.rrx - Recognition Actions]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.02" ]]>
<![CDATA[
]]>
<![CDATA['Updated 03/08/2007 EKuzmin]]>
<![CDATA[
]]>
<![CDATA['	- SearchOrder implemented, MatchBarcode - checks for equivalence]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.1.03" ]]>
<![CDATA[
]]>
<![CDATA['Updated 01/29/2008 TScholl]]>
<![CDATA[
]]>
<![CDATA['	- Updated action Information]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.01"]]>
<![CDATA[
]]>
<![CDATA[' Updated 4/29/2008 NSK ]]>
<![CDATA[
]]>
<![CDATA[' Get setup parameters from runtime DCO if present]]>
<![CDATA[
]]>
<![CDATA[' MatchBarCode enhanced to use setup parameters, previously was using defaults]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.02"]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/3/2008 NSK ]]>
<![CDATA[
]]>
<![CDATA[' Removed reference of rrunner and recog_shared - not needed]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.03"]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/17/2008 NSK ]]>
<![CDATA[
]]>
<![CDATA[' Put back reference to rrunner - needed]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.04"]]>
<![CDATA[
]]>
<![CDATA[' Updated 4/24/2009 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Added option to call ReadBarCode via DCOProcessor, if it is enabled]]>
<![CDATA[
]]>
<![CDATA[' Added InitBarCodeX function for initialization]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "7.5.05"]]>
<![CDATA[
]]>
<![CDATA[' Updated 4/27/2009 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Added reference to recog_shared.rrx file]]>
<![CDATA[
]]>
<![CDATA[' The rrx now uses the more ]]>
<![CDATA[
]]>
<![CDATA[' robust "IsAlive" helper function to determine if the DCOprocessor object is valid or not (replacing "IsObject").]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.06"]]>
<![CDATA[
]]>
<![CDATA[' Updated 4/30/2009 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 19745 Added G tags to make the XML format more compliant.  Standardized help formatting and modified some help text.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.07"]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/03/2009 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' SPR 25276. Added creation of the goBarCodeX object if it doesn't exist to MatchBarcode action]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.08"]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/9/2009 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' SPR 25276. Added global synchronization object to MatchBarCode action to protect call to barcode.dll from simultaneous use]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.09"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/06/2010 Rferin]]>
<![CDATA[
]]>
<![CDATA[' SPR 26966.  Changed function BarCodeX to read from oDCO instead of CurrentObj. ]]>
<![CDATA[
]]>
<![CDATA[' Fixed documented return value and text descriptions for ReadBarCode, MatchBarcode and GetBarCode.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 02/16/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' SPR 27332 (Isuue #6). Fixed bug in BarCodeX function not to set default values (they are defined in barcode.dll).]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/12/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 27224 Change GetBarCode so it always returns True.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/16/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' SPR 28124 Adeed 'Set ogSemaphore = Nothing' to MatchBarcode action]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.13"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/13/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' SPR 28337 Renamed ogSemaphore to oSemaphore. As it is not a global object.]]>
<![CDATA[
]]>
<![CDATA[' Changed the semaphore to be used from "DCSync.GlobalSingleSemaphore" to "DCSync.NamedSingleSemaphore"]]>
<![CDATA[
]]>
<![CDATA[' Now requires version of dcsync.dll v 8.0.0.2 or newer]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.14"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/18/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 27215 Added help text regarding Datacap Studio Barcode_x zones tab settings.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.15"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/21/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Changed the semaphore to be used from "DCSync.NamedSingleSemaphore" to "DCSync.NamedSemaphore"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.16"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/14/2010]]>
<![CDATA[
]]>
<![CDATA[' All barcode recognition actions now make direct calls to the corresponding actions in barcode_p.rrx. This solves a backwards compatibility issue ]]>
<![CDATA[
]]>
<![CDATA[' when barcode_x.rrx actions are used.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.17" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/04/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Fixes abort in action GetBarcode]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.18" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/26/2011 Rferin]]>
<![CDATA[
]]>
<![CDATA[' 32032 Updated copyright.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.19" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/15/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Removed file extension name (extn) from <i ref="namespace.extn"> tags, just uses namespace for use]]>
<![CDATA[
]]>
<![CDATA['   with TM8.01 locale RRS. Now looks like <i ref="namespace">.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.20" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/14/2014 Rferin]]>
<![CDATA[
]]>
<![CDATA[' 106586 Added help text to state the actions are deprecated and that Barcode_P should be used instead. ]]>
<![CDATA[
]]>
<![CDATA[' A help update only, the Barcode_X actions still continue to work as before.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[Version = "9.0.0.21" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/06/2015 Rferin]]>
<![CDATA[
]]>
<![CDATA[' 128343 Changed actions that were previously marked as depricated to Private.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' LOG RRA VERSION:]]>
<![CDATA[
]]>
<![CDATA[Writelog("Barcode_X action library version " & Version)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['********************************************************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Global entries ---------------------------------------------------->]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim goBarCodeX]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</rrx>
<rrx namespace="CC" v="9.0.0.9">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA['IBM Content Classification Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' "Restricted Materials of IBM"]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.1"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/05/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Replaces ICM.rrx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.2"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/06/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for action ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version ="8.1.0.3"]]>
<![CDATA[
]]>
<![CDATA['Updated 03/07/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA['Changed Datacap.Libraries.ICM namespace to Datacap.Libraries.CC and updated help text for action FindFingerprintCC to remove extra carriage return.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version ="8.1.0.4"]]>
<![CDATA[
]]>
<![CDATA['Updated 06/05/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA['Updated help text for action FindFingerprintCC]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version ="8.1.0.5"]]>
<![CDATA[
]]>
<![CDATA['Updated 06/07/2012 CMcGhee]]>
<![CDATA[
]]>
<![CDATA['Updated help text for action SetProblemValueCC]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version= "9.0.0.1"]]>
<![CDATA[
]]>
<![CDATA['Updated 9/25/2015 JMartinez]]>
<![CDATA[
]]>
<![CDATA['Added actions SetDecisionPlanCC, SetDecisionPlanFieldsCC,  RunDecisionPlanCC. Private: RunDecisionPlanForFileInVariableCC,ClassifyTextCC, ClassifySeparateBlocksCC]]>
<![CDATA[
]]>
<![CDATA['Added deprecation notice for the action FindFingerprintCC, replaced with ClassifyCC]]>
<![CDATA[
]]>
<![CDATA['Added action ClassifyCC]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version= "9.0.0.2"]]>
<![CDATA[
]]>
<![CDATA['Updated 10/01/2015 JMartinez ]]>
<![CDATA[
]]>
<![CDATA['Added actions ClassifyTextCC and RunDecisionPlanForTextCC to classify any text. 118212]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version= "9.0.0.3"]]>
<![CDATA[
]]>
<![CDATA['Updated 10/02/2015 JMartinez 118203]]>
<![CDATA[
]]>
<![CDATA[' When running classification via a knowledge base (ClassifyCC, ClassifyTextCC actions) a list of matches and their confidence values is kept in the variables "MatchinCategoryX", "MatchinCategoryConfX". Variable "MatchingCategoriesCount" is also populated with the number of matches retured.]]>
<![CDATA[
]]>
<![CDATA[' The behavior of the ClassifyCC can be altered so that it does not update the page type with the classification with the highest confidence. This can be done by setting the variable "UpdateDCOType" to "0" prior to calling this action.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version= "9.0.0.4"]]>
<![CDATA[
]]>
<![CDATA['Updated 10/06/2015 JMartinez 118203]]>
<![CDATA[
]]>
<![CDATA[' Added action RunDecisionPlanForBlocksCC]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version= "9.0.0.5"]]>
<![CDATA[
]]>
<![CDATA['Updated 10/06/2015 JMartinez 118203]]>
<![CDATA[
]]>
<![CDATA[' Updated action help.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version= "9.0.0.6"]]>
<![CDATA[
]]>
<![CDATA['Updated 10/30/2015 JMartinez 118203]]>
<![CDATA[
]]>
<![CDATA[' Updated actions help.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version= "9.0.0.7"]]>
<![CDATA[
]]>
<![CDATA['Updated 11/14/2015 JMartinez 133799]]>
<![CDATA[
]]>
<![CDATA[' Updated actions help.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version= "9.0.0.8"]]>
<![CDATA[
]]>
<![CDATA['Updated 11/16/2015 JMartinez 133799]]>
<![CDATA[
]]>
<![CDATA[' Updated actions help.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version= "9.0.0.9"]]>
<![CDATA[
]]>
<![CDATA['Updated 11/17/2015 JMartinez 133799]]>
<![CDATA[
]]>
<![CDATA[' Updated actions help.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = '9.1.3.10"]]>
<![CDATA[
]]>
<![CDATA['Updated 09/08/2017 MShah 172950]]>
<![CDATA[
]]>
<![CDATA[' Added NLC Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = '9.1.3.11"]]>
<![CDATA[
]]>
<![CDATA['Updated 09/27/2017 Xiaoying 173077]]>
<![CDATA[
]]>
<![CDATA[' Added Visual Recognition Actions for classification]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = '9.1.3.12"]]>
<![CDATA[
]]>
<![CDATA['Updated 10/05/2017 MShah 174643]]>
<![CDATA[
]]>
<![CDATA[' Added VisualRecogTrain and NLCClassifyText Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = '9.1.3.13"]]>
<![CDATA[
]]>
<![CDATA['Updated 10/05/2017 MShah 174643]]>
<![CDATA[
]]>
<![CDATA[' Change VR and NLC Classify actions to take the classifierName]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = '9.1.3.14"]]>
<![CDATA[
]]>
<![CDATA['Updated 10/11/2017 MShah 174643]]>
<![CDATA[
]]>
<![CDATA[' Moved VR and NLC Classify actions to DocumentAnalytics action library]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="Datacap.Libraries.CC.Actions" qi="IBM Content Classification Actions.">
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="FindFingerprintCC" qi="This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by ClassifyCC.">
			<h>
<![CDATA[
]]>
<![CDATA[        This Action has been marked for Deprecation and will removed in a future release. It has been replaced with Action ]]>
				<b>
<![CDATA[ClassifyCC]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the classification is successful. Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ClassifyCC" qi="Finds the closest matching document type and assigns the page type to the page.">
			<h>
<![CDATA[
]]>
<![CDATA[        This action identifies a page using the IBM Content Classification technology. This technology analyzes the full text of pages and attempts to find match within]]>
<![CDATA[
]]>
<![CDATA[        the Knowledge Base specified in the SetKnowledgeBaseCC action. If a match is found, the Page type is populated with the ID of the category that was matched.]]>
				<br>
				</br>
<![CDATA[ If a match is not]]>
<![CDATA[
]]>
<![CDATA[        found, the page type is set to "Other". ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        When classification is complete, a list of matches and their confidence values are stored in the ]]>
				<b>
<![CDATA["MatchingCategoryX"]]>
				</b>
<![CDATA[ and ]]>
				<b>
<![CDATA["MatchingCategoryConfX"]]>
				</b>
<![CDATA[ variables. The number of matches is stored in the variable ]]>
				<b>
<![CDATA["MatchingCategoriesCount"]]>
				</b>
<![CDATA[.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        To run classification without updating the page type, set the variable "UpdateDCOType" to "0" prior to calling this action. In this case classification will not update the page type, but the variables mentioned aboved will still be populated.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Because the matching relies on a page's full text, a full page recognition action must be called prior to using the ClassifyCC action. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Note:]]>
				</b>
<![CDATA[Starting in Taskmaster 9.0.1, this action supports classification of text located layout files generated by the ]]>
				<b>
<![CDATA[Recognize]]>
				</b>
<![CDATA[ actions in the ]]>
				<b>
<![CDATA[Ocr_a.rrx]]>
				</b>
<![CDATA[ and ]]>
				<b>
<![CDATA[Ocr_sr.rrx]]>
				</b>
<![CDATA[ action libraries.]]>
<![CDATA[
]]>
<![CDATA[        If a layout file is present, the action will automatically load it as the source of the text to be classified.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetListenerURLCC("http://localhost:18087")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetLanguageCC("English")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetKnowledgeBaseCC("Mortgage")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetProblemValueCC(0.9)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Recognize() ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ClassifyCC()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the fingerprint is found. Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetKnowledgeBaseCC" qi="Sets the name of the Content Classication Knowledge Base to use to classify documents.">
			<p name="KnowledgeBaseName" type="string" qi=" The name of the IBM Content Classification Knowledge Base. This parameter is required and cannot be empty. Smart parameters are supported.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the name of the IBM Content Classification Knowledge Base to use to classify documents in an application. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action must be called after the SetListenerURLCC action.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before the actions SetProblemValueCC and UpdateKnowledgeBaseCC.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetListenerURLCC("http://localhost:18087")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetKnowledgeBaseCC("Mortgage")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          UpdateKnowledgeBaseCC()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All. ]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[, if the parameter is empty. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetProblemValueCC" qi="Sets the minimum score for fingerprint matching.">
			<p name="MinScore" type="double" qi="Minimum score for fingerprint matching. Valid values are fractional values between zero and one (for example: 0.0 and 1.0) ">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        When ClassifyCC searches for a fingerprint match, a score between zero (no match) and one (a]]>
<![CDATA[
]]>
<![CDATA[        positive match) is calculated. This action sets the minimum score that a match must have]]>
<![CDATA[
]]>
<![CDATA[        to be considered a match. Any matches with a score less than the value specified is rejected.]]>
<![CDATA[
]]>
<![CDATA[        With this action, you can control the tolerance for documents matching an existing example. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        When setting up the parameter in your application, use the decimal character from the system locale defined]]>
<![CDATA[
]]>
<![CDATA[        for the application in the Taskmaster Application Manager.  For example, when the decimal character is]]>
<![CDATA[
]]>
<![CDATA[        a period, use a value from 0.0 to 1.0.  When the decimal character is a comma, use a value from 0,0 to 1,0.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before the FindFingerprintCC action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetListenerURLCC("http://localhost:18087")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetProblemValueCC(0.9)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ClassifyCC()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True ]]>
				</b>
<![CDATA[if the parameter value is between the valid range of zero to one (0.0 and 1.0) Otherwise, ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetLanguageCC" qi="Sets the language used in the specified Knowledge Base.">
			<p name="LanguageName" type="string" qi="The name of the language used in the specified Knowledge Base">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        This action sets the language of the specified Knowledge Base or Decision Plan.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before the ClassifyCC action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetListenerURLCC("http://localhost:18087")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetLanguageCC("English")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetKnowledgeBaseCC("Mortgage")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetProblemValueCC(0.9)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ClassifyCC()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetListenerURLCC" qi="Sets the URL of the CC Listener that will be used for classification.">
			<p name="URL" type="string" qi="The URL of the CC Listener that will be used for classification. Smart parameters are supported.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        This action configures the URL of the IBM Content Classification Listener that will be used for classification, and opens the connection to the IBM Content Classification Listener. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before the actions FindFingerprintCC, SetKnowledgeBaseCC, and UpdateKnowledgeBaseCC.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetListenerURLCC("http://localhost:18087") ]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetKnowledgeBaseCC("Mortgage")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetProblemValueCC(0.9)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ClassifyCC()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the service URL is successfully set.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[  Note that]]>
<![CDATA[
]]>
<![CDATA[        this action does not test that the CC Listener exists and is running.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetDecisionPlanCC" qi="Sets the name of the Content Classification Decision Plan to use to classify text.">
			<p name="DecisionPlanName" type="string" qi="Sets he name of the IBM Content Classification Decision Plan. This parameter is required and cannot be empty.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the name of the IBM Content Classification Decision Plan to use to classify text. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action must be called after the SetListenerURLCC action.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before the actions RunDecisionPlanCC, RunDecisionPlanForBlocksCC, and RunDecisionPlanForTextCC.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetListenerURLCC("http://localhost:18087")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetDecisionPlanCC("Mortgage")]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All. ]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[, if the parameter is empty. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetDecisionPlanFieldsCC" qi="Sets the Decision Plan fields separated by comma">
			<p name="DPFields" type="string" qi="Comma separated list of content field names to be extracted from the content classification decision plan. This parameter is required and cannot be empty.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the fields returned by Content Classification that are to be saved as DCO variables on the calling object.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action must be called before the actions RunDecisionPlanCC, RunDecisionPlanForBlocksCC, and RunDecisionPlanForTextCC.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetDecisionPlanFieldsCC("Title,Loan,Loan Type")]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All. ]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[, if the parameter is empty. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ClassifyTextCC" qi="Classifies blocks on the page">
			<p name="TextToClassify" type="string">
			</p>
			<ap>
				<dl>
					<dlentry>
						<dt>
<![CDATA[TextToClassify]]>
						</dt>
						<dd>
<![CDATA[Text to be classified. Smart parameters supported.]]>
						</dd>
					</dlentry>
				</dl>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Classifies text using knowledge base ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action must be called after the SetListenerURLCC, SetKnowledgeBaseICM actions. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        When classification is complete, a list of matches and their confidence values are stored in the ]]>
				<b>
<![CDATA["MatchingCategoryX"]]>
				</b>
<![CDATA[ and ]]>
				<b>
<![CDATA["MatchingCategoryConfX"]]>
				</b>
<![CDATA[ variables. The number of matches is stored in the variable ]]>
				<b>
<![CDATA["MatchingCategoriesCount"]]>
				</b>
<![CDATA[.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetListenerURLCC("http://localhost:18087")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetLanguageCC("English")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetKnowledgeBaseCC("Mortgage")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetProblemValueCC(0.9)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ClassifyTextCC("Place Text to classify here")]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All. ]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if no problem occurs. Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RunDecisionPlanForBlocksCC" qi="Runs a previously set decision plan on selected block types of a layout xml file.">
			<p name="blockTypes" type="string" qi="Comma separated values of block types to send to decision plan. Supported block types are Block, Table, Header , Footer, Title, H1, H2, H3, and Barcode. Smart parameters are supported.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sends the specified block types in the layout XML to Content Classification so that Content Classification can choose which block types to compare text to a KB and which to use in DP rules.  For example only comparing paragraph text to a KB may produce a better match by excluding text not specific to the category.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        The layout xml file can be created by the Recognize action in the ]]>
				<b>
<![CDATA[ocr_sr]]>
				</b>
<![CDATA[ or ]]>
				<b>
<![CDATA[ocr_a]]>
				</b>
<![CDATA[ action libraries. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action ]]>
				<b>
<![CDATA[must]]>
				</b>
<![CDATA[ be called after the SetListenerURLCC, SetDecisionPlanCC, SetDecisionPlanFieldsCC actions. ]]>
				<br>
				</br>
<![CDATA[ ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        To run the decision plan without updating the page type, set the variable "UpdateDCOType" to "0" prior to calling this action. In this case classification will not update the page type, but the variables mentioned aboved will still be populated.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        When the action is complete, the Decision Plan field results are stored as variables in the calling object. The variables created are named after the names of the fields specified in SetDecisionPlanFieldsCC, if this action is used. If the decision plan uses a KB and returns a matched category, a variable ]]>
				<b>
<![CDATA[MatchingCategory]]>
				</b>
<![CDATA[ will be created as well. Under this same scenario, the type of the calling object will be set to the name of the matching category, unless the variable "UpdateDCOType" is set to "0" prior to calling this action. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Field mapping]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When block xml data is passed to a decision plan, corresponding fields and the extracted text are created in the decicion plan. Below is a list of the fields created for each block type:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Block Type = Field Name in Decision Plan]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        --------------------------------------------]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Barcode = Barcode]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Block = Block]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Footer = Footer]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        H1 = Heading1]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        H2 = Heading2]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        H3 = Heading3]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Header = Header]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Para = Body]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Table = Table (single value field containing all the text in the table), and Cell (multivalue field containing all cells of the table)]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        To take advantage of these fields in a decision plan you must add input fields to your ICC solution.  See ICC documentation for adding input fields and mapping XML nodes to them.  Input fields can then be used in a decision plan rule or to include when performing a statistical comparison to a Knowledge Base.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Important!]]>
				</b>
<![CDATA[ Depending on the version of Content Classification installed, manual changes to the docFilterManager.xml file may be required in order to ensure proper data parsing of the blocks xml on the Content Classification server side. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To determine if manual changes are required: ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        1. Open the file %ContentClassificationInstallDir%\Filters\docFilterManager.xml in an xml or text editor.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        2. Perform a search for the string "XPATH-DATACAP". If the string is present, there are no further steps to perform. If the string is not present, please follow the instructions under "Content Classification Configuration" below to manually add the necessary configuration to this file.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Content Classification configuration]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        In order for Content Classification to successfully parse the block data sent by the action RunDecisionPlanForBlocksCC, it is necessary to make manual changes to the docFilterManager.xml file is installed by Content Classification. The steps for this manual process are listed below.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        1. Make a backup copy of the existing docFilterManager.xml file. Typically, this file is located in the %ContentClassificationInstallDir%\Filters directory, for example C:\IBM\ContentClassification\Filters.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        2. Open docFilterManager.xml in a xml or text editor.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        3. Locate the xml element ]]>
				<b>
<![CDATA[AllFilters]]>
				</b>
<![CDATA[.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        4. Add the following ]]>
				<b>
<![CDATA[Filter]]>
				</b>
<![CDATA[ element to the ]]>
				<b>
<![CDATA[AllFilters]]>
				</b>
<![CDATA[ node. ]]>
				<b>
<![CDATA[Note]]>
				</b>
<![CDATA[ make sure to replace ]]>
				<b>
<![CDATA[«]]>
				</b>
<![CDATA[ and ]]>
				<b>
<![CDATA[»]]>
				</b>
<![CDATA[ with the corresponding less than and greater than symbols.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        «Filter» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «FilterName»XPATH-DATACAP«/FilterName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «Timeout»30«/Timeout» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «NvpMapping» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «PropName»/P/Block/«/PropName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «NvpName»Block«/NvpName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «/Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «PropName»/P/Header/«/PropName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «NvpName»Header«/NvpName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «/Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «PropName»/P/Footer/«/PropName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «NvpName»Footer«/NvpName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «/Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «PropName»/P/Title/«/PropName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «NvpName»Title«/NvpName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «/Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «PropName»/P/H1/«/PropName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «NvpName»Heading1«/NvpName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «/Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «PropName»/P/H2/«/PropName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «NvpName»Heading2«/NvpName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «/Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «PropName»/P/H3/«/PropName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «NvpName»Heading3«/NvpName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «/Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «PropName»/P/Barcode/«/PropName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «NvpName»Barcode«/NvpName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «/Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «PropName»/P/Table//«/PropName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «NvpName»Table«/NvpName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «/Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «PropName»/P/Table/Row/Cell«/PropName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «NvpName»Cell«/NvpName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «/Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «PropName»/P/Para/«/PropName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «NvpName»Body«/NvpName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «/Property» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «/NvpMapping» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «/Filter» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        5. Locate the xml element ]]>
				<b>
<![CDATA[AllWorkflows]]>
				</b>
<![CDATA[.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        6. Add the following ]]>
				<b>
<![CDATA[Workflows]]>
				</b>
<![CDATA[ element to the ]]>
				<b>
<![CDATA[AllWorkflows]]>
				</b>
<![CDATA[ node.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «WorkFlows» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «AllMetaData» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «TP_Extension»xmldc«/TP_Extension» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «/AllMetaData» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «FilterName»XPATH-DATACAP«/FilterName» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        «/WorkFlows» ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        7. Save and close the docFilterManager.xml file.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetListenerURLCC("http://localhost:18087")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetDecisionPlanCC("Mortage")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetDecisionPlanFieldsCC("Title,Loan,Loan Type")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RunDecisionPlanForBlocksCC("Table,Block")]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page. ]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if a decision plan name is not specified, or the action is not called at the page level, or a connection to the Content Classification server cannot be established. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RunDecisionPlanForTextCC" qi="Classifies blocks on the page">
			<p name="TextToClassify" type="string" qi="Text to be classified. Smart parameters supported.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Classifies text using decision plans ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action must be called after the SetListenerURLCC, SetKnowledgeBaseICMCC, SetDecisionPlanCC, SetDecisionPlanFieldsCC, actions.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To run the decicion plan without updating the page type, set the variable "UpdateDCOType" to "0" prior to calling this action. In this case classification will not update the page type, but the variables mentioned aboved will still be populated.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetListenerURLCC("http://localhost:18087")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetDecisionPlanCC("Mortgage")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetDecisionPlanFieldsCC("Title,Loan,Loan Type")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RunDecisionPlanForTextCC(@F)]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All. ]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if a decision plan name is not specified, or the action is not called at the page level, or a connection to the Content Classification server cannot be established. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RunDecisionPlanCC" qi="Runs decision plan on top of the page">
			<h>
<![CDATA[
]]>
<![CDATA[        Used to run the current page against the content classification decision plan specified in the ]]>
				<b>
<![CDATA[SetDecisionPlanCC]]>
				</b>
<![CDATA[ action, and]]>
<![CDATA[
]]>
<![CDATA[        extract the content fields specified in the ]]>
				<b>
<![CDATA[SetDecisionPlanFieldsCC]]>
				</b>
<![CDATA[ action. This action uses the recognition data located in layout xml, cco, or txt files associated to the calling dco page object.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action must be called after the SetListenerURLCC, SetDecisionPlanCC, SetDecisionPlanFieldsCC actions.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To run the decision plan without updating the page type, set the variable "UpdateDCOType" to "0" prior to calling this action. In this case classification will not update the page type, but the variables mentioned aboved will still be populated.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Because the matching relies on a page's full text, a full page recognition action must be called]]>
<![CDATA[
]]>
<![CDATA[        prior to using the RunDecisionPlanCC action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          Recognize() ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetListenerURLCC("http://localhost:18087")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetDecisionPlanCC("MortgageDp")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetDecisionPlanFieldsCC("EmployeeId,Date")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RunDecisionPlanCC()]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level. ]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if a decision plan name is not specified, or the action is not called at the page level, or a connection to the Content Classification server cannot be established. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UpdateKnowledgeBaseCC" qi="Updates the CC Knowledge Base.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Provides classification feedback to the Content Clasification server.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Important:]]>
				</b>
<![CDATA[ this method is to be used to provide feedback to a previously trained knowledge base, and not to be used as the primary method for training a knowledge base from scratch. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Although training via feedback is not recommended to build the knowledge base, it is recommended that it is used to submit feedback on classification data returned on a "trained" category. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        For instance, let us use a knowledge base that contains 5 categories, 4 of which have been trained. When ]]>
				<i>
<![CDATA[ ClassifyCC]]>
				</i>
<![CDATA[ runs, it will either return a match or no match. When a match is found, it is recommended to provide feedback (using UpdateKnowledgeBaseCC) to the knowledge base to assert that the classification was correct.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When there is no match (no category returned) or there is a mismatch (wrong category returned), the recommended process is to export a copy of the document to a folder and train the knowledge base with these new documents via the Classification Workbench. After the new documents have been added, the knowledge based should be exported, and documents processed in Taskmaster to provide feedback. The training should be done in a non Production system, then moved to Production after testing. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Although it is recommended that this procedure is used to submit feedback on trained categories, it should be done for a period of time, and not indefinetely, since this can cause the knowledge base to grow very large. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        In conclusion, this action should be used only for documents where the classification result was correct, and should only be used during a period of time until the training on the knowledge base is complete.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetListenerURLCC("http://localhost:18087")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ClassifyCC()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[UpdateKnowledgeBaseCC()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[ if the IBM Content Classification Knowledge Base is successfully updated.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="Convert" v="9.1.1.60">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' Document Convertion Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM” ]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2016 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['---------------------------------------------------------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA['Version = "9.1.1.60" 164481]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/04/2017 RFerin ]]>
<![CDATA[
]]>
<![CDATA[' Updated annotation help in PDFFREDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.1.0.59" 118221]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/06/2016 RFerin]]>
<![CDATA[
]]>
<![CDATA[' The actions in Convert.PDF (PDFDocumentToImage) are deprecated and changed to use PDFFREDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.1.0.58" 132635]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/20/2016 RFerin]]>
<![CDATA[
]]>
<![CDATA[' Tweaked help text PDFFREDocumentToImage can include text annotations when y_IncludeAnnotation = 1.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.1.57" 151829]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/01/2016 RFerin]]>
<![CDATA[
]]>
<![CDATA[' Tweaked help text for PDFFRE setting y_contentReuseMode.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.56" 151829]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/01/2016 RFerin]]>
<![CDATA[
]]>
<![CDATA[' Tweaked help text for PDFFRE setting y_contentReuseMode.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.55" 151829]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/12/2016 RFerin]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for PDFFRE setting y_contentReuseMode.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.54" 139449]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/04/2016 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for PDF to TIF action to reflect proper location of map file.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.53"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/22/2016 MQureshi]]>
<![CDATA[
]]>
<![CDATA[' Added WordMonochromeQuality.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.52"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/15/2016 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for actions that extract images from PDF documents using VeryPDF. The help covers the fontfile.map setting for changing fonts used when converting PDf to TIF]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.51"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/23/2015 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated location of action CreateCcoFromLayout in help text. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.50"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/01/2015 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated documentation for the action PDFFREDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[' Version increased to .50 instead of .49 because there seemed to be a missing change notice for version .49.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.48"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/31/2015 RFerin]]>
<![CDATA[
]]>
<![CDATA[' Added OutlookAttachmentTypeIndicator to allow for emails that have incorrectly set mime types.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.47"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/04/2015 IMikhaylova]]>
<![CDATA[
]]>
<![CDATA[' Remove Actions Deprecated:PDFConversionMode,PDFDocumentToImage,PDFImageCompression,PDFImageFileExtension,PDFImageFileResolution,]]>
<![CDATA[
]]>
<![CDATA[' PDFImageUseFastBinarization,PDFJpegQuality]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.46"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/05/2015 Jmartinez]]>
<![CDATA[
]]>
<![CDATA[' Added information to the help text for action textPdfFre.PDFFREDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.45"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/04/2015 Jmartinez]]>
<![CDATA[
]]>
<![CDATA[' Corrected typos in help text for xxxToPdf actions.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.44"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/04/2015 MQureshi]]>
<![CDATA[
]]>
<![CDATA[' Pdf Known Limitations.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.43"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/18/2015 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added action PDFFREDocumentToImage which supports smart params. Added action PDFFREReleaseEngine which releases the resources used by the conversion engine.]]>
<![CDATA[
]]>
<![CDATA[' Deprecated all other actions in the PDFFre library., ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.43"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/15/2015 MQureshi]]>
<![CDATA[
]]>
<![CDATA[' Added HtmlLayout.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 9.0.0.42 01/15/2015 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * Updated the help text for the actions libs supporting file type X to Pdf conversion, to reflect parameters used to achieve desired Pdf compliance (Pdf15, PdfA1a, Pdfa1b) .]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 9.0.0.41 01/08/2015 MQureshi]]>
<![CDATA[
]]>
<![CDATA[' * Added SetNamePatternFileCheck.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 9.0.0.40 01/01/2015 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for the action PdfDocumentToImage to reflect new handling of searchable PDF documents]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 9.0.0.39 12/31/2014 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added following actions convert Word,Excel,Html,Txt,Rtf, to Pdf format.]]>
<![CDATA[
]]>
<![CDATA['   WordDocumentToPdf()]]>
<![CDATA[
]]>
<![CDATA['   ExcelWorkbookToPdf()]]>
<![CDATA[
]]>
<![CDATA['   HtmlToPdf()]]>
<![CDATA[
]]>
<![CDATA['   TxtToPdf()]]>
<![CDATA[
]]>
<![CDATA['   RtfToPdf()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 9.0.0.38 12/09/2014 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * Added PDFJpegQuality 110174]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 9.0.0.37 12/05/2014 MQureshi]]>
<![CDATA[
]]>
<![CDATA[' * Added ExcelWorkbookToImageEx.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 9.0.0.36 11/20/2014 MQureshi]]>
<![CDATA[
]]>
<![CDATA[' * Added ExcelShapeMinArea.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 9.0.0.35 10/08/2014 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Updated help for DeleteSourceImagePages action]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version 9.0.0.34 10/05/2014 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Added DeleteSourceImagePages action]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.33"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/04/2014 MQureshi]]>
<![CDATA[
]]>
<![CDATA[' * Added limited exception handling into Common.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.32"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/15/2014 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * Updated help text for Datacap.Libraries.Convert.PdfFre action library.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.31"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/09/2014 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * Added new library Datacap.Libraries.Convert.PdfFre which performs PDF to TIFF convertion using the Abbyy FineReader Engine.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.30"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/30/2014 MQureshi]]>
<![CDATA[
]]>
<![CDATA[' * Added TxtFontName and TxtFontSize.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.29"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/12/2014 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Added new method SetNamePattern in common class. Used to change default naming pattern for]]>
<![CDATA[
]]>
<![CDATA['   expanded files. Requires dcname 8.1.0.7]]>
<![CDATA[
]]>
<![CDATA[' * Updated Help with info on how to use SetNamePattern to overcome 1296 file limit. ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="Datacap.Libraries.Convert.Common" qi="Convert Actions Shared Settings">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      Shared Settings that apply to all convert actions.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="DeleteSourceImagePages" qi="Removes source image dco pages.">
			<ap>
<![CDATA[
]]>
<![CDATA[        None.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Use this action to remove pages where the associated file has been converted using the convert library actions.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action will evaluate all documents and pages that are children of the batch folder. It will delete any]]>
<![CDATA[
]]>
<![CDATA[        pages that have generated new pages as a result of the convert actions.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Note: Pages are only deleted from the DCO but not the batch directory.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[DeleteSourceImagePages()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the action is successful.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if an error is encountered.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetNamePattern" qi="Changes default naming pattern for converted files.">
			<p name="PatternType" type="string" qi="A single positive numeric value.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        Value of '1' or '2'. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        1: Uses default AlphaDecimal pattern, consisting of four pairs or two characters from 01 to ZZ.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        2: Uses TMxxxxxx pattern where xxxxxx is a number from 000001 to 999999.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetNamePattern(2)]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the setting is successful.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the setting is rejected.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetNamePatternFileCheck" qi="Configures file checking behavior in naming pattern for converted files.">
			<p name="fileCheck" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[ - Enable file checking, naming pattern will increment count if preexisting files are found]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        (Default).]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ - Disable file checking, preexisting files may be overwritten.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action only applies to the AlphaDecimal naming pattern.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Use this action to avoiding appending files to the batch directory.  When file checking is enabled, newer output]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        files]]>
<![CDATA[
]]>
<![CDATA[        will not overwrite preexisting files in cases like batch reprocessing, leading to increased disk consumption.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetNamePatternFileCheck(False)]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[
]]>
<![CDATA[        SetNamePattern]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExceptionSetHandler" qi="Sets the type of exception handling to be used during batch processing   failure.">
			<p name="handler" type="int" qi="Exception handler type.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[0]]>
				</b>
<![CDATA[ – Abort the batch (Default).]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[1]]>
				</b>
<![CDATA[ – Increment a variable in the runtime hierarchy, skip abort.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[2]]>
				</b>
<![CDATA[ – Raise a task condition, skip abort.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Use this action to change or reset the abort behavior caused by conversion failures.]]>
<![CDATA[
]]>
<![CDATA[        Avoiding aborts may be desirable when an external workflow handling process is already in place.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExceptionSetHandler(0)]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if a valid parameter is specified.  Otherwise, ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[
]]>
<![CDATA[        ExceptionSetFileTypes]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ExceptionSetVariableName]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ExceptionTaskCondition]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExceptionSetFileTypes" qi="Sets the file types to be monitored for exception handling.">
			<p name="types" type="string" qi="List of file extensions to monitor, comma delimited.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets one or more file types to be monitored for special exception handling.]]>
<![CDATA[
]]>
<![CDATA[        Unspecified file types encountering processing failures will cause abort without any further action.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, or the parameter is blank, then all file types will be monitored.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ExceptionSetHandler(1)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExceptionSetFileTypes(.pdf,.doc,.docx,xls,xlsx,.txt)]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[
]]>
<![CDATA[        ExceptionSetHandler]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExceptionSetVariableName" qi="Sets the runtime document hierarchy variable to be incremented upon   exception.">
			<p name="varName" type="string" qi="Variable to be incremented.  Smart Parameters are supported.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the variable to be incremented upon exception.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Default is '@B.ConvertExceptions' when exception handler is set to flag variable.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ExceptionSetHandler(1)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExceptionFlagVariable(@B.PDFConvertExceptions)]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[
]]>
<![CDATA[        ExceptionSetHandler]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExceptionSetTaskCondition" qi="Sets the task condition to be raised upon exception.">
			<p name="taskCondition" type="int" qi="Zero-based task condition index.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the task condition, defined in workflow administration, to be raised upon exception.]]>
<![CDATA[
]]>
<![CDATA[        Batch splitting is unsupported in this action, please see the ]]>
				<b>
<![CDATA[Split]]>
				</b>
<![CDATA[ action library for information on how to]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        setup splitting a batch using rules.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ExceptionSetHandler(2)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExceptionTaskCondition(0)]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[
]]>
<![CDATA[        ExceptionSetHandler]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Word" qi="Convert Word Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Word Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Word conversion will convert electronic DOC and DOCX documents to a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available Word]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the WordDocumentToImage to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in a single batch]]>
<![CDATA[
]]>
<![CDATA[      using the default Alphadecimal file name pattern is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      To scan more than 1296 files into a single batch requires using the ]]>
			<b>
<![CDATA[SetNamePattern]]>
			</b>
<![CDATA[ action with]]>
<![CDATA[
]]>
<![CDATA[      the parameter '2' which selects the alternate file naming pattern of TMxxxxxx. In this use case]]>
<![CDATA[
]]>
<![CDATA[      all files scanned or expanded from an original scanned file will be assigned the next available]]>
<![CDATA[
]]>
<![CDATA[      TMxxxxxx pattern where xxxxxx is a range from 1 to 999999; allowing upto a total of 999999 files]]>
<![CDATA[
]]>
<![CDATA[      in a single batch after all scanned files have been expanded.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the electronic document conversion actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the electronic document conversion actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the electronic document conversion actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Example Ruleset]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following shows a specific example ruleset and functions configured to process]]>
<![CDATA[
]]>
<![CDATA[      PDF, Word and Excel documents using the convert actions.  You can add more functions to process other]]>
<![CDATA[
]]>
<![CDATA[      file formats supported by convert, such as splitting tiff files, zip files, etc.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Execution runs through each of the functions until a function completes]]>
<![CDATA[
]]>
<![CDATA[      successfully.  The page status is first checked and then it attempts to convert the page.]]>
<![CDATA[
]]>
<![CDATA[      If the page is converted successfully, the page status is set to 75, meaning it is deleted.]]>
<![CDATA[
]]>
<![CDATA[      The function completes and no further processing is performed on the ruleset.]]>
<![CDATA[
]]>
<![CDATA[      If the document cannot be converted because the type doesn't match,]]>
<![CDATA[
]]>
<![CDATA[      then control passes to the next function and again attempts to convert the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Ruleset Convert Files]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process PDF]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - PDFDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Word]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - WordDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Excel]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ExcelWorkbookToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Setting the page to a deleted status allows that page to be skipped by subsequent processing.]]>
<![CDATA[
]]>
<![CDATA[      For example, if you use virtual scan create a batch containing a PDF document, then convert the PDF to a]]>
<![CDATA[
]]>
<![CDATA[      series of image files using the convert actions, it is likely that you no longer need to perform any further]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      processing]]>
<![CDATA[
]]>
<![CDATA[      on the input PDF file.  An application could skip processing of these pages, as needed, by first calling]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ChkDCOStatus("49")]]>
<![CDATA[
]]>
<![CDATA[      and the following actions in the function will only be run on pages that have that status.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      As a general rule, subsequent processing and recognition]]>
<![CDATA[
]]>
<![CDATA[      is performed on the TIFF files that were created at run time, such as the TIFF created from DOC file, not the parent]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      DOC file.]]>
<![CDATA[
]]>
<![CDATA[      Note that setting the page to deleted does not remove the page reference]]>
<![CDATA[
]]>
<![CDATA[      from the DCO and it does not delete the file from the batch directory.  Because the original]]>
<![CDATA[
]]>
<![CDATA[      file still exists, at export time it is possible to include the original document when exporting]]>
<![CDATA[
]]>
<![CDATA[      to an external repository.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="WordDocumentToImage" qi="Converts a page with *.doc or *.docx file to a page or pages in TIFF format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is a Word Document, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the Document, based on the settings of the other]]>
<![CDATA[
]]>
<![CDATA[        Word actions that configure the conversion settings.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If the configured output image format and compression]]>
<![CDATA[
]]>
<![CDATA[        only supports black and white, such as CCITT4, colored text is]]>
<![CDATA[
]]>
<![CDATA[        exported as black.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          WordPrintQuality(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          WordTiffCompression("CCITT4")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[WordDocumentToImage()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a Word Document or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="WordDocumentToPdf" qi="Converts *.doc or *.docx files to PDF document format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is a Word Document, this action will create a searchable PDF file using the text from the original document. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Unlike the standard conversion to image actions, this action does not create a new page object in the dco. It only updates the IMAGEFILE variable to point to the newly created PDF file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        By default the produced PDF documents are compliant with the Pdf15 standard. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To create PDF documents compliant with the PdfA1a standard, set the variable "targetPdfCompliance" to "1". ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To create PDF documents compliant with PdfA1b standard, set the variable "targetPdfCompliance" to "2". ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Note:]]>
				</b>
<![CDATA[The "targetPdfCompliance" variable must to be set to the desired value prior to calling the conversion]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        action, on the same DCO object level, in order for the setting to take effect.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[WordDocumentToPdf()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a PDF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a Word Document or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="WordMonochromeQuality" qi="Adjusts binarization settings used by WordDocumentToImage.">
			<p name="method" type="int">
			</p>
			<p name="threshold" type="float">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        method is one of the following values to set the binarization method:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[0]]>
				</b>
<![CDATA[ - Threshold]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[1]]>
				</b>
<![CDATA[ - FloydSteinbergDithering]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        threshold : A floating value between 0 and 1 for rendering brightness.  Lower values are darker.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Defaults compression to CCITT4 and sets the binarization settings used for black and white output.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default values of Threshold and 0.5 will be used for monochrome compression.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[WordMonochromeQuality(0,0.45)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          WordDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="WordPrintQuality" qi="Adjusts the resolution of the image output by WordDocumentToImage.">
			<p name="dpi" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        dpi : A single positive numeric value for the dots per inch (dpi) of the output image."]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the resolution of the output image for WordDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 200 dpi will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are 200 dpi.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[WordPrintQuality(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          WordDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="WordTiffCompression" qi="Sets the compression used in the TIFF output by WordDocumentToImage.">
			<p name="tiffCompression" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        tiffCompression is one of the following values to set the TIFF compression:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[NONE]]>
				</b>
<![CDATA[ – A color image with no compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[LZW]]>
				</b>
<![CDATA[ – A color image using LZW compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CCITT4]]>
				</b>
<![CDATA[ - A black and white image with fax CCITT4 compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the compression of the output image from WordDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of CCITT4 will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are black and white with fax compression.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[WordTiffCompression(CCITT4)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          WordDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Excel" qi="Convert Excel Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Excel Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Excel conversion will convert electronic XLS and XLXS documents to a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available Excel]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the ExcelWorkbookToImage to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in a single batch]]>
<![CDATA[
]]>
<![CDATA[      using the default Alphadecimal file name pattern is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      To scan more than 1296 files into a single batch requires using the ]]>
			<b>
<![CDATA[SetNamePattern]]>
			</b>
<![CDATA[ action with]]>
<![CDATA[
]]>
<![CDATA[      the parameter '2' which selects the alternate file naming pattern of TMxxxxxx. In this use case]]>
<![CDATA[
]]>
<![CDATA[      all files scanned or expanded from an original scanned file will be assigned the next available]]>
<![CDATA[
]]>
<![CDATA[      TMxxxxxx pattern where xxxxxx is a range from 1 to 999999; allowing upto a total of 999999 files]]>
<![CDATA[
]]>
<![CDATA[      in a single batch after all scanned files have been expanded.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the electronic document conversion actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the electronic document conversion actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the electronic document conversion actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Example Ruleset]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following shows a specific example ruleset and functions configured to process]]>
<![CDATA[
]]>
<![CDATA[      PDF, Word and Excel documents using the convert actions.  You can add more functions to process other]]>
<![CDATA[
]]>
<![CDATA[      file formats supported by convert, such as splitting tiff files, zip files, etc.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Execution runs through each of the functions until a function completes]]>
<![CDATA[
]]>
<![CDATA[      successfully.  The page status is first checked and then it attempts to convert the page.]]>
<![CDATA[
]]>
<![CDATA[      If the page is converted successfully, the page status is set to 75, meaning it is deleted.]]>
<![CDATA[
]]>
<![CDATA[      The function completes and no further processing is performed on the ruleset.]]>
<![CDATA[
]]>
<![CDATA[      If the document cannot be converted because the type doesn't match,]]>
<![CDATA[
]]>
<![CDATA[      then control passes to the next function and again attempts to convert the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Ruleset Convert Files]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process PDF]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - PDFDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Word]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - WordDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Excel]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ExcelWorkbookToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Setting the page to a deleted status allows that page to be skipped by subsequent processing.]]>
<![CDATA[
]]>
<![CDATA[      For example, if you use virtual scan create a batch containing a PDF document, then convert the PDF to a]]>
<![CDATA[
]]>
<![CDATA[      series of image files using the convert actions, it is likely that you no longer need to perform any further]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      processing]]>
<![CDATA[
]]>
<![CDATA[      on the input PDF file.  An application could skip processing of these pages, as needed, by first calling]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ChkDCOStatus("49")]]>
<![CDATA[
]]>
<![CDATA[      and the following actions in the function will only be run on pages that have that status.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      As a general rule, subsequent processing and recognition]]>
<![CDATA[
]]>
<![CDATA[      is performed on the TIFF files that were created at run time, such as the TIFF created from DOC file, not the parent]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      DOC file.]]>
<![CDATA[
]]>
<![CDATA[      Note that setting the page to deleted does not remove the page reference]]>
<![CDATA[
]]>
<![CDATA[      from the DCO and it does not delete the file from the batch directory.  Because the original]]>
<![CDATA[
]]>
<![CDATA[      file still exists, at export time it is possible to include the original document when exporting]]>
<![CDATA[
]]>
<![CDATA[      to an external repository.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelWorkbookToImage" qi="Converts a page with *.xls or *.xlsx file to a page or pages in TIFF format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is an Excel Workbook, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the Workbook, based on the settings of the other]]>
<![CDATA[
]]>
<![CDATA[        Excel actions that configure the conversion settings.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If the configured output image format and compression]]>
<![CDATA[
]]>
<![CDATA[        only supports black and white, such as CCITT4, colored text is]]>
<![CDATA[
]]>
<![CDATA[        exported as black and background shading will be set to white.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ExcelPrintQuality(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelTiffCompression(CCITT4)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelPrintBlankPage(False)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelWorkbookToImage()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not an Excel Workbook or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelWorkbookToPdf" qi="Converts *.xls or *.xlsx files to PDF document format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is an Excel Workbook, this action will create a searchable PDF file using the text from the original document. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Unlike the standard conversion to image actions, this action does not create a new page object in the dco. It only updates the IMAGEFILE variable to point to the newly created PDF file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        By default the produced PDF documents are compliant with the Pdf15 standard. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To create PDF documents compliant with the PdfA1b standard, set the variable "targetPdfCompliance" to "1". ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Note:]]>
				</b>
<![CDATA[The "targetPdfCompliance" variable must to be set to the desired value prior to calling the conversion]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        action, on the same DCO object level, in order for the setting to take effect.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelWorkbookToPdf()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a PDF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not an Excel Document or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelWorkbookToImageEx" qi="Converts a page with *.xls or *.xlsx file to a page or pages in TIFF   format.">
			<p name="maxOutputPages" type="int">
			</p>
			<p name="startingSheet" type="int">
			</p>
			<p name="singleSheetOutput" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        maxOutputPages : Zero to convert all pages within the spreadsheet, or a positive integer value.  Default is 0.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        startingSheet : Zero-based sheet index denoting the starting point of conversion.  Default is 0.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        singleSheetOutput : True to only convert the starting sheet.  Default is false.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is an Excel Workbook, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the Workbook, based on parameter values and settings of the other]]>
<![CDATA[
]]>
<![CDATA[        Excel actions that affect conversion.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The number of converted pages can be capped to avoid excessive output.  Similarly, the starting]]>
<![CDATA[
]]>
<![CDATA[        sheet index is specifiable; if the value is out of range then the last sheet will be used.  Conversion]]>
<![CDATA[
]]>
<![CDATA[        is limited to a single sheet when specifically enabled or the maximum converted page count has been met.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If the configured output image format and compression]]>
<![CDATA[
]]>
<![CDATA[        only supports black and white, such as CCITT4, colored text is]]>
<![CDATA[
]]>
<![CDATA[        exported as black and background shading will be set to white.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ExcelPrintQuality(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelTiffCompression(CCITT4)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelPrintBlankPage(False)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelWorkbookToImage()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not an Excel Workbook or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelPrintQuality" qi="Adjusts the resolution of the image output by ExcelWorkbookToImage.">
			<p name="dpi" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        dpi : A single positive numeric value for the dots per inch (dpi) of the output image.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the resolution of the output image for ExcelWorkbookToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 200 dpi will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are 200 dpi.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelPrintQuality(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelTiffCompression" qi="Sets the compression used in the TIFF output by ExcelWorkbookToImage.">
			<p name="tiffCompression" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        tiffCompression is one of the following values to set the TIFF compression:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[NONE]]>
				</b>
<![CDATA[ – A color image with no compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[LZW]]>
				</b>
<![CDATA[ – A color image using LZW compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CCITT4]]>
				</b>
<![CDATA[ - A black and white image with fax CCITT4 compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the compression of the output image from ExcelWorkbookToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of CCITT4 will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are black and white with fax compression.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelTiffCompression("CCITT4")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelPrintBlankPage" qi="Determines if blank pages are created when converting Excel Workbook to TIFF.">
			<p name="blankPage" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        blankPage : A Boolean value that enables or disables creation of blank TIFFs when there is a blank Excel]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        page.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ A blank TIFF will be created if the page is blank.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ A blank TIFF will not be created if the page is blank.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        When printing an Excel Workbook, it is typical to have overflow pages that sometimes]]>
<![CDATA[
]]>
<![CDATA[        have data and sometimes are blank.  Setting the value to true will create a TIFF]]>
<![CDATA[
]]>
<![CDATA[        for the blank overflow pages in this process.  If this action is not called before]]>
<![CDATA[
]]>
<![CDATA[        ExcelWorkbookToImage, then the default of False will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelPrintBlankPage("False")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelOrientationToPortrait" qi="Forces the orientation of Excel files to portrait for   ExcelWorkbookToImage.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The TIFF files created from ExcelWorkbookToImage will all be created with a portrait orientation.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before ExcelWorkbookToImage.  If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[        the portrait / landscape setting that was saved in the original Excel file will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelOrientationToPortrait()]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelOrientationToLandscape" qi="Forces the orientation of Excel files to landscape for   ExcelWorkbookToImage.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The TIFF files created from ExcelWorkbookToImage will all be created with a landscape orientation.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before ExcelWorkbookToImage.  If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[        the portrait / landscape setting that was saved in the original Excel file will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelOrientationToLandscape()]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelScalingFactor" qi="Forces the print scaling of Excel Workbook to a specific value for   ExcelWorkbookToImage.">
			<p name="percent" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[percent]]>
				</b>
<![CDATA[ : A positive integer that controls the scaling by percentage used when converting an Excel Workbook]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        to TIFF.]]>
<![CDATA[
]]>
<![CDATA[        For example, a value of 100 means to print at 100%.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The TIFF files created from ExcelWorkbookToImage will all use the specified printing]]>
<![CDATA[
]]>
<![CDATA[        scale value when converted to TIFF.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before ExcelWorkbookToImage.  If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[        the scaling factor that was saved in the original Excel file will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelScalingFactor(100)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelShapeMinArea" qi="Specifies the minimum area required for shape rendering by ExcelWorkbookToImage.">
			<p name="minShapeArea" type="long">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        minShapeArea : -1 to render all shapes, 0 to remove all shapes, or a postive pixel value.  Default is -1.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the minimum pixel area required by shape objects in a workbook.  When a positive numeric value is specified,]]>
<![CDATA[
]]>
<![CDATA[        any shape whose area is less than the parameter value will not be output during ExcelWorkBookToImage.]]>
<![CDATA[
]]>
<![CDATA[        Shapes include object types such as lines, rectangles, and charts.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelShapeMinArea(100)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelPrintGridlines" qi="Enables or disables gridlines when converting Excel files to TIFF.">
			<p name="gridlines" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        gridlines : A Boolean value that determines if gridlines are displayed in Excel files converted to TIFF.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ Gridlines will be included in the converted image.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ Gridlines will not be shown in the converted image.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The TIFF files created from ExcelWorkbookToImage will all use the specified grid]]>
<![CDATA[
]]>
<![CDATA[        setting when converted to TIFF.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before ExcelWorkbookToImage.  If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[        the gridline setting that was saved in the original Excel file will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelPrintGridlines("False")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelAutoFitColumns" qi="Sets the automatic sizing of all columns for Excel Workbook converted to TIFF.">
			<p name="autoFitColumns" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        autoFitColumns : A Boolean value that enables and disables the automatic sizing of columns in an Excel]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ The columns will be set to automatically adjust the size based on the content.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ The columns will not have their size adjusted.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This enables the auto sizing of columns to shrink or increase the size of the column]]>
<![CDATA[
]]>
<![CDATA[        to fit all of the data within the column.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before ExcelWorkbookToImage.  If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[        the setting that was saved in the original Excel file will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelAutoFitColumns("False")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ExcelAutoFitRows" qi="Sets the automatic sizing of all rows for Excel Workbook converted to TIFF.">
			<p name="autoFitRows" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        autoFitRows : A Boolean value that enables and disables the automatic sizing of rows in an Excel file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ The rows will be set to automatically adjust the size based on the content.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ The rows will not have their size adjusted.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This enables the auto sizing of rows to shrink or increase the size of the row]]>
<![CDATA[
]]>
<![CDATA[        to fit all of the data within the row.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before ExcelWorkbookToImage.  If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[        the setting that was saved in the original Excel file will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ExcelAutoFitRows("False")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ExcelWorkbookToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Outlook" qi="Convert Outlook Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Outlook Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Outlook conversion will convert electronic MSG and EML documents to a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available Outlook]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the OutlookMessageToImageAndAttachment]]>
<![CDATA[
]]>
<![CDATA[      or OutlookMessageToAttachmentOnly to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in a single batch]]>
<![CDATA[
]]>
<![CDATA[      using the default Alphadecimal file name pattern is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      To scan more than 1296 files into a single batch requires using the ]]>
			<b>
<![CDATA[SetNamePattern]]>
			</b>
<![CDATA[ action with]]>
<![CDATA[
]]>
<![CDATA[      the parameter '2' which selects the alternate file naming pattern of TMxxxxxx. In this use case]]>
<![CDATA[
]]>
<![CDATA[      all files scanned or expanded from an original scanned file will be assigned the next available]]>
<![CDATA[
]]>
<![CDATA[      TMxxxxxx pattern where xxxxxx is a range from 1 to 999999; allowing upto a total of 999999 files]]>
<![CDATA[
]]>
<![CDATA[      in a single batch after all scanned files have been expanded.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the electronic document conversion actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the electronic document conversion actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the electronic document conversion actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Example Ruleset]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following shows a specific example ruleset and functions configured to process]]>
<![CDATA[
]]>
<![CDATA[      PDF, Word and Excel documents using the convert actions.  You can add more functions to process other]]>
<![CDATA[
]]>
<![CDATA[      file formats supported by convert, such as splitting tiff files, zip files, etc.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Execution runs through each of the functions until a function completes]]>
<![CDATA[
]]>
<![CDATA[      successfully.  The page status is first checked and then it attempts to convert the page.]]>
<![CDATA[
]]>
<![CDATA[      If the page is converted successfully, the page status is set to 75, meaning it is deleted.]]>
<![CDATA[
]]>
<![CDATA[      The function completes and no further processing is performed on the ruleset.]]>
<![CDATA[
]]>
<![CDATA[      If the document cannot be converted because the type doesn't match,]]>
<![CDATA[
]]>
<![CDATA[      then control passes to the next function and again attempts to convert the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Ruleset Convert Files]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process PDF]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - PDFDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Word]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - WordDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Excel]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ExcelWorkbookToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Setting the page to a deleted status allows that page to be skipped by subsequent processing.]]>
<![CDATA[
]]>
<![CDATA[      For example, if you use virtual scan create a batch containing a PDF document, then convert the PDF to a]]>
<![CDATA[
]]>
<![CDATA[      series of image files using the convert actions, it is likely that you no longer need to perform any further]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      processing]]>
<![CDATA[
]]>
<![CDATA[      on the input PDF file.  An application could skip processing of these pages, as needed, by first calling]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ChkDCOStatus("49")]]>
<![CDATA[
]]>
<![CDATA[      and the following actions in the function will only be run on pages that have that status.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      As a general rule, subsequent processing and recognition]]>
<![CDATA[
]]>
<![CDATA[      is performed on the TIFF files that were created at run time, such as the TIFF created from DOC file, not the parent]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      DOC file.]]>
<![CDATA[
]]>
<![CDATA[      Note that setting the page to deleted does not remove the page reference]]>
<![CDATA[
]]>
<![CDATA[      from the DCO and it does not delete the file from the batch directory.  Because the original]]>
<![CDATA[
]]>
<![CDATA[      file still exists, at export time it is possible to include the original document when exporting]]>
<![CDATA[
]]>
<![CDATA[      to an external repository.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="OutlookMessageToImageAndAttachment" qi="Converts a *.msg or *.eml file to a page or pages in TIFF   format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is an Outlook Message, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the Message, based on the settings of the other]]>
<![CDATA[
]]>
<![CDATA[        Outlook actions that configure the conversion settings.]]>
<![CDATA[
]]>
<![CDATA[        A copy of the original MSG file without attachments is created and converted to TIFF as well.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each attachment or embedded image within the e-mail will be removed from the e-mail and placed on disk.  A new page]]>
<![CDATA[
]]>
<![CDATA[        entry will be created for each attachment that can be processed by rules.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If the configured output image format and compression]]>
<![CDATA[
]]>
<![CDATA[        only supports black and white, such as CCITT4, colored text is]]>
<![CDATA[
]]>
<![CDATA[        exported as black.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          OutlookPrintQuality(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          OutlookTiffCompression("CCITT4")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[OutlookMessageToImageAndAttachment()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not an Outlook Message or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or if there is a failure in the conversion, the]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="OutlookMessageToAttachmentOnly" qi="Extracts attachments from *.msg or *.eml to pages without converting   the MSG to a TIFF.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is an Outlook Message, the attachments within the message]]>
<![CDATA[
]]>
<![CDATA[        will be saved as separate files.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each attachment or embedded image within the e-mail will be removed from the e-mail and placed on disk.  A new page]]>
<![CDATA[
]]>
<![CDATA[        entry will be created for each attachment that can be processed by subsequent rules.]]>
<![CDATA[
]]>
<![CDATA[        The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[OutlookMessageToAttachmentOnly()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the attachments are successfully extracted from the message, or if the message contains no]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        attachments.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not an Outlook Message or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[
]]>
<![CDATA[        OutlookMessageToImageAndAttachment]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="OutlookPrintQuality" qi="Adjusts the resolution of the image output by   OutlookMessageToImageAndAttachment.">
			<p name="dpi" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        dpi : A single positive numeric value for the dots per inch (dpi) of the output image.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the resolution of the output image for OutlookMessageToImageAndAttachment.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 200 dpi will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are 200 dpi.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[OutlookPrintQuality(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          OutlookMessageToImageAndAttachment()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="OutlookTiffCompression" qi="Sets the compression used in the TIFF output by OutlookMessageToImageAndAttachment.">
			<p name="tiffCompression" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        tiffCompression : A parameter of one of the following values to set the TIFF compression:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[NONE]]>
				</b>
<![CDATA[ – A color image with no compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[LZW]]>
				</b>
<![CDATA[ – A color image using LZW compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CCITT4]]>
				</b>
<![CDATA[ - A black and white image with fax CCITT4 compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the compression of the output image from OutlookMessageToImageAndAttachment.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of CCITT4 will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are black and white with fax compression.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[OutlookTiffCompression("CCITT4")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          OutlookMessageToImageAndAttachment()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="OutlookAttachmentTypeIndicator" qi="Determines if an email attachment type is set based on the extension or mime type.">
			<p name="typeIndicator" type="string" qi="Controls how attachment files are named.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MIME]]>
				</b>
<![CDATA[ – The attachment type is determined by the email mime type.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[EXT]]>
				</b>
<![CDATA[ – The attachment type is determined by the attachment extension.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        When e-mail attachments are saved to a file, the file type can be set based on the mime type specified in the e-mail]]>
<![CDATA[
]]>
<![CDATA[        or can be set based on the actual extension of the attachment.  This action is useful if you]]>
<![CDATA[
]]>
<![CDATA[        receive emails that may sometimes have an incorrect extension or incorrect mime type, allowing the application]]>
<![CDATA[
]]>
<![CDATA[        to name the extension based on the either setting.  If the primary setting is blank, then the alternative method will be used.]]>
<![CDATA[
]]>
<![CDATA[        For example, if the extension is set as the primary indicator and the attachment has a blank extension, then the]]>
<![CDATA[
]]>
<![CDATA[        mime type will be used.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, or if the provided typeIndicator parameter is incorrect, then the]]>
<![CDATA[
]]>
<![CDATA[        setting will default to "MIME" and saved attachments will be named based on the mime type indicated in the e-mail.]]>
<![CDATA[
]]>
<![CDATA[        To have an affect, this action needs to be called prior to an action that performs the attachment extraction.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        In a situation where the application needs to processes e-mails that have incorrect]]>
<![CDATA[
]]>
<![CDATA[        extensions, this action can be used to set the mime type as the indicator for the attachment file type.]]>
<![CDATA[
]]>
<![CDATA[        For example the attachment says *.txt but the mime type is listed as "application/pdf"]]>
<![CDATA[
]]>
<![CDATA[        and the mime type is the correct extension.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Conversely, if the application needs to process emails that have mime types set incorrectly, then the attachment extension can]]>
<![CDATA[
]]>
<![CDATA[        be set to the primary indicator for the file type extension.  For example, e-mails have an attachment mime type incorrectly set to]]>
<![CDATA[
]]>
<![CDATA[        "text/plain" but the attachments extensions are correctly set, say to PDF, then call this action to set the extension]]>
<![CDATA[
]]>
<![CDATA[        as the primary indicator for the attachment file type.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[OutlookAttachmentTypeIndicator("EXT")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          OutlookPrintQuality(300)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          OutlookMessageToImageAndAttachment()]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          This example will use the extension of the attachment to determine the file type of the attachment saved to disk.]]>
<![CDATA[
]]>
<![CDATA[          If the attachment is named "MyFile.PDF" and the mime type is set to text/plain, then the extracted attachment will have a "PDF" extension.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[OutlookAttachmentTypeIndicator("MIME")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          OutlookPrintQuality(300)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          OutlookMessageToImageAndAttachment()]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          This example will use the extension of the attachment to determine the file type of the attachment saved to disk.]]>
<![CDATA[
]]>
<![CDATA[          If the attachment is named "MyFile.PDF" and the mime type is set to "text/plain", then the extracted attachment will have a "TXT" extension.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Zip" qi="Convert Zip Archive Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[ZIP Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The ZIP conversion will convert extract the files contained within ZIP format files.  These]]>
<![CDATA[
]]>
<![CDATA[      files are then made available for their own processing.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in a single batch]]>
<![CDATA[
]]>
<![CDATA[      using the default Alphadecimal file name pattern is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      To scan more than 1296 files into a single batch requires using the ]]>
			<b>
<![CDATA[SetNamePattern]]>
			</b>
<![CDATA[ action with]]>
<![CDATA[
]]>
<![CDATA[      the parameter '2' which selects the alternate file naming pattern of TMxxxxxx. In this use case]]>
<![CDATA[
]]>
<![CDATA[      all files scanned or expanded from an original scanned file will be assigned the next available]]>
<![CDATA[
]]>
<![CDATA[      TMxxxxxx pattern where xxxxxx is a range from 1 to 999999; allowing upto a total of 999999 files]]>
<![CDATA[
]]>
<![CDATA[      in a single batch after all scanned files have been expanded.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the electronic document conversion actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the electronic document conversion actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the electronic document conversion actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Example Ruleset]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following shows a specific example ruleset and functions configured to process]]>
<![CDATA[
]]>
<![CDATA[      PDF, Word and Excel documents using the convert actions.  You can add more functions to process other]]>
<![CDATA[
]]>
<![CDATA[      file formats supported by convert, such as splitting tiff files, zip files, etc.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Execution runs through each of the functions until a function completes]]>
<![CDATA[
]]>
<![CDATA[      successfully.  The page status is first checked and then it attempts to convert the page.]]>
<![CDATA[
]]>
<![CDATA[      If the page is converted successfully, the page status is set to 75, meaning it is deleted.]]>
<![CDATA[
]]>
<![CDATA[      The function completes and no further processing is performed on the ruleset.]]>
<![CDATA[
]]>
<![CDATA[      If the document cannot be converted because the type doesn't match,]]>
<![CDATA[
]]>
<![CDATA[      then control passes to the next function and again attempts to convert the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Ruleset Convert Files]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process PDF]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - PDFDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Word]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - WordDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Excel]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ExcelWorkbookToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Setting the page to a deleted status allows that page to be skipped by subsequent processing.]]>
<![CDATA[
]]>
<![CDATA[      For example, if you use virtual scan create a batch containing a PDF document, then convert the PDF to a]]>
<![CDATA[
]]>
<![CDATA[      series of image files using the convert actions, it is likely that you no longer need to perform any further]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      processing]]>
<![CDATA[
]]>
<![CDATA[      on the input PDF file.  An application could skip processing of these pages, as needed, by first calling]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ChkDCOStatus("49")]]>
<![CDATA[
]]>
<![CDATA[      and the following actions in the function will only be run on pages that have that status.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      As a general rule, subsequent processing and recognition]]>
<![CDATA[
]]>
<![CDATA[      is performed on the TIFF files that were created at run time, such as the TIFF created from DOC file, not the parent]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      DOC file.]]>
<![CDATA[
]]>
<![CDATA[      Note that setting the page to deleted does not remove the page reference]]>
<![CDATA[
]]>
<![CDATA[      from the DCO and it does not delete the file from the batch directory.  Because the original]]>
<![CDATA[
]]>
<![CDATA[      file still exists, at export time it is possible to include the original document when exporting]]>
<![CDATA[
]]>
<![CDATA[      to an external repository.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ZipUnPack" qi="Extracts each file within a ZIP archive into separate files.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is a ZIP, the files contained in the archive will placed into]]>
<![CDATA[
]]>
<![CDATA[        the current batch directory.  Each new file will also have a new page created]]>
<![CDATA[
]]>
<![CDATA[        within the application environment which can be processed by subsequent rules.]]>
<![CDATA[
]]>
<![CDATA[        The original file name from which the page was extracted will be stored in the]]>
<![CDATA[
]]>
<![CDATA[        ParentImage variable, for possible future reference within your application.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ChkDCOStatus("49")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ZipUnPack()]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetDCOStatus("75")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          This example checks to see if the current page of type "other", if so, it tries to unzip the page.]]>
<![CDATA[
]]>
<![CDATA[          If the unzip is successful, then the current page was a valid zip file.  The files have now]]>
<![CDATA[
]]>
<![CDATA[          been removed from the zip and are located in the batch directory.  The next action]]>
<![CDATA[
]]>
<![CDATA[          sets the page status of the zip file to "Deleted".  This does not delete it from the batch, but]]>
<![CDATA[
]]>
<![CDATA[          stops further processing of the zip file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the contents of the ZIP file is successfully extracted.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a PDF or if there is a failure in the extraction.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or if there is a failure in the extraction, the]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ZipPassword" qi="Sets the password for Password protected archives that will be used by ZipUnPack.">
			<p name="pwd" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        pwd : The password for the archive.  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The password provided will be used to extract password protected archives.  This action must be called before]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ZipUnPack.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ChkDCOStatus("49")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ZipOverwrite("True")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ZipPassword("MySafePassword")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ZipUnPack()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetDCOStatus("75")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ZipOverwrite" qi="Controls overwriting files when extracting from ZIP archives.">
			<p name="overwrt" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        A Boolean value that indicates if a subsequent ZipUnPack action should overwrite existing files.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ Overwrite files that already exist.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ Do not overwrite files that already exist.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action must be called before ZipUnPack.  If this action is not called, then ZipUnPack will use the default]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        value of True.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ChkDCOStatus("49")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ZipOverwrite("True")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ZipUnPack()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetDCOStatus("75")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Tiff" qi="Multpage Tiff image tool Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[TIFF Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Tagged Image Format File conversion will convert multipage TIFs to a set of individual TIF files.]]>
<![CDATA[
]]>
<![CDATA[      One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in a single batch]]>
<![CDATA[
]]>
<![CDATA[      using the default Alphadecimal file name pattern is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      To scan more than 1296 files into a single batch requires using the ]]>
			<b>
<![CDATA[SetNamePattern]]>
			</b>
<![CDATA[ action with]]>
<![CDATA[
]]>
<![CDATA[      the parameter '2' which selects the alternate file naming pattern of TMxxxxxx. In this use case]]>
<![CDATA[
]]>
<![CDATA[      all files scanned or expanded from an original scanned file will be assigned the next available]]>
<![CDATA[
]]>
<![CDATA[      TMxxxxxx pattern where xxxxxx is a range from 1 to 999999; allowing upto a total of 999999 files]]>
<![CDATA[
]]>
<![CDATA[      in a single batch after all scanned files have been expanded.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the electronic document conversion actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the electronic document conversion actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the electronic document conversion actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Example Ruleset]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following shows a specific example ruleset and functions configured to process]]>
<![CDATA[
]]>
<![CDATA[      PDF, Word and Excel documents using the convert actions.  You can add more functions to process other]]>
<![CDATA[
]]>
<![CDATA[      file formats supported by convert, such as splitting tiff files, zip files, etc.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Execution runs through each of the functions until a function completes]]>
<![CDATA[
]]>
<![CDATA[      successfully.  The page status is first checked and then it attempts to convert the page.]]>
<![CDATA[
]]>
<![CDATA[      If the page is converted successfully, the page status is set to 75, meaning it is deleted.]]>
<![CDATA[
]]>
<![CDATA[      The function completes and no further processing is performed on the ruleset.]]>
<![CDATA[
]]>
<![CDATA[      If the document cannot be converted because the type doesn't match,]]>
<![CDATA[
]]>
<![CDATA[      then control passes to the next function and again attempts to convert the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Ruleset Convert Files]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process PDF]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - PDFDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Word]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - WordDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Excel]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ExcelWorkbookToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Setting the page to a deleted status allows that page to be skipped by subsequent processing.]]>
<![CDATA[
]]>
<![CDATA[      For example, if you use virtual scan create a batch containing a PDF document, then convert the PDF to a]]>
<![CDATA[
]]>
<![CDATA[      series of image files using the convert actions, it is likely that you no longer need to perform any further]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      processing]]>
<![CDATA[
]]>
<![CDATA[      on the input PDF file.  Subsequent processing and recognition]]>
<![CDATA[
]]>
<![CDATA[      will be on the new TIFF files that were created at run time.]]>
<![CDATA[
]]>
<![CDATA[      Note that setting the page to deleted does not remove the page reference]]>
<![CDATA[
]]>
<![CDATA[      from the DCO and it does not delete the file from the batch directory.  Because the original]]>
<![CDATA[
]]>
<![CDATA[      file still exists, at export time it is possible to include the original document when exporting]]>
<![CDATA[
]]>
<![CDATA[      to an external repository.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SplitMultipageTiff" qi="Creates separate images for each page in a multipage Tiff file.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is a TIFF, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the document.  If the input page was a single]]>
<![CDATA[
]]>
<![CDATA[        page TIFF file, a single page TIFF will still be output.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which]]>
<![CDATA[
]]>
<![CDATA[        the page was extracted will be stored in the ParentImage variable,]]>
<![CDATA[
]]>
<![CDATA[        for possible future reference within your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If the input TIFF has a bit depth of 1 (black and white), then the output compression will]]>
<![CDATA[
]]>
<![CDATA[        be set to group 4 fax.  If the input TIFF has a bit depth greater than 1, then the output]]>
<![CDATA[
]]>
<![CDATA[        compression will be uncompressed.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SplitMultipageTiff()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a TIFF or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SplitTIFFCompression" qi="Sets the compression method used in the TIFF output by SplitMultipageTiff.">
			<p name="compressionTypeColor" type="int">
			</p>
			<p name="compressionTypeBW" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        One of the following compression values are allowed.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[0:]]>
				</b>
<![CDATA[ Source Image compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[1:]]>
				</b>
<![CDATA[ No compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[2:]]>
				</b>
<![CDATA[ CCITT modified Huffman RLE. (BW 1 bit images only)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[3:]]>
				</b>
<![CDATA[ CCITT Group 3 T.4 fax. (BW 1 bit images only)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[4:]]>
				</b>
<![CDATA[ CCITT Group 4 T.6 fax. (BW 1 bit images only)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[5:]]>
				</b>
<![CDATA[ LZW Lempel-Ziv and Welch]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the compression of the output image from SplitMultipageTiff. The action automatically detects the image bit]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        depth]]>
<![CDATA[
]]>
<![CDATA[        (1 bit is a Black and White image, higher bit counts are treated as color) and uses the appropriate]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        compressionTypeColor or compressionTypeBW setting.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[BW 1 bit images only ]]>
				</i>
<![CDATA[ compression values used as a color setting will be ignored and will use the default]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        action compression setting for color images.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of CCITT4 (CITT Group 4 T.6) will be used for black and white]]>
<![CDATA[
]]>
<![CDATA[        pages and source page image compression for color pages.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SplitTIFFCompression(4,1)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SplitMultipageTiff()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the compression setting was successfull.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the compression setting used is not a supported type.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Pdf" qi="PDF conversion Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[PDF Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The PDF conversion will convert electronic PDF documents to a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available PDF]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the PDFDocumentToImage to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in a single batch]]>
<![CDATA[
]]>
<![CDATA[      using the default Alphadecimal file name pattern is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      To scan more than 1296 files into a single batch requires using the ]]>
			<b>
<![CDATA[SetNamePattern]]>
			</b>
<![CDATA[ action with]]>
<![CDATA[
]]>
<![CDATA[      the parameter '2' which selects the alternate file naming pattern of TMxxxxxx. In this use case]]>
<![CDATA[
]]>
<![CDATA[      all files scanned or expanded from an original scanned file will be assigned the next available]]>
<![CDATA[
]]>
<![CDATA[      TMxxxxxx pattern where xxxxxx is a range from 1 to 999999; allowing upto a total of 999999 files]]>
<![CDATA[
]]>
<![CDATA[      in a single batch after all scanned files have been expanded.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[PDF Considerations]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      If you have separately purchased the DCPDF option, do not mix use the actions provided]]>
<![CDATA[
]]>
<![CDATA[      with the DCPDF Library (DCPDF.rrx) mixed with the actions from Convert within the same]]>
<![CDATA[
]]>
<![CDATA[      task profile or your documents may not all be converted properly.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the electronic document conversion actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the electronic document conversion actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the electronic document conversion actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Example Ruleset]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following shows a specific example ruleset and functions configured to process]]>
<![CDATA[
]]>
<![CDATA[      PDF, Word and Excel documents using the convert actions.  You can add more functions to process other]]>
<![CDATA[
]]>
<![CDATA[      file formats supported by convert, such as splitting tiff files, zip files, etc.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Execution runs through each of the functions until a function completes]]>
<![CDATA[
]]>
<![CDATA[      successfully.  The page status is first checked and then it attempts to convert the page.]]>
<![CDATA[
]]>
<![CDATA[      If the page is converted successfully, the page status is set to 75, meaning it is deleted.]]>
<![CDATA[
]]>
<![CDATA[      The function completes and no further processing is performed on the ruleset.]]>
<![CDATA[
]]>
<![CDATA[      If the document cannot be converted because the type doesn't match,]]>
<![CDATA[
]]>
<![CDATA[      then control passes to the next function and again attempts to convert the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Ruleset Convert Files]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process PDF]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - PDFDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Word]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - WordDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Excel]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ExcelWorkbookToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Setting the page to a deleted status allows that page to be skipped by subsequent processing.]]>
<![CDATA[
]]>
<![CDATA[      For example, if you use virtual scan create a batch containing a PDF document, then convert the PDF to a]]>
<![CDATA[
]]>
<![CDATA[      series of image files using the convert actions, it is likely that you no longer need to perform any further]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      processing]]>
<![CDATA[
]]>
<![CDATA[      on the input PDF file.  Subsequent processing and recognition]]>
<![CDATA[
]]>
<![CDATA[      will be on the new TIFF files that were created at run time.]]>
<![CDATA[
]]>
<![CDATA[      Note that setting the page to deleted does not remove the page reference]]>
<![CDATA[
]]>
<![CDATA[      from the DCO and it does not delete the file from the batch directory.  Because the original]]>
<![CDATA[
]]>
<![CDATA[      file still exists, at export time it is possible to include the original document when exporting]]>
<![CDATA[
]]>
<![CDATA[      to an external repository.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Known Limitations:]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Datacap.Libraries.Convert.Pdf library actions do not support Unicode characters in the file name or path and PDFs that contain non-native style fonts might have limited or poor output. You can use the Datacap.Libraries.Convert.PdfFRE actions as a working alternative.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFDocumentToImage" qi="Create a TIFF image for each page in a PDF file.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[*** This Action Is Deprecated ***]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action has been deprecated and is scheduled to be removed in a future release.]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that you no longer use this action.]]>
<![CDATA[
]]>
<![CDATA[        Instead, use the PDFFREDocumentToImage action in the Convert.PDFFRE action library.        ]]>
<![CDATA[
]]>
<![CDATA[        Additionally, the font mapping file listed below in this action help is no longer used, instead]]>
<![CDATA[
]]>
<![CDATA[        the settings for the PDFFREDocumentToImage action are used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If the current page is a PDF, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the document.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which]]>
<![CDATA[
]]>
<![CDATA[        the page was extracted will be stored in the ParentImage variable, for]]>
<![CDATA[
]]>
<![CDATA[        possible future reference within your application.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[Important:]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      The font mapping file, used by the convert actions to extract images from PDF, uses "Lucida Sans Unicode" as the default font.  ]]>
<![CDATA[
]]>
<![CDATA[      The Lucida Sans Unicode font is installed by default in the Windows OS, making it a reliable default font setting.  ]]>
<![CDATA[
]]>
<![CDATA[      It is possible that the font "Arial Unicode MS" may perform better in some instances when converting from PDF to image.  ]]>
<![CDATA[
]]>
<![CDATA[      You can change the configuration file to use this font, or other fonts, instead of the default font.  ]]>
<![CDATA[
]]>
<![CDATA[      However, if the specified font is not installed on the machine that is performing the conversion the text will render as blank on the final image.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To change the font that is used to render a PDF to image, modify the fontfile.map file. ]]>
<![CDATA[
]]>
<![CDATA[        In 64-bit Windows, this file is located in the Windows "SysWow64" directory. ]]>
<![CDATA[
]]>
<![CDATA[        In 32-bit Windows, this file is located in the Windows "system32" directory. To change the default font:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      - Open fontfile.map in any text editor]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      - Change the ]]>
				<b>
<![CDATA[defaultwinfont]]>
				</b>
<![CDATA[ value from:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				<i>
<![CDATA[
]]>
<![CDATA[        ]]>
					<b>
<![CDATA[L_10646.ttf]]>
					</b>
<![CDATA[
]]>
<![CDATA[      ]]>
				</i>
<![CDATA[ to ]]>
				<i>
<![CDATA[
]]>
<![CDATA[        ]]>
					<b>
<![CDATA[ARIALUNI.TTF (this is the font used in previous Taskmaster versions)]]>
					</b>
<![CDATA[
]]>
<![CDATA[      ]]>
				</i>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      - Save the changes and exit.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      This example will change the default font from "Lucida Sans Unicode" to "Arial Unicode MS".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      Previous versions of the Convert actions used Arial Unicode MS as the default font. This was changed in current versions since this font is not installed by default in the OS. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          PDFBitDepth(1)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFDocumentToImage()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a PDF or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFBitDepth" qi="Sets the bit depth of the image output by PDFDocumentToImage.">
			<p name="p_iVal" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        One of the following bit depth values are allowed.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[1:]]>
				</b>
<![CDATA[ black and white.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[8:]]>
				</b>
<![CDATA[ 256 color.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[24:]]>
				</b>
<![CDATA[ True color.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[*** This Action Is Deprecated ***]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action has been deprecated and is scheduled to be removed in a future release.]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that you no longer use this action.]]>
<![CDATA[
]]>
<![CDATA[        Instead, use the PDFFREDocumentToImage action in the Convert.PDFFRE action library.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Sets the bit depth for the output TIFF.  The number of bits determine the color capacity of an image.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, a default value of 1 is used.  This action must be called before PDFDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFBitDepth(1)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFCompression" qi="Sets the compression method used in the TIFF output by PDFDocumentToImage.">
			<p name="p_iVal" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        One of the following compression values are allowed.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[1:]]>
				</b>
<![CDATA[ No compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[2:]]>
				</b>
<![CDATA[ CCITT modified Huffman RLE.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[3:]]>
				</b>
<![CDATA[ CCITT Group 3 fax.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[4:]]>
				</b>
<![CDATA[ CCITT Group 4 fax.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[5:]]>
				</b>
<![CDATA[ LZW Lempel-Ziv and Welch.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[7:]]>
				</b>
<![CDATA[ JPEG.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[32773:]]>
				</b>
<![CDATA[ Macintosh RLE.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[*** This Action Is Deprecated ***]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action has been deprecated and is scheduled to be removed in a future release.]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that you no longer use this action.]]>
<![CDATA[
]]>
<![CDATA[        Instead, use the PDFFREDocumentToImage action in the Convert.PDFFRE action library.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Sets the compression of the output image from PDFDocumentToImage.  If this]]>
<![CDATA[
]]>
<![CDATA[        action is not called, the default value of CCITT4 will be used.  Typically,]]>
<![CDATA[
]]>
<![CDATA[        input documents for recognition are black and white with fax compression.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          PDFBitDepth(1)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFCompression(4)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFConversionMethod" qi="Sets the conversion method used in the TIFF output by PDFDocumentToImage.">
			<p name="p_iVal" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        A numeric value of one of the following.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[1:]]>
				</b>
<![CDATA[ Uses method 1 of converting PDF to TIFF.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[2:]]>
				</b>
<![CDATA[ Uses method 2 of converting PDF to TIFF.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[*** This Action Is Deprecated ***]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action has been deprecated and is scheduled to be removed in a future release.]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that you no longer use this action.]]>
<![CDATA[
]]>
<![CDATA[        Instead, use the PDFFREDocumentToImage action in the Convert.PDFFRE action library.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        There are two methods that are can be used to convert a PDF to TIFF.]]>
<![CDATA[
]]>
<![CDATA[        The first method is slightly faster.  The second method gives better results.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, PDFDocumentToImage will use the second method by default,]]>
<![CDATA[
]]>
<![CDATA[        which produces a more accurate output TIFF.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          PDFBitDepth(1)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFConversionMethod(2)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFGrayscale" qi="Sets the output by PDFDocumentToImage to be grayscale.">
			<p name="p_bVal" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        A Boolean value to set grayscale mode.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ The resulting TIFF will be grayscale.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ The resulting TIFF will not be converted to grayscale.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[*** This Action Is Deprecated ***]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action has been deprecated and is scheduled to be removed in a future release.]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that you no longer use this action.]]>
<![CDATA[
]]>
<![CDATA[        Instead, use the PDFFREDocumentToImage action in the Convert.PDFFRE action library.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Sets the PDF conversion to TIFF so the output images are grayscale.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before PDFDocumentToImage. If this action is not called,]]>
<![CDATA[
]]>
<![CDATA[        a default value of False will be used by PDFDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFGrayscale(True)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFHorizontalResolution" qi="Sets the output horizontal resolution for PDFDocumentToImage.">
			<p name="p_iVal" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        p_iVal : A positive numeric value for the horizontal resolution in dots per inch (DPI).]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[*** This Action Is Deprecated ***]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action has been deprecated and is scheduled to be removed in a future release.]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that you no longer use this action.]]>
<![CDATA[
]]>
<![CDATA[        Instead, use the PDFFREDocumentToImage action in the Convert.PDFFRE action library.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Sets the horizontal resolution for PDF conversion to TIFF.  It is]]>
<![CDATA[
]]>
<![CDATA[        recommended that the horizontal and vertical resolutions be kept the same, creating an isotropic image.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default resolution of 200 is used.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before PDFDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[        Note that the Horizontal and Vertical resolutions must be identical, creating an isotropic image.]]>
<![CDATA[
]]>
<![CDATA[        If the resolutions are different, the larger of the two resolutions will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          PDFBitDepth(1)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFHorizontalResolution(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFVerticalResolution(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFQuality" qi="Sets the conversion quality for PDFDocumentToImage.">
			<p name="p_iVal" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        p_iVal : A positive numeric value between 0 and 100 that determines the image quality.  100 is the highest quality.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[*** This Action Is Deprecated ***]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action has been deprecated and is scheduled to be removed in a future release.]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that you no longer use this action.]]>
<![CDATA[
]]>
<![CDATA[        Instead, use the PDFFREDocumentToImage action in the Convert.PDFFRE action library.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        This determines the quality of the output TIFF.  Choosing a higher]]>
<![CDATA[
]]>
<![CDATA[        value will give you a better output TIFF, but will increase processing time.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before PDFDocumentToImage.  If]]>
<![CDATA[
]]>
<![CDATA[        PDFQuality is not called, the default value of 100 is used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          PDFBitDepth(1)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFQuality(100)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFVerticalResolution" qi="Sets the output vertical resolution for PDFDocumentToImage.">
			<p name="p_iVal" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        p_iVal : A positive numeric value for the vertical resolution in dots per inch (DPI).]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[*** This Action Is Deprecated ***]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action has been deprecated and is scheduled to be removed in a future release.]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that you no longer use this action.]]>
<![CDATA[
]]>
<![CDATA[        Instead, use the PDFFREDocumentToImage action in the Convert.PDFFRE action library.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Sets the vertical resolution for PDF conversion to TIFF.  It is]]>
<![CDATA[
]]>
<![CDATA[        recommended that the horizontal and vertical resolutions be kept the same, creating an isotropic image.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default resolution of 200 is used.]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before PDFDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[        Note that the Horizontal and Vertical resolutions must be identical, creating an isotropic image.]]>
<![CDATA[
]]>
<![CDATA[        If the resolutions are different, the larger of the two resolutions will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          PDFBitDepth(1)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFHorizontalResolution(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFVerticalResolution(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          PDFDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.PdfFRE" qi="Convert PDF Actions using Abbyy FineReader Engine">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[PDF Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The PDF conversion will convert electronic PDF documents to a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available PDF]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the PDFDocumentToImage to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in a single batch]]>
<![CDATA[
]]>
<![CDATA[      using the default Alphadecimal file name pattern is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      To scan more than 1296 files into a single batch requires using the ]]>
			<b>
<![CDATA[SetNamePattern]]>
			</b>
<![CDATA[ action with]]>
<![CDATA[
]]>
<![CDATA[      the parameter '2' which selects the alternate file naming pattern of TMxxxxxx. In this use case]]>
<![CDATA[
]]>
<![CDATA[      all files scanned or expanded from an original scanned file will be assigned the next available]]>
<![CDATA[
]]>
<![CDATA[      TMxxxxxx pattern where xxxxxx is a range from 1 to 999999; allowing upto a total of 999999 files]]>
<![CDATA[
]]>
<![CDATA[      in a single batch after all scanned files have been expanded.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[PDF Considerations]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      If you have separately purchased the DCPDF option, do not mix use the actions provided]]>
<![CDATA[
]]>
<![CDATA[      with the DCPDF Library (DCPDF.rrx) mixed with the actions from Convert within the same]]>
<![CDATA[
]]>
<![CDATA[      task profile or your documents may not all be converted properly.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the electronic document conversion actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the electronic document conversion actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the electronic document conversion actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Example Ruleset]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following shows a specific example ruleset and functions configured to process]]>
<![CDATA[
]]>
<![CDATA[      PDF, Word and Excel documents using the convert actions.  You can add more functions to process other]]>
<![CDATA[
]]>
<![CDATA[      file formats supported by convert, such as splitting tiff files, zip files, etc.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Execution runs through each of the functions until a function completes]]>
<![CDATA[
]]>
<![CDATA[      successfully.  The page status is first checked and then it attempts to convert the page.]]>
<![CDATA[
]]>
<![CDATA[      If the page is converted successfully, the page status is set to 75, meaning it is deleted.]]>
<![CDATA[
]]>
<![CDATA[      The function completes and no further processing is performed on the ruleset.]]>
<![CDATA[
]]>
<![CDATA[      If the document cannot be converted because the type doesn't match,]]>
<![CDATA[
]]>
<![CDATA[      then control passes to the next function and again attempts to convert the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Ruleset Convert Files]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process PDF]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - PDFFREDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Word]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - WordDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Excel]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ExcelWorkbookToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Setting the page to a deleted status allows that page to be skipped by subsequent processing.]]>
<![CDATA[
]]>
<![CDATA[      For example, if you use virtual scan create a batch containing a PDF document, then convert the PDF to a]]>
<![CDATA[
]]>
<![CDATA[      series of image files using the convert actions, it is likely that you no longer need to perform any further]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      processing]]>
<![CDATA[
]]>
<![CDATA[      on the input PDF file.  Subsequent processing and recognition]]>
<![CDATA[
]]>
<![CDATA[      will be on the new TIFF files that were created at run time.]]>
<![CDATA[
]]>
<![CDATA[      Note that setting the page to deleted does not remove the page reference]]>
<![CDATA[
]]>
<![CDATA[      from the DCO and it does not delete the file from the batch directory.  Because the original]]>
<![CDATA[
]]>
<![CDATA[      file still exists, at export time it is possible to include the original document when exporting]]>
<![CDATA[
]]>
<![CDATA[      to an external repository.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFFREDocumentToImage" qi="Converts an PDF file to TIFF format.">
			<p name="resolution" type="string" qi="The resolution of extracted images.">
			</p>
			<p name="compressionBW" type="string" qi="The compression of extracted black and white image files.">
			</p>
			<p name="compressionColor" type="string" qi="The compression of extracted color image files.">
			</p>
			<p name="compressionGray" type="string" qi="The compression of extracted grayscale image files.">
			</p>
			<p name="extensionBW" type="string" qi="The file extension of extracted black and white image files.">
			</p>
			<p name="extensionColor" type="string" qi="The file extension of extracted color image files.">
			</p>
			<p name="extensionGray" type="string" qi="The file extension of extracted grayscale image files.">
			</p>
			<p name="convertMode" type="string" qi="Preseve colors on images or convert all to black and white.">
			</p>
			<p name="useFastBinarization" type="string" qi="Use fast image binarization algorithm when convertMode is set to preserve colors.">
			</p>
			<p name="jpegQuality" type="string" qi="Jpeg quality of the of images extracted with JPEG compression.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[resolution: ]]>
				</b>
<![CDATA[ The resolution of extracted images. Valid values are in the range of ]]>
				<b>
<![CDATA[50-3200]]>
				</b>
<![CDATA[. Smart parameters supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[compressionBW: ]]>
				</b>
<![CDATA[ The compression of extracted black and white pages in the source PDF. For a list of valid compression values, see the section ]]>
				<b>
<![CDATA[ compression values]]>
				</b>
<![CDATA[ below. Smart parameters supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[compressionColor: ]]>
				</b>
<![CDATA[ The compression of extracted color pages in the source PDF. For a list of valid compression values, see the section ]]>
				<b>
<![CDATA[ compression values]]>
				</b>
<![CDATA[ below. Smart parameters supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[compressionGray: ]]>
				</b>
<![CDATA[ The compression of extracted grayscale pages in the source PDF. For a list of valid compression values, see the section ]]>
				<b>
<![CDATA[compression values]]>
				</b>
<![CDATA[ below. Smart parameters supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[extensionBW:]]>
				</b>
<![CDATA[The file extension of extracted black and white pages in the source PDF. Smart parameters supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[extensionColor:]]>
				</b>
<![CDATA[The file extension of extracted color pages in the source PDF. Smart parameters supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[extensionGray:]]>
				</b>
<![CDATA[The file extension of extracted grayscale pages in the source PDF. Smart parameters supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[convertMode:]]>
				</b>
<![CDATA[ Used to set the conversion mode. Valid values are ]]>
				<b>
<![CDATA[0]]>
				</b>
<![CDATA[ (Preserve color) and ]]>
				<b>
<![CDATA[1]]>
				</b>
<![CDATA[ (convert all images to black and white). Smart parameters supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[useFastBinarization: ]]>
				</b>
<![CDATA[ This setting is relevant when ]]>
				<b>
<![CDATA[convertMode]]>
				</b>
<![CDATA[ is set to ]]>
				<b>
<![CDATA[1]]>
				</b>
<![CDATA[. It causes the conversion function to use a faster binarization algorithm to convert pages to black and white during extraction. Valid values are ]]>
				<b>
<![CDATA[true]]>
				</b>
<![CDATA[ or ]]>
				<b>
<![CDATA[false]]>
				</b>
<![CDATA[. Smart parameters supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[jpegQuality: ]]>
				</b>
<![CDATA[ The quality of the color images extracted with JPEF compression. Valid values are ]]>
				<b>
<![CDATA[0-100]]>
				</b>
<![CDATA[. The higher the value, the higher the quality. Smart parameters supported.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Compression values:]]>
				</b>
<![CDATA[ ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        BmpBwUncompressed = 1]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        BmpGrayUncompressed = 2]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        BmpColorUncompressed = 3]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        DcxBwPackbits = 4]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        DcxGrayPackbits = 5]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        DcxColorPackbits = 6]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        JpegGrayJfif = 7]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        JpegColorJfif = 8]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        PcxBwPackbits = 9]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        PcxGrayPackbits = 10]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        PcxColorPackbits = 11]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        PngBwPng = 12]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        PngGrayPng = 13]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        PngColorPng = 14]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffBwUncompressed = 15]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffBwCcittGroup3 = 16]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffBwCcittGroup4 = 18]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffBwPackbits = 19]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffGrayUncompressed = 20]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffGrayPackbits = 21]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffGrayJpegJfif = 22]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffColorUncompressed = 23]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffColorPackbits = 24]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffColorJpegJfif = 25]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Jpeg2kGray = 28]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Jpeg2kColor = 29]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffBwLZW = 31]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffGrayLZW = 32]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffColorLZW = 33]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffBwZip = 34]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffGrayZip = 35]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        TiffColorZip = 36]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        JBIG2 = 43]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is a PDF, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the document. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the pdf document contains searchable text, a CCO file containing the positions and text is also created for each page in the document.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Note:]]>
				</b>
<![CDATA[ The NormalizeCCO action from the ]]>
				<b>
<![CDATA[CCO2CCO]]>
				</b>
<![CDATA[ action library should be called in a subsequent ruleset to ]]>
<![CDATA[
]]>
<![CDATA[        ensure the integrity of the CCO file. This is also required if the application will be using the navigation and pattern match actions]]>
<![CDATA[
]]>
<![CDATA[        to find recognized text on a page or perform pattern matching. ]]>
				<br>
				</br>
<![CDATA[ ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which]]>
<![CDATA[
]]>
<![CDATA[        the page was extracted will be stored in the ParentImage variable, for]]>
<![CDATA[
]]>
<![CDATA[        possible future reference within your application. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        To prevent creating a CCO and to ignore searchable text within a PDF, enable "convPdfIgnoreContent" by setting the variable to "1" ]]>
<![CDATA[
]]>
<![CDATA[        in the page DCO prior to calling PDFDocumentToImage.]]>
<![CDATA[
]]>
<![CDATA[        When "y_createLayout" is set to "1", then convPdfIgnoreContent is automatically enabled.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Turning the CCO file creation feature OFF is recommended in the case where it is unlikely that the application will process searchable PDF documents, or in the]]>
<![CDATA[
]]>
<![CDATA[        case where full page OCR is required later in the workflow.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Creating a Layout File:]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action has the capbility to run recognition in addition to text extraction. ]]>
<![CDATA[
]]>
<![CDATA[        This can be enabled by setting the DCO variable "y_createLayout" to "1" prior to calling the action. ]]>
<![CDATA[
]]>
<![CDATA[        By default, this feature is turned off.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        When this option is turned on, a layout xml file (i.e tm000001_layout.xml) will be created per image extracted. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Note that when "y_createLayout" is enabled, a CCO file is not created by default.]]>
<![CDATA[
]]>
<![CDATA[        Use the action CreateCcoFromLayout in the SharedRecognitionTools library on each newly created page ]]>
<![CDATA[
]]>
<![CDATA[        to convert each layout XML to a CCO]]>
<![CDATA[
]]>
<![CDATA[        to allow other CCO actions to operate on the text.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        The layout file groups text into blocks as a person would looking at the document. ]]>
<![CDATA[
]]>
<![CDATA[        Each block may have the default type of block or a specific type such as title or table. ]]>
<![CDATA[
]]>
<![CDATA[        There are locate actions available in the ]]>
				<b>
<![CDATA[DocumentAnalytics]]>
				</b>
<![CDATA[ action library to navigate the block structure such as ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[GoSiblingBlockNext]]>
				</b>
<![CDATA[. This is in contrast to the CCO file produced by other actions that ]]>
<![CDATA[
]]>
<![CDATA[        groups text into lines that span the width of the page. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        The layout XML file also retains font and color attributes, saved in CSS format, for the text which ]]>
<![CDATA[
]]>
<![CDATA[        is used for extracting data and reconstructing the document in a new format. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        To use the Locate actions and perform click ‘n’ key during verification, use the action ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CreateCcoFromLayout]]>
				</b>
<![CDATA[ action in the ]]>
				<b>
<![CDATA[SharedRecognitionTools]]>
				</b>
<![CDATA[ action library. ]]>
<![CDATA[
]]>
<![CDATA[        This action will create a CCO file for the page after producing the layout XML file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Following are the types of elements that may be present in the layout XML file:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Block Type/XML Node]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[
]]>
<![CDATA[          Block/Block]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Header/Header]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Footer/Footer]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Title/Title]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Heading1/H1]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Heading2/H2]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Heading3/H3]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Picture/Picture]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Barcode/Barcode]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Space/S]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Tab/Tab]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Table/Table]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Row/Row]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Cell/Cell]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Paragraph/Para]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Line/L]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Sentence/Sent]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Word/W]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Character/C]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</i>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Text Extraction versus Text Recognition]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        By default, the text included in the layout XML is obtained from a combination of automatic ]]>
<![CDATA[
]]>
<![CDATA[        recognition that is run on each page of the PDF and from searchable text that is embedded within the PDF. ]]>
<![CDATA[
]]>
<![CDATA[        Any images that are embedded on the page have the text recognized by the engine.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If areas of the page contain both an image and searchable text associated with the image,]]>
<![CDATA[
]]>
<![CDATA[        the engine decides whether the engine must use the searchable text or recognize the text from the matching image.]]>
<![CDATA[
]]>
<![CDATA[        Because the engine performs recognition, the confidence of the text might vary even if the same searchable text is embedded in the PDF.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The variable y_contentReuseMode can be used to force the engine to use only the recognized]]>
<![CDATA[
]]>
<![CDATA[        text on the page or only to use the embedded text on the page. One reason why you might decide]]>
<![CDATA[
]]>
<![CDATA[        only to use the embedded text is to prevent recognition and produce high confidence results.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        A drawback of only to using the embedded text can be that if the embedded text is wrong or incomplete, ]]>
<![CDATA[
]]>
<![CDATA[        recognition is not performed to capture that missing data that results in a layout XML that is incomplete ]]>
<![CDATA[
]]>
<![CDATA[        compared to what the user sees when the user views the PDF. Do not use this setting if the source PDF ]]>
<![CDATA[
]]>
<![CDATA[        file is of the image-on-text type, because in this case, the text layer is not extracted. ]]>
<![CDATA[
]]>
<![CDATA[        If a text line contains characters that are not included in the alphabet of the selected recognition languages, ]]>
<![CDATA[
]]>
<![CDATA[        this text is not be written to the result and mode 0 or 1 must be used.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        These settings of y_contentReuseMode can be set on the DCO node that is being converted:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        rrSet("0", "@X.y_contentReuseMode") - The default auto mode that uses a combination of recognition and embedded text.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        rrSet("1", "@X.y_contentReuseMode") - Only recognition is used to create the layout XML.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        rrSet("2", "@X.y_contentReuseMode") - Only embedded text is used to create the layout XML.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        For more information about configuring the recognition language, refer the OCR/A Action ]]>
				<b>
<![CDATA[Recognize.]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Including PDF Annotations]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        By default, text annotations included in the source PDF file will not be included in the output image.]]>
<![CDATA[
]]>
<![CDATA[        "Free Text" annotations in source PDF can be included in the output image by setting the page DCO variable y_IncludeAnnotation to "1".]]>
<![CDATA[
]]>
<![CDATA[        Other types of PDF annotations are not supported, such as popup and ink annotations.]]>
<![CDATA[
]]>
<![CDATA[        This feature will not cause the text of a "Sticky note" to be displayed on the image and a]]>
<![CDATA[
]]>
<![CDATA[        sticky note icon may display on the final image regardless of this setting.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFFREDocumentToImage(300,32,32,32,".bw.tif", ".color.tif", ".gray.tif", 0, false,100)]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a supported Image type or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="PDFFREReleaseEngine" qi="Releases resources used by the conversion engine.">
			<h>
<![CDATA[
]]>
<![CDATA[        Releases resources used by the conversion engine.  This action should only be called once]]>
<![CDATA[
]]>
<![CDATA[        after all PDFs have been processed or the engine will be loaded, unloaded, loaded etc.]]>
<![CDATA[
]]>
<![CDATA[        Place the action in a rule that is called on the batch close and it will be called after all]]>
<![CDATA[
]]>
<![CDATA[        pages are processed.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          PDFFREReleaseEngine(300,32,32,32,".bw.tif", ".color.tif", ".gray.tif", 0, false,100)]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[PDFFREReleaseEngine()]]>
					</b>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          The example above performs the conversion, then releases all resources used by the engine.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.  Typically at the Batch close.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Images" qi="Convert Image Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Images Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Images conversion will convert Image files of various formats a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available Image]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the ImageToTIFF to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in a single batch]]>
<![CDATA[
]]>
<![CDATA[      using the default Alphadecimal file name pattern is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      To scan more than 1296 files into a single batch requires using the ]]>
			<b>
<![CDATA[SetNamePattern]]>
			</b>
<![CDATA[ action with]]>
<![CDATA[
]]>
<![CDATA[      the parameter '2' which selects the alternate file naming pattern of TMxxxxxx. In this use case]]>
<![CDATA[
]]>
<![CDATA[      all files scanned or expanded from an original scanned file will be assigned the next available]]>
<![CDATA[
]]>
<![CDATA[      TMxxxxxx pattern where xxxxxx is a range from 1 to 999999; allowing upto a total of 999999 files]]>
<![CDATA[
]]>
<![CDATA[      in a single batch after all scanned files have been expanded.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the electronic document conversion actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the electronic document conversion actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the electronic document conversion actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Example Ruleset]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following shows a specific example ruleset and functions configured to process]]>
<![CDATA[
]]>
<![CDATA[      PDF, Word and Excel documents using the convert actions.  You can add more functions to process other]]>
<![CDATA[
]]>
<![CDATA[      file formats supported by convert, such as splitting tiff files, zip files, etc.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Execution runs through each of the functions until a function completes]]>
<![CDATA[
]]>
<![CDATA[      successfully.  The page status is first checked and then it attempts to convert the page.]]>
<![CDATA[
]]>
<![CDATA[      If the page is converted successfully, the page status is set to 75, meaning it is deleted.]]>
<![CDATA[
]]>
<![CDATA[      The function completes and no further processing is performed on the ruleset.]]>
<![CDATA[
]]>
<![CDATA[      If the document cannot be converted because the type doesn't match,]]>
<![CDATA[
]]>
<![CDATA[      then control passes to the next function and again attempts to convert the page.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Ruleset Convert Files]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process PDF]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - PDFDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Word]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - WordDocumentToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - Function Process Excel]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ChkDCOStatus("49")]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - ExcelWorkbookToImage()]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      - - SetDCOStatus("75")]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Setting the page to a deleted status allows that page to be skipped by subsequent processing.]]>
<![CDATA[
]]>
<![CDATA[      For example, if you use virtual scan create a batch containing a PDF document, then convert the PDF to a]]>
<![CDATA[
]]>
<![CDATA[      series of image files using the convert actions, it is likely that you no longer need to perform any further]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      processing]]>
<![CDATA[
]]>
<![CDATA[      on the input PDF file.  Subsequent processing and recognition]]>
<![CDATA[
]]>
<![CDATA[      will be on the new TIFF files that were created at run time.]]>
<![CDATA[
]]>
<![CDATA[      Note that setting the page to deleted does not remove the page reference]]>
<![CDATA[
]]>
<![CDATA[      from the DCO and it does not delete the file from the batch directory.  Because the original]]>
<![CDATA[
]]>
<![CDATA[      file still exists, at export time it is possible to include the original document when exporting]]>
<![CDATA[
]]>
<![CDATA[      to an external repository.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ImageToTIFF" qi="Converts an Image file to TIFF format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is an Image, the file will be converted to a single TIFF file.]]>
<![CDATA[
]]>
<![CDATA[        ImageFileTypesToConvert must be used along with ImageToTIFF.]]>
<![CDATA[
]]>
<![CDATA[        Only the image types set by a previous call to ImageFileTypesToConvert will be converted to a TIFF.]]>
<![CDATA[
]]>
<![CDATA[        No images will be converted if ImageFileTypesToConvert has not been set, or if a color TIFF is processed]]>
<![CDATA[
]]>
<![CDATA[        and the ImageMonoType has not been selected.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ImageFileTypesToConvert(".jpg,.jpeg,gif,bmp")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ImageToTIFF()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a supported Image type or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ImageMonoType" qi="Sets the method to use when converting color images to black and white tiffs.">
			<p name="Mono" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        Mono : A positive numeric value of 1 to 4 for the type of conversion to use.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        1: Convert image using Diffusion method.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        2: Convert image using Halftone method.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        3: Convert image using Bayer method.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        4: Convert image using Threshold method with a threshold value. Value defaults to 10.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the black and white conversion algorithm to use when converting color or grey scale images to TIFF.]]>
<![CDATA[
]]>
<![CDATA[        If you are using the threshold method, you must also call the ImageMonoThreshold action]]>
<![CDATA[
]]>
<![CDATA[        prior to converting the image with ImageToTIFF.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Error diffusion is a type of halftoning in which the quantization residual is distributed to neighboring]]>
<![CDATA[
]]>
<![CDATA[        pixels that have not yet been processed. Its main use is to convert a color image into a black and white image.]]>
<![CDATA[
]]>
<![CDATA[        Halftone is the reprographic technique that simulates continuous tone imagery]]>
<![CDATA[
]]>
<![CDATA[        through the use of dots, varying either in size or in spacing.  Bayer method is an image dithering algorithm]]>
<![CDATA[
]]>
<![CDATA[        that is commonly used to maintain a the characteristics of a photo image of higher colors in an image of less color]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        depth.]]>
<![CDATA[
]]>
<![CDATA[        The threshold method makes individual pixels in an image black if their value is greater]]>
<![CDATA[
]]>
<![CDATA[        than the threshold value and the remaining pixels white.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        For best results, you may need to experiment with the different types of images that you are expecting]]>
<![CDATA[
]]>
<![CDATA[        to process and select the conversion method that gives you the best results.  If the resulting TIFF images]]>
<![CDATA[
]]>
<![CDATA[        are going to be used in a subsequent recognition process, pick the technique that works best to]]>
<![CDATA[
]]>
<![CDATA[        output dark, solid characters with as little background noise, or dithering around the characters, as possible.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ImageFileTypesToConvert(".jpg,.jpeg,gif,bmp")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ImageMonoType(1)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ImageToTIFF()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ImageDefaultDPI" qi="Sets the default dpi (dots per inch) when converting images that do not have an   embedded dpi value.">
			<p name="X" type="short" qi="Horizonal dpi (X axis). A positive numeric value normally ranging from 96 to 300">
			</p>
			<p name="Y" type="short" qi="Vertical dpi (Y axis). A positive numeric value normally ranging from 96 to 300">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the default dpi to use when converting color or greyscale images to B/W TIFF when the source image does not]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        have a dpi value.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ImageFileTypesToConvert(".jpg,.jpeg,gif,bmp")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ImageDefaultDPI("200","200")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ImageMonoType(4)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ImageMonoThreshold(9)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ImageToTIFF()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if there is a failure to set the default X or Y dpi value, otherwise ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ImageMonoThreshold" qi="Sets the threshold value when converting Image to 1 bit tiff using threshold type   conversion.">
			<p name="thresh" type="short" qi="A positive numeric value from 1 to 255.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        thresh: A positive numeric value from 1 to 255.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the B/W conversion algorithm value to use when converting color or grey scale images to TIFF with the]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Threshold method option.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ImageFileTypesToConvert(".jpg,.jpeg,gif,bmp")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ImageMonoType(4)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ImageMonoThreshold(9)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ImageToTIFF()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ImageFileTypesToConvert" qi="Sets the file extension values of image types to convert to tiff.">
			<p name="fileextensions" type="string" qi="A CSV string of file extensions that defines the image types that will be   converted.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        fileextensions : A CSV string of file extensions that defines the image types that will be converted.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the file extension values of image types to convert to TIFF.  The file types of JEPG, BMP, PNG, TIFF and GIF]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        are supported.]]>
<![CDATA[
]]>
<![CDATA[        A period prefixing the extension is allowed, but not required.  Because TIFF is supported, it is possible to use]]>
<![CDATA[
]]>
<![CDATA[        this action to convert a color TIFF to a Black and White TIFF.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This action must be used prior to ImageToTIFF.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ImageFileTypesToConvert(".jpg,.jpeg,gif,bmp")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ImageToTIFF()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Html" qi="Convert Html Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Html Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Html conversion will convert electronic HTM and HTML documents to a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available Html]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the HtmlToImage to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in a single batch]]>
<![CDATA[
]]>
<![CDATA[      using the default Alphadecimal file name pattern is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      To scan more than 1296 files into a single batch requires using the ]]>
			<b>
<![CDATA[SetNamePattern]]>
			</b>
<![CDATA[ action with]]>
<![CDATA[
]]>
<![CDATA[      the parameter '2' which selects the alternate file naming pattern of TMxxxxxx. In this use case]]>
<![CDATA[
]]>
<![CDATA[      all files scanned or expanded from an original scanned file will be assigned the next available]]>
<![CDATA[
]]>
<![CDATA[      TMxxxxxx pattern where xxxxxx is a range from 1 to 999999; allowing upto a total of 999999 files]]>
<![CDATA[
]]>
<![CDATA[      in a single batch after all scanned files have been expanded.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the electronic document conversion actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the electronic document conversion actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the electronic document conversion actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="HtmlToImage" qi="Converts a page with *.htm or *.html file to a page or pages in TIFF format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is an Html Document, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the Document, based on the settings of the other]]>
<![CDATA[
]]>
<![CDATA[        Html actions that configure the conversion settings.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If the configured output image format and compression only supports black and white, such as CCITT4,]]>
<![CDATA[
]]>
<![CDATA[        colored text is exported as black.  Html table borders will not be rendered onto output images using default]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        settings.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          HtmlPrintQuality(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          HtmlTiffCompression(CCITT4)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[HtmlToImage()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not an Html Document or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="HtmlToPdf" qi="Converts *.htm or *.html files to PDF document format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is an Html Document, this action will create a searchable PDF file using the text from the original document. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Unlike the standard conversion to image actions, this action does not create a new page object in the dco. It only updates the IMAGEFILE variable to point to the newly created PDF file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        By default the produced PDF documents are compliant with the Pdf15 standard. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To create PDF documents compliant with the PdfA1a standard, set the variable "targetPdfCompliance" to "1". ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To create PDF documents compliant with PdfA1b standard, set the variable "targetPdfCompliance" to "2". ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Note:]]>
				</b>
<![CDATA[The "targetPdfCompliance" variable must to be set to the desired value prior to calling the conversion]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        action, on the same DCO object level, in order for the setting to take effect.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[HtmlToPdf()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a PDF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not an Html Document or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="HtmlLayout" qi="Sets custom layout settings for HtmlToImage.">
			<p name="sMargins" type="string">
			</p>
			<p name="tableFit" type="int">
			</p>
			<p name="tableBorders" type="bool">
			</p>
			<p name="cellShading" type="bool">
			</p>
			<p name="clearBackground" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[sMargins]]>
				</b>
<![CDATA[ - Four comma-delimited positive integer values for Left, Top, Right, Bottom page margins in inches]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        * 10.]]>
<![CDATA[
]]>
<![CDATA[        Default is 5 or 0.5 inches on all sides.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[tableFit]]>
				</b>
<![CDATA[ - 0 to auto fit to contents (cells shrink according to contents),]]>
<![CDATA[
]]>
<![CDATA[        1 to use all available space (cells expand to available page width), or]]>
<![CDATA[
]]>
<![CDATA[        2 to use fixed widths (cells sized according to their Width properties).]]>
<![CDATA[
]]>
<![CDATA[        Default is 0.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[tableBorders]]>
				</b>
<![CDATA[ - True to render table borders.  Enabling borders is not recommended as it may cause issues]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        during CCO normalization,]]>
<![CDATA[
]]>
<![CDATA[        leading to misbehavior during text location, click and key, or other operations.  Default is false.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[cellShading]]>
				</b>
<![CDATA[ - True to render cell shading.  Enabling shading for bitonal output may lead to unreadable text]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        in cells with background]]>
<![CDATA[
]]>
<![CDATA[        noise.  Shading may cause speckling that can interfere with recognition or other operations.  Default is true for]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        color output, else false.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[clearBackground]]>
				</b>
<![CDATA[ - True to clear the document background.  Enabling this setting may improve clarity durity]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        color output.  Default is false.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[HtmlLayout(5,5,5,5,1,false,true,true)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          HtmlToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="HtmlPrintQuality" qi="Adjusts the resolution of the image output by HtmlToImage.">
			<p name="dpi" type="int" qi="A single positive numeric value for the dots per inch (dpi) of the output image.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the resolution of the output image for HtmlToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 200 dpi will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are 200 dpi.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[HtmlPrintQuality(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          HtmlDocumentToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="HtmlTiffCompression" qi="Sets the compression used in the TIFF output by HtmlToImage.">
			<p name="tiffCompression" type="string" qi="A parameter of one of the following values to set the TIFF compression:">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[NONE]]>
				</b>
<![CDATA[ – A color image with no compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[LZW]]>
				</b>
<![CDATA[ – A color image using LZW compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CCITT4]]>
				</b>
<![CDATA[ - A black and white image with fax CCITT4 compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the compression of the output image from HtmlToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of CCITT4 will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are black and white with fax compression.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[HtmlTiffCompression(CCITT4)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          HtmlToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Rtf" qi="Convert Rtf Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Rtf Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Rtf conversion will convert electronic RTF documents to a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available Rtf]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the RtfToImage to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in a single batch]]>
<![CDATA[
]]>
<![CDATA[      using the default Alphadecimal file name pattern is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      To scan more than 1296 files into a single batch requires using the ]]>
			<b>
<![CDATA[SetNamePattern]]>
			</b>
<![CDATA[ action with]]>
<![CDATA[
]]>
<![CDATA[      the parameter '2' which selects the alternate file naming pattern of TMxxxxxx. In this use case]]>
<![CDATA[
]]>
<![CDATA[      all files scanned or expanded from an original scanned file will be assigned the next available]]>
<![CDATA[
]]>
<![CDATA[      TMxxxxxx pattern where xxxxxx is a range from 1 to 999999; allowing upto a total of 999999 files]]>
<![CDATA[
]]>
<![CDATA[      in a single batch after all scanned files have been expanded.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the electronic document conversion actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the electronic document conversion actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the electronic document conversion actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RtfToImage" qi="Converts a page with *.rtf file to a page or pages in TIFF format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is a Rtf Document, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the Document, based on the settings of the other]]>
<![CDATA[
]]>
<![CDATA[        Rtf actions that configure the conversion settings.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If the configured output image format and compression]]>
<![CDATA[
]]>
<![CDATA[        only supports black and white, such as CCITT4, colored text is]]>
<![CDATA[
]]>
<![CDATA[        exported as black.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          RtfPrintQuality(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RtfTiffCompression(CCITT4)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RtfToImage()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a Rtf Document or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RtfToPdf" qi="Converts *.rtf files to PDF document format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is an Rtf Document, this action will create a searchable PDF file using the text from the original document. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Unlike the standard conversion to image actions, this action does not create a new page object in the dco. It only updates the IMAGEFILE variable to point to the newly created PDF file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        By default the produced PDF documents are compliant with the Pdf15 standard. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To create PDF documents compliant with the PdfA1a standard, set the variable "targetPdfCompliance" to "1". ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To create PDF documents compliant with PdfA1b standard, set the variable "targetPdfCompliance" to "2". ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Note:]]>
				</b>
<![CDATA[The "targetPdfCompliance" variable must to be set to the desired value prior to calling the conversion]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        action, on the same DCO object level, in order for the setting to take effect.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RtfToPdf()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a PDF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not an Rtf Document or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RtfPrintQuality" qi="Adjusts the resolution of the image output by RtfToImage.">
			<p name="dpi" type="int" qi="A single positive numeric value for the dots per inch (dpi) of the output image.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the resolution of the output image for RtfToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 200 dpi will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are 200 dpi.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RtfPrintQuality(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RtfToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RtfTiffCompression" qi="Sets the compression used in the TIFF output by RtfToImage.">
			<p name="tiffCompression" type="string" qi="A parameter of one of the following values to set the TIFF compression:">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[NONE]]>
				</b>
<![CDATA[ – A color image with no compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[LZW]]>
				</b>
<![CDATA[ – A color image using LZW compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CCITT4]]>
				</b>
<![CDATA[ - A black and white image with fax CCITT4 compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the compression of the output image from RtfToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of CCITT4 will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are black and white with fax compression.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RtfTiffCompression(CCITT4)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RtfToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
	<com ref="Datacap.Libraries.Convert.Txt" qi="Convert Txt Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Txt Overview]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The Txt conversion will convert electronic TXT documents to a TIF file.  One possible use of the TIF]]>
<![CDATA[
]]>
<![CDATA[      files is to perform recognition and subsequent rules processing on them.  Use the available Txt]]>
<![CDATA[
]]>
<![CDATA[      conversion actions to set the conversion as desired, then use the TxtToImage to convert]]>
<![CDATA[
]]>
<![CDATA[      the images that have been input to the batch.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If you are converting to TIF images so recognition can be performed, it is suggested that]]>
<![CDATA[
]]>
<![CDATA[      the output TIF format be one bit black and white, fax group 4 compressed images.]]>
<![CDATA[
]]>
<![CDATA[      Images of this specification work best for recognition.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Conversion Limits]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      When using the conversion actions, the maximum number of initial input files in a single batch]]>
<![CDATA[
]]>
<![CDATA[      using the default Alphadecimal file name pattern is 1296.  These files can then expand into more files within the]]>
<![CDATA[
]]>
<![CDATA[      batch, creating a batch with far more than 1296 total documents in the end.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example, an input batch of a word document containing 6 pages will result]]>
<![CDATA[
]]>
<![CDATA[      in a batch of 7 files, the initial DOC file and then the resulting 6 TIFFs that were generated from the pages.]]>
<![CDATA[
]]>
<![CDATA[      For each file that is to be converted within the batch, there is a maximum of 1296 output pages.]]>
<![CDATA[
]]>
<![CDATA[      For example, a word document consisting of 2000 pages will only have the first]]>
<![CDATA[
]]>
<![CDATA[      1296 pages converted to TIFF. Likewise, a single ZIP file has a maximum of 1296]]>
<![CDATA[
]]>
<![CDATA[      files within it and a msg file has a maximum of 1296 attachments.]]>
<![CDATA[
]]>
<![CDATA[      The 1296 limit exists on each input file, not a total limit for all files combined.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      When using the convert actions, there is a 3 level limit for embedded files.]]>
<![CDATA[
]]>
<![CDATA[      For example a MSG file can contain a ZIP file which can contain a PDF file.]]>
<![CDATA[
]]>
<![CDATA[      At the end of the conversion, all files will be extracted and all of the pages]]>
<![CDATA[
]]>
<![CDATA[      in the PDF will be converted to a TIFF.  An example that isn’t allowed is a]]>
<![CDATA[
]]>
<![CDATA[      MSG file that contains a ZIP file that contains another ZIP file that contains a PDF because.]]>
<![CDATA[
]]>
<![CDATA[      this has a 4 level hierarchy, which is not permitted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      To scan more than 1296 files into a single batch requires using the ]]>
			<b>
<![CDATA[SetNamePattern]]>
			</b>
<![CDATA[ action with]]>
<![CDATA[
]]>
<![CDATA[      the parameter '2' which selects the alternate file naming pattern of TMxxxxxx. In this use case]]>
<![CDATA[
]]>
<![CDATA[      all files scanned or expanded from an original scanned file will be assigned the next available]]>
<![CDATA[
]]>
<![CDATA[      TMxxxxxx pattern where xxxxxx is a range from 1 to 999999; allowing upto a total of 999999 files]]>
<![CDATA[
]]>
<![CDATA[      in a single batch after all scanned files have been expanded.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[The Rules]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Because rules are flexible, there are multiple ways that your applications can]]>
<![CDATA[
]]>
<![CDATA[      use the electronic document conversion actions.  The following is one recommended way of using the actions]]>
<![CDATA[
]]>
<![CDATA[      within your Application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Perform the electron virtual scanning in its own task profile, to create the batch of]]>
<![CDATA[
]]>
<![CDATA[      input documents to be processed.  Use the electronic document conversion actions in their own task]]>
<![CDATA[
]]>
<![CDATA[      task profile.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      In a single ruleset, you can perform all of the actions to convert your]]>
<![CDATA[
]]>
<![CDATA[      electronic documents to TIF files prior to recognition.  Create a function for each type]]>
<![CDATA[
]]>
<![CDATA[      of electronic document that you expect to convert with the electronic document conversion actions.]]>
<![CDATA[
]]>
<![CDATA[      For example, one function to operate on ZIP files, another to operate on Word files, etc., for]]>
<![CDATA[
]]>
<![CDATA[      as many different types as you need.  If the default values are not adequate, use the actions]]>
<![CDATA[
]]>
<![CDATA[      to configure your output format, then use the action to convert the document to]]>
<![CDATA[
]]>
<![CDATA[      a TIF file for each page within the document.  If the page is not of the expected type,]]>
<![CDATA[
]]>
<![CDATA[      the action will return false and proceed to the next type and attempt to convert again.]]>
<![CDATA[
]]>
<![CDATA[      This operation will continue until all of the desired types have been converted.]]>
<![CDATA[
]]>
<![CDATA[      Types that are not expected, will be ignored by this process.]]>
<![CDATA[
]]>
<![CDATA[      You can setup additional rules to handle them,]]>
<![CDATA[
]]>
<![CDATA[      if required by your specific application.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Variables Created During Conversion]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The conversion actions will store data in variables that may be useful.  These are the variables]]>
<![CDATA[
]]>
<![CDATA[      created:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      "IMAGEFILE" : The name of the TIF file that is associated with the converted page.]]>
<![CDATA[
]]>
<![CDATA[      The value would typically look like this "01010000.tif".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      "ParentImage" : The name of the document that was used to create this page.  If the TIF was created by]]>
<![CDATA[
]]>
<![CDATA[      the conversion of a WORD file, then the value would typically look like "02000000.doc".]]>
<![CDATA[
]]>
<![CDATA[      This variable is on the page level.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="TxtToImage" qi="Converts a page with *.txt file to a page or pages in TIFF format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is a Txt Document, the file will be converted to multiple TIFF files,]]>
<![CDATA[
]]>
<![CDATA[        one TIFF file for each page within the Document, based on the settings of the other]]>
<![CDATA[
]]>
<![CDATA[        Txt actions that configure the conversion settings.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each new TIFF will also have a new page created within the application environment]]>
<![CDATA[
]]>
<![CDATA[        which can be processed by subsequent rules.  The original file name from which the page was]]>
<![CDATA[
]]>
<![CDATA[        extracted will be stored in the ParentImage variable, for possible future reference within]]>
<![CDATA[
]]>
<![CDATA[        your application.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If the configured output image format and compression]]>
<![CDATA[
]]>
<![CDATA[        only supports black and white, such as CCITT4, colored text is]]>
<![CDATA[
]]>
<![CDATA[        exported as black.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          TxtPrintQuality(200)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          TxtTiffCompression(CCITT4)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[TxtToImage()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a TIFF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not a Txt Document or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="TxtToPdf" qi="Converts *.txt files to PDF document format.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the current page is an Txt Document, this action will create a searchable PDF file using the text from the original document. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Unlike the standard conversion to image actions, this action does not create a new page object in the dco. It only updates the IMAGEFILE variable to point to the newly created PDF file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        By default the produced PDF documents are compliant with the Pdf15 standard. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To create PDF documents compliant with the PdfA1a standard, set the variable "targetPdfCompliance" to "1". ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To create PDF documents compliant with PdfA1b standard, set the variable "targetPdfCompliance" to "2". ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Note:]]>
				</b>
<![CDATA[The "targetPdfCompliance" variable must to be set to the desired value prior to calling the conversion]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        action, on the same DCO object level, in order for the setting to take effect.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[TxtToPdf()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully converted to a Pdf document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the current page is not an Txt Document or if there is a failure in the conversion.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the number of input files/pages exceeds the maximum allowed or]]>
<![CDATA[
]]>
<![CDATA[        if there is a failure in the conversion, the batch will be set to abort.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="TxtFontName" qi="Adjusts the font name of text in the image output by TxtToImage.">
			<p name="fontName" type="string" qi="Font name to be used in the output image.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the font name for text in the output image for TxtToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of Times New Roman will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[TxtFontName(Courier New)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          TxtToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="TxtFontSize" qi="Adjusts the font size of text in the image output by TxtToImage.">
			<p name="fontSize" type="int" qi="Font size to be used in the output image.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the font size for text in the output image for TxtToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 10 will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[TxtFontSize(12)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          TxtToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="TxtPrintQuality" qi="Adjusts the resolution of the image output by TxtToImage.">
			<p name="dpi" type="int" qi="A single positive numeric value for the dots per inch (dpi) of the output image.">
			</p>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the resolution of the output image for TxtToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 200 dpi will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are 200 dpi.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[TxtPrintQuality(200)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          TxtToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="TxtTiffCompression" qi="Sets the compression used in the TIFF output by TxtToImage.">
			<p name="tiffCompression" type="string" qi="A parameter of one of the following values to set the TIFF compression:">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[NONE]]>
				</b>
<![CDATA[ – A color image with no compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[LZW]]>
				</b>
<![CDATA[ – A color image using LZW compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CCITT4]]>
				</b>
<![CDATA[ - A black and white image with fax CCITT4 compression.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the compression of the output image from TxtToImage.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of CCITT4 will be used.]]>
<![CDATA[
]]>
<![CDATA[        Typically, input documents for recognition are black and white with fax compression.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[TxtTiffCompression(CCITT4)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          TxtToImage()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="DCImageFix" v="8.1.0.0">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' Document Convertion Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['IBM InfoSphere Classification Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2013 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.0"]]>
<![CDATA[
]]>
<![CDATA[' Created 05/11/2009 JMartinez]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.0"]]>
<![CDATA[
]]>
<![CDATA[' Created 05/23/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA['- Moved parameter information from the qi= tag to the standard parameter help section]]>
<![CDATA[
]]>
<![CDATA['- Moved action information from the qi= tag to the standard action help section]]>
<![CDATA[
]]>
<![CDATA['- Added IBM Copyright notice]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
	</g>
	<com ref="Datacap.Libraries.ImageFix.Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ImageEnhance">
			<p name="BackupFileExtension" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        The file extension that the action is to assign to the backup of the original Image file.]]>
<![CDATA[
]]>
<![CDATA[        For example: tio]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        The extension must be at least 1 character.  If the leading period is provided, ]]>
<![CDATA[
]]>
<![CDATA[        it must have at least one character following it.  Long name file extensions are allowed.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Initiates image processing to perform a preconfigured set of image enhancements.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action after a ]]>
				<scr>
<![CDATA[LoadSettings]]>
				</scr>
<![CDATA[ or ]]>
				<scr>
<![CDATA[LoadSettings_FingerprintID]]>
				</scr>
<![CDATA[ action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          LoadSettings("C:\ParentDir\Invoice\Process\ImageFix.ini")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ImageEnhance("tio")]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Keep in mind in this example that the ImageFix settings specified in ImageFix.ini will be]]>
<![CDATA[
]]>
<![CDATA[          applied to every page in the batch.  An example of the copied file name: "TM000001.tio".]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          LoadSettings("C:\ParentDir\Invoice\Process\ImageFix.ini")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ImageEnhance("tio.tif")]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          This example uses a longer file extension, which preserves the original file type,]]>
<![CDATA[
]]>
<![CDATA[          making it easier to view the original file without renaming.]]>
<![CDATA[
]]>
<![CDATA[          An example of the copied file name: "TM000001.tio.tif".]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page or Field Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is not 3 or 4 alphanumeric characters, or if there is an exception encountered while enhancing the image.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LoadSettings">
			<p name="BackupFileExtension" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[String]]>
				</i>
<![CDATA[value of the path to the ImageFix Settings file (.ini).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Note, however, that the action can use Smart Parameter syntax, such as the '@PATH(string)']]>
<![CDATA[
]]>
<![CDATA[        method to specify the path.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action loads the settings that the ]]>
				<b>
<![CDATA[ImageFix]]>
				</b>
<![CDATA[action will use to process all images]]>
<![CDATA[
]]>
<![CDATA[        in the current batch. The action's parameter includes the file's name and complete path to]]>
<![CDATA[
]]>
<![CDATA[        its location in the application's ]]>
				<b>
<![CDATA[Process]]>
				</b>
<![CDATA[directory. As an alternative, the parameter]]>
<![CDATA[
]]>
<![CDATA[        can use a ]]>
				<i>
<![CDATA[smart]]>
				</i>
<![CDATA[ parameter such as @Path to designate the value of the path to the]]>
<![CDATA[
]]>
<![CDATA[        same ]]>
				<b>
<![CDATA[Process]]>
				</b>
<![CDATA[directory.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[LoadSettings(C:\ParentDir\Invoice\Process\ImageFix.ini)]]>
						</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[ImageEnhance(tio)]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          Loads the settings file using the path denoted by the "ScanFixSettings" key that is listed]]>
<![CDATA[
]]>
<![CDATA[          in the Paths.ini file.  If the key pointed to a relative path, it would be converted to the]]>
<![CDATA[
]]>
<![CDATA[          appropriate full path and then use that path to find the settings:]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[LoadSettings(@PATH(ScanFixSettings))]]>
						</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[ImageEnhance(tio)]]>
					</scr>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ImageFix Settings file that you specify as a parameter is not found. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LoadSettings_FingerprintID">
			<p name="FingerprintsFolderPath" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[String]]>
				</i>
<![CDATA[ value of the path to the fingeprint folder ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Note, however, that the action can use Smart Parameter syntax, such as the '@PATH(string)']]>
<![CDATA[
]]>
<![CDATA[        method to specify the path.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Loads the specific ImageFix Settings file (.ini) that corresponds to the Fingerprint ID of the current page.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The action will search the application's fingerprint folder for a fingerprint-specific]]>
<![CDATA[
]]>
<![CDATA[        ImageFix Settings file. Settings for these files are assigned during the Image Enhancement phase]]>
<![CDATA[
]]>
<![CDATA[        of Fingerprint Definition, using tools of Rule Manager's Image Processing Setup dialog.]]>
<![CDATA[
]]>
<![CDATA[        (Chapter 3 of the Rule Manager Reference shows you how to define a fingerprint-specific]]>
<![CDATA[
]]>
<![CDATA[        ImageFix Settings file.)]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Important!]]>
				</b>
<![CDATA[ The name of a fingerprint-specific ImageFix Settings file is limited to]]>
<![CDATA[
]]>
<![CDATA[        the Fingerprint ID with the ".ini" extension: 1044.ini, for example.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[LoadSettings_FingerprintID()]]>
						</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[ImageEnhance(tio)]]>
					</scr>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if a fingerprint-specific Settings file does not exist. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</com>
</rrx>
<rrx namespace="Ewsmail" v="8.0.1.22">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' EWSMail Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.2"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/13/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA['  * SPR 27158 Added Datacap Studio help to the actions.  ]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.6"]]>
<![CDATA[
]]>
<![CDATA[' Updated 3/18/10 NSK]]>
<![CDATA[
]]>
<![CDATA[' Added ex_EMLOption action declaration and help]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.9"]]>
<![CDATA[
]]>
<![CDATA[' Updated 5/17/2010 NSK]]>
<![CDATA[
]]>
<![CDATA[' Added ex_ews_version to select Exchange Server version (if not 2010)]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 5/28/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 28371 - Update help to make it more consistent.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/03/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 28371 - Update help for ex_scan.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/21/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 28371 - Remove spaces from email variable names.  EmailCount added to ex_scan. ]]>
<![CDATA[
]]>
<![CDATA[' Adjusted help to match imail action help, where possible.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.13"]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/15/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 26932 - Updated help text in ex_ews_version, ex_login and ex_EMLOption.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "7.6.15"]]>
<![CDATA[
]]>
<![CDATA[' Updated 7/16/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 26932 / 27158 - Updated help text in ex_login.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.16"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/13/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 28909 Added information in the ex_scan help regarding the email processing method.]]>
<![CDATA[
]]>
<![CDATA[' Also updated ex_max_docs to clarify that a batch can end up with more attachments than the value set in ex_max_docs.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.17"]]>
<![CDATA[
]]>
<![CDATA[' Updated 02/10/2011 PHofle]]>
<![CDATA[
]]>
<![CDATA[' * Enhanced action/method qi text for ex_login to say smartparameters are supported. SPR 31013]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.18"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/19/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 32145 31022 Removed use of SIT and removed use of qi parameters for help text.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.19"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/13/2011 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 31793 Added information regarding email subject lengths.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.20"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/30/2013 MQureshi]]>
<![CDATA[
]]>
<![CDATA[' Added ex_HTTP_timeout to specify Exchange HTTP request/response timeout]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.21"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/06/2013 MQureshi]]>
<![CDATA[
]]>
<![CDATA[' Added ex_load_properties_option for loading additional properties at once]]>
<![CDATA[
]]>
<![CDATA[''**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="ewsmail.CDCewsmail" qi="Exchange EWS main input actions - import image attachments from email messages">
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ex_ews_version" qi="Select the Exchange Server version.">
			<p name="version" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        The value 0, 1 or 2, indicating the following:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        1 = Exchange 2007 SP1]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        2 = Exchange 2010]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        0 = latest version (default)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Each version of Exchange uses a slightly different communication protocol.  Use this action to set the expected version.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        In order to connect successfully with:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        •	Exchange 2007 SP1, call this action with parameter "1" before im_login.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        •	Exchange 2010, call action with parameter "2" before im_login.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        •	The latest version "known" by the .NET library in use (which is .NET 3.5 and is currently Exchange 2010), this action must be called with parameter "0".]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called at all it uses the default "0", the latest version.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_ews_version(1)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_login("mymailserver/Exchange.asmx","Username@Org","password")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level, Open event.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_login]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ex_HTTP_timeout" qi="Specifies the maximum time to wait for an HTTP request or response from Exchange Server.">
			<p name="nSecs" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nSecs : The maximum number of seconds to wait.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The maximum time to wait for an HTTP request or response from Exchange Server.]]>
<![CDATA[
]]>
<![CDATA[        For example, this may be used by the ex_scan action while trying to ingest a very large email that]]>
<![CDATA[
]]>
<![CDATA[        may otherwise result in import failing due to the operation timing out.  This timeout is in addition]]>
<![CDATA[
]]>
<![CDATA[        to any server-side timeout configuration settings.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the timeout defaults to 100 seconds.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_HTTP_timeout("60")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_scan()]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          This example causes the timeout to be set to 60 seconds.  When ingesting emails, any response exceeding this value may fail.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_login, ex_scan]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ex_load_properties_option" qi="Option to flag .">
			<p name="nOption" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nOption : 0 to load base properties, 1 to load limited extended base properties, 2 to load extended properties]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Used to optionally load certain properties at once.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default of 0 will be used to load base properties.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_load_properties_option("1")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_scan()]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          This example causes less trips to the Exchange Server as additional properties are loaded once.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_scan]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ex_login" qi="Specifies the the Exchange Server and mail account">
			<p name="hostname" type="string" qi="URL of Exchange Web Service, ends with /Exchange.asmx (Smartparameters are supported)">
			</p>
			<p name="username" type="string" qi="Username@Org for mail account and organization (blank to use Windows Authentication, Smartparameters are supported)">
			</p>
			<p name="password" type="string" qi="Password for mail account (blank if none or Windows Authentication, Smartparameters are supported )">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        hostname : URL of Exchange Web Service, ends with /Exchange.asmx]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        username : Username@Org for mail account and organization (blank to use Windows Authentication)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        password : Password for mail account (blank if none or Windows Authentication)]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        All parameters support smart parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Connects to the mail server using the specified account information.]]>
<![CDATA[
]]>
<![CDATA[        Login credentials are for a Microsoft Exchange mail server.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The mail account must contain an Inbox folder and separate folders for messages imported (Done)]]>
<![CDATA[
]]>
<![CDATA[        and errors (Problem).  The Done and Problem folders must be subfolders of the email account's Inbox.]]>
<![CDATA[
]]>
<![CDATA[        The names of these folders can be specified using the ex_done_folder and ex_problem_folder actions.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The Microsoft Exchange Email actions are designed to scan an email Inbox for incoming mail messages,]]>
<![CDATA[
]]>
<![CDATA[        and place selected messages into a new batch.]]>
<![CDATA[
]]>
<![CDATA[        It is possible to ignore all messages except those containing specific attachment types.]]>
<![CDATA[
]]>
<![CDATA[        The actions are typically assigned to a Task that is executed by an unattended Taskmaster Rulerunner station.]]>
<![CDATA[
]]>
<![CDATA[        Multiple Inboxes can be scanned by stringing together a set of]]>
<![CDATA[
]]>
<![CDATA[        login/scan/logout actions for each Inbox, or by assigning an Inbox to each input task.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_login("mymailserver/Exchange.asmx","Username@Org","password")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level, open event.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the login succeeds.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_logout]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="ex_scan" qi="Poll the specified mail server for incoming email with image attachments">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Scans emails in the Inbox for specified attachments, imports selected emails with attachments into the batch.  ]]>
<![CDATA[
]]>
<![CDATA[        Call once for each batch.]]>
<![CDATA[
]]>
<![CDATA[        A connection to the email server must have previously been established using the ex_login action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each input email (document) will contain the following variables set in the document hierarchy:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[TYPE]]>
				</b>
<![CDATA[: Always set to "Document".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MessageID]]>
				</b>
<![CDATA[: The email message ID.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Subject]]>
				</b>
<![CDATA[: The email subject.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Body]]>
				</b>
<![CDATA[: The text within the email.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[DateSent]]>
				</b>
<![CDATA[: The sent date stamp on the email.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[From]]>
				</b>
<![CDATA[: The email sender.]]>
				<br>
				</br>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[To]]>
				</b>
<![CDATA[: The email recipients.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Priority]]>
				</b>
<![CDATA[: The state of the email importance flag.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[DateReceived]]>
				</b>
<![CDATA[: The received date stamp on the email.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each email attachment (page) will have the following variables set:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[TYPE]]>
				</b>
<![CDATA[: Always set to "Other".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[IMAGEFILE]]>
				</b>
<![CDATA[: The name of the attachment as saved on disk.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ATTACHNAME]]>
				</b>
<![CDATA[: The name of the attachment.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The following batch level variable is created:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[EmailCount]]>
				</b>
<![CDATA[: The number of emails scanned into the batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Note: If the configured Done or Problem folders do not exist, the email will be moved to the Deleted Items folder.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Waiting emails are processed in blocks.  The amount of emails processed in a block will be the number of]]>
<![CDATA[
]]>
<![CDATA[        waiting emails, or the number of emails remaining from the value set in ex_max_docs, up to a maximum of 50.]]>
<![CDATA[
]]>
<![CDATA[        After a block of emails are processed, the wait time]]>
<![CDATA[
]]>
<![CDATA[        is checked.  If the wait time has not been reached and the maximum number of emails]]>
<![CDATA[
]]>
<![CDATA[        has not been reached, then another block of emails are processed.]]>
<![CDATA[
]]>
<![CDATA[        If the wait time has been reached, then no more emails are input to the batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that the subject line be no longer than 78 characters as this is a]]>
<![CDATA[
]]>
<![CDATA[        common subject line length limitation.  Some systems may support even shorter lengths,]]>
<![CDATA[
]]>
<![CDATA[        truncating the subject.  Our testing has been successful with lengths up to 255 characters.]]>
<![CDATA[
]]>
<![CDATA[        It is recommended to test your settings and use lengths appropriate for your systems.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Use ex_max_docs to configure the number of emails processed per batch.  The number of items]]>
<![CDATA[
]]>
<![CDATA[        included in the batch can be different than this amount, see ex_max_docs for more details.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Important: If any concurrently running threads might be using the same account,]]>
<![CDATA[
]]>
<![CDATA[        your EWSMail-related tasks cannot be run in a multi-threaded configuration. Instead, use single-threaded tasks only.]]>
<![CDATA[
]]>
<![CDATA[        For information about configuring threads in Rulerunner, see Configuring Rulerunner to run tasks.]]>
<![CDATA[
]]>
<![CDATA[        For information about the account, see ex_login.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ex_wait_time("20")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_abort_time("40")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_max_docs("50")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_types("jpg,tif")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_scan()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[			 ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Returns ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the operation fails, and the action will also pause before returning based on]]>
<![CDATA[
]]>
<![CDATA[        the configured abort time configured by ex_abort_time.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If no selected emails were available, the action returns ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[ and also pauses before returning based ]]>
<![CDATA[
]]>
<![CDATA[        on the wait time configured using ex_wait_time.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_login, ex_wait_time, ex_max_docs]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="ex_logout" qi="Disconnect from the mail server">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Closes the connection to the mail server. ]]>
<![CDATA[
]]>
<![CDATA[        Call once for each batch after ex_login and ex_scan have completed.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_logout()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open or Close event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="ex_types" qi="Specifies valid image attachment extensions">
			<p name="extensions" type="string" qi="Comma-separated list of file image file attachment extensions to import, with or without period. If a blank extension is supplied, ex_scan will import messages with no attachments.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        extensions : A comma-separated list of file image file attachment extensions to import, ]]>
<![CDATA[
]]>
<![CDATA[        with or without period. If a blank extension is supplied, ex_scan will import messages with no attachments.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action specifies the allowable email attachment types.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of ".pdf" will be used.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is called and no attachment types are specified, all emails and any attachments are added to the batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If attachment types are specified and the email contains:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        • Only the specified attachment types, the email and attachments will be added to the batch]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        • Only unspecified attachment types, or if it contains a mix of specified and unspecified attachment types, the email is moved to the Problem folder]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        • No attachments, the email is moved to the Problem folder]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ex_wait_time("20")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_abort_time("40")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_max_docs("200")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_types("jpg,tif")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ex_wait_time" qi="Specifies the maximum time to wait for input emails for a single batch.">
			<p name="nSecs" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nSecs : The maximum number of seconds to wait.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The maximum time to wait for input files for a single batch.]]>
<![CDATA[
]]>
<![CDATA[        Used by the ex_scan action after the first email has been processed to determine how long to]]>
<![CDATA[
]]>
<![CDATA[        wait for the batch to fill up.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        The import of emails into the batch will stop when the ]]>
<![CDATA[
]]>
<![CDATA[        wait limit is reached or when the maximum emails per batch has been reached.  ]]>
<![CDATA[
]]>
<![CDATA[        While waiting for new mail to arrive, the mailbox will be polled every two seconds to ]]>
<![CDATA[
]]>
<![CDATA[        check for waiting mail. The action will continue to include new emails into the batch ]]>
<![CDATA[
]]>
<![CDATA[        until this wait time is reached or the maximum number of emails per batch is reached.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default wait time of 5 seconds will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_wait_time("20")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_scan()]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          This example causes the scan operation to wait for 20 seconds for additional email,]]>
<![CDATA[
]]>
<![CDATA[          after processing the first email, before finishing the scan operation.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_scan]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="ex_abort_time" qi="Specifies the delay time before returning when a batch aborts.">
			<p name="nSecs" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nSecs : The number of seconds to wait.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The action will wait the specified time before returning when an abort occurs.]]>
<![CDATA[
]]>
<![CDATA[        This action can be useful to prevent a large number of aborted batches due to]]>
<![CDATA[
]]>
<![CDATA[        an abort condition.  For example, if the email server should become unavailable]]>
<![CDATA[
]]>
<![CDATA[        for a time, the abort timeout will limit the amount of aborted batches until]]>
<![CDATA[
]]>
<![CDATA[        the mail server becomes available again.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 30 seconds will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ex_wait_time("20")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_abort_time("60")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_max_docs("200")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_scan]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_scan]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="ex_max_docs" qi="Specifies maximum number of emails to include in a single batch.">
			<p name="nDocs" type="int" qi="The maximum number of emails in a batch.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nDocs : The maximum number of emails in a batch.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The import of emails into the batch will stop when this email limit is reached]]>
<![CDATA[
]]>
<![CDATA[        or when the maximum wait time has been reached.  While waiting for new mail to arrive,]]>
<![CDATA[
]]>
<![CDATA[        the configured mailbox will be polled every two seconds to check for waiting mail.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 100 will be used.  ]]>
<![CDATA[
]]>
<![CDATA[        The actual amount of emails included in the batch could be less than this maximum.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Note: The value indicates the number of emails with expected attachments that will be processed.]]>
<![CDATA[
]]>
<![CDATA[        If a waiting email contains an unexpected attachment, it is not counted against the]]>
<![CDATA[
]]>
<![CDATA[        total maximum count.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        It is also possible for an email to contain more than one valid attachment type.  When this happens,]]>
<![CDATA[
]]>
<![CDATA[        it is possible for the number of items input to the batch can be greater than the number]]>
<![CDATA[
]]>
<![CDATA[        of configured emails.  For example, if ex_max_docs is set to 5 and if there are 5 waiting]]>
<![CDATA[
]]>
<![CDATA[        emails and each email has 2 attachments, the total number of attachments that will be]]>
<![CDATA[
]]>
<![CDATA[        included in the batch will be 10.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_max_docs("50")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_scan()]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          This example causes the scan operation to limit the number of emails in a]]>
<![CDATA[
]]>
<![CDATA[          batch to a maximum of 50.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_scan]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="ex_done_folder" qi="Specifies folder for successfully imported emails">
			<p name="folder" type="string" qi="Destination folder for successfully imported emails">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        folder : Destination folder for successfully imported emails]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Specifies the name of the email folder into which successfully imported emails are placed.  ]]>
<![CDATA[
]]>
<![CDATA[        This folder must be a subfolder of the email account's Inbox.  ]]>
<![CDATA[
]]>
<![CDATA[        When an email is processed and the attachment is imported, the email is moved ]]>
<![CDATA[
]]>
<![CDATA[        to the folder name specified by this action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of "Done" will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_done_folder("Imported")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_problem_folder("Failed")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_scan]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="ex_problem_folder" qi="Specifies folder for problem emails">
			<p name="folder" type="string" qi="Destination folder for problem email">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        folder : Destination folder for problem email]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        When an email is processed and the attachment is not one of the expected types, ]]>
<![CDATA[
]]>
<![CDATA[        the email is moved to the folder name specified by this action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        This folder must be a subfolder of the email account's Inbox.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of "Problem" will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ex_done_folder("Imported")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_problem_folder("Failed")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_scan]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ex_EMLOption" qi="Creates a one page document per email containing an .eml file.">
			<p name="folder" type="int" qi="Optional - use a nonzero value to store one .eml file per email.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        folder : Optional - use a nonzero value to store one .eml file per email.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If set, the ex_scan action creates a one page document containing the email and ]]>
<![CDATA[
]]>
<![CDATA[        attachments in an .eml file; no attachment pages are created.]]>
<![CDATA[
]]>
<![CDATA[        When called with a non-zero parameter, the ex_scan function does ]]>
<![CDATA[
]]>
<![CDATA[        not create pages for each attachment, instead one page is created per email document, ]]>
<![CDATA[
]]>
<![CDATA[        containing an .eml file suitable for subsequent processing using eDocument Conversion actions.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        When you use this action, pages for attachments are not created, and variables for those attachments are not set.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ex_EMLOption(1)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ex_scan()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ex_scan]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[	]]>
	</com>
</rrx>
<rrx namespace="FileIO" v="9.0.4.11">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' File I/O Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2016 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="Datacap.Libraries.FileIO.Actions" qi="File manipulation actions.">
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="CopyFile" qi="Copies a file.">
			<p name="sourcefile" type="string">
			</p>
			<p name="targetfile" type="string">
			</p>
			<p name="overwrite" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        sourcefile : The name and path of the file to copy. Smart parameters are supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        targetfile : The target path and filename.  Smart parameters are supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        overwrite : if the target file exists, this determines if it should be overwritten. True will overwrite the target file.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The file is copied from one location to the specified location.  If a file of the same target name]]>
<![CDATA[
]]>
<![CDATA[        already exists in the target directory, the overwrite parameter will determine if that file will be overwritten by the new file.]]>
<![CDATA[
]]>
<![CDATA[        The output directory must exist for this action to succeed.  You can use action IsDirectoryPresent to create]]>
<![CDATA[
]]>
<![CDATA[        the target directory.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If target file ends with a backslash, meaning only the target directory is specified,]]>
<![CDATA[
]]>
<![CDATA[        the same file name from the source string will be used as the target file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Because the target file name can be different from the source file, this action]]>
<![CDATA[
]]>
<![CDATA[        allows the copied file to be renamed in one step.  If you want to perform a "move" operation,]]>
<![CDATA[
]]>
<![CDATA[        call the DeleteFile to remove the source file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported in the source and target file name parameters.  DOS * and ? wildcards are not supported.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[CopyFile("C:\MyFile.txt", "c:\temp\+@BATCHID+.txt", true)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This action will copy MyFile.txt to the temp directory and give it a new name of the current batch ID]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[CopyFile("@VAR(IMAGEFILE)", "c:\temp\", true)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This action will copy the file specified by the variable IMAGEFILE and copy it to the temp directory.          ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully copied.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="DeleteFile" qi="Deletes a file.">
			<p name="filename" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        filename : The name and path of the file to delete. Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Deletes the specified file.  DOS wildcards are permitted in the file name.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[DeleteFile("C:\Temp\DeleteThis.txt")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          The above example deletes the specific file.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[DeleteFile("C:\Temp\*.*")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          The above example deletes all of the files in the 'Temp' directory.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[DeleteFile("C:\Temp\@BATCHID+.txt")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          The above example deletes the file name that matches the current batch ID and has an extension of 'TXT'.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ReadTextFile" qi="Reads a text file.">
			<p name="filename" type="string">
			</p>
			<p name="target" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[filename]]>
				</b>
<![CDATA[: The name and path of the text file to read. Smart parameters are supported.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[target]]>
				</b>
<![CDATA[: The DCO node to store the value of the text file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[         Smart parameters are supported for each parameter.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Reads the specified file.  ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ReadFile("C:\Temp\ReadThis.txt","@P.text")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          The above example reads the specific file and saves the value to the parent page of the calling object's to a variable labeled 'text'.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ReadFile("C:\Temp\ReadThis.xml","@P\xmltext")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          The above example reads the specific file and saves the value to the parent page of the calling object to a field named 'xmltext'.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[ if the text file exists and was successfully read, otherwise ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="DeleteDirectory" qi="Deletes a directory and optionally deletes subdirectories">
			<p name="Directory" type="string">
			</p>
			<p name="Recursive" type="bool">
			</p>
			<p name="FailureReturnValue" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Directory:]]>
				</b>
<![CDATA[ The path of the directory to delete.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Recursive:]]>
				</b>
<![CDATA[ True will delete the directory and all files and subdirectories.]]>
<![CDATA[
]]>
<![CDATA[        False will only delete the directory and requires that the directory is empty.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[FalureReturnValue:]]>
				</b>
<![CDATA[ True will cause the action to always return True, even if]]>
<![CDATA[
]]>
<![CDATA[        the delete fails.  False will cause the action to return False if the directory delete fails.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for the directory path.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Deletes the specified directory and can optionally delete subdirectories.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[DeleteDirectory("C:\MyDir1\MyDir2",True,True)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will delete MyDir2 and all files and subdirectories.]]>
<![CDATA[
]]>
<![CDATA[          If the delete fails, the action will still return true.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        If the directory is deleted, the action always returns ]]>
				<b>
<![CDATA[True.]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If a failure occurs when deleting a directory, the action will return the value of FailureReturnValue.]]>
<![CDATA[
]]>
<![CDATA[        This allows you to determine if the action should return True or False on a directory failure.]]>
<![CDATA[
]]>
<![CDATA[        Depending on the applicaiton, it may make sence to ignore a delete failure so this action can be set to always return true.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="CopyDirectory" qi="Copies a directory and its subdirectories">
			<p name="SourceDirectory" type="string">
			</p>
			<p name="DestDirectory" type="string">
			</p>
			<p name="Recursive" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[SourceDirectory:]]>
				</b>
<![CDATA[ The path of the directory to copy.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[DestDirectory:]]>
				</b>
<![CDATA[ The path to the destination directory.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Recursive:]]>
				</b>
<![CDATA[ True will copy the directory files and subdirectories.]]>
<![CDATA[
]]>
<![CDATA[        False will only copy the files in the initial directory and requires that the directory is empty.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for the directory paths.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Copies the source directory to the target directory.  If the target directory does not exist, it will be created, however]]>
<![CDATA[
]]>
<![CDATA[        the parent directory does need to exist.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[CopyDirectory("C:\MyDir1\MyDir2","C:\MyNewDir",True)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will delete MyDir2 and all files and subdirectories to C:\MyNewDir.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        If a failure occurs when coping a directory, the action will return false.  If some of the files]]>
<![CDATA[
]]>
<![CDATA[        have been copied prior to the failure, those files will remain.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="CheckFreeDiskSpace" qi="Checks the size of the available disk space.">
			<p name="DriveLetter" type="string">
			</p>
			<p name="Threshold" type="string">
			</p>
			<p name="TargetVariable" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[DriveLetter:]]>
				</b>
<![CDATA[ The drive letter to test for available disk space. UNC paths are not supported.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Threshold:]]>
				</b>
<![CDATA[ Optional.  The minimum amount of required disk space in bytes.  If provided, this value]]>
<![CDATA[
]]>
<![CDATA[        must be a positive integer.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[TargetVariable:]]>
				</b>
<![CDATA[ Optional. The DCO variable to store the value of the available disk space.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for each parameter.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Checks the available amount of free disk space in bytes.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[CheckFreeDiskSpace("D","1000","@P.FreeSpace")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Checks that the amount of available disk space on drive D is at least 1000 bytes.  ]]>
<![CDATA[
]]>
<![CDATA[          It also stores the amount of free space in the page level runtime DCO variable "FreeSpace".]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[CheckFreeDiskSpace("D","@B.MyLimit","")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Only checks that the amount of available disk space on drive D is at least as much]]>
<![CDATA[
]]>
<![CDATA[          as the value specified in the batch level variable "MyLimit".]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[CheckFreeDiskSpace("D","","@P.FreeSpace")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Only stores the amount of free space in the page level runtime DCO variable "FreeSpace".]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Returns False if the threshold is specified and the amount of free disk space is less]]>
<![CDATA[
]]>
<![CDATA[        than the specified value, if the target variable is provided but cannot be set, or]]>
<![CDATA[
]]>
<![CDATA[        if the drive letter is invalid.  Otherwise True is returned.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="GetFileSize" qi="Obtains the size of a file and stores it in the specified variable.">
			<p name="filename" type="string">
			</p>
			<p name="targetVariable" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        filename : The name and path of the file.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        targetVariable : The name of the variable to store the file size.  The variable level must be specified with a Smart Parameter.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for each of the input parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The size of the specified file will be stored into the specified variable.  This can be]]>
<![CDATA[
]]>
<![CDATA[        helpful to test for problems, such as empty files.  Subsequent actions can]]>
<![CDATA[
]]>
<![CDATA[        perform tests on the stored value and act upon it.]]>
				<br>
				</br>
<![CDATA[ ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If the specified file is not found,]]>
<![CDATA[
]]>
<![CDATA[        the action will return ]]>
				<b>
<![CDATA[true]]>
				</b>
<![CDATA[ and a size of 0 will be stored into the variable.]]>
<![CDATA[
]]>
<![CDATA[        If any other kind of error occurs, the action will return false and the variable]]>
<![CDATA[
]]>
<![CDATA[        may or may not be set to 0.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[GetFileSize("C:\Temp\MyFile.txt", "@B.MyVariable")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example sets the file size in the variable 'MyVariable' at the batch level.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the target variable is blank.  ]]>
<![CDATA[
]]>
<![CDATA[        Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="GetProfileString" qi="Reads a key value from a settings file.">
			<p name="filename" type="string">
			</p>
			<p name="section" type="string">
			</p>
			<p name="key" type="string">
			</p>
			<p name="targetVariable" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        filename : The INI file name.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        section : The section within the file.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        key : The key within the section.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        targetVariable : The variable where to store the value.  The variable level must be specified with a smart parameter.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for each of the input parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Reads the value from a settings file, typically a .INI file, and stores it into the variable specified.]]>
<![CDATA[
]]>
<![CDATA[        If the variable does not exist, it will be created.]]>
<![CDATA[
]]>
<![CDATA[        If the key does not exist but the file does exist, the action will still return true]]>
<![CDATA[
]]>
<![CDATA[        and an empty string will be stored in the variable.  If you need to test for a blank]]>
<![CDATA[
]]>
<![CDATA[        key value, you can use the IsProfilePresent action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If you are reading Unicode characters from an INI file, ]]>
<![CDATA[
]]>
<![CDATA[        it is required that the file is in a format that supports Unicode.  ]]>
<![CDATA[
]]>
<![CDATA[        If the file is not a Unicode format, the Unicode characters may appear ]]>
<![CDATA[
]]>
<![CDATA[        incorrectly when read by GetProfileString or displayed in an editor.  ]]>
<![CDATA[
]]>
<![CDATA[        Most file editors will let you chose the type of file encoding.  ]]>
<![CDATA[
]]>
<![CDATA[        See the help for your specific editor.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[GetProfileString("C:\Settings.ini", "MySection", "MyKey", "@B.MyVariable")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          The value for 'MyKey' will be placed into the variable 'MyVariable'.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the settings file exists and the target variable is valid.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="IsDirectoryPresent" qi="Determines if the specified directory exists and optionally creates it.">
			<p name="directoryName" type="string">
			</p>
			<p name="create" type="bool">
			</p>
			<p name="testExistence" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        directoryName : The directory path to test.  Smart parameters are allowed.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        create : Specifies if the directory should be created.  True will create the directory, if it does not exist.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        testExistence : Determines if true should be returned if the directory exists or does not exist.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Checks for the existence of a directory.  Depending on the input parameters,]]>
<![CDATA[
]]>
<![CDATA[        if the directory does not exist, the action will create the directory.  The]]>
<![CDATA[
]]>
<![CDATA[        meaning of the return value can be changed using the testExistence parameter.]]>
<![CDATA[
]]>
<![CDATA[        This allows rules to continue if a directory exists or rules can continue if a directory does not exist.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[IsDirectoryPresent("c:\temp", true, true)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will create the directory C:\temp, if it does not exist, and return true]]>
<![CDATA[
]]>
<![CDATA[          if the directory exists or was created successfully.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[IsDirectoryPresent("c:\temp", true, false)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will create the directory C:\temp, if it does not exist, and return false]]>
<![CDATA[
]]>
<![CDATA[          if the directory exists or was created successfully.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        If testExistence is ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[, the action will return True if the directory exists or if the]]>
<![CDATA[
]]>
<![CDATA[        directory did not exist but was successfully created.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If testExistence is ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[, the action will return True if the directory does not exist.  This allows you to perform]]>
<![CDATA[
]]>
<![CDATA[        negative tests that will return true when a directory does not exist.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If an error occurs, the action will return false.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="IsFilePresent" qi="Determines if the specified file exists.">
			<p name="filename" type="string">
			</p>
			<p name="testExistence" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        filename : The file name and path.  Smart parameters are allowed.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        testExistence : true tests that the file exists, false tests that the file does not exist.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Checks for the existence of a file.  Depending on the testExistence parameter, ]]>
<![CDATA[
]]>
<![CDATA[        the action can return true if a file exists or true if a file does not exist to ]]>
<![CDATA[
]]>
<![CDATA[        provide flexibility when creating rules.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[IsFilePresent("C:\MyDir\MyFile.abc", false)]]>
					</b>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          In this example, if the file does not exist, the action will return ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[True]]>
					</b>
<![CDATA[ and any subsequent actions will be processed.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        If testExistence is ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ the action will return true if the file exists.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If testExistence is ]]>
				<b>
<![CDATA[false,]]>
				</b>
<![CDATA[ the action will return true if the file does not exist.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If an error occurs, the action will return false.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="IsFileReadOnly" qi="Tests the read only attribute of a file.">
			<p name="filename" type="string">
			</p>
			<p name="testForReadOnly" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        filename : The file name and path of the file to test.  Smart parameters are allowed.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        testForReadOnly : Determines if the action should return true for read-only or read-write.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action will indicate if a file is set to read only.  ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[IsFileReadOnly("c:\mydir\myfile.txt", true)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          if the file "myfile.txt" is set to read only, the action will return ]]>
					<b>
<![CDATA[true]]>
					</b>
<![CDATA[.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[IsFileReadOnly("c:\mydir\myfile.txt", false)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          if the file "myfile.txt" is not set to read only, the action will return ]]>
					<b>
<![CDATA[true]]>
					</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        If testForReadOnly is ]]>
				<b>
<![CDATA[true,]]>
				</b>
<![CDATA[ the action will return true if the file is read only.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If testForReadOnly is ]]>
				<b>
<![CDATA[false,]]>
				</b>
<![CDATA[ the action will return true if the file is not read only.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If an error occurs, or if the file does not exist, the action will return false.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="IsProfilePresent" qi="Tests that a profile exists and that a specific section and key exists within it.">
			<p name="filename" type="string">
			</p>
			<p name="section" type="string">
			</p>
			<p name="key" type="string">
			</p>
			<p name="testExistence" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[         filename : The INI file name.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[         section : The section within the file.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[         key : The key within the section.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[         testExistence : true tests that the it exists, false tests that it does not exist.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[         The parameters "filename", "section" and "key" can accept smart parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Checks that a specific section and key exists within a settings file, typically an INI file.  It does not]]>
<![CDATA[
]]>
<![CDATA[        test the value of the key, only that a value exists.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[IsProfilePresent("C:\MyDir\settings.ini", "mysection", "mykey", true)]]>
					</b>
<![CDATA[ ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          In this example, if settings.ini exists and contains "mysection", "mykey" and if "mykey" ]]>
<![CDATA[
]]>
<![CDATA[          has a non-blank value, it will return ]]>
					<b>
<![CDATA[True.]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if testExistence is true and the section and key is found within the profile and the key has an assigned value.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if testExistence is false and the section or key is not found within the profile or the key value is blank.]]>
<![CDATA[
]]>
<![CDATA[        Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RenameFile" qi="Renames or moves the specified file.">
			<p name="oldName" type="string">
			</p>
			<p name="newName" type="string">
			</p>
			<p name="overwrite" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[       oldName : The source file name and path.  Allows smart parameters.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[       newName : The destination file name and path. Allows smart parameters.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[       overwrite : Specifies if the destination file should be overwritten. True will overwrite an existing file.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Renames the specified file to the new name.  If the directories for the original ]]>
<![CDATA[
]]>
<![CDATA[        and new file names are different, the file will be moved to the new directory.  ]]>
<![CDATA[
]]>
<![CDATA[        If the overwrite parameter is true, the file will overwrite an existing file.  ]]>
<![CDATA[
]]>
<![CDATA[        If overwrite is false, an existing file will not be overwritten.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RenameFile("C:\MyDir\File1.txt", "C:\MyDir\File2.txt", true)]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example renames the file within the same directory, overwriting any existing file called "File2.txt".]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RenameFile("C:\MyDir\File1.txt", "C:\New\File1.txt", true)]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example moves the file from MyDir to New, overwriting any existing file called "File1.txt".]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the file is successfully renamed or moved.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetFileReadOnly" qi="Sets or removes the read only attribute from a file or set of files.">
			<p name="readonly" type="bool">
			</p>
			<p name="filename" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[       readonly : true turns on the read only attribute, false turns it off.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[       filename : The path and filename.  Smart parameters and DOS wildcards are allowed.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets a the read only attribute of a file, or a group of files.  The read only attribute can ]]>
<![CDATA[
]]>
<![CDATA[        be set or cleared with this action.  Standard DOS * and ? wildcards can be used to affect a change]]>
<![CDATA[
]]>
<![CDATA[        on multiple files at once.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetFileReadOnly(false, "C:\MyDir\*.*")]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example sets all of the files in MyDir as read-write.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetProfileString" qi="Writes a value to a profile file, typically called an INI file.">
			<p name="filename" type="string">
			</p>
			<p name="section" type="string">
			</p>
			<p name="key" type="string">
			</p>
			<p name="value" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        filename : The profile file name.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        section : The section within the file.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        key : specifies if the destination file should be overwritten.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        value : The value to write.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for each of the input parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Writes a value to a settings profile, typically a file with an INI]]>
<![CDATA[
]]>
<![CDATA[        extension.  The value is stored in the variable proved as a parameter.]]>
<![CDATA[
]]>
<![CDATA[        If the variable does not exist, it will be created.]]>
<![CDATA[
]]>
<![CDATA[        If the variable does exist, the current value will be replaced with the new value.]]>
<![CDATA[
]]>
<![CDATA[        If the file does not exist, the file will be created.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If you are writing Unicode characters to the INI file, ]]>
<![CDATA[
]]>
<![CDATA[        it is required that the file exist and that it is in Unicode format.  ]]>
<![CDATA[
]]>
<![CDATA[        If the file is not a Unicode format, the Unicode characters may appear ]]>
<![CDATA[
]]>
<![CDATA[        incorrectly when read by GetProfileString or displayed in an editor.  ]]>
<![CDATA[
]]>
<![CDATA[        Most file editors will let you chose the type of file encoding.  ]]>
<![CDATA[
]]>
<![CDATA[        See the help for your specific editor.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetProfileString("C:\MyDir\config.ini","MySection","MyKey","Batch+@BATCHID")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the value is written to the profile.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
		<method name="SplitFileName" qi="Splits a file name into user specified variables.">
			<p name="inputFilename" type="string">
			</p>
			<p name="rootPathVariable" type="string">
			</p>
			<p name="pathVariable" type="string">
			</p>
			<p name="fileVariable" type="string">
			</p>
			<p name="extVariable" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[      inputFilename : The input file name to break into its three logical parts.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      rootPathVariable : The name of the variable to store the root path.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      pathVariable : The name of the variable to store the file path.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      fileVariable : The name of the variable to store the file name without the extension.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      extVariable : The name of the variable to store the file extension.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Smart parameters are supported for each of the input parameters.  For each of the]]>
<![CDATA[
]]>
<![CDATA[      parameters that accept a variable, the level must be specified with a Smart Parameter.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      It is not necessary to specify a variable name for each part of the path that is split.]]>
<![CDATA[
]]>
<![CDATA[      Only destination variables for the desired values need to be specified.]]>
<![CDATA[
]]>
<![CDATA[      If you do not want to store a particular file name part, leave that parameter blank.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[      This action will split the input file name into its root path, path, file name and the extension,]]>
<![CDATA[
]]>
<![CDATA[      and place each of the parts into their own variables.  The file does not need to exist.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If the file contains a file extension, the saved file extension will contain a preceding period.      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
				<e>
<![CDATA[
]]>
<![CDATA[        ]]>
					<b>
<![CDATA[SplitFileName("C:\Dir1\Dir2\MyFile.abc","@B.FROOT","@B.FPATH", "@B.FNAME","@B.FEXT")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        This example splits the file and saves the information into 4 variables at the batch level:]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        FROOT = "C:\"]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        FPATH = "C:\Dir1\Dir2"]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        FNAME = "MyFile"]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        FEXT  = ".abc"]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
					<b>
<![CDATA[SplitFileName("@VAR(IMAGEFILE)","","","","@B.EXT")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        Obtains the value stored in the variable IMAGE file and only saves the file extension into a variable called EXT.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[      ]]>
				</e>
<![CDATA[
]]>
<![CDATA[    ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the structure of the file name or path is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      The file does not need to exist for this action to succeed.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ]]>
		<method name="ZipOcrResults" qi="Creates a ZIP file containing recognition results for every page of the document.">
			<h>
<![CDATA[
]]>
<![CDATA[        This action will create a ZIP file for the associated document. The Zip file name is based on the ID of the document object]]>
<![CDATA[
]]>
<![CDATA[        in the format of DocumentID.ocr.zip.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This zip file will contain all of the files with recognition results from every page of the document.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        For example- if an action is called on document with ID "20160914.000000.01" which contains two pages,]]>
<![CDATA[
]]>
<![CDATA[        then a zip file called 20160914.000000.01.ocr.zip will be created. The contents of the ZIP will]]>
<![CDATA[
]]>
<![CDATA[        contain all of the recognition results associated with each page similar to this:　]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[        tm000001.xml]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        tm000001_layout.xml]]>
				<br>
				</br>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[        tm000001c.xml]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        tm000002.xml]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        tm000002_layout.xml]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        tm000002c.xml]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Document level]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the zip file is created successfully otherwise ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="FingerprintMaintenance" v="8.0.1.2">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA['Fingerprint Maintenance Actions]]>
<![CDATA[
]]>
<![CDATA[' Copyright Datacap Inc. 2009-2010, All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.0"]]>
<![CDATA[
]]>
<![CDATA[' 11/8/2010 Michael Schlachter]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.0"]]>
<![CDATA[
]]>
<![CDATA[' 12/9/2010 Michael Schlachter]]>
<![CDATA[
]]>
<![CDATA[' Added support for smart parameters]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.2"]]>
<![CDATA[
]]>
<![CDATA[' 12/16/2010 Michael Schlachter]]>
<![CDATA[
]]>
<![CDATA[' Added smart paremter support to DeleteFingerprints and updated help indicating that smart parameters are supported]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.3"]]>
<![CDATA[
]]>
<![CDATA[' 5/11/2011 Michael Schlachter]]>
<![CDATA[
]]>
<![CDATA[' updated to Visual Studio 2010]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.4"]]>
<![CDATA[
]]>
<![CDATA[' 5/11/2012 Michael Schlachter]]>
<![CDATA[
]]>
<![CDATA[' added encryption]]>
<![CDATA[
]]>
<![CDATA['Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['"Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['5725-C15]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['© Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA['disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA['IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
	<h>
<![CDATA[These actions are used to automate the deletion of fingerprints in your application.  It is intended for applications]]>
<![CDATA[
]]>
<![CDATA[	that create fingerprints automatically.  By periodically deleting fingerprints that are not used you can decrease the time]]>
<![CDATA[
]]>
<![CDATA[	it takes to load them when the FindFingerprint action is called.]]>
<![CDATA[
]]>
<![CDATA[	]]>
	</h>
	<com ref="Datacap.Libraries.FingerprintMaintenance.Actions" qi="Actions to automate fingerprint deletion.">
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="OpenDatabase" qi="Opens a connection to the fingerprint database.">
			<ap>
<![CDATA[Fingerprint database connection string.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[			  Opens a connection to the fingerprint database using the connection string provided in the parameter.  A smart parameter may be used.]]>
<![CDATA[
]]>
<![CDATA[			  ]]>
				<e>
<![CDATA[
]]>
<![CDATA[				  ]]>
					<b>
<![CDATA[OpenDatabase("provider=microsoft.jet.oledb.4.0;data source=c:\datacap\apt\APTFingerprint.mdb;persist security info=false")]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example obtains the connection string set in the applicaiton manager.]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[OpenDatabase("@APPVAR(*/dco_*[1]/fingerprintconn:cs)")]]>
					</b>
<![CDATA[
]]>
<![CDATA[			  ]]>
				</e>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[			  ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[ if the connection is established.]]>
<![CDATA[
]]>
<![CDATA[			  ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the connection is not established.]]>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</ret>
			<p name="ConnectionString" type="string" qi="Fingerprint database connection string.">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="SetFingerprintFolder" qi="Specifies the folder containing the fingerprint files.">
			<ap>
<![CDATA[Folder path where the fingerprints are located.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[			  Specifies the folder containing the fingerprint files.  A smart parameter may be used.]]>
<![CDATA[
]]>
<![CDATA[			  ]]>
				<e>
<![CDATA[
]]>
<![CDATA[				  ]]>
					<b>
<![CDATA[SetFingerprintFolder("C:\Datacap\APT\fingerprint")]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example obtains the path set in the applicaiton manager.]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetFingerprintFolder("@APPPATH(*/fingerprint)")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[			  Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</ret>
			<p name="Folder" type="string" qi="Folder containing the fingerprints.">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="DeleteFingerprint" qi="Deletes specified fingerprint.">
			<ap>
<![CDATA[The ID of the fingerprint to delete.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[			  Deletes the CCO, TIFF and FPXML files for the specified fingerprint.  Also deletes the database record and position information from the DCO.  A smart parameter may be used.]]>
<![CDATA[
]]>
<![CDATA[			  ]]>
				<e>
<![CDATA[
]]>
<![CDATA[				  ]]>
					<b>
<![CDATA[DeleteFingerprint("1002")]]>
					</b>
<![CDATA[
]]>
<![CDATA[			  ]]>
				</e>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[			  Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</ret>
			<p name="ID" type="string" qi="ID of fingerprint to delete">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="DeleteFingerprints" qi="Deletes all fingerprints returned by the SQL statement in the parameter">
			<ap>
<![CDATA[SQL statement used to return a recordset of fingerprints that should be deleted.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[			  Deletes all fingerprints returned by the query specified in the parameter.  A smart parameter may be used.]]>
<![CDATA[
]]>
<![CDATA[			  ]]>
				<e>
<![CDATA[
]]>
<![CDATA[			  ]]>
					<b>
<![CDATA[Access]]>
					</b>
<![CDATA[ - DeleteFingerprints("SELECT * FROM Template WHERE tp_LastHit ]]>
<![CDATA[<]]>
<![CDATA[ dateadd("d",-30,NOW)")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[			  ]]>
					<b>
<![CDATA[SQL]]>
					</b>
<![CDATA[ - DeleteFingerprints("SELECT * FROM Template WHERE tp_LastHit ]]>
<![CDATA[<]]>
<![CDATA[ dateadd(d,-2,GETDATE())")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
					<b>
<![CDATA[Oracle]]>
					</b>
<![CDATA[ - DeleteFingerprints("SELECT * FROM Template WHERE tp_LastHit ]]>
<![CDATA[<]]>
<![CDATA[ TRUNC(SYSDATE) - 30")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[		  ]]>
				</e>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[			  Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</ret>
			<p name="SQL" type="string" qi="SQL statement to return a recordset of fingerprints to be deleted">
			</p>
		</method>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="CloseDatabase" qi="Closes connection to the fingerprint database and saves the Setup DCO.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[			  Closes the open database connection and saves the Setup DCO if position information was deleted.  The Setup DCO will not be modified if FPXML files are used, or if no fingerprints were deleted.]]>
<![CDATA[
]]>
<![CDATA[			  ]]>
				<e>
<![CDATA[
]]>
<![CDATA[				  ]]>
					<b>
<![CDATA[CloseDatabase()]]>
					</b>
<![CDATA[
]]>
<![CDATA[			  ]]>
				</e>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[			  Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[		  ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="ICM" v="8.1.0.8">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA['IBM Content Classification Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' "Restricted Materials of IBM"]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.0" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/05/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * 31996 - Initial implementation.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.1" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/17/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * 31996 - Updated help text for actions UpdateKnowledgebaseICM and SetKnowledgeBaseNameICM.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.2" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/09/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * 31996 - Added action SetMaxConnectionsICM.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.3"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/16/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * 31996 - Removed action SetMaxConnectionsICM as it is no longer relevant with the change to Datacap.Libraries.CC.dll v8.1.0.6]]>
<![CDATA[
]]>
<![CDATA['         - Added action SetLanguageICM to specify the language used in the working knowledge base.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.4"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/01/2011 CMcGhee]]>
<![CDATA[
]]>
<![CDATA[' * 32902 - Updated help text:  fixed typos and grammar, changed name from InfoSphere ]]>
<![CDATA[
]]>
<![CDATA['to IBM Classification Module]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.5"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/07/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * 32902 Re-added action SetMaxConnectionsICM as is required for multi-threaded processing in Datacap.Libraries.CC.dll v8.1.0.7]]>
<![CDATA[
]]>
<![CDATA['         Updated help text for the FindFingerprintICM action ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.6"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/08/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' * 31996 - Removed action SetMaxConnectionsICM as it is no longer relevant with the change to Datacap.Libraries.CC.dll v8.1.0.8]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.7"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/05/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help for actions to state that they have been replaced by actions in CC.rrx library.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version ="8.1.0.8"]]>
<![CDATA[
]]>
<![CDATA['Updated 03/07/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA['Changed Datacap.Libraries.ICM.Actions namespace to Datacap.Libraries.CC.Actions]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
	</g>
	<com ref="Datacap.Libraries.CC.Actions" qi="IBM Content Classification Actions. This action library has been replaced by CC.rrx.">
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="FindFingerprintICM" qi="This action has been replaced by FindFingerprintCC in CC.rrx.">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetKnowledgeBaseICM" qi="This action has been replaced by SetKnowledgeBaseCC in CC.rrx.">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetProblemValueICM" qi="This action has been replaced by SetProblemValueCC in CC.rrx.">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetLanguageICM" qi="This action has been replaced by SetLanguageCC in CC.rrx.">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetListenerURLICM" qi="This action has been replaced by SetListenerURLCC in CC.rrx">
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UpdateKnowledgeBaseICM" qi="This action has been replaced by UpdateKnowledgeBaseCC in CC.rrx.">
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="Imail" v="9.0.1.24">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' IMail Actions]]>
<![CDATA[
]]>
<![CDATA['--------------------------------------------------------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 ]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2015 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA['--------------------------------------------------------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' version 9.0.0.17 update im_login action help to show support for :port at end of mail server URL/IP]]>
<![CDATA[
]]>
<![CDATA[' version 9.0.0.20 updated help for im_login regarding ssl port number.]]>
<![CDATA[
]]>
<![CDATA[' version 9.0.0.21 Added SetProxy action.]]>
<![CDATA[
]]>
<![CDATA[' version 9.0.0.22 Updated the help for im_reject_types.]]>
<![CDATA[
]]>
<![CDATA[' version 9.0.1.23 Updated the help for im_scan.]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="dcjmail.CDCjmail" qi="IMAP email import actions - import image attachments from email messages.">
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      The IMail actions are designed to scan an email Inbox for incoming mail messages,]]>
<![CDATA[
]]>
<![CDATA[      and place selected messages into a new Batch.]]>
<![CDATA[
]]>
<![CDATA[      It is possible to ignore all messages except those containing specific attachment types.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The actions are typically assigned to a Task that is executed by an unattended Rulerunner station.]]>
<![CDATA[
]]>
<![CDATA[      Multiple Inboxes can be scanned by stringing together a set of]]>
<![CDATA[
]]>
<![CDATA[      login/scan/logout actions for each Inbox, or by assigning an Inbox to each input task.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The mail account must contain an Inbox folder and separate folders for messages successfully imported (Done folder)]]>
<![CDATA[
]]>
<![CDATA[      and messages that encountered errors (Problem folder).  Processed emails will be placed into one of these folders.]]>
<![CDATA[
]]>
<![CDATA[      Done and Problem folders must be at the same level of the folder hierarchy as the Inbox and must be manually]]>
<![CDATA[
]]>
<![CDATA[      created prior to running your application.]]>
<![CDATA[
]]>
<![CDATA[      The names of these folders can be changed using the im_done_folder and im_problem_folder actions.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_login" qi="Specifies the IMAP mail server URL and login credentials.">
			<p name="hostname" type="string">
			</p>
			<p name="username" type="string">
			</p>
			<p name="password" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        hostname : URL or IP address of IMAP mail server. May end with colon followed by port number (:port).]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        username : Username for mail account.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        password : Password for mail account.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for all parameters.  The password can be encrypted by storing it in the Advanced section of the Custom tab in the Application Manager.  The URL and user name parameters can be stored in the General section of the Datacap Application Manager but they cannot be encrypted.  To retrieve the password that is stored in the Advanced section, use a smart parameter for the action's password parameter similar to @APPVAR(values/adv/mailPassword) where mailPassword is the name entered for the value in the Application Manager.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Connects to the mail server using the specified account information.]]>
<![CDATA[
]]>
<![CDATA[        Specifies the mail server URL and login credentials.]]>
<![CDATA[
]]>
<![CDATA[        Login credentials are for a mail server that supports the IMAP protocol (such as MS Exchange, and many others).]]>
<![CDATA[
]]>
<![CDATA[        Call once for each batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        To connect on an encrypted channel using SSL / HTTPS protocol, call im_useSSL(True) before login.]]>
<![CDATA[
]]>
<![CDATA[        If a port number is not specified in the host name when using SSL, port 993 will be used.        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_login("mymailserver.com","theuser","password")]]>
					</b>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_login("mymailserver.com:8000","theuser","password")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example specifies the port along with the host name.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the login succeeds.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[im_useSSL]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_SetProxy" qi="Allows optional specification of proxy service settings.">
			<p name="hostname" type="string">
			</p>
			<p name="proxyPort" type="string">
			</p>
			<p name="proxyType" type="string">
			</p>
			<p name="proxyUsername" type="string">
			</p>
			<p name="proxyPassword" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        hostname : URL or IP address of proxy service.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        proxyPort : The proxy service connection port.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        proxyType : The type of proxy service: HTTP, SOCKS4, SOCKS5 or NONE.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        proxyUsername : Username for the proxy server.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        proxyPassword : Password for the proxy server.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for all parameters.  ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        The password can be encrypted by storing it in the Advanced section of the Custom tab in the Application Manager.  ]]>
<![CDATA[
]]>
<![CDATA[        The URL and user name parameters can be stored in the General section of the Datacap Application Manager but they cannot be encrypted.  ]]>
<![CDATA[
]]>
<![CDATA[        To retrieve the password that is stored in the Advanced section, ]]>
<![CDATA[
]]>
<![CDATA[        use a smart parameter for the action's password parameter similar to ]]>
<![CDATA[
]]>
<![CDATA[        @APPVAR(values/adv/mailProxyPassword) where mailProxyPassword is the name entered for the value in the Application Manager.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Optionally sets the values to a proxy service that will be used to connect to the email server.]]>
<![CDATA[
]]>
<![CDATA[        This action does not confirm that the connection to the proxy service is successful. Connection to the]]>
<![CDATA[
]]>
<![CDATA[        proxy service will not occur until the im_login action is called.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If this action is used, it must be called prior to the im_login action.  If this action is not]]>
<![CDATA[
]]>
<![CDATA[        called, then no proxy service will be used.  If proxyType is not one of the supported ]]>
<![CDATA[
]]>
<![CDATA[        types, then it will default to "none".]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_SetProxy("theHostName", "1234", "SOCKS4", "MyUser", "@APPVAR(values/adv/mailProxyPassword)")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_login("mymailserver.com","theuser","password")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          This example sets up the parameters to use a proxy and then performs the login.]]>
<![CDATA[
]]>
<![CDATA[          The parameter for the password is an example smart parameter that obtains the password]]>
<![CDATA[
]]>
<![CDATA[          from an advanced value in the application service.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level, typically batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the proxyPort is not numeric, otherwise ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[im_login]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_scan" qi="Poll the specified mail server for incoming emails with image attachments.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Scans emails in the Inbox for specified attachments, imports selected emails with attachments into the batch.]]>
<![CDATA[
]]>
<![CDATA[        Call once for each batch.]]>
<![CDATA[
]]>
<![CDATA[        A connection to the email server must have previously been established using the im_login action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each input email will contain the following variables set in the document hierarchy:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[TYPE]]>
				</b>
<![CDATA[: Always set to "Document".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Subject]]>
				</b>
<![CDATA[: The email subject.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Body]]>
				</b>
<![CDATA[: The text within the email.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[DateSent]]>
				</b>
<![CDATA[: The sent date stamp on the email.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[From]]>
				</b>
<![CDATA[: The email sender.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[User]]>
				</b>
<![CDATA[: The email user specified in the im_login action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[To]]>
				</b>
<![CDATA[: The email recipients.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Priority]]>
				</b>
<![CDATA[: The state of the email importance flag.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Attachments are ingested as individual pages within the email document, unless im_StoreEML(true) is called before im_scan.  With individual attachments, each attachment page will have the following variables set:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[TYPE]]>
				</b>
<![CDATA[: Always set to "Other".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[IMAGEFILE]]>
				</b>
<![CDATA[: The name of the attachment as saved on disk.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The following batch level variable is created:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[EmailCount]]>
				</b>
<![CDATA[: The number of emails scanned into the batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that the subject line be no longer than 78 characters as this is a]]>
<![CDATA[
]]>
<![CDATA[        common subject line length limitation.  Some systems may support even shorter lengths,]]>
<![CDATA[
]]>
<![CDATA[        truncating the subject.  Our testing has been successful with lengths up to 255 characters.]]>
<![CDATA[
]]>
<![CDATA[        It is recommended to test your settings and use lengths appropriate for your systems.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Important: If any concurrently running threads might be using the same account,]]>
<![CDATA[
]]>
<![CDATA[        your Imail-related tasks cannot be run in a multi-threaded configuration. Instead, use single-threaded tasks only.]]>
<![CDATA[
]]>
<![CDATA[        For information about configuring threads in Rulerunner, see Configuring Rulerunner to run tasks.]]>
<![CDATA[
]]>
<![CDATA[        For information about the account, see im_login.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          im_wait_time("20")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_abort_time("40")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_max_docs("200")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_types("jpg,tif")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_scan()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Returns ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the operation fails, and pauses before returning.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If no selected emails were available, the action returns ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[ and pauses before returning.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Action returns when timeout is reached, or the requested number of emails have been processed.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[im_useSSL, im_done_folder, im_problem_folder, im_wait_time, im_abort_time, im_StoreEML, im_AcceptMixedAttachments, im_AcceptNoAttachments, im_SortByDate]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_logout" qi="Disconnect from the mail server.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Closes the connection to the mail server.]]>
<![CDATA[
]]>
<![CDATA[        Call once for each batch after im_login and im_scan have completed.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_logout()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open or Close event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_types" qi="Specifies valid file extensions for attachments to ingest.">
			<p name="extensions" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        extensions : Comma-separated list of file image file extensions to import,]]>
<![CDATA[
]]>
<![CDATA[        with or without period.  If the parameter is blank, all emails with or without attachments will be processed.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action specifies the allowable email attachment types.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of ".pdf" will be used.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is called and no attachment types are specified, all emails and any attachments are added to the batch.]]>
<![CDATA[
]]>
<![CDATA[        When emails without attachments are processed, this will result in documents without any "pages".]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If attachment types are specified and the email contains:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        • Only the specified attachment types, the email and attachments will be added to the batch]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        • Only unspecified attachment types, or if it contains a mix of specified and unspecified attachment types, the email is moved to the Problem folder]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        • No attachments, the email is moved to the Problem folder]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          im_wait_time("20")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_abort_time("40")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_max_docs("200")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_types("jpg,tif")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_reject_types" qi="Specifies file extensions for attachments to reject.">
			<p name="extensions" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        extensions : Comma-separated list of file image file extensions to ignore,]]>
<![CDATA[
]]>
<![CDATA[        with or without period.  Use in conjunction with im_AcceptMixedAttachments(True) to reject emails with specific attachment types.]]>
<![CDATA[
]]>
<![CDATA[        Attachments specified in im_types will be ingested, attachment types not specified in im_types or im_reject_types will be ignored.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action specifies disallowed attachment types.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          im_types("jpg,tif")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_AcceptMixedAttachments("True")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_reject_types(".eml")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_wait_time" qi="Specifies the maximum time to wait for input emails for a single batch.">
			<p name="nSecs" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nSecs : The maximum number of seconds to wait.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The maximum time to wait for input emails for a single batch, when there is at least one pending email.]]>
<![CDATA[
]]>
<![CDATA[        Used by the im_scan action after the first email has been processed to determine]]>
<![CDATA[
]]>
<![CDATA[        how long to wait for the batch to fill up.  If no emails are pending, the im_scan action]]>
<![CDATA[
]]>
<![CDATA[        will not wait regardless of the wait time value.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The import of emails into the batch will stop when the wait limit is reached]]>
<![CDATA[
]]>
<![CDATA[        or when the maximum emails per batch has been reached.]]>
<![CDATA[
]]>
<![CDATA[        While waiting for new mail to arrive,]]>
<![CDATA[
]]>
<![CDATA[        the configured mailbox will be polled every two seconds to check for waiting mail.]]>
<![CDATA[
]]>
<![CDATA[        The action will continue to include new files into the batch until this wait time]]>
<![CDATA[
]]>
<![CDATA[        is reached or the maximum number of emails per batch is reached.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default wait time of 5 seconds will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_wait_time("20")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_abort_time("60")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_max_docs("200")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_types("jpg,tif")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_abort_time" qi="Specifies the delay time before returning when a batch aborts.">
			<p name="nSecs" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nSecs : The number of seconds to wait.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The action configures how long an Imail action will wait before returning when an abort occurs.]]>
<![CDATA[
]]>
<![CDATA[        This action can be useful to prevent a large number of aborted batches due to an error condition.]]>
<![CDATA[
]]>
<![CDATA[        For example, if the email server should become unavailable for a time, or any other error that is quickly returned from the email server.]]>
<![CDATA[
]]>
<![CDATA[        The abort timeout will limit the number of aborted batches until the mail server becomes available again.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default abort time value of 30 seconds will be used.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        When logging in or ingesting emails, a single action can make multiple communication requests to the email server.]]>
<![CDATA[
]]>
<![CDATA[        If the server does not respond to any single communication request within a specific period of time, the request will fail and cause]]>
<![CDATA[
]]>
<![CDATA[        the batch to abort. By default, any single communication request to the email server will wait]]>
<![CDATA[
]]>
<![CDATA[        5 minutes for a response. Typically communication is very fast and this default time is more than enough required for a ]]>
<![CDATA[
]]>
<![CDATA[        typical request to complete.]]>
<![CDATA[
]]>
<![CDATA[        This timeout is different from the value set by the im_abort_time action.  If necessary, the maximum time to wait for an email server]]>
<![CDATA[
]]>
<![CDATA[        response can be adjusted by setting the DCO variable "ImailResponseTimeout" to the number of seconds to wait for]]>
<![CDATA[
]]>
<![CDATA[        a response before forcefully stopping the waiting request to the email server.  The variable should be set on the same]]>
<![CDATA[
]]>
<![CDATA[        DCO object that calls the IMail actions.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          im_wait_time("20")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_abort_time("60")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_max_docs("200")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_types("jpg,tif")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          In this example the abort time is set to 60 seconds.  If there is a failure when processing an email]]>
<![CDATA[
]]>
<![CDATA[          that causes the action to abort, the action will delay an additional 60 seconds before]]>
<![CDATA[
]]>
<![CDATA[          returning. This is to prevent a large number of cascade failures in a very short time as in the case]]>
<![CDATA[
]]>
<![CDATA[          where the server may immediately reject the request for various reasons.]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_max_docs" qi="Specifies maximum number of emails to include in a single batch.">
			<p name="nDocs" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nDocs : The maximum number of emails in a batch.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The import of emails into the batch will stop when this email limit is reached]]>
<![CDATA[
]]>
<![CDATA[        or when the maximum wait time has been reached.  While waiting for new mail to arrive,]]>
<![CDATA[
]]>
<![CDATA[        the configured mailbox will be polled every two seconds to check for waiting mail.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 100 will be used.]]>
<![CDATA[
]]>
<![CDATA[        The actual amount included in the batch could be less than this maximum.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          im_wait_time("20")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_abort_time("60")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_max_docs("50")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_types("jpg,tif")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          This example causes the scan operation to limit the number of emails in a]]>
<![CDATA[
]]>
<![CDATA[          batch to a maximum of 50.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_done_folder" qi="Specifies the IMAP folder for successfully imported emails.">
			<p name="folder" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        folder : Destination IMAP folder for successfully imported emails.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        When an email is processed and the attachment is imported, the email is moved to the folder name]]>
<![CDATA[
]]>
<![CDATA[        specified by this action.]]>
<![CDATA[
]]>
<![CDATA[        The folder is expected to be on the root level, the same level as the inbox folder in the mail account specified by the im_login action.]]>
<![CDATA[
]]>
<![CDATA[        If the folder exists in a subfolder,]]>
<![CDATA[
]]>
<![CDATA[        then use a forward slash to separate the folder names.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of "Done" will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_done_folder("Imported")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_problem_folder("Failed")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example changes the default names of the "Done" and "Problem" folders and also requires]]>
<![CDATA[
]]>
<![CDATA[          the "Imported" and "Failed" folders to be on the same level as the "Inbox" folder.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_done_folder("Inbox/Imported")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_problem_folder("Inbox/Failed")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          This example requires the folders to be a subfolder of the Inbox folder.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_problem_folder" qi="Specifies the IMAP folder for problem emails.">
			<p name="folder" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        folder : Destination IMAP folder for problem emails.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Smart paramters are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        When an email is processed and the attachment is not one of the expected types,]]>
<![CDATA[
]]>
<![CDATA[        the email is moved to the folder specified by this action. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The folder is expected to be on the root level, the same level as the inbox folder of the mail account specified by the im_login action.]]>
<![CDATA[
]]>
<![CDATA[        If the folder exists in a subfolder, then use a forward slash to separate the folder names.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of "Problem" will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          im_done_folder("Imported")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_problem_folder("Failed")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example changes the default name of the "Problem" folder to "Failed" and]]>
<![CDATA[
]]>
<![CDATA[          requires the "Imported" and "Failed" folders to be on the same level as the "Inbox" folder.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          im_done_folder("Inbox/Imported")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_problem_folder("Inbox/Failed")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example specifies the folder which is a subfolder of the Inbox folder.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_UseSSL" qi="Connect to IMAP Server via SSL encrypted channel">
			<p name="bUseSSL" type="bool" qi="A boolean value that enables or disables SSL communication">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ Use SSL to encrypt communication with the mail server.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ Communicate with the email server without encryption.  This is the default method if im_UseSSL is not called.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action will configure the im_login action to use SSL for the login and must be called prior to im_login to have any effect.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        When SSL is enabled, and no port number has been specified in the host name of the im_login action,]]>
<![CDATA[
]]>
<![CDATA[        subsequent im_login and im_scan actions communicate with the email server via IMAPS protocol using SSL encryption via port 993.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When SSL is not in use, these actions communicate with the email server via IMAP protocol via port 143.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[im_UseSSL("True")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          im_login("mymailserver.com","theuser","password")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_StoreEML" qi="Store one .eml file per message, rather than one file per attachment">
			<p name="bStoreEML" type="bool" qi="A boolean value that enables storing each email message as an .eml file">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ Store each ingested email message, formatted together with all attachments, in a single .eml file and attach it as a page to the document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ Add each ingested email message as a document, with associated variables, and add each attachment as a page within the document.]]>
<![CDATA[
]]>
<![CDATA[        This is the default if im_StoreEML is not called. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If set, the im_scan action creates a one page document containing the email and]]>
<![CDATA[
]]>
<![CDATA[        attachments in an .eml file; no attachment pages are created and no variables are set in the document.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_AcceptMixedAttachments" qi="Ingest emails with selected attachment types, even if non-selected attachment types are included">
			<p name="bMixedOK" type="bool" qi="A boolean value that enables ingestion of emails with both allowed and disallowed attachment types">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ An email message with an attachment type not specified by im_types will be ingested as long as it contains some desired attachment.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ An email message with any disallowed attachment will be rejected.  This is the default process if this action is never called.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If this action is never called, the presence of any attachment not specified by im_types will cause im_scan to treat that email message as a "Problem".]]>
<![CDATA[
]]>
<![CDATA[        If this action is called with parameter True, messages with disallowed attachment types are ingested as long as they contain at least one allowed attachment.]]>
<![CDATA[
]]>
<![CDATA[        If im_types is called with a blank parameter prior to im_scan, all emails are ingested, so this action has no effect.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_AcceptNoAttachments" qi="Ingest emails without attachments, even if attachment types are specified">
			<p name="bNoAttachOK" type="bool" qi="A boolean value that enables ingestion of emails with no attachments">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ An email message with no attachments will be ingested by im_scan.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ An email message no attachments will be rejected by im_scan, unless im_types has been called with a blank parameter.  This is the default behavoir if this action is never called.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If this action is never called, the absence of an attachment will cause im_scan to treat that email message as a "Problem".]]>
<![CDATA[
]]>
<![CDATA[        If this action is called with parameter True, messages with no attachments are ingested.]]>
<![CDATA[
]]>
<![CDATA[        If im_types is called with a blank parameter prior to im_scan, all emails are ingested, so this action has no effect.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="im_SortByDate" qi="Sort emails by received date">
			<p name="bSort" type="bool" qi="A boolean value that enables or disables sorting of emails before ingestion">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ Causes im_scan to sort email messages by date received and ingest the oldest messages first.]]>
<![CDATA[
]]>
<![CDATA[        This is the default behavior if im_SortByDate is never called. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ Disables sorting of email messages.  This greatly increases performance of im_scan when many emails are pending in the inbox.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        When sorting is enabled, all pending emails are sorted and the oldest is ingested first.  This can take a significant amount of time for each batch.  When the inbox may contain a large number of emails (e.g. more than 100), call im_SortByDate(False) to speed up the process.  In this case, messages are processed in the order that the email server presents them to Taskmaster.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="mvscan" v="9.0.2.31">
	<com ref="Datacap.Libraries.mvScan.Actions" qi="MultiThreaded vScan Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      Use these actions to create batches from files on disk, typically on a network file share. ]]>
<![CDATA[
]]>
<![CDATA[      The input files may be image files produced by a Multifunction Device (MFD) or fax, or arbitrary files dropped off for processing.]]>
<![CDATA[
]]>
<![CDATA[      mvscan actions can safely run in multiple threads or processes, on a single computer or on multiple computers. These instances coordinate with each other by creating *.lock files in the input folder.]]>
<![CDATA[
]]>
<![CDATA[      mvscan scans one or more folders within a single subtree and mantains a cached list of files for ingestion, for performance and to reduce load on the network and file system.]]>
<![CDATA[
]]>
<![CDATA[	  External processes that place files in the input folders must never overwrite an existing file.  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="set_folder" qi="Specifies the top level folder to search for files to be ingested">
			<p name="folderpath" type="string" qi="Path to folder containing files to be ingested">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        folderpath : A string value specifying the path an input folder. Multiple input folders can be separated by vertical bar symbols (|).  ]]>
<![CDATA[
]]>
<![CDATA[        The scan() action ingests selected file types from these folders, and optionally subfolders, into batches for processing.]]>
<![CDATA[
]]>
<![CDATA[        Each ingested batch will contain files from a single folder.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action must be called before scan().]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_folder("@APPPATH(vscanimagedir)+@STRING(\input folder)")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          scan()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="set_copy_folder" qi="Optional, sets a folder to contain a copy of each ingested file">
			<p name="folderpath" type="string" qi="Path to folder to contain a copy of each ingested file">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        folderpath : A string value specifying the path of the folder where a copy of each input files will be placed, in addition to the batch.  This folder must exist or the scan() action will produce an error.]]>
<![CDATA[
]]>
<![CDATA[        For demo purposes, set the copy folder the same as the input folder.  In this case the scan action leaves ingested files in place and rescans the input folder, ignoring the cache file.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action must be called before scan() to take effect.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_folder("@APPPATH(vscanimagedir)+@STRING(\input folder)")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          set_copy_folder(@APPPATH(vscanimagedir)+@STRING(\copy folder))]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          scan()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="set_problem_folder" qi="Required, sets folder for any files that cannot be ingested">
			<p name="folderpath" type="string" qi="Path to folder to contain any files that cannot be ingested">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        folderpath : A string value specifying the path of the folder where files that cannot be ingested will be placed.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action must be called before scan().  If this action is not called, and scan is unable to ingest a file, the batch will be aborted. Any files already ingested into the batch will remain in the batch. The file which cannot be ingested may be left in a locked state.  Manual intervention will be required.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_folder("@APPPATH(vscanimagedir)+@STRING(\input folder)")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          set_problem_folder(@APPPATH(vscanimagedir)+@STRING(\problem folder))]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          scan()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="scan" qi="Poll the specified folder for files to ingest.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Scans the source folder for files with desired extensions, then ingests them into a batch.]]>
<![CDATA[
]]>
<![CDATA[        Call once for each batch.]]>
<![CDATA[
]]>
<![CDATA[        All desired options must be set prior to calling this action.]]>
<![CDATA[
]]>
<![CDATA[        If no files are present for ingestion the batch is set to pending status and the action returns immediately.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Each input file will generate one or more "pages" in the batch with the following page variables set:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[TYPE]]>
				</b>
<![CDATA[: Always set to "Other".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[IMAGEFILE]]>
				</b>
<![CDATA[: The filename within the batch, e.g. TM000002.tif]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          set_folder("@APPPATH(vscanimagedir)+@STRING(\mvscan folder)")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          set_types("jpg,pdf,tif")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          set_max_docs("2")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[scan()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Returns ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the operation fails, and pauses before returning.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Action returns when timeout is reached, or the requested number of files have been ingested.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="set_types" qi="Comma-separated list of file extensions to be ingested. Can be specified with or without period. Default is TIF. Overrides set_metadata_types().">
			<p name="extensions" type="string" qi="Comma-separated list of file image file extensions to import">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        String value of extension(s) of input files that should be ingested.  For multiple types, separate]]>
<![CDATA[
]]>
<![CDATA[        each one with a comma. Any files with extensions not in this list are ignored.  A smart parameter that evaluates to a file extension or list of extensions is accepted.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        It is optional to include a period before each extension. The parameter is not case-sensitive.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Uses the value of a file extension(s) to specify the type of files the task will scan.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This is an optional action: the task will scan .tif files by default.]]>
<![CDATA[
]]>
<![CDATA[        For this action to take effect, it must be called before the scan action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This action overrides any previous call to set_metadata_types(), and causes files to be ingested without metadata.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_types("tif,tiff,pdf")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Scan()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This sequence will ingest files ending with ".tif", ".tiff", and ".pdf".]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="set_metadata_types" qi="Specifies metadata trigger file extension or comma-separated list. Overrides set_types().">
			<p name="extensions" type="string" qi="Metadata image file extension(s). If specified, XML metadata files (AKA trigger files) control ingestion of pages into batches, along with associated metadata. If specified, these extensions override any prior call to set_types()">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        String value of extension(s) of input files containing "pointers" to files to be ingested along with metadata to be included in the batch for each file.  For multiple types, separate]]>
<![CDATA[
]]>
<![CDATA[        each one with a comma. Any files with extensions not in this list are ignored.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        It is optional to include a period before each extension. The parameter is not case-sensitive.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action overrides any previous call to set_types(), and forces the action to read properly formatted XML from the metadata trigger file to determine which files get ingested, rather than ingesting individual files into the batch.  Other settings such as set_min_age() are applied to the metadata files.]]>
<![CDATA[
]]>
<![CDATA[		The XML file must follow the format below.]]>
<![CDATA[
]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    The tag name of the XML root node must be ᐸinputᐳ.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    The ᐸitemᐳ nodes represent a group of input files or images that share metadata.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    The ᐸitemᐳ nodes must contain at least one attribute, but can have a number of attributes. In this example, the ᐸitemᐳ nodes contain the attributes name=, vendor_number=, vendor_name=, invoice_number=.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    The ᐸitemᐳ attribute names are entered in the item as text following the =.]]>
<![CDATA[
]]>
<![CDATA[    These name values are prepended with Meta_Item_ when they are written to the DCO to define the metadata variable names that are placed on each page. The attribute values populate the variable values.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    The inner most nodes must be ᐸfilenameᐳ and contain items that represent single input files.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    A ᐸfilenameᐳ can be either a fully qualified path, for example \\server\folder\filename, or a partial path relative to the location of the metadata file such as folder\filename. The number of filenames in each repeating item is only limited to the practical limit of how many files you want to ingest in a single batch.]]>
<![CDATA[
]]>
<![CDATA[    Each file is ingested as a Page in the batch, regardless of the file type or contents.]]>
				<br>
				</br>
<![CDATA[
]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[All of the items in a metadata file are ingested into the same batch. For example, if a metadata file contains 1 node with 50 filenames, 50 files are ingested for that single metadata file. If the metadata file contains 5 nodes with 50 filenames in each of them, then 250 files are ingested. The external system that creates the metafile must create all of the files to be ingested before writing the metafile that refers to them.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[Here is an example of a valid XML metadata file:]]>
<![CDATA[
]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[ᐸinputᐳ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ᐸitem name="Invoice1" vendor_number="TS265329" vendor_name="Busy Car Repair" invoice_number="28100"ᐳ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ᐸfilenameᐳC:\Datacap\APT\images\Input\Invoice_0001S1.tifᐸ/filenameᐳ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ᐸfilenameᐳC:\Datacap\APT\images\Input\Invoice_0002S1.tifᐸ/filenameᐳ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ᐸ/itemᐳ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ᐸitem name="Invoice2" vendor_number="TS23785354" vendor_name="Trucking Co." invoice_number="876-3456"ᐳ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ᐸfilenameᐳC:\Datacap\APT\images\Input\Invoice_0003S1.tifᐸ/filenameᐳ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ᐸfilenameᐳC:\Datacap\APT\images\Input\Invoice_0004S1.tifᐸ/filenameᐳ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ᐸ/itemᐳ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[ᐸ/inputᐳ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_metadata_types("xml")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Scan()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This sequence will scan for metadata trigger files ending in ".xml".]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="set_sort_method" qi="Selects method for sorting files for ingestion">
			<p name="method" type="string" qi="Sort method can be either DATE (default) or NAME.  The parameter is not case sensitive.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The scan action takes snapshots of the input folder, sorts the files by either date last modified (default) or by filename, and then tries to ingest the files in that order.  This action allows you to override the default sort order.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_sort_method("NAME")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Scan()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This sequence will ingest files in alphabetical order.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level Open event only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="set_wait_time" qi="Specifies interval to wait for additional files to ingest, before finishing a batch which has not reached the specified maximum size or time limits.">
			<p name="nSecs" type="int" qi="Time to wait for files to complete a batch.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nSecs : The maximum number of seconds to wait for files to complete a batch.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The maximum time to wait for input files to arrive, if at least one file was ingested, no more files are available, and the batch has not reached capacity.]]>
<![CDATA[
]]>
<![CDATA[        Ingestion of files into the batch will stop when the wait limit is reached]]>
<![CDATA[
]]>
<![CDATA[        or when the maximum number of files per batch has been reached.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If no files are available during the scan() action, and this time is reached, the scan action will return and the batch status will remain "pending".]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default wait time of 2 seconds will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        NOTE: This action can be used to group incoming files when ingesting from a single input folder. It is not effective in tree mode or for metadata XML.  ]]>
<![CDATA[
]]>
<![CDATA[        When ingesting from multiple folders or in tree mode, use set_min_age instead to wait for a group of files to appear in the input folders.  See set_min_age for the special case set_wait_time(0) in tree mode.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_wait_time("60")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          scan()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		]]>
		<method name="set_abort_time" qi="Specifies delay time if batch aborts">
			<p name="nSecs" type="int" qi="Time to wait before continuing when a serious error occurs.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nSecs : Time to wait before continuing when a serious error occurs.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The scan action will wait the specified time before returning if a fatal error is detected that would cause the batch to abort.]]>
<![CDATA[
]]>
<![CDATA[        This action can be useful to prevent a large number of aborted batches due to an abort condition.]]>
<![CDATA[
]]>
<![CDATA[        For example, if the source folder should become unavailable for some time,]]>
<![CDATA[
]]>
<![CDATA[        the abort timeout will limit the number of aborted batches until the folder becomes available again.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default abort time value of 5 seconds will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_abort_time("60")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          scan()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="set_move_wait_time" qi="Specifies time to wait for source file to be deleted after move">
			<p name="nSecs" type="int" qi="Number of seconds to wait for source file to be deleted, before failure.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nSecs : Number of seconds to wait for source file to be deleted, before failure.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Over a slow network, and especially with large input files, moving the file from the source folder to the batch folder may take a significant length of time.  The scan action checks that the source file has been deleted after moving it.  If the source file still exists, the scan action waits for a length of time, checking periodically if the file has been deleted.  At the end of this time period, if the source file still exists, the copy in the batch folder is renamed with an extension ".failed" and it is not included in the batch.  It is then assumed that the original source file will be ingested by another subsequent scan task.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_move_wait_time("120")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          scan()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="set_max_docs" qi="Specifies maximum number of pages in each batch.  If Metadata files are used, this is the maximum number of metadata files to import.">
			<p name="nDocs" type="int" qi="Number of documents in a batch.  Default 100.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nDocs : An integer value which specifies the maximum number of input files to place into a batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If Metadata files are used (set_metadata_types() is called instead of set_types(), this specifies the maximum number of metadata files to ingest.  All files referenced in each metadata file are included in the batch, there is no limit on the number of pages in the batch in this case.]]>
<![CDATA[
]]>
<![CDATA[        The default value is 100.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        For this action to take effect, it must be called before the Scan action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          set_tree_mode(false)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_max_docs("1")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          scan()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="set_tree_mode" qi="Determines whether subdirectories are included in the scan for files to ingest">
			<p name="bTreeFlag" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        bTreeFlag : A Boolean value that enables or disables ingesting files from sub-folders within the top level scan folder.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ Search for files in subfolders to any depth below the scan folder. Folder names beginning with underscore (_) are ignored.  This is the default if the action is not called.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ Ingest files located in the scan folder only.  Ignore subfolders.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Each batch will contain files from only one folder regardless of the tree mode setting.  Files from multiple folders will never be ingested into the same batch.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Tree mode is true by default. For this action to take effect, it must be called before the Scan action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          set_types("tif")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_tree_mode(false)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[scan()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="set_delete_empty_folders" qi="Determines whether empty subdirectories will be deleted">
			<p name="bParam" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        bParam : A Boolean value that enables or disables deleting sub-folders if they are empty.  The root folder specified for ingestion is never deleted. Subfolders are only deleted if both this setting and tree mode are enabled.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ Delete subfolders of the main ingestion folder if they are empty. This is the default if the action is not called.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ Leave empty subfolders intact.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If tree mode is not enabled, this setting has no effect.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        For this action to take effect, it must be called before the Scan action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          set_types("tif")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_min_age("10")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_tree_mode(True)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_delete_empty_folders(False)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          scan()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="set_min_age" qi="Specifies minimum age of file since last modified">
			<p name="nSecs" type="int" qi="Number of seconds to wait after file modified before ingesting">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        nSecs : An integer value, the number of seconds to wait after file modified before ingesting.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        The default value is zero, meaning ingest files as soon as they are present.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This setting can be used to prevent premature ingestion of a file which may be incomplete. For example, a network scanner or multifunction device might create the image file and write contents over a period of time, rather than all at once.  In that case ingesting the file immediately could cause errors, whereas waiting for 5 or 10 seconds would provide sufficient time for the file to be completed.  If required, the appropriate value must be determined experimentally.]]>
<![CDATA[
]]>
<![CDATA[        If tree mode is enabled, all files in a given folder must meet the minimum age before any file from that folder is ingested. This allows you to keep files written to a subfolder in the same batch. To override this behavoir and check the age of files individually in tree mode, set_wait_time to zero.  ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        For this action to take effect, it must be called before the Scan action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          set_types("tif")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_min_age("10")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          scan()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="set_image_validation" qi="Forces TIFF images to be checked before ingesting">
			<p name="bValidate" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        bValidate : A Boolean value that enables or disables validating image files during ingestion.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ Check to confirm that each file ingested contains a valid TIFF or JPG image.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ Copy input files regardless of type or contents.  This is the default if the action is not called.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Enables testing that each file ingested is a valid image file. If enabled, converts black and white TIF files to G4 compression.  This action should not be called against invalid file types such as PDFs due to incompatibility.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        For this action to take effect, it must be called before the Scan action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          set_types("tif")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_image_validation("True")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          scan()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="set_multipage_burst" qi="Forces multipage TIFF images to be split into single pages during ingestion">
			<p name="bBurst" type="bool" qi="Nonzero to force bursting of TIFF image files. Default = 0, no bursting.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        bBurst : A Boolean value that enables or disables bursting multipage image files during ingestion.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ Any multipage TIFF file will be separated into multiple pages in the batch, one per image.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ One page is output per input file.  This is the default if the action is not called.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Enables splitting or bursting multipage source image files into one image per page in the batch.]]>
<![CDATA[
]]>
<![CDATA[        For this action to take effect, it must be called before the Scan action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This action requires that set_types() be called with only one extension of TIF, TIFF, JPG or JPEG.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          set_types(".tif")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[set_multipage_burst(1)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          scan()]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          If the scan action in this sequence encounters a multipage .tif file, then it will]]>
<![CDATA[
]]>
<![CDATA[          read each one into the current batch as a separate image, thereby "bursting" the multipage]]>
<![CDATA[
]]>
<![CDATA[          file into individual images.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="mv_retain_folders" qi="Preserves the directory structure of files in the input folder tree">
			<p name="bRetain" type="bool" qi="Nonzero to enable this option, default is disabled">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        bRetainFolders : A Boolean value that enables or disables preserving the directory structure.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True:]]>
				</b>
<![CDATA[ If and when an input file is moved to the Problem or Copy folders, the path relative to the base input folder is reproduced within the Problem or Copy folder.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False:]]>
				</b>
<![CDATA[ Input files are placed directly in the Problem or Copy folder as appropriate. The relative path within the input folder is only retained in the ScanSrcPath variable.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If the option is enabled, the Problem and Copy folders are populated with subfolders to match the path of the input files relative to the root input folder.]]>
<![CDATA[
]]>
<![CDATA[        Additionally, the following variables are added to the page to allow the application to determine the path of the input file:]]>
<![CDATA[
]]>
<![CDATA[        ScanSrcInputFolder (the full path of the root input folder for this file), ScanSrcSubFolder (the relative path of the ingestion folder where the file was found, including the input root folder name but not the path leading up to it), and ScanSrcFileName (just the original filename without a path).]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="Nenu" v="9.0.4.29">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' NENU Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' 'Restricted Materials of IBM']]>
<![CDATA[
]]>
<![CDATA[' 5725-C15]]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2016 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/17/2009 OGorbunov]]>
<![CDATA[
]]>
<![CDATA[' * 22425 Inital implementation.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.2"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/17/2009 OGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Consolidated SetaTMLog actions]]>
<![CDATA[
]]>
<![CDATA[' Added functionality to QuerySetAge function to recognize seconds. ]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.3"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/06/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 29187 Added help text. Removed SetDebugFlag.  SetTMLog was changed to ConfigureMessageLog.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.4"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/11/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 29196 Update help text for parameters that accept smart parameters. ]]>
<![CDATA[
]]>
<![CDATA['       OpenApplicationEx, SetApplication, SetServer, SetAdminDB, SetEngineDB, SetUser, SetPassword, SetStation, ]]>
<![CDATA[
]]>
<![CDATA['       ChangeBatchesStatus, ChangeBatchesStatusOrder, ChangeBatchesStatusTaskOrder, MoveBatches, ]]>
<![CDATA[
]]>
<![CDATA['       SendEmail, ResetPendingOrNotify, ConfigureMessageLog, SetSQLSeparator, QuerySetJobID, ]]>
<![CDATA[
]]>
<![CDATA['       QuerySetTaskID, QuerySetStatus, QuerySetOperator, QuerySetStation, QuerySetDateRange,]]>
<![CDATA[
]]>
<![CDATA['       QuerySetAge, QuerySetGeneric and WriteEventLog.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.5"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/01/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Added actions (help review needed):]]>
<![CDATA[
]]>
<![CDATA[' ClearLog()]]>
<![CDATA[
]]>
<![CDATA[' SetReportingTable(...)	]]>
<![CDATA[
]]>
<![CDATA[' SetUsageDBTable(...)]]>
<![CDATA[
]]>
<![CDATA[' ClearAudit()]]>
<![CDATA[
]]>
<![CDATA[' ClearDebug()]]>
<![CDATA[
]]>
<![CDATA[' Added classes(header review needed. Copied the same one from "Datacap.Libraries.Nenu.Actions".):]]>
<![CDATA[
]]>
<![CDATA[' "Datacap.Libraries.Nenu.aTMSetup"]]>
<![CDATA[
]]>
<![CDATA[' "Datacap.Libraries.Nenu.Reporting"]]>
<![CDATA[
]]>
<![CDATA[' "Datacap.Libraries.Nenu.BatchProcess"]]>
<![CDATA[
]]>
<![CDATA[' "Datacap.Libraries.Nenu.SQLQuerySetup"]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.6"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/01/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Renamed class "Datacap.Libraries.Nenu.Actions" to "Datacap.Libraries.Nenu.Logging"]]>
<![CDATA[
]]>
<![CDATA[' Renamed class "Datacap.Libraries.Nenu.aTMSetup" to "Datacap.Libraries.Nenu.AppSetup"]]>
<![CDATA[
]]>
<![CDATA[' Renamed action ConfigureMessageLog to ConfigureLogging and moved it to Logging class]]>
<![CDATA[
]]>
<![CDATA[' Moved DisconnectAll to AppSetup class]]>
<![CDATA[
]]>
<![CDATA[' Renamed action GetRecordSet to WriteRecordSet and moved to Logging class]]>
<![CDATA[
]]>
<![CDATA[' Renamed GetSQLQuery to WriteSQLQuery and moved to Logging class]]>
<![CDATA[
]]>
<![CDATA[' Renamed ChangeBatchesStatus to ChangeBatchStatus]]>
<![CDATA[
]]>
<![CDATA[' Renamed ChangeBatchesStatusOrder to ChangeBatchStatusOrder]]>
<![CDATA[
]]>
<![CDATA[' Renamed ChangeBatchesStatusTaskOrder to ChangeBatchStatusTaskOrder]]>
<![CDATA[
]]>
<![CDATA[' Remamed class "Datacap.Libraries.Nenu.SQLQuerySetup" to "Datacap.Libraries.Nenu.QuerySetup"]]>
<![CDATA[
]]>
<![CDATA[' Renamed action SetSQLSeparator to QuerySetSeparator]]>
<![CDATA[
]]>
<![CDATA[' Moved action RunSQLQuery to QuerySetup class]]>
<![CDATA[
]]>
<![CDATA[' Renamed action ClearAudit to ClearAuditTable]]>
<![CDATA[
]]>
<![CDATA[' Renamed action ClearDebug to ClearDebugTable]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['' Version = "8.0.7"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/09/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' moved all the actions to a single class "Actions"]]>
<![CDATA[
]]>
<![CDATA[' renamed:]]>
<![CDATA[
]]>
<![CDATA[' ConfigureLogging to LogConfigure]]>
<![CDATA[
]]>
<![CDATA[' WriteRecordSet to LogWriteRecordSet]]>
<![CDATA[
]]>
<![CDATA[' WriteSQLQuery to LogWriteSQLQuery]]>
<![CDATA[
]]>
<![CDATA[' ClearLog to LogClear]]>
<![CDATA[
]]>
<![CDATA[' SendEmail to LogSendEmail]]>
<![CDATA[
]]>
<![CDATA[' WriteEventLog to LogWriteEventLog]]>
<![CDATA[
]]>
<![CDATA[' DisconnectAll to SetupDisconnectAll]]>
<![CDATA[
]]>
<![CDATA[' OpenApplication to SetupOpenApplication]]>
<![CDATA[
]]>
<![CDATA[' OpenApplicationEx to SetupOpenApplicationEx]]>
<![CDATA[
]]>
<![CDATA[' RunSqlQuery to ProcessRunSqlQuery]]>
<![CDATA[
]]>
<![CDATA[' ClearAuditTable to ProcessClearAuditTable]]>
<![CDATA[
]]>
<![CDATA[' ClearDebugTable to ProcessClearDebugTable]]>
<![CDATA[
]]>
<![CDATA[' MoveDBRecords to ProcessMoveDBRecords]]>
<![CDATA[
]]>
<![CDATA[' ChangeBatchStatus to ProcessChangeBatchStatus]]>
<![CDATA[
]]>
<![CDATA[' ChangeBatchStatusOrder to ProcessChangeBatchStatusOrder]]>
<![CDATA[
]]>
<![CDATA[' ChangeBatchStatusTaskOrder to ProcessChangeBatchStatusTaskOrder]]>
<![CDATA[
]]>
<![CDATA[' DeleteBatches to ProcessDeleteBatches]]>
<![CDATA[
]]>
<![CDATA[' MoveBatches to ProcessMoveBatches]]>
<![CDATA[
]]>
<![CDATA[' ResetPendingOrNotify to ProcessResetPendingOrNotify]]>
<![CDATA[
]]>
<![CDATA[' QueryTMUsage to ReportQueryTMUsage]]>
<![CDATA[
]]>
<![CDATA[' SetReportingTable to RetorpSetReportingTable]]>
<![CDATA[
]]>
<![CDATA[' SetUsageDBTable to ReportSetUsageDBTable]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.8"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/23/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 29187 Minor help updates.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.9"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/28/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Renamed RetorpSetReportingTable to ReportSetReportingTable]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/28/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Added parameter asAttachment to ProcessResetPendingOrNotify]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 09/30/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 29187 Minor help updates.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/18/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Added parameter to ProcessMoveDBRecords action to select target DB date time separator.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.13"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/22/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 29886 Clarified the help to state that when performing multiple operations that include]]>
<![CDATA[
]]>
<![CDATA['       moving the database records, the database move should be performed last.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.14"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/27/2010 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Moved parameter targetDBSQLSeparator in the action ProcessMoveDBRecords to the end of list, as it is not likely to be used.]]>
<![CDATA[
]]>
<![CDATA[' Updated help for QuerySetSeparator.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.15"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/13/2010 RFerin]]>
<![CDATA[
]]>
<![CDATA[' 30131 Fixed help text for ProcessDeleteBatches.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.16"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/01/2011 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Added ProcessInjectBatches Function]]>
<![CDATA[
]]>
<![CDATA[' Added QuerySetBatchRange Function]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.17"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/21/2011 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Added function QuerySetDateFormat and QuerySetDateTimeFormat]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.18"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/22/2011 RFerin ]]>
<![CDATA[
]]>
<![CDATA[' 32144 Removed support for DCSit.  Use smart parameters to obtain passwords from the application service.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.19"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/22/2011 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' 31243 Fixed help for action SetupOpenApplication]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.20"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/03/2011 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Moved parameter information from the qi= tag to the standard parameter help section]]>
<![CDATA[
]]>
<![CDATA[' Moved action information from the qi= tag to the standard action help section]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.21"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/03/2011 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Fixed typo in coma word]]>
<![CDATA[
]]>
<![CDATA[' Added location of the audit and debug tables to the help]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.22"]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/14/2012 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Fixed typos in action's help]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.23"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/20/2012 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Fixed typos in action's help]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.24"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/20/2012 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Fixed help for QuerySetGeneric action]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.25"]]>
<![CDATA[
]]>
<![CDATA[' Updated 04/20/2012 AGorbunov]]>
<![CDATA[
]]>
<![CDATA[' Fixed help for SetupOpenApplication, SetupOpenApplicationEX, SetPasword, SetUser and SetStation (LDAP - leave blank user, pwd and station).]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.26"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/03/2013 MQureshi]]>
<![CDATA[
]]>
<![CDATA[' Added action ProcessDeleteBatchesEx]]>
<![CDATA[
]]>
<![CDATA[' Deprecated action ProcessDeleteBatches]]>
<![CDATA[
]]>
<![CDATA[' Fixed help to use better examples for QuerySetJobID]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "8.1.0.27"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/13/2013 MQureshi]]>
<![CDATA[
]]>
<![CDATA[' Added action ProcessMoveBatchesEx]]>
<![CDATA[
]]>
<![CDATA[' Deprecated action ProcessMoveBatches]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.0.28"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/20/2014 MQureshi]]>
<![CDATA[
]]>
<![CDATA[' Added action ProcessRunSqlQueryEx]]>
<![CDATA[
]]>
<![CDATA[' Deprecated action ProcessRunSqlQuery]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Version = "9.0.4.29"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/25/2016 IMIKHAYLOVA]]>
<![CDATA[
]]>
<![CDATA[' Made privite actions ProcessRunSqlQuery,ProcessDeleteBatches,ProcessMoveBatches]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="Datacap.Libraries.Nenu.Actions" qi="Logging actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      NENU, the New Enhanced Notification Utility, can monitor one or more applications, perform maintenance]]>
<![CDATA[
]]>
<![CDATA[      and reporting on them.  Everything NENU does is action based, allowing it to be]]>
<![CDATA[
]]>
<![CDATA[      highly customized to the needs of specific applications.  NENU has the ability to build queries using]]>
<![CDATA[
]]>
<![CDATA[      rulesets and actions from within Datacap Studio.  The results of the queries can be acted]]>
<![CDATA[
]]>
<![CDATA[      on directly to send notifications or automatically adjust batch states.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Using the "QuerySet" actions, queries can be dynamically generated at run time, piece by piece.]]>
<![CDATA[
]]>
<![CDATA[      Each action will specify aspects of the query until it is finally executed.  The result is]]>
<![CDATA[
]]>
<![CDATA[      a record set of batches that can be acted upon as required.]]>
<![CDATA[
]]>
<![CDATA[      For example, it is possible to delete or mote batches that have reached a certain age.  If batches]]>
<![CDATA[
]]>
<![CDATA[      have become stuck in an aborted state, an email can be generated to a set of recipients to notify them]]>
<![CDATA[
]]>
<![CDATA[      of the issue.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LogClear" qi="Clears current Log.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Clears current log.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogClear()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LogConfigure" qi="Configures features of aTM logging.">
			<p name="severity" type="int">
			</p>
			<p name="filePath" type="string">
			</p>
			<p name="overwrite" type="bool">
			</p>
			<p name="reflash" type="bool">
			</p>
			<p name="showTime" type="bool">
			</p>
			<p name="showDate" type="bool">
			</p>
			<p name="showSeverity" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        severity: The log severity limit [0-9]. 0 = maximum logging.  4 or 5 = typically informational or error logging. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        filePath: Log file path name or blank to disable logging.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        overwrite: True will overwrite any existing file. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        reflash: True will flush the error message buffer to disk after every write. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        showTime: True adds the current time to each log message. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        showDate: True adds the current date to each log message. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        showSeverity: True adds the severity to the log. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Configures aTM logging.  The severity controls verbosity of the log; logging only severe errors will provide]]>
<![CDATA[
]]>
<![CDATA[	the best performance at expense of reduced debugging information, should a debug trace be required.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This will not change logging as configured for each of the tasks in the target application (i.e. RRS logs).]]>
<![CDATA[
]]>
<![CDATA[	If this action is not called, no aTM log file will be created.  aTM logging can be evaluated to see which]]>
<![CDATA[
]]>
<![CDATA[	requests were transmitted to the Taskmaster Server.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogConfigure("5", "@STRING(C:\ParentDir\NENU\Logs\NENU.aTM)")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          In this example, rolling 'NENU.aTM.#.log' logs will be placed into the custom directory.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogConfigure("5", "@APPPATH(export)")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          In this example, the output directory is retrieved from the application service]]>
<![CDATA[
]]>
<![CDATA[          using Smart parameters.  The path is the export directory for the current application.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if logging is successfully configured.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LogWriteRecordSet" qi="Outputs the results of ProcessRunSqlQuery to the error log.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Writes out the result of the last call to ProcessRunSqlQuery to the error file.]]>
<![CDATA[
]]>
<![CDATA[        This action can be useful for debugging an application.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!Demo Job")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogWriteRecordSet("")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the write is successful.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery, LogWriteSQLQuery]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LogWriteSQLQuery" qi="Outputs the constructed SQL query to the error log.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Writes out the result of the previous calls to the "QuerySet" actions to the error file.]]>
<![CDATA[
]]>
<![CDATA[        This action can be useful for debugging an application, allowing you to view the]]>
<![CDATA[
]]>
<![CDATA[        exact SQL that was constructed and used in ProcessRunSqlQuery.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!Demo Job")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogWriteSQLQuery("")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the log is successfully written.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery, LogWriteRecordSet]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LogSendEmail" qi="Sends email with log to comma separated list of recipients.">
			<p name="asattachment" type="bool">
			</p>
			<p name="addressFrom" type="string">
			</p>
			<p name="addressTo" type="string">
			</p>
			<p name="subject" type="string">
			</p>
			<p name="user" type="string">
			</p>
			<p name="password" type="string">
			</p>
			<p name="domain" type="string">
			</p>
			<p name="server" type="string">
			</p>
			<p name="port" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        All parameters support Smart parameters.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        asattachment: Send the log as attachment to the e-mail. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        addressFrom: Address From (Optional). Default value: currentUser@currentDomain. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        addressTo: Comma separated list of recipients. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        subject: email subject (Optional). Default value: 'NENU notification current_date_and_time'. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        user: Mail user name (Optional). Default value: current user credentials. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        password: Mail user password (Optional). Default value: current user credentials. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        domain: Mail user domain (Optional). Default value: current domain. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        server: Mail Server name (Optional). Default value: mail.current_domain. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        port: Mail Server Port number (Optional). Default value: 25. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sends an email using the SMTP protocol.  As NENU actions run, an in-memory log keeps track of each of the NENU actions]]>
<![CDATA[
]]>
<![CDATA[        that are called and their parameters.  The LogSendEmail action will place the action activity information into an]]>
<![CDATA[
]]>
<![CDATA[        email and send it.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogSendEmail("jsmith@somewhere.com", "jdoe@somewhere.com,mmoore@somewhere.com", "", "", "", "", "", "")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the email is sent.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="LogWriteEventLog" qi="Writes a message to the Event Log.">
			<p name="message" type="string">
			</p>
			<p name="level" type="int">
			</p>
			<p name="eventID" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        message: Message to write to the Event Log and the local log.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        level: Integer value. 0 - informational, 1 - Warning, 2 - Error. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        eventID: Integer value. Desired Event ID. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Unconditionally writes out a message to the Windows Event Log and to the application log file for the running task.]]>
<![CDATA[
]]>
<![CDATA[        Set the level and event ID to the values that is appropriate for the message being logged.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogWriteEventLog("This is an informational message.", "0", "10")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example writes the message 'This is an informational message.' to the event log.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[LogWriteEventLog("@B.MyMessage", "0", "10")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example uses Smart parameters to write out the value of the batch level variable "MyMessage".]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the event is successfully logged.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetupDisconnectAll" qi="Disconnect from all Taskmaster servers.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Closes the connections to all Taskmaster databases that were opened by NENU actions.]]>
<![CDATA[
]]>
<![CDATA[        Some NENU actions will automatically close the connection to the database]]>
<![CDATA[
]]>
<![CDATA[        after a query has been performed.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetupDisconnectAll()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetupOpenApplication" qi="Creates connection to the application based on default settings.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        A simplified version of SetupOpenApplicationEx.  It is identical in operation with the difference that]]>
<![CDATA[
]]>
<![CDATA[        all of the default parameters are used.  The default values can be set]]>
<![CDATA[
]]>
<![CDATA[        independently by individual actions, such as SetApplication, SetServer, etc.  See SetupOpenApplicationEx for more information.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When using LDAP or ADSI authentication use the ]]>
				<b>
<![CDATA[SetUser]]>
				</b>
<![CDATA[, ]]>
				<b>
<![CDATA[SetStation]]>
				</b>
<![CDATA[ and ]]>
				<b>
<![CDATA[SetApplication]]>
				</b>
<![CDATA[ actions instead of SetupOpenApplication.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetApplication("APT")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetServer("Server 1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetUser("user")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetPassword("password")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetAdminDB("*/tmadmin:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetEngineDB("*/tmengine:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetupOpenApplication()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the application exists in the application service the connection was successful.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[
]]>
<![CDATA[        SetupOpenApplicationEx, SetApplication, SetServer, SetAdminDB, SetEngineDB, SetUser, SetPassword, SetStation]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="SetupOpenApplicationEx" qi="Creates connection to the application based on the parameters provided.">
			<p name="application" type="string">
			</p>
			<p name="server" type="string">
			</p>
			<p name="admin" type="string">
			</p>
			<p name="engine" type="string">
			</p>
			<p name="debugFlag" type="bool">
			</p>
			<p name="user" type="string">
			</p>
			<p name="password" type="string">
			</p>
			<p name="station" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        All parameters, except for debugFlag, support Smart parameters. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        application: Application name (Optional). Default value: the name of the application that is running this action. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        server: Server name (Optional). Default value: first available server in the application. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        admin: Administration Database name (Optional). Default value: first available Admin DB. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        engine: Engine Database name (Optional). Default value: first available Engine DB. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        debugFlag: Debug Flag (Optional). Default value: false. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        user: User name (Optional). Default value: current user credentials.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        password: Password (Optional). Default value: current user credentials.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        station: Station ID (Optional). Default value: Current station name.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Similar to SetupOpenApplication, this action will connect NENU to a specific application.]]>
<![CDATA[
]]>
<![CDATA[        The difference between the two actions is that here the default parameters]]>
<![CDATA[
]]>
<![CDATA[        can be overridden in one single action.  These parameters determine what application]]>
<![CDATA[
]]>
<![CDATA[        is to be monitored by NENU.  This action, or SetupOpenApplication, should be called first, then]]>
<![CDATA[
]]>
<![CDATA[        the NENU actions can be used to perform queries on the application and perform any]]>
<![CDATA[
]]>
<![CDATA[        required actions based on the results.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When using LDAP or ADSI authentication use the ]]>
				<b>
<![CDATA[SetUser]]>
				</b>
<![CDATA[, ]]>
				<b>
<![CDATA[SetStation]]>
				</b>
<![CDATA[ and ]]>
				<b>
<![CDATA[SetApplication]]>
				</b>
<![CDATA[ actions instead of SetupOpenApplicationEx.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetupOpenApplicationEX("Survey", "", "SurveyAdm.mdb", "SurveyEng.mdb", "False", "", "", "1")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the application exists in the application service the connection was successful.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[
]]>
<![CDATA[        SetupOpenApplication, SetApplication, SetServer, SetAdminDB, SetEngineDB, SetUser, SetPassword, SetStation]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetApplication" qi="Specifies the name of the Application used by NENU.">
			<p name="application" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        application: The application name.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets the name of the application, as defined within the application service, which]]>
<![CDATA[
]]>
<![CDATA[        will be used by NENU.  The application]]>
<![CDATA[
]]>
<![CDATA[        will determine the rules and databases that will be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[        This will be the default value used for the action SetupOpenApplication.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetApplication("APT")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetServer("Server 1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetupOpenApplication("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if the application name is missing.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupOpenApplication, SetupOpenApplicationEx]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetServer" qi="Specifies the name of the Taskmaster Server.">
			<p name="server" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        server: Server name.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The name of the Taskmaster server as it is defined in the application service, which will be]]>
<![CDATA[
]]>
<![CDATA[        the server used by subsequent NENU actions.]]>
<![CDATA[
]]>
<![CDATA[        This will be the default value used for the action SetupOpenApplication.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetApplication("APT")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetServer("Server 1")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetupOpenApplication("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False,]]>
				</b>
<![CDATA[ if a server name is not specified.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupOpenApplication, SetupOpenApplicationEx]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetAdminDB" qi="Specifies the Administration database.">
			<p name="adminDB" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        adminDB: Administration Database key in the Application Service.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Obtains the Administrator database connection information from the application service.]]>
<![CDATA[
]]>
<![CDATA[        This will be the default value used for the action SetupOpenApplication.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetApplication("APT")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetServer("Server 1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetAdminDB("*/tmadmin:cs")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetEngineDB("*/tmengine:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetupOpenApplication("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupOpenApplication, SetupOpenApplicationEx]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetEngineDB" qi="Specifies the Engine database.">
			<p name="engineDB" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        engineDB: Engine Database key in the Application Service. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Obtains the Engine database connection information from the application service.]]>
<![CDATA[
]]>
<![CDATA[        This will be the default value used for the action SetupOpenApplication.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetApplication("APT")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetServer("Server 1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetAdminDB("*/tmadmin:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetEngineDB("*/tmengine:cs")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetUser("Admin")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupOpenApplication, SetupOpenApplicationEx]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetUser" qi="Action to set a user name to login to the Server.">
			<p name="user" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        user: User name.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Specifies the name of the user for the login to the Administrator and Engine databases.]]>
<![CDATA[
]]>
<![CDATA[        This will be the default value used for the action SetupOpenApplication.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When using LDAP or ADSI authentication use the ]]>
				<b>
<![CDATA[SetUser]]>
				</b>
<![CDATA[, ]]>
				<b>
<![CDATA[SetStation]]>
				</b>
<![CDATA[ and ]]>
				<b>
<![CDATA[SetApplication]]>
				</b>
<![CDATA[ to login.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetApplication("APT")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetServer("Server 1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetAdminDB("*/tmadmin:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetEngineDB("*/tmengine:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetUser("Admin")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetupOpenApplication("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupOpenApplication, SetupOpenApplicationEx]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetPassword" qi="Action to set password to connect to the Server.">
			<p name="password" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        password: Password. Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Specifies the password for the previously specified user ID.]]>
<![CDATA[
]]>
<![CDATA[        This will be the default value used for the action SetupOpenApplication.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When using LDAP or ADSI authentication use the ]]>
				<b>
<![CDATA[SetUser]]>
				</b>
<![CDATA[, ]]>
				<b>
<![CDATA[SetStation]]>
				</b>
<![CDATA[ and ]]>
				<b>
<![CDATA[SetApplication]]>
				</b>
<![CDATA[ to login, do not call the SetPassword action with an empty value.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetApplication("APT")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetServer("Server 1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetAdminDB("*/tmadmin:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetEngineDB("*/tmengine:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetUser("Admin")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetPassword("@APPVAR(values/adv/MyNENUPassword)")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetupOpenApplication("")]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          This example uses the Smart Parameter @APPPVAR to obtain the value of the password from the value name "MyNENUPassword"]]>
<![CDATA[
]]>
<![CDATA[	  in the "Custom Values" tab of the application service manager.  The value name is configurable.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupOpenApplication, SetupOpenApplicationEx]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetStation" qi="Action to set station ID to connect to the Server.">
			<p name="station" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        station: Station ID. Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Specifies the station ID for login.]]>
<![CDATA[
]]>
<![CDATA[        This will be the default value used for the action SetupOpenApplication.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When using LDAP or ADSI authentication use the ]]>
				<b>
<![CDATA[SetUser]]>
				</b>
<![CDATA[, ]]>
				<b>
<![CDATA[SetStation]]>
				</b>
<![CDATA[ and ]]>
				<b>
<![CDATA[SetApplication]]>
				</b>
<![CDATA[ to login.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetApplication("APT")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetServer("Server 1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetAdminDB("*/tmadmin:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetEngineDB("*/tmengine:cs")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetStation("1")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          SetupOpenApplication("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupOpenApplication, SetupOpenApplicationEx]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessChangeBatchStatus" qi="Changes the status of one or more batches.">
			<p name="newStatus" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        newStatus: The new batch status: aborted, cancelled, finished, hold, job done, pending, running.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Using the results from a previous query performed by NENU actions, the selected batches]]>
<![CDATA[
]]>
<![CDATA[        will have their status attribute changed.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The database connection will be closed by this action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!Demo Job")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessChangeBatchStatus("hold")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the batch status is successfully changed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessChangeBatchStatusOrder" qi="Changes batch status and order.">
			<p name="newStatus" type="string">
			</p>
			<p name="newOrder" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        newStatus: The new batch status: aborted, cancelled, finished, hold, job done, pending, running.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        newOrder: New task order, zero-based index of task inside its job. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Using the results from a previous query performed by NENU actions, the selected batches]]>
<![CDATA[
]]>
<![CDATA[        will have their status and order attributes changed.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The database connection will be closed by this action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessChangeBatchStatusOrder("hold", "1")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the batch status is successfully changed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessChangeBatchStatusTaskOrder" qi="Changes batch status, task and order.">
			<p name="newStatus" type="string">
			</p>
			<p name="newOrder" type="int">
			</p>
			<p name="newTask" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        newStatus: The new batch status: aborted, cancelled, finished, hold, job done, pending, running.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        newOrder: New task's order, zero-based index of task inside its job. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        newTask: New task's name. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Using the results from a previous query performed by NENU actions, the selected batches]]>
<![CDATA[
]]>
<![CDATA[        will have their status, order and task attributes changed.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The database connection will be closed by this action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!Demo Job")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessChangeBatchStatusTaskOrder("hold", "1", "Verify")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the batch status is successfully changed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessClearAuditTable" qi="Clears the Audit table located in the admin database.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Clears the Audit table located in the admin database.  This action can be called to ensure]]>
<![CDATA[
]]>
<![CDATA[        that Audit table is cleared when information is moved from one]]>
<![CDATA[
]]>
<![CDATA[        database to another.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessClearAuditTable("")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the table is cleared.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessClearDebugTable]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessClearDebugTable" qi="Clears the Debug table located in the engine database.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Clears the Debug table located in the engine database.  This action can be called to ensure]]>
<![CDATA[
]]>
<![CDATA[        that Debug table is cleared when information is moved from one]]>
<![CDATA[
]]>
<![CDATA[        database to another.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessClearDebugTable("")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the table is cleared.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessClearAuditTable]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessDeleteBatchesEx" qi="Delete selected batches.">
			<p name="deleteSubFolders" type="bool">
			</p>
			<p name="preserveEngineDBRecords" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        deleteSubFolders: True deletes any sub-folders within batch directories regardless of creation source. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[	preserveEngineDBRecords: True retains engine database records (only batch directories are deleted). ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Using the results from a previous query performed by NENU actions, the selected batches]]>
<![CDATA[
]]>
<![CDATA[        will be deleted from disk.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        A previous query must have been run to identify the batches to delete.]]>
<![CDATA[
]]>
<![CDATA[        The database connection will be closed by this action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!Demo Job")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessDeleteBatchesEx("false,false")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the batches are deleted.  Otherwise ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessMoveBatchesEx, ProcessMoveDBRecords]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessMoveBatchesEx" qi="Move selected batches to folder specified in the parameter.">
			<p name="pathTo" type="string">
			</p>
			<p name="moveSubFolders" type="bool">
			</p>
			<p name="preserveEngineDBPaths" type="bool">
			</p>
			<p name="continueOnError" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        pathTo: The destination directory for the batches. Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[	      moveSubFolders: True moves any sub-folders within batch directories regardless of creation source.]]>
<![CDATA[
]]>
<![CDATA[                        Required if batches contain sub-folders, else operations, including database update, will fail.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[	      preserveEngineDBPaths: True preserves original batch directory paths inside the engine database. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[	      continueOnError: True continues processing if any single batch fails to be moved with non-fatal error. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Using the results from a previous query performed by NENU actions, the selected batches]]>
<![CDATA[
]]>
<![CDATA[        will be moved to the specified destination directory.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        A previous query must have been run to identify the batches to move to the new directory.]]>
<![CDATA[
]]>
<![CDATA[        The destination directory must exist.  The database connection will be closed by this action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If you are moving batches from one location to another and also moving database records from]]>
<![CDATA[
]]>
<![CDATA[        one database to another, move the batches first.  The movement of the database records should]]>
<![CDATA[
]]>
<![CDATA[        be performed last.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!Demo Job")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessMoveBatchesEx("@STRING(C:\My Old Batches\),false,false,false")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example runs a query to select all batches from station "1" where the Job ID]]>
<![CDATA[
]]>
<![CDATA[          does not equal "Demo Job", then moves the batches to a directory called "My Old Batches".]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!Demo Job")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessMoveBatchesEx("@APPPATH(BatchArchiveDirectory),false,false,false")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example also selects the same set of batches as above, however it uses a]]>
<![CDATA[
]]>
<![CDATA[          Smart parameter to obtain the full path to directory from the Application Service.]]>
<![CDATA[
]]>
<![CDATA[          A key called "BatchArchiveDirectory" will have to exist in the Application Service.]]>
<![CDATA[
]]>
<![CDATA[          If these rules are used for multiple applications, each application can have]]>
<![CDATA[
]]>
<![CDATA[          a unique definition of this value within the Application Service, making these rules]]>
<![CDATA[
]]>
<![CDATA[          very flexible.]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          One benefit of this approach is that in an environment where there is a test system]]>
<![CDATA[
]]>
<![CDATA[          and a production system, each system will have unique values stored in the]]>
<![CDATA[
]]>
<![CDATA[          Application Service.  Each of the environments can have a different physical directory]]>
<![CDATA[
]]>
<![CDATA[          specified within the Application Service, allowing the rules in each system to remain identical.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the batches are successfully moved.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessDeleteBatchesEx, ProcessMoveDBRecords]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessMoveDBRecords" qi="Creates connection to the application based on the parameters provided and moves selected database data to this application.">
			<p name="application" type="string">
			</p>
			<p name="server" type="string">
			</p>
			<p name="admin" type="string">
			</p>
			<p name="engine" type="string">
			</p>
			<p name="debugFlag" type="bool">
			</p>
			<p name="user" type="string">
			</p>
			<p name="password" type="string">
			</p>
			<p name="station" type="string">
			</p>
			<p name="deleteOriginal" type="bool">
			</p>
			<p name="targetDBSQLSeparator" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        application: Application name (Optional). Default value: the name of the application that is running this action. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        server: Server name (Optional). Default value: first available server in the application. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        admin: Administration Database name (Optional). Default value: first available Admin DB. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        engine: Engine Database name (Optional). Default value: first available Engine DB. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        debugFlag: Debug Flag (Optional). Default value: false. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        user: User name (Optional). Default value: current user credentials. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        password: Password (Optional). Default value: current user credentials. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        station: Station ID (Optional). Default value: Current station name]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        deleteOriginal: Delete database records in source database. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        targetDBSQLSeparator: Target Database date and time separator (Optional). If left blank action will try to detect the correct separator based on the connection string. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Creates connection to the application based on the parameters provided and moves]]>
<![CDATA[
]]>
<![CDATA[        selected database data to this application.  When performing operations on a batch and you are also]]>
<![CDATA[
]]>
<![CDATA[        going to be moving the database records from one database to another, perform the database]]>
<![CDATA[
]]>
<![CDATA[        move operation last.  When database records are moved, the database connection is still]]>
<![CDATA[
]]>
<![CDATA[        connected to the original database.  Performing subsequent operations will still be]]>
<![CDATA[
]]>
<![CDATA[        working on the original database, not the records in the new database.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessMoveDBRecords("APTBack","tms","admin","engine","false","admin","admin","1","true","")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          In this example the source database is Oracle and the target is Access.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessMoveBatchesEx, ProcessDeleteBatchesEx]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessResetPendingOrNotify" qi="Resets all selected batches to 'Pending' status.">
			<p name="threshold" type="int">
			</p>
			<p name="asattachment" type="bool">
			</p>
			<p name="addressFrom" type="string">
			</p>
			<p name="addressTo" type="string">
			</p>
			<p name="subject" type="string">
			</p>
			<p name="user" type="string">
			</p>
			<p name="password" type="string">
			</p>
			<p name="domain" type="string">
			</p>
			<p name="server" type="string">
			</p>
			<p name="port" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        All parameters, except for threshold, support Smart parameters.]]>
<![CDATA[
]]>
<![CDATA[        threshold: Maximum amount of attempts to reset the batch to status 'Pending'. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        asattachment: Send the log as attachment to the e-mail. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        addressFrom: Address From (Optional). Default value: currentUser@currentDomain. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        addressTo: The email recipient.  If multiple recipients, separate using a comma. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        subject: Email subject (Optional). Default value: 'NENU notification current_date_and_time'. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        user: Mail user name (Optional). Default value: current user credentials. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        password: Mail user password (Optional). Default value: current user credentials. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        domain: Mail user domain (Optional). Default value: current domain. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        server: Mail Server name (Optional). Default value: mail.current_domain. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        port: Mail Server Port number (Optional). Default value: 25. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Resets the status of all batches selected by a previous SQL query to 'Pending' status.]]>
<![CDATA[
]]>
<![CDATA[        The action will attempt to reset the batch by the amount specified in the 'threshold' parameter.]]>
<![CDATA[
]]>
<![CDATA[        if the maximum reset attempts are reached, the action sends an email, along with the a log,]]>
<![CDATA[
]]>
<![CDATA[        to the provided list of recipients.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          QuerySetJobID("!Demo Job")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ProcessResetPendingOrNotify("3", "rrodrig@somewhere.com", "tom@somewhere.com,john@somewhere.com","","","","","","")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the email is sent.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessRunSqlQueryEx" qi="Runs the previously defined NENU query.">
			<p name="minRecords" type="int">
			</p>
			<p name="maxRecords" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        minRecords - Minimum number of records required.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        maxRecords - Maximum number of records required, equal to or greater than minRecords.  Use -1 for no limit.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[          Performs the SQL select query using a query previously built using NENU actions.]]>
<![CDATA[
]]>
<![CDATA[          The "QuerySet" actions need to have been previously called to create the]]>
<![CDATA[
]]>
<![CDATA[          query.  The resulting record set is retained in memory and can be acted upon]]>
<![CDATA[
]]>
<![CDATA[          using other actions.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          The action LogWriteRecordSet can be used to write out the recordset, usually for]]>
<![CDATA[
]]>
<![CDATA[          debugging, as well as LogWriteSQLQuery which will output the constructed query.]]>
<![CDATA[
]]>
<![CDATA[          QueryClear can be used to remove any existing query settings.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<e>
<![CDATA[
]]>
<![CDATA[            QuerySetStation("1")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[            QuerySetJobID("!Demo Job")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[            ]]>
					<b>
<![CDATA[ProcessRunSqlQueryEx("1,-1")]]>
					</b>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            This example obtains results that include all batches, except for Demo Job, that have been run on station "1".]]>
<![CDATA[
]]>
<![CDATA[            The action will return true if at least one non-Demo Job batch is found for that station ID.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query is successful and the number of batches identified is within range of specified parameters.]]>
<![CDATA[
]]>
<![CDATA[        Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[LogWriteRecordSet, LogWriteSQLQuery, QueryClear]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ReportQueryTMUsage" qi="Update the ReportUser Database with the current users.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action will query the number of users current logged on and place the information]]>
<![CDATA[
]]>
<![CDATA[        into the reportUser.  This information is statistical information that can later]]>
<![CDATA[
]]>
<![CDATA[        be used to generate usage reports with the RV2 reporting system.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ReportQueryTMUsage("")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the database update was successful.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ReportSetReportingTable" qi="Sets database that contains reports on all processed batches">
			<p name="tbName" type="string">
			</p>
			<p name="batchColumn" type="string">
			</p>
			<p name="attemptColumn" type="string">
			</p>
			<p name="doneColumn" type="string">
			</p>
			<p name="actionColumn" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        tbName: Table name in Engine database. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        batchColumn: Optional. Name of the column that contains Batch ID. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        attemptColumn: Optional. Name of the column that contains attempts. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        doneColumn: Optional. Name of the column that contains completion result. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        actionColumn: Optional. Name of the column that contains last action performed. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets database that contains reports on all processed batches. Table must exist in the engine database.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ReportSetReportingTable("NENU","nn_batch","nn_attempt","nn_done","nn_action")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ReportSetUsageDBTable]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ReportSetUsageDBTable" qi="Sets database that contains reports on users logged in to TM">
			<p name="tbName" type="string">
			</p>
			<p name="ipAddressColumn" type="string">
			</p>
			<p name="jobIDColumn" type="string">
			</p>
			<p name="portColumn" type="string">
			</p>
			<p name="processedBathcesColumn" type="string">
			</p>
			<p name="stationColumn" type="string">
			</p>
			<p name="taskIDColumn" type="string">
			</p>
			<p name="userIDColumn" type="string">
			</p>
			<p name="queryTimeColumn" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        tbName: Table name in Engine database. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ipAddressColumn: IP Address column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        jobIDColumn: Job ID column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        portColumn: Port column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        processedBathcesColumn: Processed batches column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        stationColumn: Station ID column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        taskIDColumn: Task ID column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        userIDColumn: User ID column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        queryTimeColumn: Query time column. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets database that contains reports on users logged in to TM. Table must exist in the engine database.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ReportSetUsageDBTable("reportUsers","ru_ip","ru_job","ru_port","ru_bathces","ru_station","ru_task","ru_user","ru_time")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ReportSetUsageDBTable]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QuerySetSeparator" qi="Sets SQL Date and Time Separator for SQL queries.">
			<p name="separator" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        separator: Date separator. Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Configures the Date and Time separator used by the database.  If this action is not called, the]]>
<![CDATA[
]]>
<![CDATA[        value for the separator will be selected based on the connection string. Some database]]>
<![CDATA[
]]>
<![CDATA[        separators are: MS SQL"'", Oracle "'", Access "#".]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetSeparator("#")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QuerySetDateFormat" qi="Sets custom Date format for SQL queries.">
			<p name="dateFormat" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        dateFormat: Date format. Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Configures the Date format used by the database.  If this action is not called, the]]>
<![CDATA[
]]>
<![CDATA[        value for the Date format will be ]]>
				<b>
<![CDATA["yyyy/MM/dd"]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[        Detailed description of available values are:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[d]]>
				</b>
<![CDATA[	Represents the day of the month as a number from 1 through 31. A single-digit day is formatted without a leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[dd]]>
				</b>
<![CDATA[	Represents the day of the month as a number from 01 through 31. A single-digit day is formatted with a leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ddd]]>
				</b>
<![CDATA[	Represents the abbreviated name of the day of the week (Mon, Tues, Wed etc.)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[dddd]]>
				</b>
<![CDATA[	Represents the full name of the day of the week (Monday, Tuesday etc.)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[h]]>
				</b>
<![CDATA[	12-hour clock hour (e.g. 7)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[hh]]>
				</b>
<![CDATA[	12-hour clock, with a leading 0 (e.g. 07)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[H]]>
				</b>
<![CDATA[	24-hour clock hour (e.g. 19)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[HH]]>
				</b>
<![CDATA[	24-hour clock hour, with a leading 0 (e.g. 19)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[m]]>
				</b>
<![CDATA[	Minutes]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[mm]]>
				</b>
<![CDATA[	Minutes with a leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[M]]>
				</b>
<![CDATA[	Month number]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MM]]>
				</b>
<![CDATA[	Month number with leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MMM]]>
				</b>
<![CDATA[	Abbreviated Month Name (e.g. Dec)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MMMM]]>
				</b>
<![CDATA[	Full month name (e.g. December)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[s]]>
				</b>
<![CDATA[	Seconds]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ss]]>
				</b>
<![CDATA[	Seconds with leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[t]]>
				</b>
<![CDATA[	Abbreviated AM / PM (e.g. A or P)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[tt]]>
				</b>
<![CDATA[	AM / PM (e.g. AM or PM]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[y]]>
				</b>
<![CDATA[	Year, no leading zero (e.g. 2001 would be 1)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[yy]]>
				</b>
<![CDATA[	Year, leading zero (e.g. 2001 would be 01)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[yyy]]>
				</b>
<![CDATA[	Year (e.g. 2001 would be 001)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[yyyy]]>
				</b>
<![CDATA[	Year (e.g. 2001 would be 2001)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[K]]>
				</b>
<![CDATA[	Represents the time zone information of a date and time value (e.g. +05:00)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[z]]>
				</b>
<![CDATA[	With DateTime values, represents the signed offset of the local operating system's time zone from Coordinated Universal Time (UTC), measured in hours. (e.g. +6)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[zz]]>
				</b>
<![CDATA[	As z but with leading zero (e.g. +06)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[zzz]]>
				</b>
<![CDATA[	With DateTime values, represents the signed offset of the local operating system's time zone from UTC, measured in hours and minutes. (e.g. +06:00)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[f]]>
				</b>
<![CDATA[	Represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ff]]>
				</b>
<![CDATA[	Represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[fff]]>
				</b>
<![CDATA[	Represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ffff]]>
				</b>
<![CDATA[	Represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value. While it is possible to display the ten thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[fffff]]>
				</b>
<![CDATA[	Represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value. While it is possible to display the hundred thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ffffff]]>
				</b>
<![CDATA[	Represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value. While it is possible to display the millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[fffffff]]>
				</b>
<![CDATA[	Represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value. While it is possible to display the ten millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[F]]>
				</b>
<![CDATA[	Represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value. Nothing is displayed if the digit is zero.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[:]]>
				</b>
<![CDATA[	Represents the time separator defined in the current DateTimeFormatInfo..::.TimeSeparator property. This separator is used to differentiate hours, minutes, and seconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[/]]>
				</b>
<![CDATA[ 	 Represents the date separator defined in the current DateTimeFormatInfo..::.DateSeparator property. This separator is used to differentiate years, months, and days.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA["]]>
				</b>
<![CDATA[ 	 Represents a quoted string (quotation mark). Displays the literal value of any string between two quotation marks ("). Your application should precede each quotation mark with an escape character (\).]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[']]>
				</b>
<![CDATA[	 Represents a quoted string (apostrophe). Displays the literal value of any string between two apostrophe (') characters.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[%c]]>
				</b>
<![CDATA[ 	Represents the result associated with a c custom format specifier, when the custom date and time format string consists solely of that custom format specifier. That is, to use the d, f, F, h, m, s, t, y, z, H, or M custom format specifier by itself, the application should specify %d, %f, %F, %h, %m, %s, %t, %y, %z, %H, or %M. For more information about using a single format specifier, see Using Single Custom Format Specifiers.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetDateFormat("dd-MMM-yy")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
			<see>
<![CDATA[QuerySetDateTimeFormat]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QuerySetDateTimeFormat" qi="Sets custom DateTime format for SQL queries.">
			<p name="dateTimeFormat" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        dateTimeFormat: DateTime format. Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Configures the Date and Time format used by the database.  If this action is not called, the]]>
<![CDATA[
]]>
<![CDATA[        value for the Date format will be ]]>
				<b>
<![CDATA["yyyy/MM/dd HH:mm:ss"]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[        Detailed description of available values are:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[d]]>
				</b>
<![CDATA[	Represents the day of the month as a number from 1 through 31. A single-digit day is formatted without a leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[dd]]>
				</b>
<![CDATA[	Represents the day of the month as a number from 01 through 31. A single-digit day is formatted with a leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ddd]]>
				</b>
<![CDATA[	Represents the abbreviated name of the day of the week (Mon, Tues, Wed etc.)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[dddd]]>
				</b>
<![CDATA[	Represents the full name of the day of the week (Monday, Tuesday etc.)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[h]]>
				</b>
<![CDATA[	12-hour clock hour (e.g. 7)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[hh]]>
				</b>
<![CDATA[	12-hour clock, with a leading 0 (e.g. 07)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[H]]>
				</b>
<![CDATA[	24-hour clock hour (e.g. 19)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[HH]]>
				</b>
<![CDATA[	24-hour clock hour, with a leading 0 (e.g. 19)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[m]]>
				</b>
<![CDATA[	Minutes]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[mm]]>
				</b>
<![CDATA[	Minutes with a leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[M]]>
				</b>
<![CDATA[	Month number]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MM]]>
				</b>
<![CDATA[	Month number with leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MMM]]>
				</b>
<![CDATA[	Abbreviated Month Name (e.g. Dec)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MMMM]]>
				</b>
<![CDATA[	Full month name (e.g. December)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[s]]>
				</b>
<![CDATA[	Seconds]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ss]]>
				</b>
<![CDATA[	Seconds with leading zero]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[t]]>
				</b>
<![CDATA[	Abbreviated AM / PM (e.g. A or P)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[tt]]>
				</b>
<![CDATA[	AM / PM (e.g. AM or PM]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[y]]>
				</b>
<![CDATA[	Year, no leading zero (e.g. 2001 would be 1)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[yy]]>
				</b>
<![CDATA[	Year, leading zero (e.g. 2001 would be 01)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[yyy]]>
				</b>
<![CDATA[	Year (e.g. 2001 would be 001)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[yyyy]]>
				</b>
<![CDATA[	Year (e.g. 2001 would be 2001)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[K]]>
				</b>
<![CDATA[	Represents the time zone information of a date and time value (e.g. +05:00)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[z]]>
				</b>
<![CDATA[	With DateTime values, represents the signed offset of the local operating system's time zone from Coordinated Universal Time (UTC), measured in hours. (e.g. +6)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[zz]]>
				</b>
<![CDATA[	As z but with leading zero (e.g. +06)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[zzz]]>
				</b>
<![CDATA[	With DateTime values, represents the signed offset of the local operating system's time zone from UTC, measured in hours and minutes. (e.g. +06:00)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[f]]>
				</b>
<![CDATA[	Represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ff]]>
				</b>
<![CDATA[	Represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[fff]]>
				</b>
<![CDATA[	Represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ffff]]>
				</b>
<![CDATA[	Represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value. While it is possible to display the ten thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[fffff]]>
				</b>
<![CDATA[	Represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value. While it is possible to display the hundred thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ffffff]]>
				</b>
<![CDATA[	Represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value. While it is possible to display the millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[fffffff]]>
				</b>
<![CDATA[	Represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value. While it is possible to display the ten millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On Windows NT 3.5 and later, and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[F]]>
				</b>
<![CDATA[	Represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value. Nothing is displayed if the digit is zero.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[:]]>
				</b>
<![CDATA[	Represents the time separator defined in the current DateTimeFormatInfo..::.TimeSeparator property. This separator is used to differentiate hours, minutes, and seconds.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[/]]>
				</b>
<![CDATA[ 	 Represents the date separator defined in the current DateTimeFormatInfo..::.DateSeparator property. This separator is used to differentiate years, months, and days.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA["]]>
				</b>
<![CDATA[ 	 Represents a quoted string (quotation mark). Displays the literal value of any string between two quotation marks ("). Your application should precede each quotation mark with an escape character (\).]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[']]>
				</b>
<![CDATA[	 Represents a quoted string (apostrophe). Displays the literal value of any string between two apostrophe (') characters.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[%c]]>
				</b>
<![CDATA[ 	Represents the result associated with a c custom format specifier, when the custom date and time format string consists solely of that custom format specifier. That is, to use the d, f, F, h, m, s, t, y, z, H, or M custom format specifier by itself, the application should specify %d, %f, %F, %h, %m, %s, %t, %y, %z, %H, or %M. For more information about using a single format specifier, see Using Single Custom Format Specifiers.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetDateFormat("dd-MMM-yy hh:mm:ss tt")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
			<see>
<![CDATA[QuerySetDateFormat]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QueryClear" qi="Clears the SQL query.">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Clears any SQL query that may be in memory.  This action can be called to ensure]]>
<![CDATA[
]]>
<![CDATA[        that any NENU query that you build is not building on any previous information.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QueryClear("")]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query is cleared.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QuerySetJobID" qi="Sets the Job ID for the SQL query.">
			<p name="jobid" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        jobid: Job name.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        When building a query, this action sets the job ID that will be selected in the result set.]]>
<![CDATA[
]]>
<![CDATA[        If you wish to match multiple job IDs, use commas to separate values.  An exclamation point]]>
<![CDATA[
]]>
<![CDATA[        can be used to negate the query.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetJobID("Demo Job,Web Job")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will create a result set that contains batches with job ID of "Demo Job" and "Web Job".]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetJobID("Demo Job")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetJobID("Web Job")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will create an empty result set.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetJobID("!Demo Job")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will create a result set that contains all batches except for the job ID of "Demo Job".]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="QuerySetTaskID" qi="Sets the Task ID for the SQL query.">
			<p name="taskid" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        taskid: Task ID.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        When building a query, this action sets the task ID that will be selected in the result set.]]>
<![CDATA[
]]>
<![CDATA[        The current task batches selected will match the supplied value.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        To find multiple values, separate them with commas.]]>
<![CDATA[
]]>
<![CDATA[        An exclamation point can be prefixed to the value to find all values except the ones specified.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetTaskID("Verify")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will query all batches for the survey application that are]]>
<![CDATA[
]]>
<![CDATA[          at the verify task.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetTaskID("@B.MyQueryTask")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example uses Smart parameters to retrieve the name of]]>
<![CDATA[
]]>
<![CDATA[          the task to query from a batch level variable called 'MyQueryTask'.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QuerySetStatus" qi="Sets the Task status for the SQL query.">
			<p name="status" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        status: The batch status: aborted, cancelled, finished, hold, job done, pending, running.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Selects all of the batches that match the specified status.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        To find multiple values, separate them with commas.]]>
<![CDATA[
]]>
<![CDATA[        An exclamation point can be prefixed to the value to find all values except the ones specified.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetStatus("finished")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QuerySetPriority" qi="Sets the Priority for the SQL query.">
			<p name="priority" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        priority: Batch Priority. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Selects all of the batches that match the specified priority.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        To find multiple values, separate them with commas.]]>
<![CDATA[
]]>
<![CDATA[        An exclamation point can be prefixed to the value to find all values except the ones specified.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetPriority("1")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QuerySetBranch" qi="Sets the minimum number of children for the SQL query.">
			<p name="children" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        children: The minimum number of children for the batch. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Selects all of the batches that have at least the minimum number of specified children.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetBranch("3")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QuerySetOperator" qi="Sets the operator for the SQL query.">
			<p name="operator" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        operator: The operator ID.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Selects all of the batches that match the specified operator ID.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        To find multiple values, separate them with commas.]]>
<![CDATA[
]]>
<![CDATA[        An exclamation point can be prefixed to the value to find all values except the ones specified.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetOperator("Admin")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="QuerySetStation" qi="Sets the station for the SQL query.">
			<p name="station" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        station: The station ID.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Selects all of the batches that match the specified station.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        To find multiple values, separate them with commas.]]>
<![CDATA[
]]>
<![CDATA[        An exclamation point can be prefixed to the value to find all values except the ones specified.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetStation("1")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="QuerySetDateRange" qi="Sets Date range for SQL query.">
			<p name="start" type="string">
			</p>
			<p name="end" type="string">
			</p>
			<p name="queryAgeStart" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        start: Date Range Start.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        end: Date Range End.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        queryAgeStart: True will use the batch start date.  False will use the batch end date. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Selects all of the batches that match the specified priority.]]>
<![CDATA[
]]>
<![CDATA[        If queryAgeStart is set to True, the query will use the batch start date, qs_start.  If queryAgeStart]]>
<![CDATA[
]]>
<![CDATA[        is set to False, the query will use the batch end date, qu_done.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        An exclamation point can be prefixed to the value to find all values except the ones specified.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetDateRange("03/16/2010","05/26/2010","True")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will select all of the batches that have been created ]]>
<![CDATA[
]]>
<![CDATA[          between the two specified dates.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetDateRange("03/16/2010","@DATE(mm/dd/yyyy)","True")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example uses a Smart parameter to obtain the current date.  The query will]]>
<![CDATA[
]]>
<![CDATA[          select all batches that have been created between 03/16/2010 and the current date.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="QuerySetAge" qi="Selects batches based on age using a date or number of seconds.">
			<p name="age" type="string">
			</p>
			<p name="queryAgeStart" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        age: All dates prior or within this date will be selected.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        queryAgeStart: If true, age will use the start time of the batch.  If false, age will use the end time of the batch. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Builds a query that selects batches based on the age of a batch.  The age can be specified using a date or in seconds.]]>
<![CDATA[
]]>
<![CDATA[        The queryAgeStart parameter determines if the age is based on the start of the batch, the qs_start column, ]]>
<![CDATA[
]]>
<![CDATA[        or based on the end of the batch, the qu_done column.]]>
<![CDATA[
]]>
<![CDATA[        If a date is specified, all batches will be selected based on the date. ]]>
<![CDATA[
]]>
<![CDATA[        If a number is specified, all batches will be selected based on the number of seconds.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        To control the age range use the exclamation point '!'.   When the exclamation point is not specified,]]>
<![CDATA[
]]>
<![CDATA[        the age between now and the specified value will be selected.  When the exclamation point is specified,]]>
<![CDATA[
]]>
<![CDATA[        the ages that are older than the value specified will be selected.         ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetAge("300","True")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will select all batches started within last 300 seconds.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetAge("!300","true")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This example will select all batches started prior to 300 seconds ago.]]>
<![CDATA[
]]>
<![CDATA[          Use the same pattern when using dates.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[	  ]]>
		<method name="QuerySetGeneric" qi="Builds an SQL query using the provided column name and value.">
			<p name="column" type="string">
			</p>
			<p name="value" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        column: Column in the database table to query.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        value: Value to match within the specified column.  Smart parameters are supported. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Allows building of a query where the column and value of the tmbatch, queue or qstats table are explicitly specified.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Any wild card specified in the "value" parameter would need to be appropriate for your target database.]]>
<![CDATA[
]]>
<![CDATA[        The column value is not validated until the query is run using ProcessRunSqlQuery.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[QuerySetGeneric("pb_userid", "admin")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ProcessRunSqlQuery("")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[ProcessRunSqlQuery]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="QuerySetBatchRange" qi="Sets range of batches for SQL query.">
			<p name="start" type="string">
			</p>
			<p name="end" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        start: BatchID of the first batch in the range. Default value 00000000.000". ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        end: BatchID of the last batch in the range. Default value zzzzzzzz.zzz". ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Allows selecting batch range based on the BatchID.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetBatchRange("20110059.001","20110059.010")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[InjectBatches("20110059.001")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the query has been successfully set.  It does not mean]]>
<![CDATA[
]]>
<![CDATA[        the query has been performed.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[InjectBatches]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ProcessInjectBatches" qi="Injects the data from master batch to all batches selected and updates DB.">
			<p name="masterBatchID" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        masterBatchID: Master batch to copy data from. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Allows creating large set of batches at some predefined  state.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          QuerySetBatchRange("20110059.001","20110059.010")]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[InjectBatches("20110059.001")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if all the all the batches were successfully set.]]>
<![CDATA[
]]>
<![CDATA[        Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[QuerySetBatchRange]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="ocr_j" v="9.0.0.0">
	<com ref="Datacap.Libraries.OcrRose.Actions" qi="Japanese Zonal OCR Library for handprint and machine print recognition">
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="InitializeEngine">
			<ap>
<![CDATA[
]]>
<![CDATA[        This action does not require input parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action initializes the Rosetta Stone engine wrapper.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[InitializeEngine()]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the action succeeds.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ReleaseEngine">
			<ap>
<![CDATA[
]]>
<![CDATA[        This action does not require input parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action releases resources used by the engine wrapper.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[ReleaseEngine()]]>
					</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the action succeeds.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="Recognize">
			<ap>
<![CDATA[
]]>
<![CDATA[        This action does not require input parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action performs zonal Japanese machine print and handprint recognition.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The following recognition parameters can be configured via dco variables (must be set at the calling level):]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Frame Type]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This setting applies to constrained fields, and it is used to set the type of constrained field to be recognized. This setting is configured via the ]]>
				<b>
<![CDATA[rsFrameType]]>
				</b>
<![CDATA[ variable. Valid values are: ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        0 - Unconstrained field (default) ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        1 - Normal]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        2 - Individual]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        3 - Field]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        4 - Box]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        5 - Ladder]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        6 - Solid ladder]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[OCR Type]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This setting applies to any fields, and is used to set the type of OCR to perform on the field. This setting is configured via the ]]>
				<b>
<![CDATA[rsOcrType]]>
				</b>
<![CDATA[ variable. Valid values are: ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        1 - Machine printed Japanese characters (alpha, default)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        2 - Machine printed numbers]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        4 - Machine printed alpha-numeric characters]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        8 - Handwritten number]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        16 - Handwritten alpha-numeric characters]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        32 - Handwritten Japanese characters (alpha)]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        64 - Currency Numeric Handwritten Japanese characters]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          InitializeEngine()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          rrSet("3", "@F.rsFrameType")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          rrSet("8", "@F.rsOcrType")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[Recognize()]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ReleaseEngine]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Field level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True,]]>
				</b>
<![CDATA[ if the action succeeds.  Otherwise, ]]>
				<b>
<![CDATA[False.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="Datacap.Libraries.NovoDynamics" v="8.1.0.5">
	<com ref="Datacap.Libraries.NovoDynamics.Actions" qi="NovoDynamics Action Library">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      This library provides actions for performing recognition, full page and zonal, for Arabic and Hebrew documents. ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The available actions are RecognizePageOCR_N and RecognizePageFieldsOCR_N. Both actions are page level actions, meaning that they have be bound to the dco page object.  ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[      The actions respond to the following settings, which can be specified at setup time or runtime by creating and setting dco PAGE variables, also listed below (variable names and valid values are case-sensitive and should be set prior to calling the actions in this library): ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
				<i>
<![CDATA[Alphabet Mode]]>
				</i>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Description: Configures the system to use a specific alphabet recognizer when detecting the dominant language on the input document image.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Default value: automatic.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      DCO variable: "n_am". The following values are valid: arabicNumbers, extendedArabic, extendedCyrillic, extendedHebrew, extendedLatin.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
				<i>
<![CDATA[Page Decomposition Mode]]>
				</i>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Description: Configures the automatic zone detection mode.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Default value: 0 - Automatic.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      DCO variable: "n_dm". The following values are valid: 0- Automatic, 1- Simple Page, 2- Complex Page, 3- No Decomposition.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Note]]>
			</b>
<![CDATA[: This setting does not affect the action RecognizePageFieldsOCR_N.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[Output Diacriticals]]>
				</i>
<![CDATA[
]]>
<![CDATA[      ]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Description: Configures the processing mode to make an additional effort to recognize and output diacritical information on Arabic text. ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Default value: 0 - Disable.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      DCO variable: "n_od". The following values are valid: 0 - Disable, 1- Enable.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[Language Mode]]>
				</i>
<![CDATA[
]]>
<![CDATA[      ]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Description: Configures the system to use a specific language when recognizing the text on a document. ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Default value: automatic.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      DCO variable: "n_lm". The following values are valid: arabic, hebrew.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Note]]>
			</b>
<![CDATA[: when using this setting, the Alphabet Mode MUST also be set. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[Skip Recognition]]>
				</i>
<![CDATA[
]]>
<![CDATA[      ]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Description: Causes the engine to skip recognition of a zone. ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Default value: empty.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      DCO variable: "n_sr". The following values are valid: "1".]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RecognizePageOCR_N">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action performs full page recognition.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<i>
<![CDATA[Alert!]]>
					</i>
<![CDATA[
]]>
<![CDATA[        ]]>
				</b>
<![CDATA[ The NormalizeCCO action from the ]]>
				<b>
<![CDATA[CCO2CCO]]>
				</b>
<![CDATA[ action library should be called after]]>
<![CDATA[
]]>
<![CDATA[        RecognizePageOCR_N if the application will be using the navigation and pattern match actions]]>
<![CDATA[
]]>
<![CDATA[        to find recognized text on a page or perform pattern matching. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<i>
<![CDATA[Alert!]]>
					</i>
<![CDATA[
]]>
<![CDATA[        ]]>
				</b>
<![CDATA[If a CCO file does not exist at the time this action is called, the action will create one.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          RotateImage()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RecognizePageOCR_N()]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[NormalizeCCO("")]]>
					</b>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This sequence creates a CCO file for the current page, and checks to see if rotation of the image is needed.]]>
<![CDATA[
]]>
<![CDATA[          Full-page recognition then takes place in response to settings (see the action library help text for available settings via runtime\setup variables).]]>
<![CDATA[
]]>
<![CDATA[          The recognition results are stored in the CCO file. The words and lines in the CCO are then sorted]]>
<![CDATA[
]]>
<![CDATA[          for use by navigation and pattern match actions.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[        Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RecognizePageFieldsOCR_N">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This page-level action recognizes all fields on the page that have been configured for OCR/N]]>
<![CDATA[
]]>
<![CDATA[        recognition (see the action library help text for available settings via runtime\setup variables)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Important!]]>
				</b>
<![CDATA[ Page level recognition settings are used to recognized the fields\zones. Per zone recognition settings are not supported.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ReadZones()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RecognizePageFieldsOCR_N()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the]]>
<![CDATA[
]]>
<![CDATA[        Document Hierarchy. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="ocr_sr" v="9.1.2.31">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['******************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' OCRS R Recognition Actions ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' "Restricted Materials of IBM"]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Copyright IBM Corp. 1994, 2015 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.1.0.21"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/05/2014 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for RecognizeToPDFOCR_S action.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Older change notices arranged by date entered, ascending]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.0" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/19/2010 jmartinez]]>
<![CDATA[
]]>
<![CDATA['   Initial implementation. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.0.1" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/24/2010 jmartinez]]>
<![CDATA[
]]>
<![CDATA[' Action names are now consistent, ending in OCR_S]]>
<![CDATA[
]]>
<![CDATA[' Added actions RecognizeToFile_OCRS,RecognizeFieldVoteOCR_S,RecognizePageFields2CCO_OCRS]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.2" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 03/24/2010 jmartinez]]>
<![CDATA[
]]>
<![CDATA[' Removed action RecognizePageFields2CCO_OCRS - usually this action applies to handprint recognition which is not performed by this engine.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.3" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/09/2010 jmartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for actions RecognizeToPDFOCR_S,RecognizeToFileOCR_S, and RecognizeFieldVoteOCR_S]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.4" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/11/2010 jmartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for action RecognizePageOCR_S to say that NormalizeCCO or CCO2CCO actions must be called after full page OCR ]]>
<![CDATA[
]]>
<![CDATA[' if the application will be using navigation and pattern match actions. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.5"]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/23/10 jmartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for action RecognizeFieldVoteOCR_S to describe exaclty how confidence values are raised. ]]>
<![CDATA[
]]>
<![CDATA[' Corrected retrun value help text for action RotateImageOCR_S ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.6"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/24/11 jmartinez]]>
<![CDATA[
]]>
<![CDATA['- Moved parameter information from the qi= tag to the standard parameter help section]]>
<![CDATA[
]]>
<![CDATA['- Moved action information from the qi= tag to the standard action help section]]>
<![CDATA[
]]>
<![CDATA['- Added IBM Copyright notice]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.7"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/18/2011 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' 31991 Updated help text for action RecognizeToFile_OCR_S to. This action can be called only at the Document or Page level.]]>
<![CDATA[
]]>
<![CDATA[' 32483 Updated help text for action RecognizeToPDFOCR_S.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.8"]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/04/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for action RecognizeToPDFOCR_S]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.9"]]>
<![CDATA[
]]>
<![CDATA[' Updated 02/17/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for the action RecognizeFieldOCR_S. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/20/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for the action RecognizePageOCR_S. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/24/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for the action RotateImageOCR_S. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/14/2012 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added Action SetEngineTimeoutOCR_S]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = 8.0.0.13]]>
<![CDATA[
]]>
<![CDATA[' Updated 01/08/2014 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added actions ]]>
<![CDATA[
]]>
<![CDATA[' - SetOutOfProcessTimeoutOCR_S]]>
<![CDATA[
]]>
<![CDATA[' - SetOutOfProcessLoggingOCR_S]]>
<![CDATA[
]]>
<![CDATA[' - SetContinueOnFailureOCR_S]]>
<![CDATA[
]]>
<![CDATA[' - UseOutOfProcessRecogOCR_S]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = 8.0.0.14]]>
<![CDATA[
]]>
<![CDATA['Updated 04/23/2014]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for the action RecognizeToPDFOCR_S]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.15"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/08/2014 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added new action RotateImageExOCR_S]]>
<![CDATA[
]]>
<![CDATA[' Exposed a new setting, typesToInclude (variable), that takes a comma delimited list of page types to include in the pdf document or (other file type) to be created. Only the pages specified will be included. By default all pages are added.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.16"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/13/2014 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Replaced the "typesToInclude" setting with a new setting, "typesToExclude" (variable), that takes a comma delimited list of page types to exclude from pdf document or (other file type) being created. By default all page types are added.]]>
<![CDATA[
]]>
<![CDATA[' Added a new setting, "statusToExclude" which takes a comma delimited list of page statuses to exclude from pdf document or (other file type) being created. By default all page statuses are added.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.17"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/28/2014 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added back support for typesToInclude variable. The filters have the following hierarchy: statusToExclude overrides typesToInclude which overrides typesToExclude]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.18"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/22/2014 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for action RotateImageExOCR_S]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.19"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/04/2014 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for Recognize action]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.20"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/05/2014 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for Recognize action. Added document level support.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.21"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/05/2014 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for RecognizeToPdfOCR_S action. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.22"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/28/2015 94748 RFerin]]>
<![CDATA[
]]>
<![CDATA[' Updated help text about the automatic retry feature.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.23"]]>
<![CDATA[
]]>
<![CDATA[' Updated 08/27/2015 JMartinez  129794]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for the Recognize action.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.24"]]>
<![CDATA[
]]>
<![CDATA[' Updated 9/08/2015 JMartinez 130991]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for the RecognizeToPdfOCR_S action.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.25"]]>
<![CDATA[
]]>
<![CDATA[' Updated 9/28/2015 JTucci 118220]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for the library header to list]]>
<![CDATA[
]]>
<![CDATA[' supported languages.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.26"]]>
<![CDATA[
]]>
<![CDATA[' Updated 9/28/2015 JTucci 118220]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for the library header to list.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.27" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 5/10/2016 Vshriva6 141307]]>
<![CDATA[
]]>
<![CDATA[' Added new action "ReleaseEngineOCR_SR" which releases the recognition engine. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.28" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/17/2016 RFerin 118526]]>
<![CDATA[
]]>
<![CDATA[' Help corrections.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.0.0.29" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 6/21/2016 RFerin 118526]]>
<![CDATA[
]]>
<![CDATA[' Help corrections.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.1.0.30" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 9/28/2016 RFerin 152609]]>
<![CDATA[
]]>
<![CDATA[' Help clarification that RecognizeTOPDFOCR_S does not support PDF to PDF.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.1.0.31" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 9/27/2017 Vshriva6 172998]]>
<![CDATA[
]]>
<![CDATA[' Help clarification for RecognizeToFileOCR_S output mode which are deprecated.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "9.1.0.32" ]]>
<![CDATA[
]]>
<![CDATA[' Updated 11/7/2017 Vshriva6 172998]]>
<![CDATA[
]]>
<![CDATA[' Updated action help for RecognizeToFileOCR_S output mode and removed third party name.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['*****************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="Datacap.Libraries.ScansoftR.Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<h>
<![CDATA[
]]>
<![CDATA[      The OCR/SR action library provides actions that perform recognition and rotation of images using the OCR/S engine.]]>
<![CDATA[
]]>
<![CDATA[      Page and field level recognition can be performed which can then be processed by actions in other]]>
<![CDATA[
]]>
<![CDATA[      libraries and ultimately displayed to the user for verification.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Automatic Retry]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The OCR/SR actions support automatic retries when a recognition takes longer than expected.]]>
<![CDATA[
]]>
<![CDATA[      In rare situations recognition can fail to complete, such as when processing a damaged or atypical]]>
<![CDATA[
]]>
<![CDATA[      image.  When this occurs, once the configured timeout is reached, the recognition engine will]]>
<![CDATA[
]]>
<![CDATA[      be stopped and restarted, then recognition attempted again until the retry count is reached.]]>
<![CDATA[
]]>
<![CDATA[      By default, when a failure occurs because of the timeout being reached, the action will]]>
<![CDATA[
]]>
<![CDATA[      be retried 1 time.  The default timeout is 180 seconds. These default values can be]]>
<![CDATA[
]]>
<![CDATA[      changed using the SetupAutomaticRetry action in the RecogShared library.]]>
<![CDATA[
]]>
<![CDATA[      No other actions are required to setup the automatic retry feature.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      After a recognition operation is complete, the variable ]]>
			<b>
<![CDATA[RecogStatus]]>
			</b>
<![CDATA[ is set to indicate the]]>
<![CDATA[
]]>
<![CDATA[      success or failure of recognition. If page-level recognition is being performed,]]>
<![CDATA[
]]>
<![CDATA[      RecogStatus values of 0, 1 or 2 are considered successful.]]>
<![CDATA[
]]>
<![CDATA[      The list of successful values includes:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      0 - Success]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      1 - Recognition was successful but there are no results...the page was empty.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      2 - Recognition was successful and additional processing such as "RotateImage" was performed.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Other values are considered failures.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[Supported Languages]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The following languages are supported by OCR_Sr:]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Afrikaans (39), Albanian (23), Catalan (11), Chinese Simplified (120), Chinese Traditional (121), Croatian (21), Czech (17), Danish (7), Dutch]]>
<![CDATA[
]]>
<![CDATA[      (3), English (0), Esperanto (28), Estonian (25), Faroese (52), Finnish (6), French (2), Gaelic Irish (56), Gaelic Scottish (57), German (1),]]>
<![CDATA[
]]>
<![CDATA[      Greek (15), Hungarian (19), Icelandic (8), Italian (13), Japanese (119), Latvian (26), Lithuanian (27), Maltese (14), Norwegian (4), Polish (16),]]>
<![CDATA[
]]>
<![CDATA[      Portuguese (9), Portuguese Brazil (45), Rhaetic (90), Romanian (22), Russian(36), Sami (98), Sami Northern (100), Sami Southern (101), Serbian]]>
<![CDATA[
]]>
<![CDATA[      Cyrillic (30), Serbian Latin (29), Slovakian (18), Slovenian (20), Spanish (10), Swahili (105), Swedish (5), Turkish (24)]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The language can be bound to the DCO object by selecting it in the OCR_S tab in the zones tab of Datacap Studio.]]>
<![CDATA[
]]>
<![CDATA[      When selected in the OCR_S tab the variable ]]>
			<b>
<![CDATA[s_lg]]>
			</b>
<![CDATA[ is set to the numeric value of the language.]]>
<![CDATA[
]]>
<![CDATA[      The language also can be set within rules using the ]]>
			<b>
<![CDATA[rrSet]]>
			</b>
<![CDATA[ action to set]]>
<![CDATA[
]]>
<![CDATA[      the ]]>
			<b>
<![CDATA[s_lg]]>
			</b>
<![CDATA[ variable to the numeric value for the desired language.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For example: ]]>
			<b>
<![CDATA[rrSet("2", "@X.s_lg")]]>
			</b>
<![CDATA[ will set the language to French.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If the ]]>
			<b>
<![CDATA[s_lg]]>
			</b>
<![CDATA[ variable is not set for the current DCO object, the recognized]]>
<![CDATA[
]]>
<![CDATA[      language is determined by the current locale set with the ]]>
			<b>
<![CDATA[hr_locale]]>
			</b>
<![CDATA[ variable.]]>
<![CDATA[
]]>
<![CDATA[      For example, if the locale is set for Germany, then the text will be recognized as German.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      The value in ]]>
			<b>
<![CDATA[s_lg]]>
			</b>
<![CDATA[ takes precedence over the locale setting.]]>
<![CDATA[
]]>
<![CDATA[      If ]]>
			<b>
<![CDATA[s_lg]]>
			</b>
<![CDATA[ is set but the engine should use the value set for ]]>
			<b>
<![CDATA[hr_locale]]>
			</b>
<![CDATA[ instead,]]>
<![CDATA[
]]>
<![CDATA[      setting the variable ]]>
			<b>
<![CDATA[dco_uselocale]]>
			</b>
<![CDATA[ to "1" will give precedence to ]]>
			<b>
<![CDATA[hr_locale.]]>
			</b>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetEngineTimeoutOCR_S">
			<p name="Seconds" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Seconds]]>
				</b>
<![CDATA[ - value indicating the number of seconds to wait to determine that an OCR/S recognition]]>
<![CDATA[
]]>
<![CDATA[        action has stalled.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The OCR/SR action library supports automatic retry of operations without needing special rules to handle a]]>
<![CDATA[
]]>
<![CDATA[        failure.  Calling SetEngineTimeoutOCR_S will disable the automatic]]>
<![CDATA[
]]>
<![CDATA[        retry of recognition failures, enabling legacy mode where any recognition retries must be handled within rules.]]>
<![CDATA[
]]>
<![CDATA[        It is recommended to not call SetEngineTimeoutOCR_S and instead use the automatic retry feature.]]>
<![CDATA[
]]>
<![CDATA[        See the top level help topic in the OCR/SR library for more information.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This action sets the maximum amount of time, in seconds, that the recognition engine will spend processing a single image/zone.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If a recognition action does not complete within the specified number of seconds indicated by a]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[SetOutOfProcessTimeoutOCR_S]]>
				</b>
<![CDATA[action or a ]]>
				<b>
<![CDATA[SetEngineTimeoutOCR_S]]>
				</b>
<![CDATA[action, it is assumed that the]]>
<![CDATA[
]]>
<![CDATA[        recognition engine has encountered a severe error, and is removed from memory. ]]>
<![CDATA[
]]>
<![CDATA[        A variable with RecogStatus of 1 is created in the calling object in this situation. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If ]]>
				<b>
<![CDATA[SetEngineTimeoutOCR_S]]>
				</b>
<![CDATA[is not called, the default value of 180 seconds will be used. In normal]]>
<![CDATA[
]]>
<![CDATA[        conditions, the default value will be sufficient and does not need to be changed. This value will]]>
<![CDATA[
]]>
<![CDATA[        need to be increased only if a single page consistently takes more than 3 minutes to complete, which]]>
<![CDATA[
]]>
<![CDATA[        is a very atypical situation. The programmer can choose to shorten this time to reduce the time to]]>
<![CDATA[
]]>
<![CDATA[        detect failures earlier, provided there is time left to perform recognition in "worst case" scenarios.]]>
<![CDATA[
]]>
<![CDATA[        For best results, this timeout should be set the same or a bit shorter than the value specified in a]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[SetOutOfProcessTimeoutOCR_S]]>
				</b>
<![CDATA[action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetEngineTimeoutOCR_S(180)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RecognizeFieldOCR_S]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page or Field.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is not numeric or less than 1. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupAutomaticRetry in the RecogShared action library.]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetOutOfProcessTimeoutOCR_S">
			<p name="Seconds" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Seconds]]>
				</b>
<![CDATA[ - value indicating the number of seconds to wait to determine that an out-of-process]]>
<![CDATA[
]]>
<![CDATA[        recognition action has stalled.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action is provided for legacy support of rules that manually perform a retry of recognition failures]]>
<![CDATA[
]]>
<![CDATA[        and is provided for backwards compatibility.  It is recommended that you allow OCR/SR actions to automatically]]>
<![CDATA[
]]>
<![CDATA[        handle retries of recognition failures.  When automatic mode is used, this action does not need to be called.]]>
<![CDATA[
]]>
<![CDATA[        See the top level help topic in the OCR/SR library for more information.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This action sets the number of seconds to wait to determine that an out-of-process]]>
<![CDATA[
]]>
<![CDATA[        action has stalled.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If a recognition action does not complete within the specified number of seconds indicated by a]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[SetOutOfProcessTimeoutOCR_S]]>
				</b>
<![CDATA[action or a ]]>
				<b>
<![CDATA[SetEngineTimeoutOCR_S]]>
				</b>
<![CDATA[action, it is assumed that the]]>
<![CDATA[
]]>
<![CDATA[        recognition engine has encountered a severe error, is removed from memory. A variable with RecogStatus of -1 is created in the calling object in this situation.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If ]]>
				<b>
<![CDATA[SetOutOfProcessTimeoutOCR_S]]>
				</b>
<![CDATA[is not called, the default value of 600 seconds will be used. In normal]]>
<![CDATA[
]]>
<![CDATA[        conditions, the default value will be sufficient and does not need to be changed. This value will]]>
<![CDATA[
]]>
<![CDATA[        need to be increased only if a single page consistently takes more than 10 minutes to complete, which]]>
<![CDATA[
]]>
<![CDATA[        is a very atypical situation. The programmer can choose to shorten this time to reduce the time to]]>
<![CDATA[
]]>
<![CDATA[        detect failures earlier, provided there is time left to perform recognition in "worst case" scenarios.]]>
<![CDATA[
]]>
<![CDATA[        For best results, this timeout should be set the same or a bit longer than the value specified in a]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[SetEngineTimeoutOCR_S]]>
				</b>
<![CDATA[action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetEngineTimeoutOCR_S(185) ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetOutOfProcessTimeoutOCR_S(180)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RecognizeFieldOCR_S]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page or Field.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is not numeric or less than 1. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
			<see>
<![CDATA[SetupAutomaticRetry in the RecogShared action library.]]>
			</see>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RecognizeFieldOCR_S">
			<ap>
<![CDATA[None]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This field-level action is a shortcut to zonal recognition procedures that are carried out]]>
<![CDATA[
]]>
<![CDATA[        in response to settings in the OCR/S tab of DStudio.  Automatic retry is supported if the operation timeout is reached.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RecognizeFieldOCR_S()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Field level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
				<b>
<![CDATA[Field]]>
				</b>
<![CDATA[object of the]]>
<![CDATA[
]]>
<![CDATA[        Document Hierarchy. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RecognizeFieldVoteOCR_S">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This field-level action initiates a voting procedure that first uses specifications in the OCR/S]]>
<![CDATA[
]]>
<![CDATA[        tab of the Recognition Options Setup dialog to recognize the field's characters. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When this action stores the results of recognition, it first determines if the corresponding]]>
<![CDATA[
]]>
<![CDATA[        Field object of the Document Hierarchy contains a value. If a value is present, the action]]>
<![CDATA[
]]>
<![CDATA[        compares the field's existing value with the recognition results - character by character.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If a particular character's values match, the Confidence Rating for the character]]>
<![CDATA[
]]>
<![CDATA[        is raised to 9 if the original confidence is smaller than 9. Otherwise the confidence of matching characters is raised to the maximum level (10).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Note that when using this voting procedure, the second Recognition engine is secondary and its results]]>
<![CDATA[
]]>
<![CDATA[        are never assigned.  Instead, the action changes the Confidence Ratings on the basis of results provided]]>
<![CDATA[
]]>
<![CDATA[        by the first Recognition engine. If there are no recognition results previous to this action, it]]>
<![CDATA[
]]>
<![CDATA[        will act just like the ]]>
				<b>
<![CDATA[RecognizeFieldOCR_S]]>
				</b>
<![CDATA[ action.]]>
<![CDATA[
]]>
<![CDATA[        Automatic retry is supported if the operation timeout is reached.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          RecognizeFieldICR_C()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RecognizeFieldVoteOCR_S()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Field only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
				<b>
<![CDATA[Field]]>
				</b>
<![CDATA[ object of the]]>
<![CDATA[
]]>
<![CDATA[        Document Hierarchy. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RecognizePageOCR_S">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action responds to settings in the OCR/S tab of the Recognition Options Setup dialog to recognize]]>
<![CDATA[
]]>
<![CDATA[        all characters on a page, and populates the page's CCO file with the recognition results.]]>
<![CDATA[
]]>
<![CDATA[        Automatic retry is supported if the operation timeout is reached.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
					<i>
<![CDATA[Alert!]]>
					</i>
				</b>
<![CDATA[ The NormalizeCCO action from the ]]>
				<b>
<![CDATA[CCO2CCO]]>
				</b>
<![CDATA[ action library should be called after]]>
<![CDATA[
]]>
<![CDATA[        RecognizePageOCR_S if the application will be using the navigation and pattern match actions]]>
<![CDATA[
]]>
<![CDATA[        to find recognized text on a page or perform pattern matching. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The DCO variable s_charReplace can be used to indicate characters that should be replaced with an alternate character]]>
<![CDATA[
]]>
<![CDATA[        during the recognition step.]]>
<![CDATA[
]]>
<![CDATA[        This procedure can be used when replacing a specific character in a post processing step is not feasible.]]>
<![CDATA[
]]>
<![CDATA[        Using this technique it can be a way to limit characters with full page recognition as can be done with field level recognition.]]>
<![CDATA[
]]>
<![CDATA[        The replacement string must contain pairs of comma separated decimal values that represent the characters]]>
<![CDATA[
]]>
<![CDATA[        to replace, such as: "original,new,original,new,original,new,etc."]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that this feature is used only if absolutely necessary. It is usually better to adjust characters]]>
<![CDATA[
]]>
<![CDATA[        later in a follow on step.  s_charReplace is only used during full page recognition.  It is not used for field level recognition.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Alert!]]>
				</b>
<![CDATA[ If a CCO file does not exist at the time this action is called, the action will create one.  If a CCO file]]>
<![CDATA[
]]>
<![CDATA[        already exists, it will be replaced.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          AnalyzeImage()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RotateImage()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RecognizePageOCR_S()]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[NormalizeCCO("")]]>
					</b>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          This sequence creates a CCO file for the current page, and checks to see if rotation of the image is needed.]]>
<![CDATA[
]]>
<![CDATA[          Full-page recognition then takes place in response to settings in the OCR/S tab of the Recognition]]>
<![CDATA[
]]>
<![CDATA[          Options Setup dialog The recognition results are stored in the CCO file. The words and lines in the CCO are then sorted]]>
<![CDATA[
]]>
<![CDATA[          for use by navigation and pattern match actions.]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          rrSet("8212,45","@X.s_charReplace")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RecognizePageOCR_S()]]>
					</b>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          This example shows how to use the character replacement string. In this case, any dashes that are ]]>
<![CDATA[
]]>
<![CDATA[          recognized as a Unicode dash (8213 in decimal),]]>
<![CDATA[
]]>
<![CDATA[          are converted to a standard minus sign character (45 in decimal).  If there were more]]>
<![CDATA[
]]>
<![CDATA[          characters to filter, just continue with more pairs in the same string.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[        Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="Recognize">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The ]]>
				<b>
<![CDATA[Recognize]]>
				</b>
<![CDATA[ action performs document layout analysis and OCR, generating a layout XML file such as TM000001_layout.xml. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        The layout file groups text into blocks similar to how a person would visually see and identify the structure while looking at the document. For example, a page can have tables, paragraphs, lines, etc., which are all a type of a block. Each block may have the default type of block or a specific type such as title or table, depending on how it was interpreted by the recognition engine. There are locate actions available in the Locate action library to navigate the block structure such as GoSiblingBlockNext . This is in contrast to the CCO file produced by other actions that groups text into lines that span the width of the page. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        The layout XML file also retains font and color attributes, saved in CSS format, for the text which is used for extracting data and reconstructing the document in a new format. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To use the Locate actions and perform click 'n' key during verification, use the action ]]>
				<b>
<![CDATA[CreateCcoFromLayout]]>
				</b>
<![CDATA[ action in the ]]>
				<b>
<![CDATA[SharedRecognitionTools]]>
				</b>
<![CDATA[ action library. This action will create a CCO file for the page after producing the layout XML file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Following are the types of elements that may be present in the layout XML file:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Block Type/XML Node]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<i>
<![CDATA[
]]>
<![CDATA[          Block/Block]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Header/Header]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Footer/Footer]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Title/Title]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Heading1/H1]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Heading2/H2]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Heading3/H3]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Picture/Picture]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Barcode/Barcode]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Space/S]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Tab/Tab]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Table/Table]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Row/Row]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Cell/Cell]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Paragraph/Para]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Line/L]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Sentence/Sent]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Word/W]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          Character/C]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</i>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Supported File Formats]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The Recognize action can process color images and PDF files. When processing PDF documents, the action will extract embedded text within the PDF document, and perform recognition only on those areas that contain data but do not contain embedded text. This improves the processing speed and overall performance of the processing of PDF documents.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Tip: It is also possible to process Microsoft Excel, Microsoft Word, Html, Rtf, and Txt documents by first converting those documents to searchable PDFs via the Convert library. For example, a Microsoft Excel document can be converted to PDF by calling the action ExcelWorkbookToPdf. Once the PDF document is created, then it can be processed through the Recognize action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Language Detection]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The ]]>
				<b>
<![CDATA[Recognize]]>
				</b>
<![CDATA[ action does not support language detection. However, this feature is available in the ]]>
				<b>
<![CDATA[Recognize]]>
				</b>
<![CDATA[ action of the ]]>
				<b>
<![CDATA[ocr_a.rrx]]>
				</b>
<![CDATA[ action library.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[Recognize()]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          CreateCcoFromLayout()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          This sequence creates layout xml file and subsequently a CCO file for the current page. The CCO file produced is ready for use by navigation and pattern match actions.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[        Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RecognizePageFieldsOCR_S">
			<ap>
<![CDATA[None.]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This page-level action recognizes all fields on the page that have been configured for OCR/S]]>
<![CDATA[
]]>
<![CDATA[        recognition (see the OCR/S tab of the Recognition Options Setup dialog.)]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Note:]]>
				</b>
<![CDATA[Individual field-level recognition actions will overwrite the results from this page-level action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        The action will not recognize a zoned field if the Skip Recognition checkbox in the OCR/S tab of the]]>
<![CDATA[
]]>
<![CDATA[        Recognition Options Setup dialog has been selected.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Automatic retry is supported if the operation timeout is reached.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ReadZones()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RecognizePageFieldsOCR_S()]]>
					</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the]]>
<![CDATA[
]]>
<![CDATA[        Document Hierarchy. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RecognizeToPDFOCR_S">
			<p name="OutputPDFType" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        A numeric value indicating the PDF output type:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[1.]]>
				</b>
<![CDATA[ A PDF document with the original image in the foreground with the recognized text hidden in the background (but in the correct position). Perfect for archiving and indexing documents.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[2.]]>
				</b>
<![CDATA[ A general PDF document where the text in the original image is replaced by the corresponding text recognized by the engine.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[3.]]>
				</b>
<![CDATA[ A special type of PDF document, where the suspect words are covered by their images cut out from the original image.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[4.]]>
				</b>
<![CDATA[ A non-searchable PDF document.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<lvl>
<![CDATA[Document and Page only.]]>
			</lvl>
			<h>
<![CDATA[
]]>
<![CDATA[        This action converts a scanned Image file (.tif) to an Adobe Portable Document Format (PDF) file. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        By default, PDF documents created by this action are compatible with PDF version 1.6. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        However, it is possible to change the default compatibility by setting the "s_pdfVersion" variable to one of the following values:]]>
				<br>
				</br>
<![CDATA[ ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        2 = PDF Version 1.5 ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        3 = PDF Version 1.4 ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        4 = PDF Version 1.3 ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        5 = PDF Version 1.2 ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        6 = PDF Version 1.1 ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        7 = PDF Version 1.0 ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        8 = PDF Version A ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        9 = PDF Version 1.6 ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        10 = PDF Version 1.7]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        11 = PDF Version A2B ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        12 = PDF Version A2U ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        13 = PDF Version A1A ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        14 = PDF Version A2A ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        To exclude specific page types, set the variable "typesToExclude" to a comma delimited list of page types to exclude from the pdf. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To include specific page types, set the variable "typesToInclude" to a comma delimited list of page types to include from the pdf. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        To exclude specific page status, set the variable "statusToExclude" to a comma delimited list of page status to exclude from the pdf. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        When more than one filter is specified, the following order of precedence takes place: ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        - "statusToExclude" overrides "typesToInclude" ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        - "typesToInclude" overrides "typesToExclude" ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If calling the action at the document level, the types and status filters apply to both the documents and child pages. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If calling the action at the page level, the types and status filters apply to the page only. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        These variables must be set before calling the action ]]>
				<b>
<![CDATA[RecognizeToPDFOCR_S]]>
				</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Automatic retry is supported if the operation timeout is reached.]]>
<![CDATA[
]]>
<![CDATA[        This action does not support converting or combining PDFs into a new PDF.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          rrSet("75","@D.statusToExclude) ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          rrSet("Blank","@D.typesToExclude) ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RecognizeToPDFOCR_S(3)]]>
					</b>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          The above example creates a PDF document with all pages contained in the dco document object , except those with type "Blank" and status of "75". ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the rule with this action is not applied to a document or page object, and/or if the parameters are not in the valid range. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RotateImageOCR_S">
			<ap>
<![CDATA[None]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action performs automatic rotation of black and white .TIF (or .TIFF) files. The automatic image rotation algorithm relies on, and works best with,]]>
<![CDATA[
]]>
<![CDATA[        images with good quality machine printed text.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If an image contains text with various orientations, for example vertical and horizontal,]]>
<![CDATA[
]]>
<![CDATA[        the image might be rotated undesirably.]]>
<![CDATA[
]]>
<![CDATA[        The automatic rotation algorithm does not fully work with images containing 9-pin dot-matrix text or other non-machine printed text.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that this action be called in a separate ruleset after recognition due]]>
<![CDATA[
]]>
<![CDATA[        to instances where the recognition engine will not release the image until the ruleset has completed.]]>
<![CDATA[
]]>
<![CDATA[        This problem can manifest as a "cco does not exist" error in the log file.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Automatic retry is supported if the operation timeout is reached.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RotateImageOCR_S()]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RecognizePageICR_C()]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          In this example, automatic image rotation is performed prior to full page recognition via the ICR_C actions.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page only.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the]]>
<![CDATA[
]]>
<![CDATA[        Document Hierarchy, or if the action cannot locate the image file representing the current page.]]>
<![CDATA[
]]>
<![CDATA[        Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RotateImageExOCR_S">
			<p name="ImagePath" type="string" qi="Path to the image file to rotate. If left blank, the current page image file is used by default.">
			</p>
			<p name="RotationMode" type="string" qi="Type of rotation to apply to the image. Valid values are 0 (Auto), 1 (No Rotation), 2 (90 degree rotation, clockwise), 3 (180 degree rotation, clockwise), 4 (90 degree rotation, counter-clockwise). If left blank, 0(Auto) is used by default.">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ImagePath:]]>
				</b>
<![CDATA[ Path to the image file to rotate. Smart parameters are supported. If left blank, the current page's image file is used by default.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[RotationMode:]]>
				</b>
<![CDATA[ Type of rotation to apply to the image. Valid values are: ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[ 0 - (Auto)]]>
				<br>
				</br>
<![CDATA[ 1 - (No Rotation)]]>
				<br>
				</br>
<![CDATA[ 2 - (90 degree rotation, clockwise)]]>
				<br>
				</br>
<![CDATA[ 3 - (180 degree rotation, clockwise)]]>
				<br>
				</br>
<![CDATA[ 4 - (90 degree rotation, counter-clockwise)]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[ If left blank, 0(Auto) is used by default.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action performs rotation of the specified image, using the specified rotation mode. When the ]]>
				<b>
<![CDATA[RotationMode]]>
				</b>
<![CDATA[ is not specified, the automatic image rotation algorithm is used. Note that this algorithm relies on, and works best with,]]>
<![CDATA[
]]>
<![CDATA[        images with good quality machine printed text.]]>
				<br>
				</br>
<![CDATA[If an image contains text with various orientations, for example vertical and horizontal,]]>
<![CDATA[
]]>
<![CDATA[        the image might be rotated undesirably.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        The automatic rotation algorithm does not fully work with images containing 9-pin dot-matrix text or other non-machine printed text.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        After the action runs and the image is rotated, the rotation applied to the image is saved in a page level variable called ]]>
				<b>
<![CDATA[OCRSRotMod]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that this action be called in a separate ruleset after recognition due]]>
<![CDATA[
]]>
<![CDATA[        to instances where the recognition engine will not release the image until the ruleset has completed.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Automatic retry is supported if the operation timeout is reached.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RotateImageEx("","")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RotateImageEx("", "2") ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          In this example, the first instance of RotateImageEx rotates the current page image file automatically and saves the rotation mode applied in the variable "OCRSRotMod".]]>
<![CDATA[
]]>
<![CDATA[          The second instance applies a 90 degree rotation to the current image.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the ruleset with this action is not bound to a ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the]]>
<![CDATA[
]]>
<![CDATA[        Document Hierarchy, or if the action cannot locate the image file specified in the first parameter, or if the rotation mode specified is not within the valid set of values.]]>
<![CDATA[
]]>
<![CDATA[        Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="RecognizeToFileOCR_S">
			<p name="FileType" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[fileType]]>
				</b>
<![CDATA[ - The action requires a ]]>
				<i>
<![CDATA[Numeric]]>
				</i>
<![CDATA[parameter from 1-22 to specify a combination of recognition targets]]>
<![CDATA[
]]>
<![CDATA[        and output formats.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Important!]]>
				</b>
<![CDATA["Image" refers to the image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[        "Filename" is the string portion of a file's name that precedes its extension.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The output for all of these parameters will produce a file name that is identical to the original]]>
<![CDATA[
]]>
<![CDATA[        file name and will have the extension specified for that parameter.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		]]>
				<b>
<![CDATA[1.]]>
				</b>
<![CDATA[ A PDF document with the original image in the foreground with the recognized text hidden in the background (but in the correct position). Perfect for archiving and indexing documents.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[2.]]>
				</b>
<![CDATA[ A general PDF document where the text in the original image is replaced by the corresponding text recognized by the engine.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[3.]]>
				</b>
<![CDATA[ A special type of PDF document, where the suspect words are covered by their images cut out from the original image.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[4.]]>
				</b>
<![CDATA[ A non-searchable PDF document.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[5.]]>
				</b>
<![CDATA[ Recognize an HTML image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".html" (HTML 140).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[6.]]>
				</b>
<![CDATA[ Recognize an image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in an Excel file.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".xls" (Excel 2000.) - ]]>
				<b>
<![CDATA[Obsolete]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[7.]]>
				</b>
<![CDATA[ Recognize any image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Word2000 file with a ".doc" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".doc" (Word 2000).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[8.]]>
				</b>
<![CDATA[ Recognize any image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a WordML file.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".doc" (Word ML).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[9.]]>
				</b>
<![CDATA[ Recognize any image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Word97 file.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".doc" (Word 97)  - ]]>
				<b>
<![CDATA[Obsolete]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[10.]]>
				</b>
<![CDATA[ Recognize any image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a RTF2000SWord file.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".rtf" (RTF 2000SWord) - ]]>
				<b>
<![CDATA[Obsolete]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[11.]]>
				</b>
<![CDATA[ Recognize any image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in an RTF2000 file.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".rtf" (RTF 2000).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[12.]]>
				</b>
<![CDATA[ Recognize the image of the bound ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with an ".RTF6" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".rtf" (Rich Text).  ]]>
				<b>
<![CDATA[Obsolete]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[13.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with an "RTF6" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".rtf" (Rich Text).   ]]>
				<b>
<![CDATA[Obsolete]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[14.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with an ".Text" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".txt" (Text).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[15.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with an ".Csv" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".txt" (CSV - Comma Separated Variable).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[16.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with a ".FormattedTxt" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".txt" (Formatted Text).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[17.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with a ".UText" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".txt" (Text).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[18.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with a ".UCSV" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".CSV" (Comma Separated Variable).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[19.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with a ".UFormattedText" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".txt" (Text).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[20.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with an ".Audio" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".aud" (Text).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[21.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with a ".WordPad" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".rtf" (Rich Text for WordPad).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[22.]]>
				</b>
<![CDATA[ Recognize the image of the ]]>
				<b>
<![CDATA[Page]]>
				</b>
<![CDATA[object of the Document Hierarchy in a Text file with an ".XML" extension.]]>
<![CDATA[
]]>
<![CDATA[        Output: ".xml" (XML).]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		]]>
				<b>
<![CDATA[
]]>
<![CDATA[		The following output converters are no longer supported:"]]>
<![CDATA[
]]>
<![CDATA[		]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[		]]>
					<li>
<![CDATA[Converters.Text.Excel97/Excel 2000]]>
					</li>
<![CDATA[
]]>
<![CDATA[		]]>
					<li>
<![CDATA[Converters.Text.Word2000 (native Doc format, replaced with Converters.Text.RTF2000)]]>
					</li>
<![CDATA[
]]>
<![CDATA[		]]>
					<li>
<![CDATA[Converters.Text.Word97 (native Doc format, replaced with Converters.Text.RTF2000)]]>
					</li>
<![CDATA[
]]>
<![CDATA[		]]>
					<li>
<![CDATA[Converters.Text.RTF97]]>
					</li>
<![CDATA[
]]>
<![CDATA[		]]>
					<li>
<![CDATA[Converters.Text.RTF6]]>
					</li>
<![CDATA[
]]>
<![CDATA[		]]>
					<li>
<![CDATA[Converters.Text.RTF2000SWord]]>
					</li>
<![CDATA[
]]>
<![CDATA[		]]>
					<li>
<![CDATA[Converters.Text.eBook]]>
					</li>
<![CDATA[
]]>
<![CDATA[		]]>
					<li>
<![CDATA[Converters.Text.MicrosoftReader]]>
					</li>
<![CDATA[
]]>
<![CDATA[		]]>
				</b>
<![CDATA[
]]>
<![CDATA[		]]>
				<br>
				</br>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Performs OCR recognition on the image of a source page, and stores the output of the OCR/S recognition]]>
<![CDATA[
]]>
<![CDATA[        engine in a file. The output file is in one of 22 alternative formats. Because the files are not actually]]>
<![CDATA[
]]>
<![CDATA[        processed in the format you specify, this action is useful primarily for debugging the engine,]]>
<![CDATA[
]]>
<![CDATA[        of if you need raw (unverified) OCR output in that format.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Automatic retry is supported if the operation timeout is reached.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[
]]>
<![CDATA[          By default, PDF documents created by this action are compatible with PDF version 1.6. ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          However, it is possible to change the default compatibility by setting the "s_pdfVersion" variable to one of the following values:]]>
					<br>
					</br>
<![CDATA[ ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          2 = PDF Version 1.5 ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          3 = PDF Version 1.4 ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          4 = PDF Version 1.3 ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          5 = PDF Version 1.2 ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          6 = PDF Version 1.1 ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          7 = PDF Version 1.0 ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          8 = PDF Version A ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          9 = PDF Version 1.6 ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          10 = PDF Version 1.7]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          11 = PDF Version A2B ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          12 = PDF Version A2U ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          13 = PDF Version A1A ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          14 = PDF Version A2A ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          To exclude specific page types, set the variable "typesToExclude" to a comma delimited list of page types to exclude from the pdf. ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          To exclude specific page status, set the variable "statusToExclude" to a comma delimited list of page status to exclude from the pdf. ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          These variables must be set before calling the action "RecognizeToFileOCR_S"]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          rrSet("75","@D.statusToExclude) ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          rrSet("Blank","@D.typesToExclude) ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[RecognizeToFileOCR_S(1)]]>
					</b>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          The above example creates a PDF document with all pages contained in the dco document object , except those with type "Blank" and status of "75". ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page or Document.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if a ruleset with this action is bound to a ]]>
				<b>
<![CDATA[Field]]>
				</b>
<![CDATA[object of the Document Hierarchy,]]>
<![CDATA[
]]>
<![CDATA[        or if the parameter is not numeric. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetOutOfProcessLoggingOCR_S">
			<p name="EnableLogging" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[EnableLogging]]>
				</b>
<![CDATA[ - a value indicating whether write out logs for the out-of-process process for debugging purposes.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action write out logs for the out-of-process process for debugging purposes.]]>
<![CDATA[
]]>
<![CDATA[        The log file is written to the batch folder. Multiple logs are created and they are named: ]]>
<![CDATA[
]]>
<![CDATA[        "dcoprocessor.logdcoproc XX_XX_XX.log", where X are numerics.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetOutOfProcessLoggingOCR_S(true)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetOutOfProcessTimeoutOCR_S(185)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RecognizeFieldOCR_S]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page or Field.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetContinueOnFailureOCR_S">
			<p name="ContinueOnFailure" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ContinueOnFailure]]>
				</b>
<![CDATA[ - a value indicating whether a recognition action will abort or continue after it has encountered an error.]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of ]]>
				<b>
<![CDATA[true]]>
				</b>
<![CDATA[ is used.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action is provided for legacy support of rules that manually perform a retry of recognition failures]]>
<![CDATA[
]]>
<![CDATA[        and is provided for backwards compatibility.  It is recommended that you allow OCR/SR actions to automatically]]>
<![CDATA[
]]>
<![CDATA[        handle retries of recognition failures.  When automatic mode is used, this action does not need to be called.]]>
<![CDATA[
]]>
<![CDATA[        See the top level help topic in the OCR/SR library for more information.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This action sets a value indicating whether a recognition action will abort or continue after it has encountered an error. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default behavior is for the recognition actions to continue on error. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetContinueOnFailureOCR_S(true)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetOutOfProcessTimeoutOCR_S(185)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RecognizeFieldOCR_S]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page or Field.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="UseOutOfProcessRecogOCR_S">
			<p name="UseOutOfProcessRecog" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[UseOutOfProcessRecog]]>
				</b>
<![CDATA[ -A value indicating whether recognition will run out-of-process. Set to true for out-of-process recognition, and False for in-process recognition. By default, the recognition actions run out-of-process. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        This action is provided for legacy support of rules that manually perform a retry of recognition failures]]>
<![CDATA[
]]>
<![CDATA[        and is provided for backwards compatibility.  It is recommended that you allow OCR/SR actions to automatically]]>
<![CDATA[
]]>
<![CDATA[        handle retries of recognition failures.]]>
<![CDATA[
]]>
<![CDATA[        When automatic mode is used, this action does not need to be called and recognition will be automatically run out of process.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This action indicates whether recognition will run out-of-process or in process.  Running out of process improves stability of the application.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If a recognition action does not complete within the specified number of seconds indicated by a]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[SetOutOfProcessRecogTimeoutOCR_S]]>
				</b>
<![CDATA[action or a ]]>
				<b>
<![CDATA[SetEngineTimeoutOCR_S]]>
				</b>
<![CDATA[action, it is assumed that the]]>
<![CDATA[
]]>
<![CDATA[        recognition engine has encountered a severe error. If the recognition action does not complete by the specified time on the second attempt, the recognition]]>
<![CDATA[
]]>
<![CDATA[        action will be set to abort if ]]>
				<b>
<![CDATA[ContinueOnFailure(False)]]>
				</b>
<![CDATA[was used.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          SetEngineTimeoutOCR_S(180)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<b>
<![CDATA[SetOutOfProcessTimeoutOCR_S(185)]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          RecognizeFieldOCR_S]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Page or Field.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the parameter is not numeric or less than 1. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[	]]>
		<method name="ReleaseEngineOCR_SR">
			<h>
<![CDATA[
]]>
<![CDATA[        This action releases the Nuance Engine. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ReleaseEngineOCR_SR()]]>
					<br>
					</br>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[All]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="OpenTextFaxServer" v="9.0.0.12">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[' Open Text Fax Server (RightFax) Actions]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Licensed Materials - Property of IBM]]>
<![CDATA[
]]>
<![CDATA[' “Restricted Materials of IBM”]]>
<![CDATA[
]]>
<![CDATA[' 5725-C15 5725-C69]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' © Copyright IBM Corp. 1994, 2011 All Rights Reserved]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' US Government Users Restricted Rights - Use, duplication or]]>
<![CDATA[
]]>
<![CDATA[' disclosure restricted by GSA ADP Schedule Contract with]]>
<![CDATA[
]]>
<![CDATA[' IBM Corp.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Version = "8.0.1.0"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/16/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA['  Initial Implementation of Open Text Fax Server actions (RightFax)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.1"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/17/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA['  Exposed action Disconnect() which allows an application to disconnect or close the connection to the server.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.2"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/17/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA['  Exposed action SetAbortTimeout(int Milliseconds) to allows the user to set the time to wait before aborting a batch.]]>
<![CDATA[
]]>
<![CDATA['  Updated help text for actions to include default values used.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.0.1.3"]]>
<![CDATA[
]]>
<![CDATA[' Updated 12/23/2010 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added action SendFax and accompanying help text.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.0.1.4"]]>
<![CDATA[
]]>
<![CDATA[' Updated 1/11/11 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated documentation for the SendAsFax action.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.0.1.5"]]>
<![CDATA[
]]>
<![CDATA[' Updated 1/12/11 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated documentation for the UseWindowsAuthentication action.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "8.1.0.6"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/23/11 JMartinez]]>
<![CDATA[
]]>
<![CDATA['- Moved parameter information from the qi= tag to the standard parameter help section]]>
<![CDATA[
]]>
<![CDATA['- Moved action information from the qi= tag to the standard action help section]]>
<![CDATA[
]]>
<![CDATA['- Added IBM Copyright notice]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.7"]]>
<![CDATA[
]]>
<![CDATA[' Updated 05/23/11 RFerin]]>
<![CDATA[
]]>
<![CDATA[' SPR 35163 - Identified which parameters support smart parameters.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = "8.1.0.8"]]>
<![CDATA[
]]>
<![CDATA[' Updated 2/20/2013]]>
<![CDATA[
]]>
<![CDATA[' Updated help for SendAsFax action. Smart parameters are now supported.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = 8.1.0.9"]]>
<![CDATA[
]]>
<![CDATA['Updated 05/21/2013 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Added new actions SetProcessedFaxesFolder,SetInputFolder, SetRetryTimeout, SetNumberOfRetries,ContinueOnConnectionError, and ContinueOnFaxImportError]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = 8.1.0.10"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/03/2013 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for ImportFaxes action to list all fax properties saved as variables when a fax is imported.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = 8.1.0.11"]]>
<![CDATA[
]]>
<![CDATA[' Updated 07/03/2013 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text for ImportFaxes action to list all fax properties saved as variables when a fax is imported.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Version = 9.0.0.12"]]>
<![CDATA[
]]>
<![CDATA[' Updated 06/18/2015 JMartinez]]>
<![CDATA[
]]>
<![CDATA[' Updated help text]]>
<![CDATA[
]]>
<![CDATA['**************************************************************************************************]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<com ref="Datacap.Libraries.OpenTextFaxServer.Actions">
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="Connect" ditaname="dcaca565" qi="Creates the connection to the Fax server.">
			<h>
<![CDATA[This action should be called after setting the server connection parameters via the following actions: ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[
]]>
<![CDATA[          ]]>
					<i>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetWindowsAuthentication(True)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</i>
<![CDATA[
]]>
<![CDATA[        ]]>
				</b>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[Connect()]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level or if the connection to fax server cannot be established. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="Disconnect" ditaname="dcaca568" qi="Disconnects the connection from the Fax server.">
			<h>
<![CDATA[
]]>
<![CDATA[        This action should be called after the ]]>
				<scr>
<![CDATA[Import()]]>
				</scr>
<![CDATA[ or ]]>
				<scr>
<![CDATA[Connect()]]>
				</scr>
<![CDATA[.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Typically this action would be called at the Batch's close node, after the connection to the fax server is made and faxes are imported.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportPages()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[Disconnect()]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level or if the connection to fax server cannot be closed. Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ImportFaxes" ditaname="dcaca569" qi="Imports the faxes from the Fax server into the document batch.">
			<h>
<![CDATA[
]]>
<![CDATA[        This action imports faxes from the fax server. Each fax that is imported is stored in a document inside the Datacap batch. The following fax information]]>
<![CDATA[
]]>
<![CDATA[        will be stored in the document's variables (some of these variables can be empty): ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<ul>
					<li>
<![CDATA[FaxUniqueID]]>
					</li>
<![CDATA[
]]>
<![CDATA[        ]]>
					<li>
<![CDATA[FaxStatus]]>
					</li>
<![CDATA[
]]>
<![CDATA[        ]]>
					<li>
<![CDATA[TotalPages]]>
					</li>
<![CDATA[
]]>
<![CDATA[        ]]>
					<li>
<![CDATA[LastHistoryChangeDateTime]]>
					</li>
<![CDATA[
]]>
<![CDATA[        ]]>
					<li>
<![CDATA[FromFaxNumber]]>
					</li>
<![CDATA[
]]>
<![CDATA[        ]]>
					<li>
<![CDATA[FromName]]>
					</li>
<![CDATA[
]]>
<![CDATA[        ]]>
					<li>
<![CDATA[FromVoiceNumber]]>
					</li>
<![CDATA[
]]>
<![CDATA[        ]]>
					<li>
<![CDATA[FromGeneralFaxNumber]]>
					</li>
<![CDATA[
]]>
<![CDATA[        ]]>
					<li>
<![CDATA[FromGeneralVoiceNumber]]>
					</li>
<![CDATA[
]]>
<![CDATA[        ]]>
					<li>
<![CDATA[Attachments]]>
					</li>
<![CDATA[
]]>
<![CDATA[        ]]>
					<li>
<![CDATA[ToFaxNumber]]>
					</li>
<![CDATA[
]]>
<![CDATA[        ]]>
					<li>
<![CDATA[ToVoiceNumber]]>
					</li>
				</ul>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Note:]]>
				</b>
<![CDATA[ Setting the batch variable "WriteFaxXMLData" to "1" will cause the action to write all possible fax properties to an XML file. The XML is named based on the]]>
<![CDATA[
]]>
<![CDATA[        created document ID for a fax, i.e "20120109.000008.01.xml".]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action after a ]]>
				<scr>
<![CDATA[Connect()]]>
				</scr>
<![CDATA[ action. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[ImportFaxes()]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Note: if the Connect() action is not called prior to calling ImportFaxes(), ImportFaxes() will automatically call the Connect() action. However, the actions]]>
<![CDATA[
]]>
<![CDATA[          that set the connection parameters need to be called prior to ImportFaxes(). ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level or if an exception is encountered while importing faxes.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SendAsFax" ditaname="dcaca570" qi="Faxes the contents of the document or page to the specified Fax number.">
			<p name="ToFaxNumber" type="string">
			</p>
			<p name="ToName" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ToFaxNumber : Recipient's fax number. This parameter is required. Smart parameters are supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ToName : Recipient's name. This paramater is optional. If left empty, the default ToName configured for the logged in user (on the server) will be used. Smart parameters are supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Faxes the document contents to the specified fax number.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SendAsFax("123-456-8971","John Doe")]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Note: a connection to the fax server must be established via actions before using the ]]>
					<b>
<![CDATA[
]]>
<![CDATA[            ]]>
						<i>
<![CDATA[SendAsFax]]>
						</i>
					</b>
<![CDATA[ action. ]]>
					<br>
					</br>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Document and Page levels.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the document or page levels, or the fax number is not specified, or the document does not contain pages (attachments), if a connection cannot be made to the fax server, or if the fax server returns an exception while attempting to send the fax.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetAbortTimeout" ditaname="dcaca571" qi="Sets the amount of time to wait before you stop running a batch.">
			<p name="Milliseconds" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        Milliseconds :The amount of time, in milliseconds, to wait before aborting a batch. The default value is 10000 ms (10 seconds). ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        The action will wait the specified time before returning when an abort occurs.]]>
<![CDATA[
]]>
<![CDATA[        This action can be useful to prevent a large number of aborted batches due to]]>
<![CDATA[
]]>
<![CDATA[        an abort condition. For example, if the fax server should become unavailable]]>
<![CDATA[
]]>
<![CDATA[        for a time, the abort timeout will limit the amount of aborted batches until]]>
<![CDATA[
]]>
<![CDATA[        the fax server becomes available again.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 10 seconds will be used."]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[ImportFaxes()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetAbortTimeout(5000)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetFaxRemovalAfterImport" ditaname="dcaca572" qi="Sets whether to remove processed faxes from the Fax server. This action must be set to True to enable the import of new faxes.">
			<p name="RemoveFaxes" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        A boolean that sets whether or not to remove processed faxes from the server. The default value is False.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[ – Faxes will be removed from the fax server once they are imported into a Datacap batch.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ –  Faxes will remain in the fax server once they are imported into a Datacap batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[The default value is False ]]>
				</b>
<![CDATA[ ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Sets whether or not to remove processed faxes from the server after they have been imported into the Datacap batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of False will be used."]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[ImportFaxes()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetFaxRemovalAfterImport(True)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetMaxNumberOfFaxes" ditaname="dcaca574" qi="Sets the maximum number of faxes that are allowed per batch.">
			<p name="MaxFaxes" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MaxFaxes]]>
				</b>
<![CDATA[ – The maximum number of faxes allowed per batch. The default value is 100.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 100 faxes per batch will be used.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[ImportFaxes()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetMaxNumberOfFaxes(5)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetPollingInterval" ditaname="dcaca576" qi="Sets the number of milliseconds to wait before the OpenTextFaxServer resumes fax polling from the Fax server.">
			<p name="Milliseconds" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Milliseconds]]>
				</b>
<![CDATA[ - The amount of time, in milliseconds, to wait before polling the fax server again. The default value is 2000 ms (2 seconds). ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 2 seconds will be used."]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[ImportFaxes()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetPollingInterval(5000)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetServerName" ditaname="dcaca580" qi="Sets the name of the Fax server to which you can upload faxes.">
			<p name="ServerName" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[ServerName]]>
				</b>
<![CDATA[- The name of the fax server. Smart parameters are supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<b>
<![CDATA[ImportFaxes()]]>
				</b>
<![CDATA[ or ]]>
				<b>
<![CDATA[Connect()]]>
				</b>
<![CDATA[ action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetServerName("myserver")]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetUserID" ditaname="dcaca581" qi="Sets the user ID used to log in to the Fax server.">
			<p name="UserID" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[UserID]]>
				</b>
<![CDATA[- The user ID to be used to connect to the fax server. Smart parameters are supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<b>
<![CDATA[ImportFaxes()]]>
				</b>
<![CDATA[ or ]]>
				<b>
<![CDATA[Connect()]]>
				</b>
<![CDATA[ action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[            ]]>
					<b>
<![CDATA[SetUserID("myuser")]]>
					</b>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetUserPassword" ditaname="dcaca582" qi="Sets the password used to log in to the Fax server.">
			<p name="UserPassword" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[UserPassword]]>
				</b>
<![CDATA[- The user ID password to connect to the fax server. Smart parameters are supported.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[      Include this action before a ]]>
				<b>
<![CDATA[ImportFaxes()]]>
				</b>
<![CDATA[ or ]]>
				<b>
<![CDATA[Connect()]]>
				</b>
<![CDATA[ action.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        It is recommended that you create an advanced value in the custom values tab in the]]>
<![CDATA[
]]>
<![CDATA[        Application Manager to encrypt your password instead of hard coding it in the]]>
<![CDATA[
]]>
<![CDATA[        action parameter.  The password can be retrieved using smart parameters.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetUserPassword("mypassword")]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetProtocol" ditaname="dcaca578" qi="Sets the protocol to use to connect to the Fax server.">
			<p name="Protocol" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        The protocol to be used to connect to the fax server. The default value is 4 (TCPIP). ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Valid parameter values are: ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[1]]>
				</b>
<![CDATA[ – Named Pipes]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[2]]>
				</b>
<![CDATA[ – IPXOS2]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[3]]>
				</b>
<![CDATA[ - SPX]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[4]]>
				</b>
<![CDATA[ - TCPIP]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[5]]>
				</b>
<![CDATA[ - IPX]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[6]]>
				</b>
<![CDATA[ - SecTCPIP]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[7]]>
				</b>
<![CDATA[ - SecSPX]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 4 (TCPIP protocol) will be used.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[ImportFaxes()]]>
				</scr>
<![CDATA[ or ]]>
				<scr>
<![CDATA[Connect()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserID("myuser")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetUserPassword("mypassword")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetProtocol(4)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level or if the parameter is invalid.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetWindowsAuthentication" ditaname="dcaca583" qi="Sets whether to use Windows Authentication to connect to the Fax server.">
			<p name="UseWindowsAuthentication" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[True]]>
				</b>
<![CDATA[ – Windows Authentication will be used. The actions SetUserID() and SetUserPassword() are not required when UseWindowsAuthentication is set to True.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ –  Fax Server user authentication will be used. The actions SetUserID() and SetUserPassword() are required when UseWindowsAuthentication is set to False.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[The default value is False ]]>
				</b>
<![CDATA[ ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[ImportFaxes()]]>
				</scr>
<![CDATA[ or ]]>
				<scr>
<![CDATA[Connect()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetWindowsAuthentication(True)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Batch Level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[False]]>
				</b>
<![CDATA[ if the action is not called at the batch level.  Otherwise, ]]>
				<b>
<![CDATA[True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ContinueOnConnectionError" ditaname="dcaca566" qi="Specifies whether the batch should continue if there is an error connecting to the server.">
			<p name="Continue" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        A boolean value specifying whether or not the batch should abort if there is an error connecting to the server.  ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        When the parameter is set to ]]>
				<b>
<![CDATA[true]]>
				</b>
<![CDATA[, the batch finishes with ]]>
				<b>
<![CDATA[pending]]>
				</b>
<![CDATA[ status, avoiding the creation of more batches that will result in an aborted status. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of ]]>
				<b>
<![CDATA[false]]>
				</b>
<![CDATA[ is used and the batch is aborted at the end of processing.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before the ]]>
				<scr>
<![CDATA[Connect()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[ContinueOnConnectionError(true)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetNumberOfRetries(3)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetWindowsAuthentication(True)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Always True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="ContinueOnFaxImportError" ditaname="dcaca567" qi="Specifies whether the batch should abort if there is an error importing a fax.">
			<p name="Continue" type="bool">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        A boolean value specifying whether or not the batch should abort if there is an error importing a fax.  ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        When the parameter is set to ]]>
				<b>
<![CDATA[true]]>
				</b>
<![CDATA[ the batch finishes with ]]>
				<b>
<![CDATA[pending]]>
				</b>
<![CDATA[ status, and contains all faxes that where imported successfully, up to the last one that failed to be imported. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        If ContinueOnFaxImportError is never called, the ImportFaxes action will continue processing after an error.  Call ContinueOnFaxImportError(False) to stop ingestion of faxes after an error.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before the ]]>
				<scr>
<![CDATA[Connect()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[ContinueOnFaxImportError(true)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetNumberOfRetries(3)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetWindowsAuthentication(True)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Always True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetNumberOfRetries" ditaname="dcaca575" qi="Sets the number of times to attempt a connection to the Fax server after a connection error occurs.">
			<p name="NumberOfRetries" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        An integer value representing the number of times to attempt a connection to the fax server after a connection error occurs.  ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[       If this action is not called, the default value of 3 will be used."]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before the ]]>
				<scr>
<![CDATA[Connect()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetNumberOfRetries(3)]]>
						</b>
<![CDATA[ ]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetWindowsAuthentication(True)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Always True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetRetryTimeout" ditaname="dcaca579" qi="Sets the number milliseconds to wait before attempting a connection to the fax server after a connection error occurs.">
			<p name="Milliseconds" type="int">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        An integer value representing the number milliseconds to wait before attempting a connection to the fax server after a connection error occurs.  ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the default value of 3000 milliseconds will be used.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[ImportFaxes()]]>
				</scr>
<![CDATA[ or ]]>
				<scr>
<![CDATA[Connect()]]>
				</scr>
<![CDATA[ action.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetNumberOfRetries(3) ]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetRetryTimeout(3000)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetWindowsAuthentication(True)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Always True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetInputFolder" ditaname="dcaca573" qi="Sets the name of the input folder where faxes are to be imported from.">
			<p name="FolderName" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        An string value representing the name of the user folder where faxes are to be imported from. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[
]]>
<![CDATA[        If this action is not called, the faxes are imported from the default user folder. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[ImportFaxes()]]>
				</scr>
<![CDATA[.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetNumberOfRetries(3)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetRetryTimeout(3000)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetWindowsAuthentication(True)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetInputFolder(INPUT)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Always True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<method name="SetProcessedFaxesFolder" ditaname="dcaca577" qi="Sets the name of the folder where where faxes are to be moved to after they are imported.">
			<p name="FolderName" type="string">
			</p>
			<ap>
<![CDATA[
]]>
<![CDATA[        An string value representing the name of the user folder where faxes are to be moved to after they are imported. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ap>
			<h>
<![CDATA[If this action is not called, the faxes are left in the input folder. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Include this action before a ]]>
				<scr>
<![CDATA[ImportFaxes()]]>
				</scr>
<![CDATA[.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<e>
<![CDATA[
]]>
<![CDATA[          ]]>
					<scr>
<![CDATA[
]]>
<![CDATA[            SetNumberOfRetries(3) ]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetRetryTimeout(3000)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetServerName("myserver")]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetWindowsAuthentication(True)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            SetProtocol(4)]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            Connect()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ]]>
						<b>
<![CDATA[SetProcessedFaxesFolder(OUTPUT)]]>
						</b>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[            ImportFaxes()]]>
						<br>
						</br>
<![CDATA[
]]>
<![CDATA[          ]]>
					</scr>
<![CDATA[
]]>
<![CDATA[          ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				</e>
<![CDATA[
]]>
<![CDATA[      ]]>
			</h>
			<lvl>
<![CDATA[Any level.]]>
			</lvl>
			<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Always True.]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ret>
		</method>
<![CDATA[
]]>
<![CDATA[  ]]>
	</com>
</rrx>
<rrx namespace="Statistics" v="9.0.1.3">
	<i ref="rrunner">
	</i>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['************************************************************************]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' Copyright Datacap Inc. 2001-2015, All rights Reserved]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Version = "9.0.1.4"]]>
<![CDATA[
]]>
<![CDATA[' Updated 10/20/2015 ]]>
<![CDATA[
]]>
<![CDATA[' LOG RRX VERSION:]]>
<![CDATA[
]]>
<![CDATA[Writelog("Statistics " & Version)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['********************************************************************]]>
<![CDATA[
]]>
<![CDATA['------------HELPER FUNCTIONS-------------------------------------------------]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
	<af name="SaveFieldsText" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="Save recognized page types and field values after recognition, for accuracy calculations.">
		<ap>
<![CDATA[
]]>
<![CDATA[   None.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[Call this action after page classification and OCR recognition, but before verification, to save the original recognized data for statistics calculations.]]>
<![CDATA[
]]>
<![CDATA[The type of each page is stored in page variable ClassifiedPageType.  The recognized value of each field is stored in field variable RecognizedText.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[SaveFieldsText()]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Batch level.]]>
		</lvl>
		<ret>
<![CDATA[Always True.]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	Call recursiveSaveRecognizedText(DCO)]]>
<![CDATA[
]]>
<![CDATA[if err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[	writelog("Error " & err.number)]]>
<![CDATA[
]]>
<![CDATA[	writelog("Error " & err.description)]]>
<![CDATA[
]]>
<![CDATA[	err.clear]]>
<![CDATA[
]]>
<![CDATA[end if]]>
<![CDATA[
]]>
<![CDATA[SaveFieldsText = true]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="CompareFieldsText" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="Calculates page type classification and field recognition accuracy statistics and updates database report tables.">
		<ap>
<![CDATA[
]]>
<![CDATA[   None.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[Call this action after data verification to calculate accuracy based on the changes to data during verification. The SaveFieldsText action must have previously run after the profiler task (recognition), and before verification.]]>
<![CDATA[
]]>
<![CDATA[Batch variables are populated with accuracy values. PageClassifiedErrors is the number of page classification errors (page type changed after auto-classification), PageClassifiedCount is the number of pages classified in this batch, FieldRecognitionCount is the number of fields recognized, and FieldRecognitionErrors is the number of fields that were incorrectly recognized (were changed after recognition).]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[CompareFieldsText()]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Batch level.]]>
		</lvl>
		<ret>
<![CDATA[Always True.]]>
		</ret>
		<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[	' Store page and field accuracy info in the runtime DCO batch level variables]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[	DCO.Variable("PageClassifiedErrors") = "0"]]>
<![CDATA[
]]>
<![CDATA[	DCO.Variable("PageClassifiedCount") = "0"]]>
<![CDATA[
]]>
<![CDATA[	DCO.Variable("FieldRecognitionCount") = "0"]]>
<![CDATA[
]]>
<![CDATA[	DCO.Variable("FieldRecognitionErrors") = "0"]]>
<![CDATA[
]]>
<![CDATA[	DCO.Variable("FieldAccuracyPct") = "0."]]>
<![CDATA[
]]>
<![CDATA[	DCO.Variable("ClassifyAccuracyPct") = "0."]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call recursiveCompareText(DCO)	' calculate the error info]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FieldCount = CInt(DCO.Variable("FieldRecognitionCount"))]]>
<![CDATA[
]]>
<![CDATA[	if FieldCount > 0 then ]]>
<![CDATA[
]]>
<![CDATA[		Accuracy = 100.*CDbl(FieldCount - DCO.Variable("FieldRecognitionErrors"))/FieldCount]]>
<![CDATA[
]]>
<![CDATA[		if Accuracy > 100 then Accuracy = 100]]>
<![CDATA[
]]>
<![CDATA[		if Accuracy < 0 then Accuracy = 0]]>
<![CDATA[
]]>
<![CDATA[		DCO.Variable("FieldAccuracyPct") = CStr(Accuracy)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	PageCount = CInt(DCO.Variable("PageClassifiedCount"))]]>
<![CDATA[
]]>
<![CDATA[	if PageCount > 0 then]]>
<![CDATA[
]]>
<![CDATA[		Accuracy = 100.*CDbl(PageCount - DCO.Variable("PageClassifiedErrors"))/PageCount]]>
<![CDATA[
]]>
<![CDATA[		if Accuracy > 100 then Accuracy = 100]]>
<![CDATA[
]]>
<![CDATA[		if Accuracy < 0 then Accuracy = 0]]>
<![CDATA[
]]>
<![CDATA[		DCO.Variable("ClassifyAccuracyPct") = CStr(Accuracy)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CompareFieldsText = true	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="IsBatchAborted" access="public" bInter="bInter" bDebug="bDebug" qi="Reports if batch is set to abort.">
		<ap>
<![CDATA[None.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[Test whether the batch has already been aborted and stop the ruleset if so.]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[IsBatchAborted()]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Any level.]]>
		</lvl>
		<ret>
<![CDATA[True if the batch is set to abort, else False.]]>
		</ret>
		<g>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[if babort then ]]>
<![CDATA[
]]>
<![CDATA[	isbatchaborted=true]]>
<![CDATA[
]]>
<![CDATA[	else]]>
<![CDATA[
]]>
<![CDATA[	isbatchaborted=false]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
	<af name="AddToDBTotals" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="">
		<ap>
<![CDATA[
]]>
<![CDATA[   None.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[  ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[Update application summary statistics in the reportTotal table with this batch's totals.  Once this action executes successfully it sets batch variable TotalStatsUpdated to avoid double-counting.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			<e>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[AddToDBTotals()]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ]]>
			</e>
<![CDATA[
]]>
<![CDATA[  ]]>
		</h>
		<lvl>
<![CDATA[Batch level.]]>
		</lvl>
		<ret>
<![CDATA[Always True.]]>
		</ret>
		<g>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[	AddToDBTotals = true]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	iExported = MetaWord("@B.TotalStatsUpdated")]]>
<![CDATA[
]]>
<![CDATA[	if iExported = "1" then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Statistics already updated")]]>
<![CDATA[
]]>
<![CDATA[		exit function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	' for each counter in reportTotal, only update those that have changed]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sParams = ""]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sCounter = MetaWord("@B.CheckRecognitionCount")]]>
<![CDATA[
]]>
<![CDATA[	if sCounter <> "" then]]>
<![CDATA[
]]>
<![CDATA[		if CInt(sCounter) > 0 then sParams = "rt_Feature1Count" & "," & sCounter]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set fso = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[	dFoldersize = FSO.GetFolder(Pilot.BatchDir).Size]]>
<![CDATA[
]]>
<![CDATA[	Set fso = nothing]]>
<![CDATA[
]]>
<![CDATA[	sCounter = CStr(CInt((dFolderSize + 512) / 1024))]]>
<![CDATA[
]]>
<![CDATA[	if sCounter <> "" then]]>
<![CDATA[
]]>
<![CDATA[		if CInt(sCounter) > 0 then]]>
<![CDATA[
]]>
<![CDATA[			if (sParams <> "") then sParams = sParams & ";"]]>
<![CDATA[
]]>
<![CDATA[			sParams = sParams & "rt_TotalSizeKB" & "," & sCounter]]>
<![CDATA[
]]>
<![CDATA[			DCO.Variable("SizeKB") = sCounter]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'WriteLog(sParams)]]>
<![CDATA[
]]>
<![CDATA[	  ret = true]]>
<![CDATA[
]]>
<![CDATA[	  if sParams <> "" then]]>
<![CDATA[
]]>
<![CDATA[		  ret = AddToReportTotal(sParams)]]>
<![CDATA[
]]>
<![CDATA[	  end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	if ret = true then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Statistics updated OK")]]>
<![CDATA[
]]>
<![CDATA[		DCO.variable("TotalStatsUpdated") = "1"]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</g>
	</af>
</rrx><rrx namespace="autodoc" src="c:\datacap\RRS\autodoc.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<g>
</g>
<af name="FindFingerprint" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['Attempts to match the current page to a fingerprint and creates a new fingerprint if a match does not occur."]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['Two comma-separated values (the second is optional):<br/>]]>
<![CDATA[
]]>
<![CDATA['	<b>1.</b>A <b>True</b> / <b>False</b> value:<br/> ]]>
<![CDATA[
]]>
<![CDATA['     <b>True</b> if a task is to create a new fingerprint and add it to the fingerprint directory when ]]>
<![CDATA[
]]>
<![CDATA['     a match does not occur; <br/>]]>
<![CDATA[
]]>
<![CDATA['     <b>False</b> if the task is to proceed without creating a new fingerprint.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['	<b>2.</b>Optional:<br/>  The Page Type that is to be assigned to the newly-created fingerprint.  If ]]>
<![CDATA[
]]>
<![CDATA['     omitted, the current Page Type of the current page will be used.</ap>]]>
<![CDATA[
]]>
<![CDATA['	Page level only.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	FindFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Autodoc " & Version)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("FindFingerprint skipping. Image file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam, ",", -1, 1) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (UBound(aStrParam) > 1) Then WriteLog("FindFingerprint: Parameter is invalid.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	strPageType = CurrentObj.Type]]>
<![CDATA[
]]>
<![CDATA[	strFingerprintCreation = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	If (UBound(aStrParam) = 1) Then strPageType = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_bFingerprintCreation = False]]>
<![CDATA[
]]>
<![CDATA[	If (LCase(strFingerprintCreation)="false") Then oFingerprint.m_bFingerprintCreation = False]]>
<![CDATA[
]]>
<![CDATA[	If (LCase(strFingerprintCreation)="true") Then oFingerprint.m_bFingerprintCreation = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- FindFingerprint of: "&CurrentObj.ImageName&" -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim strCCOFile]]>
<![CDATA[
]]>
<![CDATA[	strCCOFile = Left(CurrentObj.ImageName, Len(CurrentObj.ImageName)-3)&"cco"]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(strCCOFile)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("FindFingerprint skipping. CCO file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Dim oCCO]]>
<![CDATA[
]]>
<![CDATA[	Set oCCO = CCOCreator.Load(strCCOFile )]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.UpdateSearchArea]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_bBlackFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.Process oCCO, CurrentObj, oFingerprint.m_ProblemValue, strPageType]]>
<![CDATA[
]]>
<![CDATA[	If oFingerprint.m_bFailRule = True Then]]>
<![CDATA[
]]>
<![CDATA[		FindFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		FindFingerprint = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("FindFingerprint returns " & FindFingerprint) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CreateFingerprint" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[' Creates a fingerprint for the current source page. The resulting fingerprint will]]>
<![CDATA[
]]>
<![CDATA[' consist of two files: the page's Image file (.tif) and its Processing file (.cco)."]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CreateFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("CreateFingerprint skipping. Image file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- CreateFingerprint for: "& CurrentObj.ImageName & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	retn = oFingerprint.AddNewFingerprint(CurrentObj, CurrentObj.Type)]]>
<![CDATA[
]]>
<![CDATA[	If retn = False Then]]>
<![CDATA[
]]>
<![CDATA[		CreateFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		CreateFingerprint = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("CreateFingerprint returns " & CreateFingerprint) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteFingerprint" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  'Deletes the Image file (.tif) and Processing file (.cco) of the current page's fingerprint from ]]>
<![CDATA[
]]>
<![CDATA[  'the application's fingerprint directory, and its record from the Rules database.]]>
<![CDATA[
]]>
<![CDATA[  'A SetFingerprintDir action must precede this action."]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  DeleteFingerprint = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("DeleteFingerprint invalid. This Action should be used on Page level Objects only")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("DeleteFingerprint invalid. Image file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- DeleteFingerprint for: "&CurrentObj.ImageName&" -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	retn = oFingerprint.DeleteFingerprint(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	If retn <> True Then]]>
<![CDATA[
]]>
<![CDATA[		'DeleteFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("DeleteFingerprint failed, returning True")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		'DeleteFingerprint = True]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("DeleteFingerprint Action successful")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFingerprint" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['Sets a newly created fingerprint's Fingerprint Class and Fingerprint Class ID values. "]]>
<![CDATA[
]]>
<![CDATA['    A two-part, comma-separated value consisting of:<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['	  <b>1.</b>The Fingerprint Class value.  Smart parameters are supported.  Alternatively, the name of the Field on this page that specifies the Fingerprint Class.<br/>]]>
<![CDATA[
]]>
<![CDATA['	  <b>2.</b>(optional) The Fingerprint ID value. Smart parameters are supported. Alternatively, the name of the Field on this page that specifies the Fingerprint ID.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'StrParam is a CSV Value:]]>
<![CDATA[
]]>
<![CDATA[	' (0) is the HostNameField]]>
<![CDATA[
]]>
<![CDATA[	' (1) is the optional HostIDField]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam, sHostName, sHostRefID, sTmp]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam, ",", 2, 1) ]]>
<![CDATA[
]]>
<![CDATA[	sHostName = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(aStrParam) = 1 Then sHostRefID = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	sTmp = MetaWord(sHostRefID)]]>
<![CDATA[
]]>
<![CDATA[	If (sTmp = "") Then	'Field Value]]>
<![CDATA[
]]>
<![CDATA[				Set oChild = CurrentObj.FindChild(Right(sHostRefID, Len(sHostRefID)-1))]]>
<![CDATA[
]]>
<![CDATA[				If Not(oChild Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[					sTmp = oChild.Text]]>
<![CDATA[
]]>
<![CDATA[					WriteLog("HostID from field")]]>
<![CDATA[
]]>
<![CDATA[					Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	sHostRefID = sTmp]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sTmp = MetaWord(sHostName)]]>
<![CDATA[
]]>
<![CDATA[	If (sTmp = "") Then	'Field Value]]>
<![CDATA[
]]>
<![CDATA[				Set oChild = CurrentObj.FindChild(Right(sHostName, Len(sHostName)-1))]]>
<![CDATA[
]]>
<![CDATA[				If Not(oChild Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[					WriteLog("Hostname from field")]]>
<![CDATA[
]]>
<![CDATA[					sTmp = oChild.Text]]>
<![CDATA[
]]>
<![CDATA[					Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	sHostName = sTmp]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (sHostName = "" And sHostRefID = "") Then WriteLog("Host Name and Host ID are Empty.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[	sHostName = Replace(sHostName, "'", "''" )]]>
<![CDATA[
]]>
<![CDATA[	sHostRefID = Replace(sHostRefID, "'", "''" )]]>
<![CDATA[
]]>
<![CDATA[	if err.number <> 0 then Writelog("Setfingerprint err " & err.description)]]>
<![CDATA[
]]>
<![CDATA[	err.clear]]>
<![CDATA[
]]>
<![CDATA[	on error goto 0]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprint = oFingerprint.SetFingerprint(sHostName, sHostRefID, CurrentObj) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetProblemValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['Uses the decimal value you supply as a parameter to set a minimum Matching Tolerance Rating."]]>
<![CDATA[
]]>
<![CDATA['A decimal value from 0.00 (Lowest Tolerance) to 0.99 (Highest Tolerance).</ap>]]>
<![CDATA[
]]>
<![CDATA['	<lvl>All, but generally at the Page level.</lvl>]]>
<![CDATA[
]]>
<![CDATA[	Dim slocale]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetProblemValue = False]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'filter and add leading zero]]>
<![CDATA[
]]>
<![CDATA[  strparam=trim(strparam)  ]]>
<![CDATA[
]]>
<![CDATA[	if len(strparam)<=2 then strparam = "0" & strparam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'normalize number]]>
<![CDATA[
]]>
<![CDATA[  slocale = DetermineLocale ' in rrunner]]>
<![CDATA[
]]>
<![CDATA[  StrParam=DCGlobalCurrency.NormalizeNumber(strparam,slocale)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If StrParam = "" Or Not IsNumeric(StrParam) Then WriteLog("SetProblemValue: Parameter isn't a numeric"): Exit Function]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_ProblemValue = Cdbl(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	SetProblemValue = True ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<f name="SetFingerprintSearchArea" access="public">
	<p name="matchStart">
	</p>
	<p name="matchEnd">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Controls the portion of the current page that will be used to find a matching fingerprint."]]>
<![CDATA[
]]>
<![CDATA[  '  Two parameters:<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    <b>1.</b> A decimal value from 0.01 (1%) to 1.00 (all) to indicate how much of the page is to be matched.  If only]]>
<![CDATA[
]]>
<![CDATA['    one parameter is used, the range for fingerprint matching will be 0 to x, where x is the parameter.]]>
<![CDATA[
]]>
<![CDATA['    For example, 0.5 indicates that fingerprint matching will be limited to the first half of the page (0 to 50%).]]>
<![CDATA[
]]>
<![CDATA['    <br/><br/>']]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    <b>2.</b> Optional: A decimal value from 0.01 (1%) to 1.0 (all) to indicate the end point on the page to be]]>
<![CDATA[
]]>
<![CDATA['    used for fingerprint matching.  For example: if the first parameter is 0.6, and the second parameter is 1.0,]]>
<![CDATA[
]]>
<![CDATA['    the last 40% of the page will be used for fingerprint matching (60-100%).<br/>]]>
<![CDATA[
]]>
<![CDATA['    <br/>]]>
<![CDATA[
]]>
<![CDATA['    <b><i>Note.</i></b> In both cases, you can replace a decimal value with a percentage or metric measurement.]]>
<![CDATA[
]]>
<![CDATA['    To indicate the value is a "Percentage" the action can use a number followed by "p" - 50p, for example - to represent 50%.<br/>]]>
<![CDATA[
]]>
<![CDATA['    Alternatively, a value can be expressed in millimeters, if the number is immediately followed by a lower]]>
<![CDATA[
]]>
<![CDATA['    case "m": 20m, for example.<br/>]]>
<![CDATA[
]]>
<![CDATA['    When using the percentage or metric values, the number must be a whole number, ]]>
<![CDATA[
]]>
<![CDATA['    and cannot contain a decimal point.]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' SetSearchArea was replaced by SetFingerprintSearchArea so we could use the "f" tag with unique parameters.]]>
<![CDATA[
]]>
<![CDATA[  Dim strTop]]>
<![CDATA[
]]>
<![CDATA[  Dim strBottom]]>
<![CDATA[
]]>
<![CDATA[  Dim slocale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprintSearchArea = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  matchStart = Trim(matchStart)]]>
<![CDATA[
]]>
<![CDATA[  matchEnd = Trim(matchEnd)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If ( Len(matchStart) = 0 ) Then ]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("SetFingerprintSearchArea: Parameter matchStart must be specified."):]]>
<![CDATA[
]]>
<![CDATA[    Exit Function		]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	if (Len(matchEnd) = 0) then]]>
<![CDATA[
]]>
<![CDATA[    ' Only one parameter was passed in.  Use it as the amount to match starting from the top.]]>
<![CDATA[
]]>
<![CDATA[    strTop = 0]]>
<![CDATA[
]]>
<![CDATA[    strBottom = matchStart]]>
<![CDATA[
]]>
<![CDATA[  else]]>
<![CDATA[
]]>
<![CDATA[    ' Two parameters were passed.  Use them as start and end.]]>
<![CDATA[
]]>
<![CDATA[    strTop = matchStart ]]>
<![CDATA[
]]>
<![CDATA[    strBottom = matchEnd  ]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'look for percentage or millimeter flags]]>
<![CDATA[
]]>
<![CDATA[  strTop=CStr(SetFingerprintSearchArea_utility(strTop))]]>
<![CDATA[
]]>
<![CDATA[  strBottom=CStr(SetFingerprintSearchArea_utility(strBottom))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'normalize number - pass as string]]>
<![CDATA[
]]>
<![CDATA[  slocale = DetermineLocale ' in rrunner]]>
<![CDATA[
]]>
<![CDATA[  strTop=DCGlobalCurrency.NormalizeNumber(strTop,slocale)]]>
<![CDATA[
]]>
<![CDATA[  strBottom=DCGlobalCurrency.NormalizeNumber(strBottom,slocale)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Convert string to double]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_SearchAreaTop = Cdbl(strTop)]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_SearchAreaBottom = Cdbl(strBottom)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("SetFingerprintSearchArea: Top: '" & cstr(oFingerprint.m_SearchAreaTop) & "' Bottom: '" & cstr(oFingerprint.m_SearchAreaBottom) & "'.")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	m_SearchArea = 1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprintSearchArea = True ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<af name="SetSearchArea" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[ ' This action has been replaced by SetFingerprintSearchArea."]]>
<![CDATA[
]]>
<![CDATA[ '    Two comma-separated parameters.  See SetFingerprintSearchArea for details.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[  Dim result]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  SetSearchArea = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam, ",", -1, 1) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (UBound(aStrParam) > 1) Then WriteLog("SetSearchArea: Parameter is invalid.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	strTop = 0]]>
<![CDATA[
]]>
<![CDATA[	strBottom = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	If (UBound(aStrParam) = 1) Then strTop = Trim(aStrParam(0)) : strBottom = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Call the function that has replaced SetSearchArea]]>
<![CDATA[
]]>
<![CDATA[  SetSearchArea = SetFingerprintSearchArea(strTop, strBottom)    ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFingerprintDir" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[' Sets the Fingerprint directory of your application."]]>
<![CDATA[
]]>
<![CDATA['    A String value specifying the directory's name and its path.  Smart parameters are supported.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters(1)]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter(1) parsing. Using original parameter '" & StrParam & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Right(StrParam,1) <> "\" Then StrParam = StrParam & "\"]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.SetFingerprintDir StrParam]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprintDir = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindBlackFingerprint" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[' Attempts to match black forms to fingerprints in the fingerprints directory of an application.]]>
<![CDATA[
]]>
<![CDATA[' If a match does not occur, the action will respond according to the parameter(s) you enter."]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['      Two comma-separated values (the second is optional)<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['      <b>1. True or False.</b><br/>]]>
<![CDATA[
]]>
<![CDATA['         <b>True</b> If a fingerprint match is not found, a new fingerprint is created and the two fingerprint files ]]>
<![CDATA[
]]>
<![CDATA['         (.tif and .cco) are placed in the fingerprint directory.<br/>]]>
<![CDATA[
]]>
<![CDATA['         <b>False</b> if the task is to proceed without creating a new fingerprint.<br/>]]>
<![CDATA[
]]>
<![CDATA['         <br/>    ]]>
<![CDATA[
]]>
<![CDATA['      <b>2. Optional.</b> <br/>]]>
<![CDATA[
]]>
<![CDATA['         The Page Type that is to be assigned to the newly created fingerprint if the first parameter ]]>
<![CDATA[
]]>
<![CDATA['         is <b>True.</b>  If you do not include this parameter, the action will assign the Page ]]>
<![CDATA[
]]>
<![CDATA['         Type of the current page.]]>
<![CDATA[
]]>
<![CDATA['    </ap>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	FindBlackFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("FindBlackFingerprint skipping. " & CurrentObj.ImageName & " doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam, ",", -1, 1) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (UBound(aStrParam) > 1) Then WriteLog("FindFingerprint: Parameter is invalid.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	strPageType = CurrentObj.Type]]>
<![CDATA[
]]>
<![CDATA[	strFingerprintCreation = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	If (UBound(aStrParam) = 1) Then strPageType = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_bFingerprintCreation = False]]>
<![CDATA[
]]>
<![CDATA[	If (LCase(strFingerprintCreation)="false") Then oFingerprint.m_bFingerprintCreation = False]]>
<![CDATA[
]]>
<![CDATA[	If (LCase(strFingerprintCreation)="true") Then oFingerprint.m_bFingerprintCreation = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- FindBlackFingerprint of: "&CurrentObj.ImageName&" -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim strCCOFile]]>
<![CDATA[
]]>
<![CDATA[	strCCOFile = Left(CurrentObj.ImageName, Len(CurrentObj.ImageName)-3)&"cco"]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(strCCOFile)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("FindBlackFingerprint skipping. CCO file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Dim oCCO]]>
<![CDATA[
]]>
<![CDATA[	Set oCCO = CCOCreator.Load(strCCOFile )]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.UpdateSearchArea]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_bBlackFingerprint = True]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.Process oCCO, CurrentObj, oFingerprint.m_ProblemValue, strPageType]]>
<![CDATA[
]]>
<![CDATA[	If oFingerprint.m_bFailRule = True Then]]>
<![CDATA[
]]>
<![CDATA[		FindBlackFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		FindBlackFingerprint = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("FindBlackFingerprint returns " & FindBlackFingerprint) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFilter_PageType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['Sets the Page Type filter for the identification (matching) algorithm.  The filter will force the]]>
<![CDATA[
]]>
<![CDATA[' fingerprint-matching algorithm to use only fingerprints associated with that Page Type.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['The String value of the Page Type you want to use as the filter.</ap>]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetFilter_PageType = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters(1)]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[     StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[     Writelog("No result from Smart Parameter parsing. Using original parameter.") 	]]>
<![CDATA[
]]>
<![CDATA[  End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- SetFilter_PageType: " & StrParam & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.SetFilterID(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	SetFilter_PageType = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFilter_HostName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['Sets the Fingerprint Class filter for the identification (matching) algorithm.  The filter will force ]]>
<![CDATA[
]]>
<![CDATA['the fingerprint-matching algorithm to use only fingerprints associated with the specified Fingerprint Class."]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['The String value of the Fingerprint Class you want to use as the filter.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetFilter_HostName = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters(1)]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[     StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[     Writelog("No result from Smart Parameter parsing. Using original parameter.") 	]]>
<![CDATA[
]]>
<![CDATA[  End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- SetFilter_HostName: " & StrParam & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.SetFilterHostName(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	SetFilter_HostName = True ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetMaxOffset" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[' Sets the Maximum Offset value while matching source pages to fingerprints. The actual shift is four times the maximum offset value in pixels (4 * MaxOffset)."]]>
<![CDATA[
]]>
<![CDATA[' Integer value between 1 and 255.</ap>]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetMaxOffset = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	If (oFingerprint.m_bCCO_WS) then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Note: SetMaxOffset is not implemented in Fingerprint Service, ignored")]]>
<![CDATA[
]]>
<![CDATA[	  SetMaxOffset = True ]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If ( Not IsNumeric(StrParam) ) Then WriteLog("MaxOffset: Parameter must be integer between 1 and 255.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[	MaxOffset = CInt(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If ( MaxOffset < 1 Or MaxOffset > 255 ) Then WriteLog("MaxOffset: Parameter must be integer between 1 and 255.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_oCCOFingerprints.MaxShift = MaxOffset]]>
<![CDATA[
]]>
<![CDATA[	SetMaxOffset = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetTemplateDir" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'qi="Sets the Template directory of your application. This directory contains the application's fingerprint templates."]]>
<![CDATA[
]]>
<![CDATA[    '  <i>String</i> value specifying the directory's name and path. <br/><br/>]]>
<![CDATA[
]]>
<![CDATA[    '  <b>Note:</b>A Drive ID (such as c:\) is optional. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters(1)]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[     StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[     Writelog("No result from Smart Parameter parsing. Using original parameter.") 	]]>
<![CDATA[
]]>
<![CDATA[  End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetTemplateDir = SetFingerprintDir(bInter, bDeBug, StrParam) ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFingerprintWebServiceURL" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['"Provides the Uniform Resource Locator (URL) that is a link to a pre-established Fingerprint Service."<ap>]]>
<![CDATA[
]]>
<![CDATA[' <i>String</i> value specifying the URL that is the link to the Fingerprint Web Service.  Accepts a Smart Parameter.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprintWebServiceURL = False]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  End if	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	Set oFingerprint.m_oCCO_WSClient = CreateObject("CCO_WSClient.Interface")]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_oCCO_WSClient.SetURL StrParam]]>
<![CDATA[
]]>
<![CDATA[  if Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Cannot connect to Fingerprint Web Service " + StrParam)]]>
<![CDATA[
]]>
<![CDATA[    Set oFingerprint.m_oCCO_WSClient = nothing]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	if (Pilot.GetProfileString("Fingerprints","UseAppID","0",Pilot.ProjectPath) = "1" or DCO.Variable("FPAPPID") = "1")  then]]>
<![CDATA[
]]>
<![CDATA[		On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		oFingerprint.m_oCCO_WSClient.SetApplicationID(oFingerprint.m_AppID)]]>
<![CDATA[
]]>
<![CDATA[		Err.Clear]]>
<![CDATA[
]]>
<![CDATA[		On Error Goto 0]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_bCCO_WS = True]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_oCCO_WSClient.SetFilterID(-1)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprintWebServiceURL = True	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindTemplate" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['Finds the fingerprint that a preceding FindFingerprint action matched to the current source page, or created instead."]]>
<![CDATA[
]]>
<![CDATA['  <i>String</i> boolean value:<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['  <b>True</b> if the action is to create a new fingerprint if the current <b>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	FindTemplate = FindFingerprint(bInter, bDeBug, StrParam) ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CalculateOffset" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['"Sets the standard Offset value to be used when matching source pages to fingerprints."]]>
<![CDATA[
]]>
<![CDATA[' Integer value between 1 and 255.</i>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CalculateOffset = False]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then WriteLog("CalculateOffset: this action works on a page level only.") : Exit Function 'must be a page]]>
<![CDATA[
]]>
<![CDATA[	CalculateOffset = oFingerprint.CalculateOffset(CurrentObj)]]>
<![CDATA[
]]>
	</g>
</af>
<af name="MergeCCOs_ByType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[' "Merges the Fingerprint files (.cco) associated with Page objects of the Document Hierarchy."]]>
<![CDATA[
]]>
<![CDATA['  Comma-separated String values indicating the Page Types of the Document Hierarchy objects to be merged.</ap>]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	Dim sMultFile]]>
<![CDATA[
]]>
<![CDATA[	Dim nDCOchildren, i, j]]>
<![CDATA[
]]>
<![CDATA[	Dim oChild, nCount]]>
<![CDATA[
]]>
<![CDATA[	Dim oPrimaryPg]]>
<![CDATA[
]]>
<![CDATA[	Dim sPPD]]>
<![CDATA[
]]>
<![CDATA[	Dim sFileExtn]]>
<![CDATA[
]]>
<![CDATA[	Dim sFilePath]]>
<![CDATA[
]]>
<![CDATA[	Dim sFileName]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim pCounter]]>
<![CDATA[
]]>
<![CDATA[	Dim bRes]]>
<![CDATA[
]]>
<![CDATA[	Dim dcImageTemp,Wx,Hx,Bx]]>
<![CDATA[
]]>
<![CDATA[	Dim nCounter ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	Set dcImageTemp = CreateObject("DCIMAGE.DCImageCtrl.1")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'This Action should run from the DCO Page to which all additional pages are to be appended.]]>
<![CDATA[
]]>
<![CDATA[	'Will use first page of specified type as root page if called from document object.]]>
<![CDATA[
]]>
<![CDATA[	'Appended Page will be first page of a valid Type in document by default. ]]>
<![CDATA[
]]>
<![CDATA[	'StrParam is a CSV of all the valid PageTypes to Append.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    MergeCCOs_ByType = False]]>
<![CDATA[
]]>
<![CDATA[    sMultFile=""]]>
<![CDATA[
]]>
<![CDATA[	nCounter=CInt(0)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Find Parent Document     ]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = Currentobj]]>
<![CDATA[
]]>
<![CDATA[	If oParent.ObjectType>1 Then ]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    For i = 1 To oParent.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[        Set oChild = CurrentObj.GetChild(i - 1)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If Not(oChild Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[			If oChild.ObjectType = 2 And InStr(Ucase(StrParam),Ucase(oChild.Type))>0 Then]]>
<![CDATA[
]]>
<![CDATA[				WriteLog ("Processing '" & oChild.ID & "' ")]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[				'Create MultiCCO file]]>
<![CDATA[
]]>
<![CDATA[                If sMultFile = "" Then]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[                    sOrigFile = oChild.ImageName]]>
<![CDATA[
]]>
<![CDATA[                    sFileExtn = Ucase(FileMgr.GetExtensionName(sOrigFile))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[                    If (sFileExtn = "TIF" Or sFileExtn = "TIFF") And FileMgr.FileExists(sOrigFile) Then]]>
<![CDATA[
]]>
<![CDATA[                    	'Log the image height]]>
<![CDATA[
]]>
<![CDATA[                    	sFilePath = FileMgr.GetParentFolderName(sOrigFile)]]>
<![CDATA[
]]>
<![CDATA[						dcImageTemp.FileName = sOrigfile]]>
<![CDATA[
]]>
<![CDATA[						Call dcImageTemp.GetImageInfo(Wx,Hx,Bx)]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Image " & sOrigFile & " Height:" & Hx)]]>
<![CDATA[
]]>
<![CDATA[						dcImageTemp.FileName = ""]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						'Set CCO filename to 1st Page ID											]]>
<![CDATA[
]]>
<![CDATA[						sMultFile = Left(sOrigFile,Len(sOrigFile)-Len(sFileExtn)) & "CCO"]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						If Not FileMgr.FileExists(sMultFile) Then		]]>
<![CDATA[
]]>
<![CDATA[							WriteLog("----- Analysis of: " & sOrigFile & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							Set oCCO = CCOCreator.Analyze(sOrigFile)]]>
<![CDATA[
]]>
<![CDATA[							bSaved = oCCO.Save(sMultFile)]]>
<![CDATA[
]]>
<![CDATA[							If bSaved=False Then ]]>
<![CDATA[
]]>
<![CDATA[								Writelog("ERROR saving File. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[								Exit Function]]>
<![CDATA[
]]>
<![CDATA[							End If]]>
<![CDATA[
]]>
<![CDATA[							Set oCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						'Setup Primary Page Ref]]>
<![CDATA[
]]>
<![CDATA[						Set oPrimaryPg = oChild]]>
<![CDATA[
]]>
<![CDATA[						pCounter = 1]]>
<![CDATA[
]]>
<![CDATA[						oPrimaryPg.Variable("CCOBlock")=Trim(sMultFile)		]]>
<![CDATA[
]]>
<![CDATA[						oPrimaryPg.Variable(Trim(FileMgr.GetFileName(sMultFile)) & "_" & CStr(pCounter))=FileMgr.GetFileName(oChild.ImageName)]]>
<![CDATA[
]]>
<![CDATA[						oPrimaryPg.Variable(Ucase(FileMgr.GetFileName(oChild.ImageName)))=nCounter]]>
<![CDATA[
]]>
<![CDATA[						nCounter=CInt(Hx)]]>
<![CDATA[
]]>
<![CDATA[																			]]>
<![CDATA[
]]>
<![CDATA[						WriteLog ("MultiPage CCO file name : '" & sMultFile & "' ")]]>
<![CDATA[
]]>
<![CDATA[												]]>
<![CDATA[
]]>
<![CDATA[                    Else]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Unexpected File Name Extension: '" & sFileExtn & "' ")]]>
<![CDATA[
]]>
<![CDATA[                    End If]]>
<![CDATA[
]]>
<![CDATA[                    ]]>
<![CDATA[
]]>
<![CDATA[                Else]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[					sAppendFile = oChild.ImageName]]>
<![CDATA[
]]>
<![CDATA[         			sExt = Ucase(FileMgr.GetExtensionName(sAppendFile))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[                    If (sExt = "TIF" Or sExt = "TIFF") Then]]>
<![CDATA[
]]>
<![CDATA[                    	'Log the image height					]]>
<![CDATA[
]]>
<![CDATA[                    	dcImageTemp.FileName = sAppendFile]]>
<![CDATA[
]]>
<![CDATA[						Call dcImageTemp.GetImageInfo(Wx,Hx,Bx)]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Image " & sAppendFile & " Height:" & Hx)]]>
<![CDATA[
]]>
<![CDATA[						dcImageTemp.FileName = ""					]]>
<![CDATA[
]]>
<![CDATA[                    						                    						]]>
<![CDATA[
]]>
<![CDATA[						sAppendCCO = Left(sAppendFile,Len(sAppendFile)-Len(sExt)) & "CCO"]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						If Not FileMgr.FileExists(sAppendCCO) Then		]]>
<![CDATA[
]]>
<![CDATA[							WriteLog("----- Analysis of: " & sAppendFile & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							Set oCCO = CCOCreator.Analyze(sAppendFile)]]>
<![CDATA[
]]>
<![CDATA[							bSaved = oCCO.Save(sAppendCCO)]]>
<![CDATA[
]]>
<![CDATA[							If bSaved=False Then ]]>
<![CDATA[
]]>
<![CDATA[								Writelog("ERROR saving File. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[								Exit Function]]>
<![CDATA[
]]>
<![CDATA[							End If]]>
<![CDATA[
]]>
<![CDATA[							Set oCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						bRes=CCOCreator.Merge(sMultFile, sAppendCCO)]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Merging CCO : '" & sAppendCCO & "' to the end of '" & sMultFile & "' returns " & bRes)]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						If bRes = False Then ]]>
<![CDATA[
]]>
<![CDATA[							If Not FileMgr.FileExists(sMultFile) Then Writelog("File Not Found:" & sMultFile)]]>
<![CDATA[
]]>
<![CDATA[							If Not FileMgr.FileExists(sAppendCCO) Then Writelog("File Not Found:" & sAppendCCO)]]>
<![CDATA[
]]>
<![CDATA[							Exit Function]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							pCounter = pCounter + 1		]]>
<![CDATA[
]]>
<![CDATA[							oPrimaryPg.Variable(Trim(FileMgr.GetFileName(sMultFile)) & "_" & CStr(pCounter))=FileMgr.GetFileName(oChild.ImageName)	]]>
<![CDATA[
]]>
<![CDATA[							oPrimaryPg.Variable(Ucase(FileMgr.GetFileName(oChild.ImageName)))=nCounter]]>
<![CDATA[
]]>
<![CDATA[							nCounter = nCounter + CInt(Hx)		]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[									]]>
<![CDATA[
]]>
<![CDATA[                        'oChild.Type = "Attachment"]]>
<![CDATA[
]]>
<![CDATA[                    Else]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Unexpected File Name Extension: '" & sExt & "' ")    ]]>
<![CDATA[
]]>
<![CDATA[                    End If]]>
<![CDATA[
]]>
<![CDATA[                End If]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[     Next 'i]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[     Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[     Set oPrimaryPg = Nothing]]>
<![CDATA[
]]>
<![CDATA[     Set dcImageTemp = Nothing]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[	If Not Err Then MergeCCOs_ByType = True ]]>
<![CDATA[
]]>
	</g>
</af>
<f name="MergeLayoutByType" access="public">
	<p name="PageTypesToMerge">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ' This action requires that a document structure exists.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  MergeLayoutByType = false]]>
<![CDATA[
]]>
<![CDATA[  PageTypesToMerge = MetaWord(PageTypesToMerge)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if IsAlive(g_DLayout) Then ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Creating VPB") 	]]>
<![CDATA[
]]>
<![CDATA[     g_DLayout.DatacapRRCurrentDCO = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[     MergeLayoutByType = g_DLayout.MergeLayout(PageTypesToMerge, Pilot.BatchDir)]]>
<![CDATA[
]]>
<![CDATA[  Else   ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Error: Cannot merge. The layout object was not loaded. Returning false.") 	]]>
<![CDATA[
]]>
<![CDATA[  End If  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function MergeLayoutByType")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<af name="BlankPagesIDBySize" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    "Uses the Image file's size to determine if the file represents a 'blank' page."]]>
<![CDATA[
]]>
<![CDATA['    A three-part, comma-separated value consisting of:<br/>]]>
<![CDATA[
]]>
<![CDATA['    <b>1.</b> Numeric value indicating the maximum size in bytes that qualifies a page as a blank page.<br/>]]>
<![CDATA[
]]>
<![CDATA['    <b>2.</b> String value representing the Page Type of a blank page.<br/>]]>
<![CDATA[
]]>
<![CDATA['    <b>3.</b>Numeric value (0, 1 or 2) to designate which pages in a multi-page Image file are to be evaluated.<br/>]]>
<![CDATA[
]]>
<![CDATA['    <br/>]]>
<![CDATA[
]]>
<![CDATA['    The third parameter is optional.<br/>]]>
<![CDATA[
]]>
<![CDATA['    0 = both sides of a two-page Image file.<br/>]]>
<![CDATA[
]]>
<![CDATA['    1 = odd pages only.<br/>]]>
<![CDATA[
]]>
<![CDATA['    2 = even images only.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim iMinSize]]>
<![CDATA[
]]>
<![CDATA[	Dim sPageType]]>
<![CDATA[
]]>
<![CDATA[	Dim iSide]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	BlankPagesIDBySize = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & ",,",",")]]>
<![CDATA[
]]>
<![CDATA[	iMinSize = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	sPageType = CStr(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	iSide = Trim(aStrParam(2))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If IsNumeric(iMinSize) Then ]]>
<![CDATA[
]]>
<![CDATA[		iMinSize = CLng(iMinSize)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Minimum size paramater must be numeric.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If		]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Len(sPageType)=0 Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("sPageType paramater must contain a value.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Len(iSide)=0 Then ]]>
<![CDATA[
]]>
<![CDATA[		iSide = CInt(0)]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If IsNumeric(iSide) Then ]]>
<![CDATA[
]]>
<![CDATA[		iSide = CInt(iSide)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("iSide paramater must be numeric {0,1,2} or blank.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	BlankPagesIDBySize = BlankPageID(CurrentObj, iMinsize, sPageType, iSide)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetApplicationID" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   String parameter that represents unique Application ID.  Smart parameters are supported.<br/>]]>
<![CDATA[
]]>
<![CDATA[ '   This value used to retrieve correct list of fingerprints loaded to the server.<br/>]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters(1)]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter(1) parsing. Using original parameter '" & StrParam & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (oFingerprint.m_bCCO_WS) Then]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_AppID = StrParam]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	oFingerprint.m_oCCO_WSClient.SetApplicationID(oFingerprint.m_AppID)]]>
<![CDATA[
]]>
<![CDATA[	Err.Clear]]>
<![CDATA[
]]>
<![CDATA[	On Error Goto 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[	SetApplicationID = false]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFingerprintFailureThreshold" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Int parameter that represents percent threshold of fingerprint upload failures to ignore.  Smart parameters are supported.<br/>]]>
<![CDATA[
]]>
<![CDATA[  '  The batch aborts if the percentage of fingerprints that are failed to load exceeds this value.<br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  Dim m_nThreshold]]>
<![CDATA[
]]>
<![CDATA[  SetFingerprintFailureThreshold = true]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters(1)]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[     StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[     Writelog("No result from Smart Parameter(1) parsing. Using original parameter '" & StrParam & "'") 	]]>
<![CDATA[
]]>
<![CDATA[  End if	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If ((Cint(StrParam)<0) OR (Cint(StrParam)>100)) Then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Error. Value has to be between values 0 and 100 original parameter value:'" & StrParam & "' . Aborting batch") ]]>
<![CDATA[
]]>
<![CDATA[     nTaskStatus=retAbort     ]]>
<![CDATA[
]]>
<![CDATA[     SetFingerprintFailureThreshold = false]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If InitAutoDocGlobalObjects=False then Exit Function      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (oFingerprint.m_bCCO_WS) Then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    m_nThreshold  = CInt(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    DIM xml]]>
<![CDATA[
]]>
<![CDATA[    Dim oXmlDoc, oNodeList, name]]>
<![CDATA[
]]>
<![CDATA[    Dim oLoaded, oFailed]]>
<![CDATA[
]]>
<![CDATA[    Dim Loaded, Failed]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    xml = oFingerprint.m_oCCO_WSClient.GetFingerprintStatistics]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Set oXmlDoc = CreateObject("Msxml2.DOMDocument")]]>
<![CDATA[
]]>
<![CDATA[    oXmlDoc.loadXML(xml)                               ]]>
<![CDATA[
]]>
<![CDATA[    Set oNodeList = oXmlDoc.getElementsByTagName("application")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[    If oNodeList.length > 0 then]]>
<![CDATA[
]]>
<![CDATA[      For each x in oNodeList]]>
<![CDATA[
]]>
<![CDATA[        name=x.getAttribute("name")]]>
<![CDATA[
]]>
<![CDATA[        if (name=oFingerprint.m_AppID)Then]]>
<![CDATA[
]]>
<![CDATA[          'WriteLog("FPSvc node " & x.xml)]]>
<![CDATA[
]]>
<![CDATA[					set oLoaded = x.selectSingleNode("./fploaded")]]>
<![CDATA[
]]>
<![CDATA[          set oFailed = x.selectSingleNode("./fpfailed")]]>
<![CDATA[
]]>
<![CDATA[          Loaded = CInt(oLoaded.text)]]>
<![CDATA[
]]>
<![CDATA[          Failed = CInt(oFailed.text)		]]>
<![CDATA[
]]>
<![CDATA[          'WriteLog("Loaded: " & oLoaded.text)			]]>
<![CDATA[
]]>
<![CDATA[          'WriteLog("Failed: " & oFailed.text)		]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[      Next]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog ("No fingerprints selected to load. Application:'"&oFingerprint.m_AppID&"'")]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[    if((Loaded+Failed)>0) Then]]>
<![CDATA[
]]>
<![CDATA[      if (Loaded<1) Then]]>
<![CDATA[
]]>
<![CDATA[        nTaskStatus=retAbort]]>
<![CDATA[
]]>
<![CDATA[        SetFingerprintFailureThreshold = false	]]>
<![CDATA[
]]>
<![CDATA[        Writelog ("Aborting the batch. None of the fingerprints loaded successfully. Failed to load: '"&Failed&"' fingerprints. Application:'"&oFingerprint.m_AppID&"'")]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        Dim percent]]>
<![CDATA[
]]>
<![CDATA[        percent = (Failed*100/(Loaded+Failed))]]>
<![CDATA[
]]>
<![CDATA[        If (percent>m_nThreshold) Then]]>
<![CDATA[
]]>
<![CDATA[          nTaskStatus=retAbort]]>
<![CDATA[
]]>
<![CDATA[          SetFingerprintFailureThreshold = false	                                ]]>
<![CDATA[
]]>
<![CDATA[          Writelog ("Aborting the batch. Threshold is set to:'" & m_nThreshold &"%' and '"&percent&"%' of fingerprints failed to load. Application:'"&oFingerprint.m_AppID&"'")]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog ("Using fingerprint service, but no Fingerprints are loaded or failed. Application:'"&oFingerprint.m_AppID&"'")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ Else]]>
<![CDATA[
]]>
<![CDATA[   Writelog ("Fingerprints service is not used. Input value ignored. Application:'"&oFingerprint.m_AppID&"'")]]>
<![CDATA[
]]>
<![CDATA[   SetFingerprintFailureThreshold = false]]>
<![CDATA[
]]>
<![CDATA[ End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="UpdateFingerprintStats" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim oCmd]]>
<![CDATA[
]]>
<![CDATA[	Dim oParam1]]>
<![CDATA[
]]>
<![CDATA[	Dim oParam2]]>
<![CDATA[
]]>
<![CDATA[	Dim DateHit]]>
<![CDATA[
]]>
<![CDATA[	Dim oRS]]>
<![CDATA[
]]>
<![CDATA[  Dim sParam]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	UpdateFingerprintStats = false]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	 If InitAutoDocGlobalObjects=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  if Not(IsObject(oFingerprint.m_oAdoCnn)) then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Connection to the fingerprint database was not created.")]]>
<![CDATA[
]]>
<![CDATA[      		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	if oFingerprint.m_oAdoCnn.State = 0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Connection to the fingerprint database was not found.")]]>
<![CDATA[
]]>
<![CDATA[      		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	if CurrentObj.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("This action was designed to operate on a page level object only.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCmd = CreateObject("ADODB.Command")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	sSQL = "UPDATE Template SET tp_HitCount = tp_HitCOunt + 1, tp_LastHit = ? WHERE tp_TemplateID = ?"]]>
<![CDATA[
]]>
<![CDATA[	oCmd.CommandText = sSQL]]>
<![CDATA[
]]>
<![CDATA[	oCmd.CommandType = 1]]>
<![CDATA[
]]>
<![CDATA[	oCmd.ActiveConnection = oFingerprint.m_oAdoCnn]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Connection set")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("TemplateID = " & CurrentObj.Variable("TemplateID"))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (IsDBOracle(oFingerprint.m_oAdoCnn) or DCO.Variable("OracleFP") = "1")  then]]>
<![CDATA[
]]>
<![CDATA[      'ORACLE VERSION:]]>
<![CDATA[
]]>
<![CDATA[      FormattedDateStamp = Year(Now) & "/" & Right("00" & Month(Now),2) & "/" & Right("00" & Day(Now),2)  ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Oracle datestamp: " & FormattedDateStamp)]]>
<![CDATA[
]]>
<![CDATA[      sParam = "to_date('" & FormattedDateStamp & "','YYYY/MM/DD')"]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Oracle date param: " & "to_date('" & FormattedDateStamp & "','YYYY/MM/DD')")]]>
<![CDATA[
]]>
<![CDATA[      oCmd.CommandText = "UPDATE Template SET tp_HitCount=tp_HitCount+1, tp_LastHit=" & sParam & " WHERE tp_TemplateID=" & CurrentObj.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	else	]]>
<![CDATA[
]]>
<![CDATA[	    Set oParam1 = oCmd.CreateParameter("P1",200,1,50)]]>
<![CDATA[
]]>
<![CDATA[	    Set oParam2 = oCmd.CreateParameter("P1",200,1,50)]]>
<![CDATA[
]]>
<![CDATA[	    oCmd.Parameters.Append oParam1]]>
<![CDATA[
]]>
<![CDATA[	    oCmd.Parameters.Append oParam2]]>
<![CDATA[
]]>
<![CDATA[	    Writelog("Parameters set")]]>
<![CDATA[
]]>
<![CDATA[      if (IsDBSQL(oFingerprint.m_oAdoCnn) or IsDBDB2(oFingerprint.m_oAdoCnn)) then]]>
<![CDATA[
]]>
<![CDATA[        'SQL Server VERSION:	]]>
<![CDATA[
]]>
<![CDATA[        FormattedDateStamp = Year(Now) & "-" & Right("00" & Month(Now),2) & "-" & Right("00" & Day(Now),2) & " " & "00:00:00" ' yyyy-MM-ddTHH:mm:ss]]>
<![CDATA[
]]>
<![CDATA[        oCmd(0).Value = FormattedDateStamp]]>
<![CDATA[
]]>
<![CDATA[			 ' Writelog("MSSQL & DB2 datestamp: " & FormattedDateStamp)]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[        'Access VERSION:	]]>
<![CDATA[
]]>
<![CDATA[        FormattedDateStamp = Date()]]>
<![CDATA[
]]>
<![CDATA[        oCmd(0).Value = FormattedDateStamp]]>
<![CDATA[
]]>
<![CDATA[	      ' WAS: oCmd(0).Value = Date() ' will not work for Oracle]]>
<![CDATA[
]]>
<![CDATA[			  'Writelog("Access datestamp: " & FormattedDateStamp)]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[	  oCmd(1).Value = CurrentObj.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	  if oCmd(1).Value = "" then]]>
<![CDATA[
]]>
<![CDATA[		  Writelog("No TemplateID found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[		  Exit Function]]>
<![CDATA[
]]>
<![CDATA[	  End if]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ WriteLog(oCmd.CommandText)]]>
<![CDATA[
]]>
<![CDATA[	oRS = oCmd.Execute]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCmd = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oParam1 = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oParam2 = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oRS = Nothing]]>
<![CDATA[
]]>
<![CDATA[	UpdateFingerprintStats = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<help>

 <![CDATA[
'************************************************************************
' AutoDoc.rrx - AutoDoc Actions
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2016 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'------------------------------------------------------------------------
'
]]>

<ref id="FindFingerprint" access="public" qi="Attempts to match the current page to a fingerprint and creates a new fingerprint if a match does not occur.">
	<ap>Two comma-separated values (the second is optional):<br/>
	<b>1.</b>A <b>True</b> / <b>False</b> value:<br/> 
     <b>True</b> if a task is to create a new fingerprint and add it to the fingerprint directory when 
     a match does not occur; <br/>
     <b>False</b> if the task is to proceed without creating a new fingerprint.<br/><br/>
	<b>2.</b>Optional:<br/>  The Page Type that is to be assigned to the newly-created fingerprint.  If 
     omitted, the current Page Type of the current page will be used.</ap>
	<lvl>Page level only.</lvl>
  
	<h>This action attempts to match the current
    <b><i>source</i></b>page to a fingerprint, and creates a new fingerprint if a match does not occur.<br/><br/>
    Include this action after a rule's SetSearchArea, SetProblemValue and SetFingerprintDir actions.
		<e><scr>AnalyzeImage()</scr><br/>
		<scr>RotateImage()</scr><br/>
		<scr>RecognizePageOCR_S()</scr><br/>
		<scr>SetSearchArea("0.5")</scr><br/>
		<scr>SetProblemValue("0.7")</scr><br/>
		<scr>SetFingerprintDir("\ParentDirectory\Application\Fingerprint")</scr><br/> 
		<scr>
      <b>FindFingerprint("True,Invoice_Page")</b></scr><br/><br/>

		In this sequence, the FindFingerprint action will only use the top 50% of the current page to 
    search for a match.  However, it will accept a match of 0.7 or higher.  If no match is found, 
    the sequence will create a new fingerprint and store it in the location specified by the 
    <scr>SetFingerprintDir</scr> action.  If the parameter has been set to False, a new fingerprint 
    will not be created in case there is no match.
		</e>
	</h>
  <ret>
    <b>False</b> if the action is not applied at the Page level, or if the parameter is False and a
    fingerprint match does not occur. Otherwise, True.  If a new Fingerprint cannot be added, the
    action still returns <b>True.</b>
  </ret>
</ref>

<ref id="CreateFingerprint" access="public" qi="Creates a fingerprint for the current source page. The resulting fingerprint will consist of two files: the page's Image file (.tif) and its Processing file (.cco).">
	<ap>None.</ap>
	<lvl>Page level only.</lvl>
	<ret>
    <b>False</b> if the rule with this action is not bound to a Page object of the Document Hierarchy; 
    if the current page does not have an Image file; or if the fingerprint's two files cannot be created.  
    Otherwise, <b>True.</b>
  </ret>
	<h>Creates a fingerprint for the current source page.<br/><br/>
		
	The resulting fingerprint will consist of two files: the page's Image file (.tif) and its Processing file (.cco).<br/><br/>
		
	<b>Alert!</b> A <scr>SetFingerprintDir</scr> action must precede this action.
		<e>
      <scr>SetFingerprintDir("C:\ParentDirectory\Application\fingerprint")</scr><br/>
      <b>CreateFingerprint()</b>
		</e>
	</h>
	<see><scr>SetFingerprintDir</scr>, <scr>DeleteFingerprint</scr></see>
</ref>

<ref id="DeleteFingerprint" access="public" qi="Deletes the Image file (.tif) and Processing file (.cco) of the current page's fingerprint from the application's fingerprint directory, and its record from the Fingerprint database. A SetFingerprintDir action must precede this action.">
	<ap>None.</ap>
	<lvl>Page level only.</lvl>
	<ret>
    Always returns <b>True.</b> Under certain conditions the action will be unable to delete the fingerprint
    but will still return True. For example if the action is not applied at the Page level or if the 
    fingerprint's Image file cannot be found. Please review the log file if DeleteFingerprint does not perform as expected.
  </ret>
	<h>
    Deletes the Image file (.tif) And Processing file (.cco) of the current page's fingerprint from the 
    application's fingerprint directory, and its record from the Fingerprint database.<br/><br/>
	
	<b>Alert!</b> A <scr>SetFingerprintDir</scr> action must precede this action.
		<e>
      <scr>SetFingerprintDir("C:\ParentDirectory\Application\fingerprint")</scr><br/>
      <b>DeleteFingerprint()</b> 
		</e>
	</h>
	<see><scr>SetFingerprintDir, CreateFingerprint</scr></see>
</ref>

<ref id="SetFingerprint" access="public" qi="Sets a newly created fingerprint's Fingerprint Class and Fingerprint Class ID values. ">
	<ap>
    A two-part, comma-separated value consisting of:<br/><br/>
	  <b>1.</b>The Fingerprint Class value.  Smart parameters are supported.  Alternatively, the name of the Field on this page that specifies the Fingerprint Class.<br/>
	  <b>2.</b>(optional) The Fingerprint ID value. Smart parameters are supported. Alternatively, the name of the Field on this page that specifies the Fingerprint ID.<br/><br/>
	</ap>
	<lvl>Page level only.</lvl>
	<ret><b>False</b> if either parameter is invalid.  Otherwise, <b>True.</b></ret>
	<h>Sets a newly created fingerprint's Fingerprint Class and Fingerprint Class ID values.<br/><br/>

	  After the mandatory Fingerprint Class value and optional Fingerprint Class ID have been manually assigned 
    by a fingerprint creation task, this action places these values into the Host table of the 
    application's Fingerprint database - as RefName and RefID values.
		<e>
      <b>SetFingerprint("@P\VendorName,@P\VendorID")</b><br/><br/>
      
		In this example, runtime values of the VendorName and VendorID Field objects will populate the Host table of the application's Fingerprint Database. 
		Alternative method: SetFingerprint("@VendorName,@VendorID")
		</e>
	</h>
</ref>

<ref id="SetProblemValue" access="public" qi="Uses the decimal value you supply as a parameter to set a minimum Matching Tolerance Rating.">
	<ap>A decimal value from 0.00 (Lowest Tolerance) to 0.99 (Highest Tolerance). The decimal separator must be appropriate for the locale.</ap>
	<lvl>All, but generally at the Page level.</lvl>
	<ret><b>False</b> if the parameter is missing or the parameter is not numeric. Otherwise, <b>True.</b></ret>
	<h>Uses the decimal value you supply as a parameter to set a minimum Matching Tolerance Rating.<br/><br/>

	<b>Important!</b> A lower rating results in lower tolerance and a greater chance for a match, but also a greater chance for a <b>False</b> match.
		<e><scr>AnalyzeImage()</scr><br/> 
		<scr>CreateFields()</scr><br/>
		<scr>RotateImage()</scr><br/>
		<scr>RecognizePageOCR-S()</scr><br/>
		<scr>SetSearchArea("0.5")</scr><br/>
		<b>SetProblemValue("0.70")</b><br/>
		<scr>SetFingerprintDir("\ParentDirectory\Application\Fingerprint")</scr><br/>
		<scr>FindFingerprint("True")</scr><br/><br/>

		In this sequence, the <scr>FindFingerprint</scr> action assigns a Matching Tolerance Rating that is neither overly restrictive nor unrealistically accepting.<br/><br/>

		If the rule's conditions do not result in a match, and <b>True</b> is used as the parameter for the <scr>FindFingerprint</scr> action, a new fingerprint will be added to the library. 
		</e>
	</h>
</ref>


<ref id="SetFingerprintSearchArea" access="public" qi="Controls the portion of the current page that will be used to find a matching fingerprint.">
  <p name="matchStart"/>
  <p name="matchEnd"/>
  <ap>
    Two parameters:<br/><br/>

    <b>1.</b> A decimal value from 0.01 (1%) to 1.00 (all) to indicate how much of the page is to be matched.
    If the second parameter is empty the first parameter represents the bottom of the area for matching, starting from the top of the page.
    If the second parameter is not empty, the first parameter is the top or start of the area for matching.
    For example, a single parameter of 0.5 indicates that fingerprint matching will be limited to the first half of the page (0 to 50%).
    Decimal separators must be appropriate for the current locale.  In applications which might be used in locales with different decimal separators, use percentage notation.
    <br/><br/>

    <b>2.</b> Optional: A decimal value from 0.01 (1%) to 1.0 (all) to indicate the end point on the page to be
    used for fingerprint matching.  If this parameter is supplied, the fist parameter is the starting point.  
    For example: if the first parameter is 0.6, and the second parameter is 1.0,
    the last 40% of the page will be used for fingerprint matching (60-100%).<br/>
    <br/>
    <b><i>Note.</i></b> In both cases, you can replace a decimal value with a percentage.
    To indicate the value is a "Percentage" the action can use a number followed by "p" - 50p, for example - to represent 50%.<br/>
    When using the percentage values, the number must be a whole number, and cannot contain a decimal separator.<br/>
    Decimal separators must be appropriate for the current locale.  In applications which might be used in locales with different decimal separators, use percentage notation.
  </ap>
  <h>
    This action uses the numeric value(s) you supply to determine the portion of the current page
    that will be used to find a matching fingerprint.
    <e>
      <b>SetFingerprintSearchArea("0.5","")</b><br/><br/>

      The example above compares lines and words in the upper 50% of the current page to the lines and
      words in the same portion of each fingerprint.  Notice the second parameter has been left blank.<br/><br/>

      <b>SetFingerprintSearchArea("0.5","1.0")</b><br/><br/>

      This example compares lines and words in the lower 50% of the current page to the lines and
      words in the same portion of each fingerprint. Remember: you can replace a parameter's decimal
      value with a percentage(p) or metric(m) number.
    </e>
  </h>
  <lvl>All levels, but generally at the Page level.</lvl>
  <ret>
    <b>False</b> if the first parameter is missing or is not numeric. Also returns <b>False</b>
    if the second parameter is not numeric.  Otherwise, <b>True.</b>
  </ret>
  <see>
    <scr>SetProblemValue</scr>
  </see>
</ref>
  
<ref id="SetSearchArea" access="public" qi="This action has been replaced by SetFingerprintSearchArea.">
  <ap>
    Two comma-separated parameters.  See SetFingerprintSearchArea for details.<br/><br/>
  </ap>
	<h>
    This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by SetFingerprintSearchArea.    
  </h>
	<see><scr>SetFingerprintSearchArea</scr></see>
</ref>

<ref id="SetFingerprintDir" access="public" qi="Sets the Fingerprint directory of your application.">
	<ap>
    A String value specifying the directory's name and its path.  Smart parameters are supported.<br/><br/>

	  <b>Note:</b> A Drive ID (such as C:\) is optional.
  </ap>
	<lvl>All levels, but generally applied at the Page level.</lvl>
	<ret>Always <b>True.</b></ret>
	<h>Sets the Fingerprint directory of your application. This directory contains the application's fingerprints.
		<e><b>SetFingerprintDir("C:\ParentDirectory\Application\Fingerprint")</b><br/><br/>

		The action above identifies the location and path of an application's Fingerprint directory. 
		</e>
	</h>
</ref>


 <ref id="FindBlackFingerprint" access="public" qi="Attempts to match black forms to fingerprints in the fingerprints directory of an application. If a match does not occur, the action will respond according to the parameter(s) you enter.">
    <ap>
      Two comma-separated values (the second is optional)<br/><br/>
      <b>1. True or False.</b><br/>
         <b>True</b> If a fingerprint match is not found, a new fingerprint is created and the two fingerprint files 
         (.tif and .cco) are placed in the fingerprint directory.<br/>
         <b>False</b> if the task is to proceed without creating a new fingerprint.<br/>
         <br/>    
      <b>2. Optional.</b> <br/>
         The Page Type that is to be assigned to the newly created fingerprint if the first parameter 
         is <b>True.</b>  If you do not include this parameter, the action will assign the Page 
         Type of the current page.
    </ap>
    <h>
      This action attempts to match black forms to fingerprints in the fingerprints directory of an application.<br/><br/>

      If a match does not occur, the action will respond according to the parameter(s) you enter.
      <e>
        <scr>AnalyzeImage()</scr><br/>
        <scr>SetSearchArea("0.5")</scr><br/>
        <scr>SetProblemValue("0.7")</scr><br/>
        <scr>SetFingerprintDir("ParentDirectory\Application\fingerprint")</scr><br/>
        <b>FindBlackFingerprint("True,PageType")</b><br/><br/>

        In this sequence, the <scr>FindBlackFingerprint</scr> action will only use the top 50% of the fingerprint to search for a match.  
        It will accept a match of 0.7 or higher.<br/><br/>

        If no match is found, the sequence will create a new fingerprint and store it in the location specified by the 
        <scr>SetFingerprintDir</scr> action.<br/><br/>

        If the parameter has been set to False, no fingerprint will be created if a match is not found.
      </e>
    </h>
   <lvl>Page level only.</lvl>
   <ret>
     <b>False</b> if the action is not applied at the Page level or if the first parameter is <b>False</b> and
     a fingerprint match does not occur. Otherwise, <b>True.</b>
   </ret>
</ref>


<ref id="SetFilter_PageType" access="public" qi="Sets the Page Type filter for the identification (matching) algorithm.  The filter will force the fingerprint-matching algorithm to use only fingerprints associated with that Page Type.">
	<ap>The String value of the Page Type you want to use as the filter.</ap>
	<lvl>All levels, but generally at the Page level.</lvl>
	<ret>Always <b>True.</b></ret>
	<h>Sets the Page Type Filter For the identification (matching) algorithm. Smart Parameters are supported.<br/><br/>

	  The filter will force the fingerprint-matching algorithm to use only fingerprints associated with that Page Type.
		<e><b>SetFilter_PageType("Invoice_Page")</b> 
		</e>
	</h>
</ref>

<ref id="SetFilter_HostName" access="public" qi="Sets the Fingerprint Class filter for the identification (matching) algorithm.  The filter will force the fingerprint-matching algorithm to use only fingerprints associated with the specified Fingerprint Class.">
	<ap>The String value of the Fingerprint Class you want to use as the filter.</ap>
	<lvl>Page level.</lvl>
	<ret>Always <b>True.</b></ret>
	<h> Sets the Fingerprint Class filter for the identification (matching) algorithm. Smart Parameters are supported.<br/><br/>

	The filter will force the fingerprint-matching algorithm to use only fingerprints associated with the specified Fingerprint Class.<br/><br/>
    
  To disable this filter, call with an empty string as the parameter.
		<e><b>SetFilter_HostName("MyFingerprintClass")</b>
		</e>
	</h>
</ref>
	


<ref id="SetMaxOffset" access="public" qi="Sets the Maximum Offset value while matching source pages to fingerprints. The actual shift is four times the maximum offset value in pixels (4 * MaxOffset).">
	<ap>Integer value between 1 and 255.</ap>
	<lvl>All levels.</lvl>
	<ret><b>False</b> if the parameter is invalid.  Otherwise, <b>True.</b></ret>
	<h>Sets the Maximum Offset value while matching source pages to fingerprints.  This action has no effect when used with the Fingerprint Service<br/><br/>

	The actual shift is four times the maximum offset value in pixels (4 * MaxOffset).  Increasing this value improves but slows the matching process.<br/><br/>

	The default value is 6: 4 * 6 = 24 pixels.
		<e><b>SetMaxOffset("12")</b><br/><br/>

		This example results in a Maximum Offset value of 48 pixels, well above the 24 pixel default. 
		</e>
	</h>
</ref>



<ref id="SetTemplateDir" access="public" qi="This action should not be used, it will be removed in future versions. It has been replaced by SetFingerprintDir.">
    <ap>
      <i>String</i> value specifying the directory's name and path. <br/><br/>
      <b>Note:</b>A Drive ID (such as c:\) is optional.
    </ap>
    <lvl>All levels, but generally at the Page level.</lvl>
    <ret>Always True.</ret>
  <h>
    This action has been replaced by SetFingerprintDir.
  </h>
  <see>SetFingerprintDir</see>
</ref>



<ref id="SetFingerprintWebServiceURL" access="public" qi="Provides the Uniform Resource Locator (URL) that is a link to a pre-established Fingerprint Service.">
  <ap>
    <i>String</i> value specifying the URL that is the link to the Fingerprint Web Service. Smart parameters are supported.
  </ap>
  <lvl>All levels.</lvl>
  <ret>Always <b>True.</b></ret>
  <h>
    Add SetFingerprintWebService URL with its single parameter to the function and move so it is prior to SetFingerprintDir action.<br/><br/>
    Note: this action is not effective unless the Fingerprint Service has been installed and configured.
    <br/>
    <br/>
    <e>
      <br/><scr>
      <b>SetFingerprintWebServiceURL("http://'FPSERVERNAME'/fpservice/Service.asmx?WSDL")</b>
  </scr><br/>
      <scr>SetFingerprintDir("\ParentDirectory\Application\Fingerprint")</scr><br/>
      <br/>
    </e>
  </h>
</ref>


<ref id="FindTemplate" access="public" qi="This action has been replaced by FindFingerprint.">
  <ap>
    <i>String</i> boolean value:<br/><br/>
    <b>True</b> if the action is to create a new fingerprint if the current <b>
      <i>source</i>
    </b>page does not match the target fingerprint.<br/><br/>
    <b>False</b> if the action is not to create a new fingerprint if there is not a match.
  </ap>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the action is not applied at the Page level. Otherwise, <b>True.</b>
  </ret>
  <h>
    This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by FindFingerprint.
  </h>
  <see>
    <scr>FindFingerprint</scr>
  </see>
</ref>



<ref id="CalculateOffset" access="public" qi="Sets the standard Offset value to be used when matching source pages to fingerprints.">
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the action is not applied at the Page level or an error occurs. Otherwise, <b>True.</b>
  </ret>
  <h>
    Calculates the Confidence and Image_Offset variables (similarity with the Fingerprint and image shift compared with the Fingerprint image) for the page based on its relation to the page's fingerprint.  The fingerprint ID must previously be set using Findfingerprint, SetFingerprint or some other method.
    <e>
      <b>CalculateOffset()</b>
    </e>
  </h>
</ref>


	
<ref id="MergeCCOs_ByType" access="public" qi="Merges the Fingerprint files (.cco) associated with Page objects of the Document Hierarchy.">
  <ap>Comma-separated string values indicating the Page Types of the Document Hierarchy objects to be merged.</ap>
  <lvl>Document level only.</lvl>
  <ret>
    <b>False</b> if a Fingerprint file (.cco) for one of the Page Types is not available. Otherwise, <b>True.</b>
  </ret>
  <h>
    Merges the Fingerprint files (.cco) associated with Page objects of the Document Hierarchy.
    <e>
      <b>MergeCCOs_ByType("Invoice_Page,Invoice_Cont")</b><br/><br/>

      The <b>MergeCCOs_ByType</b> action above permits all values of the source pages to be assigned to 
      a single, searchable Fingerprint Processing file (.cco). 
		</e>
	</h>
</ref>



<ref id="MergeLayoutByType" access="public" qi="Merges the layout files (*layout.xml) associated with Page objects of the Document Hierarchy.">
  <ap>
    Comma-separated string values indicating the Page Types of the Document Hierarchy objects to be merged.
    Smart parameters are supported.
  </ap>
  <lvl>Document level only.</lvl>
  <ret>
    <b>False</b> if a layout file (*layout.xml) for one of the Page Types is not available or if the merged layout
    cannot be created. Otherwise, <b>True.</b>
  </ret>
  <h>
    Merges the layout files (layout.xml) associated with Page objects of the Document Hierarchy.
    The layout.xml for the first page merged will become the new merged layout.xml.
    The merged layout.xml can be then loaded to create a merged CCO for the merged pages.
    The layout file for the first merged page will be updated to contain
    the recognition results from the layout block information for all of the merged pages.<br/><br/>

    Only pages contained in the current document object will be merged. A layout file must
    exist for each of the pages to be merged. Only page types indicated by the parameter
    will be included in the merged file.<br/><br/>

    <e>
      <b>MergeLayoutByType("Main_Page,Trailing_Page")</b><br/><br/>

      The <b>MergeLayoutByType</b> action above combines all of the text of the pages in the current DCO document
      of type Main_Page and Trailing_Page into
      a single, searchable layout file.
    </e>
  </h>
</ref>


  <ref id="BlankPagesIDBySize" access="public" qi="Uses the Image file's size to determine if the file represents a 'blank' page.">
  <ap>
    A three-part, comma-separated value consisting of:<br/>
    <b>1.</b> Numeric value (0 to 2147483647) indicating the maximum size in bytes that qualifies a page as a blank page.<br/>
    <b>2.</b> String value representing the Page Type of a blank page.<br/>
    <b>3.</b> Numeric value (0, 1 or 2) to designate which pages in a multi-page Image file are to be evaluated.<br/>
    <br/>
    The third parameter is optional.<br/>
    0 = both sides of a two-page Image file.<br/>
    1 = odd pages only.<br/>
    2 = even images only.
  </ap>
  <lvl>Batch, Document, or Page levels.</lvl>
  <ret>
     <b>False</b> if any parameter is invalid, the rule with this action is bound to a Field object of the Document Hierarchy, or
     if any child image of the calling object qualifies as a blank page based on the selected byte size.  Otherwise, <b>True.</b>
  </ret>
  <h>
    Uses the Image file's size to determine if the file represents a 'blank' page.<br/><br/>

    Any page or child page with an Image file smaller than the size parameter (in bytes) will be assigned the Page Type value you enter as a parameter.
    <e>
      <b>BlankPagesIDBySize("1000,Blank_Page")</b>
    </e>
  </h>
</ref>

<ref id="SetApplicationID" access="public" qi="Use this action to specify unique application ID.">
  <ap>
    String parameter that represents unique Application ID.  Smart parameters are supported.<br/>
    This value used to retrieve correct list of fingerprints loaded to the server.<br/>
  </ap>
  <lvl>Batch, Document, or Page levels.</lvl>
  <ret>
     <b>False</b> if action SetFingerprintWebServiceURL() has not been called.  Otherwise, <b>True.</b>
  </ret>
  <h>
    Uses this action to specify unique application name if multiple applications using the same <br/>

    Fingerprint Service.<br/><br/>

    <e>
      SetFingerprintWebServiceURL("http://'FPSERVERNAME'/fpservice/Service.asmx?WSDL")<br/>
      <b>SetApplicationID("1040ez")</b>
    </e>
  </h>
</ref>

<ref id="SetFingerprintFailureThreshold" access="public" qi="Uses this action to specify percentage of fingerprint upload failures to ignore.">
  <ap>
    Int parameter that represents percent threshold of fingerprint upload failures to ignore.  Smart parameters are supported.<br/>
    The batch aborts if the percentage of fingerprints that are failed to load exceeds this value.<br/>
  </ap>
  <lvl>Batch, Document, or Page levels.</lvl>
  <ret>
    Returns <b>False</b> when:<br/>
    The fingerprint service is not configured using action SetFingerprintWebServiceURL().<br/>

    Returns <b>False</b> and aborts the batch when:<br/>
    The input parameter is not a value from 0 to 100<br/>
    If the percentage of fingerprints that failed to load is greater than the threshold.<br/>
    If no fingerprints have been loaded and at least one has failed to load.<br/><br/>

    Otherwise, <b>True.</b>
  </ret>
  <h>
    Uses this action to set the maximum number of fingerprint upload failures to ignore.
    If the application has been set using the action SetApplicationID, then the threshold
    will be set for that specific application only.<br/><br/>
    <e>
      FindFingerprint(True)<br/>        
      <b>SetFingerprintFailureThreshold("10")</b>
    </e>
  </h>
</ref>

<ref id="UpdateFingerprintStats" access="public" qi="Updates the Fingerprint hit statistics.">
  <ap>
    None.
  </ap>
  <lvl>Page level.</lvl>
  <ret>
     <b>False</b> if called from any level other than Page level, or the Fingerprint database is not accessible.  Otherwise, <b>True.</b>
  </ret>
  <h>
    Use this action to increment the count for the current page and update the fingerprint statistics
    in the fingerprint database.<br/><br/>
    <e>
      <b>UpdateFingerprintStats()</b>
    </e>
  </h>
</ref>

</help>
</rrx>
<rrx namespace="barcode_p" src="c:\datacap\RRS\barcode_p.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="GetAllBarcodesBP" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    GetAllBarcodesBP = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.ObjectType < 2 Then]]>
<![CDATA[
]]>
<![CDATA[		  Writelog "This action is required to run the Page or Field level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		  Exit Function]]>
<![CDATA[
]]>
<![CDATA[	  End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Trim(strParam) = "" Then strParam = ","]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	  l_bRet = GetBarcodeBP(true,true)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If l_bRet = False Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("NumBarcodes") = "0" OR CurrentObj.Variable("NumBarcodes") = "" Then Exit Function ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    l_iBarcodes = CInt(CurrentObj.Variable("NumBarcodes"))]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    For l_iIndex = 0 to l_iBarcodes - 1]]>
<![CDATA[
]]>
<![CDATA[      If CurrentObj.Variable("GetBarCode" & l_iIndex) <> "" Then ]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.Variable("GetBarCodeList")  = CurrentObj.Variable("GetBarCodeList") & CurrentObj.Variable("GetBarCode" & l_iIndex) & strParam]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Right(CurrentObj.Variable("GetBarCodeList"),1) = strParam Then]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.Variable("GetBarCodeList") = Left(CurrentObj.Variable("GetBarCodeList"), Len(CurrentObj.Variable("GetBarCodeList"))-1)]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    GetAllBarcodesBP = true]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="GetBarcodeBP" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	    ]]>
<![CDATA[
]]>
<![CDATA[	GetBarcodeBP = False]]>
<![CDATA[
]]>
<![CDATA[  Dim barcodePos]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType < 2 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog "This action is required to run the Page or Field level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If fReadBarcodeBP(CurrentObj) Then]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If 3 = CurrentObj.ObjectType Then 'If field, then store field value]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.Text = CurrentObj.Variable("GetBarCode0")]]>
<![CDATA[
]]>
<![CDATA[      'CurrentObj.Variable("Position") = CurrentObj.Variable("Position0")]]>
<![CDATA[
]]>
<![CDATA[      barcodePos = CurrentObj.Variable("Position0")]]>
<![CDATA[
]]>
<![CDATA[      if (NOT len(barcodePos)=0) Then]]>
<![CDATA[
]]>
<![CDATA[         WriteLog("Updating field position: '" & barcodePos & "'")]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Variable("Position") = barcodePos]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  GetBarcodeBP = True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  GetBarcodeBP = False]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[	    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="GetDataMatrixCodeBP" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	GetDataMatrixCodeBP = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType < 2 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog "This action is required to run the Page or Field level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("bp_tp") = "4194304"]]>
<![CDATA[
]]>
<![CDATA[	GetDataMatrixCodeBP = fReadBarcodeBP(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.DeleteVariable("bp_tp")]]>
<![CDATA[
]]>
<![CDATA[  GetDataMatrixCodeBP = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="Get2DCodeBP" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Get2DCodeBP = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType < 2 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog "This action is required to run the Page or Field level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("bp_tp") = "2097152"]]>
<![CDATA[
]]>
<![CDATA[	Get2DCodeBP = fReadBarcodeBP(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.DeleteVariable("bp_tp")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Get2DCodeBP = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="MatchBarcodeBP" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    MatchBarcodeBP = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.ObjectType < 2 Then]]>
<![CDATA[
]]>
<![CDATA[		  Writelog "This action is required to run the Page or Field level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		  Exit Function]]>
<![CDATA[
]]>
<![CDATA[	  End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Trim(strParam) = "" Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "This action requires a parameter with the barcode text value to match. None has been specified, exiting."]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	  'l_bRet = GetBarcodeBP(true,true)]]>
<![CDATA[
]]>
<![CDATA[    l_bRet = fReadBarcodeBP(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If (l_bRet = False) Then ]]>
<![CDATA[
]]>
<![CDATA[       Writelog "Read barcode returned false"]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If (CurrentObj.Variable("NumBarcodes") = "0" OR CurrentObj.Variable("NumBarcodes") = "") Then ]]>
<![CDATA[
]]>
<![CDATA[       Writelog "No barcodes found"]]>
<![CDATA[
]]>
<![CDATA[       Exit Function ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    l_iBarcodes = CInt(CurrentObj.Variable("NumBarcodes"))]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    For l_iIndex = 0 to l_iBarcodes - 1]]>
<![CDATA[
]]>
<![CDATA[      If strParam = CurrentObj.Variable("GetBarCode" & l_iIndex) Then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog "'" & strParam & "' match found in '" & CurrentObj.Variable("GetBarCode" & l_iIndex) & "'"]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.Variable("GetBarCode") =  CurrentObj.Variable("GetBarCode" & l_iIndex)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If (3 = CurrentObj.ObjectType) Then 'If field, then store field value]]>
<![CDATA[
]]>
<![CDATA[           CurrentObj.Text = CurrentObj.Variable("GetBarCode" & l_iIndex)]]>
<![CDATA[
]]>
<![CDATA[           CurrentObj.Variable("Position") =  CurrentObj.Variable("Position" & l_iIndex)]]>
<![CDATA[
]]>
<![CDATA[        End If       ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        MatchBarcodeBP = True]]>
<![CDATA[
]]>
<![CDATA[        Exit For]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Not MatchBarcodeBP Then ]]>
<![CDATA[
]]>
<![CDATA[       Writelog "A barcode matching the text '" & strParam & "' was not found."]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("GetBarCode") =  ""]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="MatchBarcodePrefixBP" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    MatchBarcodePrefixBP = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.ObjectType < 2 Then]]>
<![CDATA[
]]>
<![CDATA[		  Writelog "This action is required to run the Page or Field level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		  Exit Function]]>
<![CDATA[
]]>
<![CDATA[	  End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Trim(strParam) = "" Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "This action requires a parameter with the barcode text value to match. None has been specified, exiting."]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	  'l_bRet = GetBarcodeBP(true,true)]]>
<![CDATA[
]]>
<![CDATA[    l_bRet = fReadBarcodeBP(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If (l_bRet = False) Then ]]>
<![CDATA[
]]>
<![CDATA[       Writelog "Read barcode returned false"]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If   ]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[    If (CurrentObj.Variable("NumBarcodes") = "0" OR CurrentObj.Variable("NumBarcodes") = "") Then ]]>
<![CDATA[
]]>
<![CDATA[       Writelog "No barcodes found"]]>
<![CDATA[
]]>
<![CDATA[       Exit Function ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    l_iBarcodes = CInt(CurrentObj.Variable("NumBarcodes"))]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    strParam = Trim(strParam)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    For l_iIndex = 0 to l_iBarcodes - 1]]>
<![CDATA[
]]>
<![CDATA[      If strParam = Left(CurrentObj.Variable("GetBarCode" & l_iIndex), Len(strParam)) Then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog "'" & strParam & "' match found in '" & CurrentObj.Variable("GetBarCode" & l_iIndex) & "'"]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.Variable("GetBarCode") =  CurrentObj.Variable("GetBarCode" & l_iIndex)]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[        If (3 = CurrentObj.ObjectType) Then 'If field, then store field value]]>
<![CDATA[
]]>
<![CDATA[           CurrentObj.Text = CurrentObj.Variable("GetBarCode" & l_iIndex)]]>
<![CDATA[
]]>
<![CDATA[           CurrentObj.Variable("Position") =  CurrentObj.Variable("Position" & l_iIndex)]]>
<![CDATA[
]]>
<![CDATA[        End If       ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        MatchBarcodePrefixBP = True]]>
<![CDATA[
]]>
<![CDATA[        Exit For]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Not MatchBarcodePrefixBP Then ]]>
<![CDATA[
]]>
<![CDATA[       Writelog "A barcode starting with the prefix '" & strParam & "' was not found."]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("GetBarCode") =  ""]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<f name="IdentifyByBarcodesBP" access="public">
	<p name="barcodePageMappings" type="string">
	</p>
	<p name="mappingsDelim" type="string">
	</p>
	<p name="keyValueSep" type="string">
	</p>
	<p name="caseSensitive" type="bool">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim bRegEx]]>
<![CDATA[
]]>
<![CDATA[	IdentifyByBarcodesBP = FALSE]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType <> 2 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog "This action is required to run at the Page level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If DCO.Variable(IDENTIFY_REGEX) <> "" Then bRegEx = CBool(DCO.Variable(IDENTIFY_REGEX))]]>
<![CDATA[
]]>
<![CDATA[	If mappingsDelim = "" Then mappingsDelim = ","]]>
<![CDATA[
]]>
<![CDATA[	If keyValueSep = "" Then keyValueSep = "="]]>
<![CDATA[
]]>
<![CDATA[	If caseSensitive = "" Then caseSensitive = "FALSE"]]>
<![CDATA[
]]>
<![CDATA[	caseSensitive = CBool(caseSensitive)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim barcodePagePairs]]>
<![CDATA[
]]>
<![CDATA[	barcodePagePairs = Split(barcodePageMappings, mappingsDelim)]]>
<![CDATA[
]]>
<![CDATA[	If UBound(barcodePagePairs) < 0 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog "Barcode-page type mappings not provided. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim barcodesFoundList]]>
<![CDATA[
]]>
<![CDATA[	If CInt(CurrentObj.FindVariable("GetBarCodeList")) < 0 Then Call GetAllBarcodesBP("bInter", "bDebug", mappingsDelim)]]>
<![CDATA[
]]>
<![CDATA[	barcodesFoundList = TRIM(CurrentObj.Variable("GetBarCodeList"))]]>
<![CDATA[
]]>
<![CDATA[	If barcodesFoundList = "" Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog "No barcodes found on page. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	If caseSensitive = FALSE Then barcodesFoundList = UCase(barcodesFoundList)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog "RegEx matching: " & bRegEx]]>
<![CDATA[
]]>
<![CDATA[	For Each mapping In barcodePagePairs]]>
<![CDATA[
]]>
<![CDATA[		Writelog "Evaluating barcode-page mapping: '" & mapping & "'"]]>
<![CDATA[
]]>
<![CDATA[		If mapping <> "" Then]]>
<![CDATA[
]]>
<![CDATA[			Dim matchBarcodeVal]]>
<![CDATA[
]]>
<![CDATA[			matchBarcodeVal = LEFT(mapping, INSTRREV(mapping, keyValueSep)-1)]]>
<![CDATA[
]]>
<![CDATA[			If caseSensitive = FALSE Then matchBarcodeVal = UCase(matchBarcodeVal)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Dim pageType]]>
<![CDATA[
]]>
<![CDATA[			pageType = RIGHT(mapping, LEN(mapping)-INSTRREV(mapping, keyValueSep))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If matchBarcodeVal <> "" AND pageType <> "" Then]]>
<![CDATA[
]]>
<![CDATA[				For Each barcodeFound in Split(barcodesFoundList, mappingsDelim)]]>
<![CDATA[
]]>
<![CDATA[					Dim bFound]]>
<![CDATA[
]]>
<![CDATA[					bFound = (Not bRegEx) AND (barcodeFound = matchBarcodeVal)]]>
<![CDATA[
]]>
<![CDATA[					bcPageIDRegEx.Pattern = matchBarcodeVal]]>
<![CDATA[
]]>
<![CDATA[					bFound = (bFound) OR (bRegEx AND bcPageIdRegEx.Test(barcodeFound))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					If bFound Then]]>
<![CDATA[
]]>
<![CDATA[						Writelog Space(3) & "Found match: '" & matchBarcodeVal &_]]>
<![CDATA[
]]>
<![CDATA[								"' in value '" & barcodeFound & "'" &_]]>
<![CDATA[
]]>
<![CDATA[								" setting page type to '" & pageType & "'"]]>
<![CDATA[
]]>
<![CDATA[						CurrentObj.Type = pageType]]>
<![CDATA[
]]>
<![CDATA[						IdentifyByBarcodesBP = TRUE]]>
<![CDATA[
]]>
<![CDATA[						Exit Function]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[				Next]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[				Writelog Space(3) & "Skipped invalid mapping"]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog Space(3) & "Skipped invalid mapping"]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	Writelog "No match found"]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<af name="ReadBarCodeBP" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ReadBarCodeBP = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType < 2 Then]]>
<![CDATA[
]]>
<![CDATA[		  Writelog "This action is required to run the Page or Field level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		  Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Trim(strParam) = "" Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "This action requires a parameter with the barcode text value to match. None has bee specified, exiting."]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("bp_su") = "1"]]>
<![CDATA[
]]>
<![CDATA[	ReadBarCodeBP = MatchBarcodeBP(true,true,strParam)]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.DeleteVariable("bp_su")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="SetMinimumConfidenceBP" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetMinimumConfidenceBP = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType < 2 Then]]>
<![CDATA[
]]>
<![CDATA[		  Writelog "This action is required to run the Page or Field level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[		  Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'On error resume next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  l_iConfidence = CInt(strParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog "There was a problem setting the confidence: " & Err.Description]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  If (1 > l_iConfidence OR l_iConfidence > 10 ) Then]]>
<![CDATA[
]]>
<![CDATA[   Writelog "The valid values for confidence are in the range of 1-10"]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable("ReqConf") = CStr(l_iConfidence)]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Minimum confidence set to " & CurrentObj.Variable("ReqConf") ]]>
<![CDATA[
]]>
<![CDATA[    SetMinimumConfidenceBP = True]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<help>
  <![CDATA[
'****************************************************
' Barcode_P.rrx - a description of the library

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2017 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.

'****************************************************

]]>


  <ref id="GetAllBarcodesBP" access="public"  qi="Searches all the barcodes on the current page and writes them to the calling object's GetBarCodeList variable.">
    <ap>The separator to use when storing multiple barcodes. The default separator is a comma.</ap>
    <h>
      Searches all the barcodes on the current page and stores them in the calling object's GetBarCodeList variable. Each barcode value is separated using the string separator value entered as a parameter.<br/><br/>
      If the engine does not detect any barcodes, then the variable GetBarCodeList is not populated nor created.
      <e>
        <b>GetAllBarcodesBP(",")</b>
      </e>
    </h>
    <lvl>Page and field level.</lvl>
    <ret>
      <b>True</b> if the action is called at the page level or field level. Otherwise, <b>False.</b><br/><br/>
      In addition the calling object's value and variable "GetBarCode" will be filled with the bar code value. This action also
      stores barcode information such as confidence, coordinates, code name, and size. If the object's barcode settings are set to read more than
      one barcode, and more than one barcode is found, barcodes are also stored in the variable "GetBarCodeX" where "X" is the index of
      the barcode found.
    </ret>
    <see>GetAllBarcodesBP</see>
  </ref>

  <ref id="GetBarcodeBP" access="public"  qi="Recognizes arbitrary 1D or 2D codes.">
    <ap>None.</ap>
    <lvl>Page or Field level only.</lvl>
    <ret>
      <b>True</b> if the action is called at the page level or field level. Otherwise, <b>False.</b><br/><br/>
      In addition the calling object's value and variable "GetBarCode" will be filled with the bar code value. This action also
      stores barcode information such as confidence, coordinates, code name, and size. If the object's barcode settings are set to read more than
      one barcode, and more than one barcode is found, barcodes are also stored in the variable "GetBarCodeX" where "X" is the index of
      the barcode found.
    </ret>
    <h>
      Use this action if your page has 1D or 2D barcodes.  Any field must have a Position assigned
      when bar code reading is performed.  For example the application would invoke the
      CreateFields action, and if the field has Position defined in the Document Hierarchy,
      it is ready for barcode reading.  If anchors or fingerprint matching are used,
      ReadZones or other registration may be required to align the fields correctly.<br/><br/>
      To explictly tell the engine which barcode type(s) to be read, the field/page being recognized
      should contain a variable (or setup property) called <b>bp_tp</b>. If the "bp_tp" variable is empty or does not exist,
      the engine detaults to "Unknown" (please see notes for "Unknown" below).<br/><br/>
      The value of this variable must be a combination of the barcode types shown below (this variable is automatically
      set when choosing the barcode types through DStudio's Zones tab, under the BAR/P recognition settings).<br/><br/>
      Multiple types can be read by adding the values of their codes together. <br/>

      <br/>

      When the barcode type is set to <b>Patch Code</b>, the following string values may be returned by the engine (the string value depends on the type of Patch Code
      that is found): <br/>

      <br/>Patch 1: <b>1100</b>
      <br/>Patch 2: <b>1001</b>
      <br/>Patch 3: <b>1010</b>
      <br/>Patch 4 / Toggle Patch: <b>0110</b>
      <br/>Patch 6: <b>0011</b>
      <br/>Patch T / Transfer patch: <b>0101</b>

      <br/><br/><b>Important! </b> When recognizing PatchCodes, the barcode type must be set explicitly to PatchCode. The default barcode type setting of "Unknown" will not detect PatchCodes.
      <br/><br/>

      <b>Valid barcode types:</b><br/>
      <br/>
      0         : Unknown. Detects all barcode types automtically, in the exception of PatchCode and PDF417. These have to be set explicitly to be detected.<br/>
      1         : INDUSTRY 2 OF 5<br/>
      2         : INTERLEAVED 2 OF 5<br/>
      4         : IATA 2 OF 5<br/>
      8         : DATALOGIC 2 OF 5<br/>
      16        : INVERT 2 OF 5<br/>
      32        : BCD MATRIX<br/>
      64        : MATRIX 2 OF 5<br/>
      128       : CODE 32<br/>
      256       : CODE 39<br/>
      512       : CODABAR 2<br/>
      1024      : CODE 93<br/>
      2048      : CODE 128<br/>
      4096      : EAN-13<br/>
      8192      : EAN-8<br/>
      16384     : UPC-A<br/>
      32768     : UPC-E<br/>
      65536     : ADD 5<br/>
      131072    : ADD 2<br/>
      262144    : UCC128/EAN-128<br/>
      524288    : Patch Code<br/>
      1048576   : PostNet<br/>
      2097152   : PDF417<br/>
      4194304   : DataMatrix<br/>
      8388608   : Code 39 Extended<br/>
      16777216  : Code 93 Extended<br/>
      33554432  : QRCode<br/>
      67108864  : IntelligentMail<br/>
      134217728 : Royal Mail (RM4SCC)<br/>
      268435456 : Australian Post 4-State Code<br/>
      536870912 : Aztec<br/>
      1073741824: GS1DataBar<br/>
      <br/>

      <b>Minimum and Maximum Settings</b><br/>
      Multiple barcodes can exist and be recognized on a single page.  The DCO variable <b>bp_su</b> controls the maximum number
      of barcodes that will attempt to be read on a single page.  If not specified, the default maximum is 10.<br/><br/>

      The minimum number of expected barcodes can be specified using the DCO variable <b>bp_minExpected.</b>
      This setting will control when image enhancement takes place.  Unless specified, the minimum expected barcodes will
      default to the same value as the maximum number of barcodes setting.<br/><br/>
      
      If the number of recognized barcodes
      is equal to or more than the specified minimum, image enhancement will be skipped.
      If the minimum number of barcodes has not been reached, and if image enhancement is enabled,
      then barcode recognition will be performed a second time using the configured type of 
      image enhancement in an attempt to read the barcode.<br/><br/>
      
      For example, if the configured minimum barcodes is 1 and the maximum is 10, first barcode
      recognition will be performed without any image enhancement and attempt to read up to 10
      barcodes.  If at least 1 barcode is read, 
      the action will complete.  If 0 barcodes are read, the action will perform the specified image
      enhancement and attempt once more to recognize the barcodes on the page.
      If 0 barcodes are read and no image enhancement is configured, the action will complete
      without a second attempt at recognition.<br/><br/>

      <b>Image Enhancement:</b><br/><br/>
      Image enhancement may be necessary in order to help read damaged or poorly scanned barcodes. 
      Depending on the problem with the barcode, different types of enhancements may make the barcode readable.
      The barcode_p actions offer a way to enhance the image prior to reading the barcode. To enable this
      feature, the variable <b>bp_enhance</b> has to be set to "1". This will only alter the image
      for barcode recognition, the original image in the batch will be left unchanged.
      The image enhancements are not cumulative, enable just the feature that is needed.<br/><br/>      
      
      The following additional variables have to be set, depending on the type of image enhancement desired:<br/><br/>

      Smooth Zoom: <b>bp_zoom</b> - This feature is automatically enabled when the variable <b>bp_enhance</b> is set to "1". 
      To disable smooth zoom set the variable to "0". It is disabled automatically if one of the other
      image enhancement settings are enabled.<br/><br/>

      The following enhancement settings are disabled by default and can be enabled when the variable is set to "1".<br/>
      Blur: <b>bp_blur</b> - Blurs the image which can help jagged lines.<br/>
      Dilate: <b>bp_dilate</b> - Expands pixels making lines thicker.<br/>
      Erode: <b>bp_erode</b> - Removes pixels along line edges.<br/>
      Flip: <b>bp_flip</b> - It is usually not necessary to flip the image for an upside-down barcode to recognize.<br/>
      Resize: <b>bp_resize</b> - Enlarges the image which could help small barcodes.<br/><br/>

      <b>NOTE:</b> Although image enhancement is turned ON by setting the <b>bp_enhance</b> variable, 
      enhancement is performed only if the number of recognized barcodes in the first recognition attempt is <b>less</b> than the 
      minimum barcodes setting.<br/><br/>

      <b>Barcode Orientation</b><br/><br/>
      Barcode orientation defaults to both horizontal and vertical.
      Specifying the orientation may help in detection of barcodes.
      If necessary, the orientation can be configured by setting the DCO variable <b>bp_or.</b><br/>
      0 = Horizontal and Vertical.<br/>
      1 = Horizontal.<br/>
      2 = Vertical.<br/>
      3 = Horizontal, Vertical and Diagonal.<br/><br/>

      <b>Barcode Byte Mode:</b><br/><br/>
      In rare cases, barcodes can contain null characters within the data stream.  
      If this occurs, the full length of the barcode can be truncated returning only the characters up to the first null character.
      To treat a barcode as byte data, set the DCO variable <b>BarcodeUseByte</b> to "1".  
      This setting will treat the stream as bytes and also convert any null characters to spaces so the entire string can then be
      utilized in other parts of the application.<br/><br/>
      
      When in byte mode, the default replacement character of a space can be set to a different replacement character
      by setting the DCO variable <b>BarcodeReplacementChar</b> to the desired replacement character.<br/><br/>

      <b>NOTE:</b> Unicode characters are not supported when using byte mode.
      <br/><br/>
      
      <br/>
      <e>
        <b>GetBarcodeBP()</b>
      </e>
    </h>
  </ref>

  <ref id="GetDataMatrixCodeBP" access="public"  qi="Recognizes Data Matrix codes">
    <ap>None.</ap>
    <lvl>Page or Field level only.</lvl>
    <ret>
      <b>True</b> if the action is called at the page level or field level. Otherwise, <b>False.</b><br/><br/>
      In addition the calling object's value and variable "GetBarCode" will be filled with the bar code value. This action also
      stores barcode information such as confidence, coordinates, code name, and size. If the object's barcode settings are set to read more than
      one barcode, and more than one barcode is found, barcodes are also stored in the variable "GetBarCodeX" where "X" is the index of
      the barcode found.
    </ret>
    <h>
      Use this action if your page or field has Data Matrix codes.  Any field must have a Position assigned
      when bar code reading is performed.  For example the application would invoke the
      CreateFields action, and if the field has Position defined in the Document Hierarchy,
      it is ready for barcode reading.  If anchors or fingerprint matching are used,
      ReadZones or other registration may be required to align the fields correctly.
      <e>
        <b>GetDataMatrixCodeBP()</b>
      </e>
    </h>
  </ref>

  <ref id="Get2DCodeBP" access="public"  qi="Recognizes PDF-417 codes.">
    <ap>None.</ap>
    <lvl>Page or Field level only.</lvl>
    <ret>
      <b>True</b> if the action is called at the page level or field level. Otherwise, <b>False.</b><br/><br/>
      In addition the calling object's value and variable "GetBarCode" will be filled with the bar code value. This action also
      stores barcode information such as confidence, coordinates, code name, and size. If the object's barcode settings are set to read more than
      one barcode, and more than one barcode is found, barcodes are also stored in the variable "GetBarCodeX" where "X" is the index of
      the barcode found.
    </ret>
    <h>
      Use this action if your page has PDF-417 codes.  Any field must have a Position assigned
      when bar code reading is performed.  For example the application would invoke the
      CreateFields action, and if the field has Position defined in the Document Hierarchy,
      it is ready for barcode reading.  If anchors or fingerprint matching are used,
      ReadZones or other registration may be required to align the fields correctly.<br/><br/>

      If the barcode data contains nulls, it is possible to enable byte mode. 
      Refer to the help for action GetBarcodeBP for more information.<br/><br/>
      <e>
        <b>Get2DCodeBP()</b><br/>
        This example reads a PDF-417 barcode on the page.<br/><br/>

        rrSet("1","@X.BarcodeUseByte")<br/>
        rrSet("~","@X.BarcodeReplacementChar")<br/>
        <b>Get2DCodeBP()</b><br/>
        This example reads a PDF-417 barcode in byte mode and changes the default null replacement character with a tilde.
      </e>
    </h>
  </ref>

  <ref id="MatchBarcodeBP" access="public"  qi="Searches all the barcodes on the current page and checks if one matches the value you enter as a parameter.">
    <ap>The String value of the barcode.</ap>
    <h>
      Searches all the barcodes on the current page or current field and checks if one of the barcodes matches the parameter value.
      If running at field level and the field does not have a zone defined, then recognition will run for the whole page.
      If a match occurs, the barcode's value is placed into a page level variable called 'GetBarCode'.
      If running at the field level, the matched value is also stored in the text property.<br/><br/>

      Refer to action GetBarcodeBP for information regarding barcode configuration.
      <e>
        <b>MatchBarcodeBP("2008")</b>
      </e>
    </h>
    <lvl>Page level and field level.</lvl>
    <ret>
      <b>True</b> if the action is called at the page level or field level and one of the barcode values on the page
      matches the parameter value (parameter value must not be empty).  Otherwise, <b>False.</b> <br/><br/>
      In addition the calling object's value and variable "GetBarCode" will be filled with the bar code value. This action also
      stores barcode information such as confidence, coordinates, code name, and size. If the object's barcode settings are set to read more than
      one barcode, and more than one barcode is found, barcodes are also stored in the variable "GetBarCodeX" where "X" is the index of
      the barcode found.
    </ret>
    <see>GetBarcodeBP</see>
  </ref>
  
  <ref id="MatchBarcodePrefixBP" access="public"  qi="Searches all the barcodes on the current page and checks if one matches the value you enter as a parameter.">
    <ap>The String value of the barcode.</ap>
    <h>
      Searches all the barcodes on the current page or current field and checks if one of the barcodes starts with the parameter value.
      If running at the field level and the field does not have a zone defined, then recognition will run for the whole page.
      If a match occurs, the barcode's value is placed into a page level variable called 'GetBarCode'.
      If running at the field level, the matched value is also stored in the text property.<br/><br/>

      Refer to action GetBarcodeBP for information regarding barcode configuration.
      <e>
        <b>MatchBarcodePrefixBP("ATM")</b>
      </e>
    </h>
    <lvl>Page level and field level.</lvl>
    <ret>
      <b>True</b> if the action is called at the page level or field level and one of the barcode values on the page
      matches the parameter value (parameter value must not be empty).  Otherwise, <b>False.</b> <br/><br/>
      In addition the calling object's value and variable "GetBarCode" will be filled with the bar code value. This action also
      stores barcode information such as confidence, coordinates, code name, and size. If the object's barcode settings are set to read more than
      one barcode, and more than one barcode is found, barcodes are also stored in the variable "GetBarCodeX" where "X" is the index of
      the barcode found.
    </ret>
    <see>GetBarCodeBP</see>
  </ref>

  <ref id="IdentifyByBarcodesBP" access="public" qi="Updates the current page type if a barcode match is found.">
    <p name="barcodePageMappings" type="string"/>
    <p name="mappingsDelim" type="string"/>
    <p name="keyValueSep" type="string"/>
    <p name="caseSensitive" type="bool"/>
    <ap>
      <b>barcodePageMappings:</b> A delimited list of barcode value-page type mappings that are
      evaluated to determine whether matching barcodes exist on the current page.
      For more information, see the Details section.
      If any of these mappings are regular expressions, set the batch variable BarcodeRegEx to true.
      If this variable is not set to true, the regular expressions are not recognized as regular expressions.<br/>
      <b>mappingsDelim:</b> (Optional) Delimiter separating mappings.  Default: comma.<br/>
      <b>keyValueSep:</b> (Optional) Delimiter used to separate the barcode value and page type in an individual mapping.  Default: equals sign (=).<br/>
      <b>caseSensitive:</b> (Optional) True enforces case sensitivity when evaluating the list of barcodes found on the page.  Default: False.
    </ap>
    <h>
      This action searches all of the barcodes that are found on the current page for a match from
      the provided mappings by using the GetBarCodeList variable. If a barcode value is found,
      this action updates the type of the current page by using the corresponding input mapping.<br/><br/>

      The GetAllBarcodesBP action is called if the GetBarCodeList variable does not exist.
      If the GetAllBarcodesBP action was called earlier with a string parameter,
      use an identical symbol for the mappingsDelim parameter.<br/><br/>

      If multiple barcode values are found, the page type that is assigned is the first
      corresponding value from the GetBarCodeList variable.<br/><br/>
      <e>
        IdentifyByBarcodesBP(Separator=Separator_Page,Attach=Attachment_Page,,,)<br/>
        IdentifyByBarcodesBP(Separator=Separator_Page%Attach=Attachment_Page,%,,)<br/>
        IdentifyByBarcodesBP(Separator|Separator_Page%Attach|Attachment_Page,%,|,True)
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>True,</b> if a match is found.  Otherwise, <b>False.</b>
    </ret>
  </ref>

  <ref id="ReadBarCodeBP" access="public"  qi="Tests the first barcode found with the value specified by the parameter.">
    <ap>A single string value of the barcode.</ap>
    <h>
      Checks if the current page contains a barcode with the value specified by the parameter.
      This action uses the first barcode it encounters.<br/>
      One possible use of this action is to identify a document's Separator page.<br/><br/>

      Refer to action GetBarCode for information regarding barcode configuration in Datacap Studio.
      <e>
        <b>ReadBarCodeBP("Separator")</b><br/>
        SetPageType("Separator")<br/><br/>
        This example looks for a barcode with the value "Separator". If found, the second action,
        a DCO action, establishes the page as a Separator page.
      </e>
    </h>
    <lvl>Page level only.</lvl>
    <ret>
      <b>True</b> if the first barcode on the page has a value that matches the parameter.
      Otherwise, <b>False.</b><br/><br/>
    </ret>
    <see>GetBarCodeBP</see>
  </ref>

  <ref id="SetMinimumConfidenceBP" access="public" >
    <ap>An integer value representing the minimum confidence required for barcodes read by the engine to be accepted. Valid values are in the range of 1-10. The default value, when this action is not used, is 7. </ap>
    <lvl>Page or Field level only.</lvl>
    <ret>
      <b>False</b> if the confidence value cannot be set either because it is invalid or an error occurs or if the action is called at a level other than page or field. Otherwise, <b>True </b>
    </ret>
    <h>
      Sets the minimum confidence required for barcodes read by the engine to be accepted. <br/>
      <e>
        <b>SetMinimumConfidenceBP(5)</b><br/>
        GetBarCodeBP()
      </e>
    </h>
  </ref>   
</help>

</rrx>
<rrx namespace="cco2cco" src="c:\datacap\RRS\cco2cco.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="NormalizeCCO" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	NormalizeCCO=False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[wleft="<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"">" & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["<xsl:output method=""xml"" indent=""yes"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["<xsl:template match=""P|L""> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   <xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     <xsl:apply-templates select=""@*"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     <xsl:apply-templates select=""W""> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["       <xsl:sort select=""@l"" data-type=""number"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     </xsl:apply-templates> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   </xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["</xsl:template> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["<xsl:template match=""@* | node()""> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   <xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     <xsl:apply-templates select=""@* | node()"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   </xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["</xsl:template> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["</xsl:stylesheet> " & vbCrLf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[wbottom="<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform""> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["<xsl:output method=""xml"" indent=""yes"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["<xsl:template match=""CCO""> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   <xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     <xsl:apply-templates select=""@*"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     <xsl:apply-templates select=""W""> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["       <xsl:sort select=""@b"" data-type=""number"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     </xsl:apply-templates> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   </xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["</xsl:template> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["<xsl:template match=""@* | node()""> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   <xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["     <xsl:apply-templates select=""@* | node()"" /> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["   </xsl:copy> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["</xsl:template> " & vbCrLf &_]]>
<![CDATA[
]]>
<![CDATA["</xsl:stylesheet> " & vbCrLf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sPath=CurrentObj.Variable("IMAGEFILE")]]>
<![CDATA[
]]>
<![CDATA[	ImageCtrl.FileName = sPath]]>
<![CDATA[
]]>
<![CDATA[	ImageCtrl.GetRes xDPI, yDPI]]>
<![CDATA[
]]>
<![CDATA[	CCOMaxHeightPixels = CCOMaxHeightTMM * yDPI / 254]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("MaxHt TMM = " & CCOMaxHeightTMM & " yDPI = " & CStr(yDPI) & " MaxHt PX = " & CCOMaxHeightPixels)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sOverlap=CurrentObj.Variable("LineHeightOverlapPercent")]]>
<![CDATA[
]]>
<![CDATA[  if CStr(sOverlap) <> "" then]]>
<![CDATA[
]]>
<![CDATA[    'WriteLog("Overlap '" & sOverlap & "'")]]>
<![CDATA[
]]>
<![CDATA[    on error resume next]]>
<![CDATA[
]]>
<![CDATA[    if CInt(sOverlap) > 0 and CInt(sOverlap) < 100 then]]>
<![CDATA[
]]>
<![CDATA[      CCOLineHeightOverlapPercent = CInt(sOverlap)]]>
<![CDATA[
]]>
<![CDATA[	    WriteLog("Line Height Overlap Percent set to " & CCOLineHeightOverlapPercent)]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[  on error goto 0]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	imageFileExtensionPeriod = instrRev(sPath,".") ]]>
<![CDATA[
]]>
<![CDATA[  sPath = Left(sPath,imageFileExtensionPeriod) & "cco"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set pObj=Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set xDoc=CCO2XML(sPath, pObj)	' extract CCO to XML doc, get back pObj=CCO in memory]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call SortXML2(xDoc, wbottom)	' sort XML by text baseline]]>
<![CDATA[
]]>
<![CDATA[	sXPath=Replace(sPath, ".cco", "sortv.xml")	]]>
<![CDATA[
]]>
<![CDATA[	'xDoc.Save(sXPath)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Split2LinesDiscret(xDoc)		' organize into lines]]>
<![CDATA[
]]>
<![CDATA[	sXPath=Replace(sPath, ".cco", "split.xml")	]]>
<![CDATA[
]]>
<![CDATA[	'xDoc.Save(sXPath)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Call SortXML2(xDoc, wleft)		' sort within line by left to right]]>
<![CDATA[
]]>
<![CDATA[	Call SortXMLBiDi(xDoc)		' sort within line LTR or RTL depending on hr_bidi]]>
<![CDATA[
]]>
<![CDATA[	sXPath=Replace(sPath, ".cco", "sorth.xml")	]]>
<![CDATA[
]]>
<![CDATA[	'xDoc.Save(sXPath)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	' now build up the full structure of lines and words]]>
<![CDATA[
]]>
<![CDATA[	Set xNodes=xDoc.selectNodes(".//W")]]>
<![CDATA[
]]>
<![CDATA[	For Each oNode In xNodes]]>
<![CDATA[
]]>
<![CDATA[		xDoc.documentElement.appendChild(oNode)]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	Set xNodes=xDoc.selectNodes(".//L")]]>
<![CDATA[
]]>
<![CDATA[	For Each oNode In xNodes]]>
<![CDATA[
]]>
<![CDATA[		oNode.parentNode.removeChild(oNode)]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	' now join together "phrases" that were previously split but belong together in a line]]>
<![CDATA[
]]>
<![CDATA[	Call ReJoin(xDoc, pObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call RecreateCCO(xDoc, sPath, pObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sXPath=Replace(sPath, ".cco", "c.xml")	]]>
<![CDATA[
]]>
<![CDATA[	xDoc.Save(sXPath)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Set xDoc=Nothing]]>
<![CDATA[
]]>
<![CDATA[	NormalizeCCO=True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="SetMaxCharacterHeightTMM" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CCOMaxHeightTMM = CInt(strParam)]]>
<![CDATA[
]]>
<![CDATA[	if CCOMaxHeightTMM <= 1 then CCOMaxHeightTMM = 64	' restore default]]>
<![CDATA[
]]>
<![CDATA[	SetMaxCharacterHeightTMM=True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="SetMaxCharacterHeightAVG" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	SetMaxCharacterHeightAVG=False]]>
<![CDATA[
]]>
<![CDATA[	strParam=trim(strParam)]]>
<![CDATA[
]]>
<![CDATA[	strParam=replace(strParam,".","")]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(strParam) or len(strParam)>2 then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	g_CCOMaxHeightAVG = CInt(strParam)]]>
<![CDATA[
]]>
<![CDATA[	if g_CCOMaxHeightAVG <= 1 then g_CCOMaxHeightAVG = 0	' restore to default OFF]]>
<![CDATA[
]]>
<![CDATA[	SetMaxCharacterHeightAVG=True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<help>
  <![CDATA[
'****************************************************
' Cco2cco.rrx - a description of the library

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2016 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.

'****************************************************

]]>

  <ref id="NormalizeCCO" access="public" qi="Sorts and filters the words and lines in a Fingerprint file (.cco)created by a Recognition engine, for use by navigation and pattern match actions. This action is only required after full page recognition by an OCR or ICR action that does NOT automatically normalize the CCO.  OCR/S, OCR/A, ICR/C full page recogntiion do NOT require this action.">
    <lvl>Page.</lvl>
    <ret>Always True.</ret>
    <h>
      This action sorts the words and lines in a Fingerprint file (.cco) created by a recognition engine,
      for use by navigation and pattern match actions. The action is called by full-page recognition
      actions for ICR/C, OCR/S, and OCR/A.  This action should always be called before using
      <b>Locate</b>actions or the <b>pat_RecogMatch_ID</b>action to find recognized text on a page.<br/><br/>

      In this context, the fingerprint is calculated for a particular image in a batch, as opposed to
      the Fingerprint database, which contains fingerprints for various page types and layout variations
      that have been defined for a particular application.<br/><br/>

      There are two types of Fingerprint files.  One type is based on the image geometry.  The second
      type is based on recognized text.  The <b>AnalyzeImage</b>action creates a geometric
      fingerprint containing lines and "words" based only on the black pixels in the image. Full-page
      recognition actions (<b>RecognizePageOCR_S, RecognizePageICR_C, RecognizePageOCR_A </b>etc.) create a
      fingerprint based on the results of recognition, i.e. both geometry and text of the
      recognized characters, words and lines.<br/><br/>

      In Recognition-based fingerprints, the order of lines and words may appear to be arbitrary,
      especially if the page contains images, tables, stamps, or blocks of text with varying font sizes.
      This can cause unpredictable results from <b>Locate</b>actions that navigate geometrically.
      The word-matching and phrase-matching action <b>pat_RecogMatch_ID</b>also requires
      well-ordered text to work reliably.<br/><br/>

      The <b>NormalizeCCO </b>action re-orders the words of text in a Recognition-based fingerprint into
      lines and words in "standard" reading order, from top to bottom and left to right.<br/><br/>

      <b>IMPORTANT NOTE: NormalizeCCO </b>discards any "words" or blocks containing characters taller than 1/4 inch, or the height set by SetMaxCharacterHeightTMM().<br/><br/>

      <b>NOTE:</b> If the <b>AnalyzeImage</b> action is called before full-page recognition,
      the recognized text is placed into the geometry created by <b>AnalyzeImage.</b>This hybrid
      Fingerprint file is not always suitable for <b>cco2cco.</b> To force creation of a pure
      recognition-based fingerprint, call <b>SetFingerprintRecogPriority(True)</b>
      before full-page recognition. This guarantees that any existing geometric fingerprint will be ignored,
      and it applies to <b>OCR_S</b>and <b>ICR_C</b>only.<br/><br/>

      <b>NOTE:</b> The full page recognition actions from the <b>ICR_C</b>, <b>OCR_A</b>, and <b>OCR_S</b> libraries call NormalizeCCO() automatically unless the action
      CCONormalization_OFF (from the <b>Recog_Shared</b> library) is called prior to recognition. The full page recognition from the <b>OCR_SR</b> library, however, requires that
      NormalizeCCO() to be called manually post recognition. <br/><br/>
      <e>
        SetFingerprintRecogPriority(True)<br/>
        RecognizePageOCR_S()<br/>
        <b>NormalizeCCO()</b><br/>
        pat_RecogMatch_ID()
      </e>
    </h> 
  </ref>

  <ref id="SetMaxCharacterHeightTMM" access="public" qi="Sets the maximum height of characters permitted by cco2cco and NormalizeCCO actions.">
    <ap>
      <i>Integer</i> maximum height of characters to permit in the CCO, in 1/10 mm units.  Default is 64, or approx 1/4 inch (50 pixels at 200 DPI).
    </ap>
    <lvl>Page.</lvl>
    <ret>Always True.</ret>
    <h>
      <e>
        <b>SetMaxCharacterHeightTMM(75)</b><br/>
        NormalizeCCO()
      </e>
    </h>
  </ref>
  
  <ref id="SetMaxCharacterHeightAVG" access="public" qi="Sets the maximum height of characters permitted by cco2cco and NormalizeCCO actions.">
    <ap>
      One or two digit <i>Integer</i> value sets the percent maximum height of characters over the average to permit in the CCO.<br/>
      Off by default. Parameter of zero (0) or less turns off this functionality.
    </ap>
    <lvl>Page.</lvl>
    <ret>Always True.</ret>
    <h>
      <e>
        <b>SetMaxCharacterHeightAVG(15)</b><br/>
        NormalizeCCO()
      </e>
    </h>
  </ref>
   
</help>

</rrx>
<rrx namespace="ClassifyLayout" src="c:\datacap\RRS\ClassifyLayout.dll">

<net ref="ClassifyLayout.Actions">
	<h>
<![CDATA[
]]>
<![CDATA[    The ClassifyLayout actions classify document pages based on page layout features such as title, page number, average font size, and the presence and locations of tables and graphics. ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<br>
		</br>
		<br>
		</br>
<![CDATA[The application must recognize the document using an OCR action that produces a layout XML file before invoking any ClassifyLayout actions.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<br>
		</br>
		<br>
		</br>
<![CDATA[Actions that produce a layout XML file include OCR_SR.Recognize and OCR_A.Recognize.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<br>
		</br>
		<br>
		</br>
<![CDATA[The Identify action creates a variable that your application rules can use to set the page Type.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<br>
		</br>
		<br>
		</br>
<![CDATA[ClassifyLayout actions store classification knowledge (page types and features associated with each type) in tables in the Fingerprint database.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</h>
	<method name="Identify">
		<h>
<![CDATA[
]]>
<![CDATA[      The Identify action analyzes the layout file for the current page and tries to find a similar page type that was previously learned by the Feedback action.]]>
<![CDATA[
]]>
<![CDATA[      This action stores the best matching page type in the page variable acidType. ]]>
<![CDATA[
]]>
<![CDATA[      It also creates variables acidPageNo (like 1/3 for first page of 3, or 0/0 if no page # found) and acidTitle (if title is detected) to be used for further processing.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Recognize()]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Identify()]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the action completes without errors, regardless of whether classification is successful or not.  If the action is called on an object other than a page, or if it encounters an internal error, it returns ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="Feedback">
		<h>
<![CDATA[
]]>
<![CDATA[      You can use the Feedback action to teach the ClassifyLayout action how to properly classify pages.]]>
<![CDATA[
]]>
<![CDATA[      The Feedback action is usually called at export time.  The Idenfity action must have run previously, ]]>
<![CDATA[
]]>
<![CDATA[      and the page type should be manually verified or corrected before calling this action.]]>
<![CDATA[
]]>
<![CDATA[      This action compares the acidType variable created by Idenfity to the verified page TYPE.]]>
<![CDATA[
]]>
<![CDATA[      If those are different, this page and its features are added to the knowledge base to be used by Identify in the future.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Feedback()]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the action is called on a page, and is able to complete.  If called on a non-page object, or if the action encounters an error, it returns ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
</net>
</rrx>
<rrx namespace="CMISClient" src="c:\datacap\RRS\CMISClient.dll">

<net ref="CMISClient.Actions">
	<method name="CMISLogin" qi="Supply login credentials and connect to the CMIS server.">
		<p name="atomPubURL" type="string">
		</p>
		<p name="userID" type="string">
		</p>
		<p name="password" type="string">
		</p>
		<p name="repositoryID" type="string">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[atomPubURL :]]>
			</b>
<![CDATA[ The AtomPub URL for your CMIS compatible repository.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[userID :]]>
			</b>
<![CDATA[ The logon user ID.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[password :]]>
			</b>
<![CDATA[ The password.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[repositoryID :]]>
			</b>
<![CDATA[ Optionally specify the CMIS repository ID.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Smart parameters are supported for all parameters.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action connects to a CMIS compatible repository using a AtomPub URL.  If the repository ID is blank,]]>
<![CDATA[
]]>
<![CDATA[      the connection will be made to the first repository returned from the CMIS connection.]]>
<![CDATA[
]]>
<![CDATA[      This action must be called before using any of the other CMIS actions.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISLogin("http://localhost:8080/alfresco/service/api/cmis","MyUserID","@APPVAR(values/adv/cmispassword)")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        The password is obtained from the application service and is set using the application manager.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISLogin("http://localhost:8080/alfresco/service/api/cmis","MyUserID","@APPVAR(values/adv/cmispassword)","MyRepositoryID")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This example passes the optional repository ID.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Returns True if the login was successful, otherwise it returns False.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="CMISUploadPage" qi="Upload the current DCO page to the CMIS server.">
		<p name="cmisUploadedName" type="string">
		</p>
		<p name="cmisUploadDirectory" type="string">
		</p>
		<p name="mimeType" type="string">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisUploadedName :]]>
			</b>
<![CDATA[ The desired final name of the file in the repository.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisUploadDirectory :]]>
			</b>
<![CDATA[ The full path for the folder within the repository where the file will be stored.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[mimeType :]]>
			</b>
<![CDATA[ The mime type of the uploaded file.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Smart parameters are supported for all parameters.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action uploads the current DCO page to the configured repository.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Note that objects created on the CMIS server may not be immediately accessible.]]>
<![CDATA[
]]>
<![CDATA[      For example, the indexing service on your CMIS server may run on a configured interval,]]>
<![CDATA[
]]>
<![CDATA[      so your new object may not be available until the indexing service completes.]]>
<![CDATA[
]]>
<![CDATA[      If you are having trouble accessing newly created objects, check the settings and documentation]]>
<![CDATA[
]]>
<![CDATA[      of your CMIS server to determine when objects should become available.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      A record of uploaded files will be placed in the file UploadRecord.xml in the batch directory.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        CMISSetDocUploadType("cmisbook:poem")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        CMISSetDocUploadProperty("cmisbook:author", "Edgar Allan Poe", "string", False)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        CMISSetDocUploadProperty("cmisbook:Title", "The Raven", "string", False)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISUploadPage("MyFile.txt", "/MyCMISDir", "text/plain")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This set of actions sets property values of the page that will be uploaded, then uploads the page.]]>
<![CDATA[
]]>
<![CDATA[        The current page will be placed into the \MyCMISDir folder and be given the mime type of text/plain.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Returns ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the file is successfully uploaded.  Otherwise, it returns ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="CMISSetDocUploadType" qi="Sets the type of the file that will be uploaded.">
		<p name="cmisDocType" type="string">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisDocType :]]>
			</b>
<![CDATA[ The document type of the uploaded file.  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action sets the CMIS document type for the file that will be subsequently uploaded in a following upload action.]]>
<![CDATA[
]]>
<![CDATA[      Use of this action is optional.  If it is not called, the value of cmis:document will be used.]]>
<![CDATA[
]]>
<![CDATA[      To set the document type, this action must be called before CMISUploadFile or CMISUploadPage.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Standard CMIS properties are of the form "CMIS:xxx".  By convention, custom CMIS properties should not use the "CMIS:" prefix.]]>
<![CDATA[
]]>
<![CDATA[      Calling this action with an empty string, will reset the value back to the default cmis:document type.]]>
<![CDATA[
]]>
<![CDATA[      Once the upload is complete, the document type is reset to the default value]]>
<![CDATA[
]]>
<![CDATA[      and this action will need to be called again to set a custom value for another upload.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If the specified upload type is invalid or not defined on your CMIS server, an error will occur in the upload action.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISSetDocUploadType("cmisbook:poem")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        CMISSetDocUploadProperty("cmisbook:author", "Edgar Allan Poe", "string", False)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        CMISSetDocUploadProperty("cmisbook:Title", "The Raven", "string", False)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        CMISUploadPage("MyFile.txt", "/MyCMISDir", "text/plain")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This uses a predefined custom document type and then sets the custom author and title properties of the uploaded file.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Always returns True.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="CMISSetDocUploadProperty" qi="Sets the value of a property belonging to the file that will be uploaded.">
		<p name="cmisDocProperyName" type="string">
		</p>
		<p name="cmisDocProperyValue" type="string">
		</p>
		<p name="valueType" type="string">
		</p>
		<p name="isMulti" type="bool">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisDocProperyName :]]>
			</b>
<![CDATA[ The name of the CMIS property to set.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisDocProperyValue :]]>
			</b>
<![CDATA[ The value of the specified property.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[valueType :]]>
			</b>
<![CDATA[ The CMIS type of the value.  Must be "string", "integer", "datetime" or "boolean".]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[isMulti :]]>
			</b>
<![CDATA[ True if the CMIS type is a multi value type.  False if the CMIS type is single.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Smart parameters are supported for cmisDocProperyName, cmisDocProperyValue and valueType.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action sets a value to the specified property for files or pages that will be uploaded]]>
<![CDATA[
]]>
<![CDATA[      to the CMIS repository.  Use of this action is optional.]]>
<![CDATA[
]]>
<![CDATA[      Standard CMIS properties are of the form "CMIS:xxx".  By convention, custom CMIS properties should not use the "CMIS:" prefix.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      This action must be called before CMISUploadFile or CMISUploadPage.  If multiple properties]]>
<![CDATA[
]]>
<![CDATA[      need to be set for a document upload, call this action multiple times to set]]>
<![CDATA[
]]>
<![CDATA[      multiple properties.  The property must be defined for the document type within the CMIS repository.]]>
<![CDATA[
]]>
<![CDATA[      If the property or value is not valid for the document type, the error will not be]]>
<![CDATA[
]]>
<![CDATA[      reported until the upload action is called.  Once the upload is complete, the property settings set with this action]]>
<![CDATA[
]]>
<![CDATA[      are discarded and this action will need to be called again to set any custom properties for another upload.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      For a boolean property type, the value must be either "true" or "false".]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The datetime type accepts an input string specifying just the date or the date and time.]]>
<![CDATA[
]]>
<![CDATA[      The application will attempt to parse the input date format based on the current locale.]]>
<![CDATA[
]]>
<![CDATA[      The action will use the locale set in the Application Service / hr_locale variable.]]>
<![CDATA[
]]>
<![CDATA[      If that is not set, the current OS locale will be used to interpret the date/time.  The action attempts to ignore]]>
<![CDATA[
]]>
<![CDATA[      unrecognized data, if possible.  If the month, day or year is missing, it will attempt to use the values]]>
<![CDATA[
]]>
<![CDATA[      from the current date.  If a time is not specified, then then time is set to 12:00 midnight.]]>
<![CDATA[
]]>
<![CDATA[      It is recommended to provide the full short date in the correct format that is correct for the current]]>
<![CDATA[
]]>
<![CDATA[      locale, and a full 4 digit year, to reduce the chance of the action guessing values incorrectly.]]>
<![CDATA[
]]>
<![CDATA[      Only Gregorian short date formats are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Example input datetime strings in the en-US locale.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      05/01/2009 14:57:32.8 becomes 5/1/2009 2:57:32 PM]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      2009-05-01 14:57:32.8 becomes  5/1/2009 2:57:32 PM]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      2009-05-01T14:57:32.8375298-04:00 becomes 5/1/2009 11:57:32 AM]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      5/01/2008 14:57:32.80 -07:00 becomes 5/1/2008 2:57:32 PM.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        CMISSetDocUploadType("cmisbook:poem")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISSetDocUploadProperty("cmisbook:author", "Edgar Allan Poe", "string", False)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISSetDocUploadProperty("cmisbook:Title", "The Raven", "string", False)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        CMISUploadPage("MyFile.txt", "/MyCMISDir", "text/plain")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This uses a predefine custom document type and then sets the author and title properties of the uploaded file.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Returns False, if the property could not be set or the datetime parameter could not be processed.  Otherwise True is returned.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="CMISUploadFile" qi="Upload a file to the CMIS server.">
		<p name="fullyQualifiedFileName" type="string">
		</p>
		<p name="cmisUploadedName" type="string">
		</p>
		<p name="cmisUploadDirectory" type="string">
		</p>
		<p name="mimeType" type="string">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[fullyQualifiedFileName :]]>
			</b>
<![CDATA[ The file name to upload with the full path specified.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisUploadedName :]]>
			</b>
<![CDATA[ The desired final name of the file in the repository.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisUploadDirectory :]]>
			</b>
<![CDATA[ The full path for the folder within the repository where the file will be stored.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[mimeType :]]>
			</b>
<![CDATA[ The mime type of the uploaded file.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Smart parameters are supported for all parameters.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action uploads a file to the configured repository.  You can optionally set properties of the uploaded file using the]]>
<![CDATA[
]]>
<![CDATA[      actions CMISSetDocUploadProperty and CMISSetDocUploadType.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Note that objects created on the CMIS server may not be immediately accessible by the client.]]>
<![CDATA[
]]>
<![CDATA[      For example, the indexing service on your CMIS server may run on a configured interval,]]>
<![CDATA[
]]>
<![CDATA[      so your new object may not be available until the indexing service completes.]]>
<![CDATA[
]]>
<![CDATA[      If you are having trouble accessing newly created objects, check the settings and documentation]]>
<![CDATA[
]]>
<![CDATA[      of your CMIS server to determine when objects should become available.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      A record of uploaded files will be placed in the file UploadRecord.xml in the batch directory.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        CMISSetDocUploadType("cmisbook:poem")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        CMISSetDocUploadProperty("cmisbook:author", "Edgar Allan Poe", "string", False)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        CMISSetDocUploadProperty("cmisbook:Title", "The Raven", "string", False)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISUploadFile("C:\MyDir\MyFile.txt","MyFile.txt", "/MyCMISDir", "text/plain")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        The uploaded file will be placed into the \MyCMISDir folder and be given the mime type of text/plain.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Returns ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the file is successfully uploaded.  Otherwise, it returns ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="CMISDoesFolderExist" qi="Tests that a folder exists on the CMIS server.">
		<p name="cmisDirectoryPath" type="string">
		</p>
		<p name="existenceResult" type="bool">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisDirectoryPath :]]>
			</b>
<![CDATA[ The folder and path to test for existence. Smart parameters are supported.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[existenceResult :]]>
			</b>
<![CDATA[ If True the action will return True when the folder exists, otherwise False is returned.]]>
<![CDATA[
]]>
<![CDATA[      If False the action will return false if the folder exists, otherwise True is returned.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Tests that the provided directory path exists in the connected CMIS repository.  This action can be configured]]>
<![CDATA[
]]>
<![CDATA[      to return true if the folder exists or return true if the folder does not exist.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISDoesFolderExist("/MyFolder/AnotherFolder", True)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Returns true if "AnotherFolder" exists in the repository and returns false if it does not exist.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISDoesFolderExist("/MyFolder/AnotherFolder", False)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Returns false if "AnotherFolder" exists in the repository and returns true if the folder does not exist.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      existenceResult if True, then return True if folder exits.  If false, return true if directory does not exist.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="CMISSetVersion" qi="Sets the version type of the file that will be uploaded.">
		<p name="cmisVersion" type="string">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisVersion :]]>
			</b>
<![CDATA[ The version of the uploaded document.  It must be one of the following: None, Major, Minor, CheckedOut.]]>
<![CDATA[
]]>
<![CDATA[      If this action is not called prior to the file upload, the type of "None" will be used.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Smart parameters are supported.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Call this action prior to the CMISUploadFile action to set the version type of the uploaded file.]]>
<![CDATA[
]]>
<![CDATA[      The support for versions is dependent on the target repository.  Check your repository documentation]]>
<![CDATA[
]]>
<![CDATA[      to determine which version types it supports via the CMIS interface.  The supported types may also]]>
<![CDATA[
]]>
<![CDATA[      vary based on the specific version configuration settings of your repository.]]>
<![CDATA[
]]>
<![CDATA[      The use of this action is optional.]]>
<![CDATA[
]]>
<![CDATA[      If this action is not called, then the type of "None" will be used for uploaded files.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISSetVersion("Major")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        CMISUploadFile("C:\MyDir\MyFile.txt","MyFile.txt", "/MyCMISDir", "text/plain")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      This action always returns ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[  If the type specified is invalid or if]]>
<![CDATA[
]]>
<![CDATA[      a CMIS connection has not yet been established, then the type will default to "None".]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="CMISDoesFileExist" qi="Tests that a file exists on the CMIS server.">
		<p name="cmisFilePath" type="string">
		</p>
		<p name="existenceResult" type="bool">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisFilePath :]]>
			</b>
<![CDATA[ The document and path to test for existence. Smart parameters are supported.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[existenceResult :]]>
			</b>
<![CDATA[ If True the action will return True when the file exists, otherwise False is returned.]]>
<![CDATA[
]]>
<![CDATA[      If False the action will return false if the file exists, otherwise True is returned.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action tests that the provided file exists in the connected CMIS repository.  This action can be]]>
<![CDATA[
]]>
<![CDATA[      configured to return true if the file exists or return true if the file does not exist.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISDoesFileExist("/MyFolder/MyDoc.txt", True)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Returns true if "MyDoc.txt" exists in the repository and returns false if it does not exist.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISDoesFileExist("/MyFolder/MyDoc.txt", False)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Returns false if "MyDoc.txt" exists in the repository and returns true if the folder does not exist.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      existenceResult if True, then return True if file exits.  If false, return true if file does not exist.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="CMISDeleteFolder" qi="Deletes a folder on the CMIS server.">
		<p name="cmisDirectoryPath" type="string">
		</p>
		<p name="ignoreFailure" type="bool">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisDirectoryPath :]]>
			</b>
<![CDATA[ The path of the folder to delete.  Smart parameters are supported.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[ignoreFailure :]]>
			</b>
<![CDATA[ Set to True to ignore any failure so the action will always return True.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      The folder must be empty for the delete to be successful.]]>
<![CDATA[
]]>
<![CDATA[      Some, but not all, CMIS repositories have the notion of a "soft" delete where the]]>
<![CDATA[
]]>
<![CDATA[      deletion is performed at a later time.  You should assume that]]>
<![CDATA[
]]>
<![CDATA[      once the object is deleted, that it is deleted forever.  If an object is deleted,]]>
<![CDATA[
]]>
<![CDATA[      it can only be restored if the repository provides a mechanism to restore the object.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      A delete failure can be ignored by using the ignoreFailure parameter.  This allows actions]]>
<![CDATA[
]]>
<![CDATA[      to continue even if the delete should fail.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISDeleteFolder("/MyFolder/AnotherFolder", false)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This returns true if AnotherFolder is deleted, otherwise it returns false.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISDeleteFolder("/MyFolder/AnotherFolder", true)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This always returns true, even if the folder is not deleted.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      If ignoreFailure is True, the action always returns true, even if the folder could not be deleted.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      If ignoreFailure is False, the action will return true if the directory is deleted, otherwise false is returned.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="CMISDeleteFile" qi="Deletes a file on the CMIS server.">
		<p name="cmisFilePath" type="string">
		</p>
		<p name="ignoreFailure" type="bool">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisFilePath :]]>
			</b>
<![CDATA[ The file to delete on the CMIS server.  Smart parameters are supported.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[ignoreFailure :]]>
			</b>
<![CDATA[ Set to True to ignore any failure so the action will always return True.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Deletes the specified file in the CMIS repository.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Some, but not all, repositories have the notion of a "soft" delete, which will perform the]]>
<![CDATA[
]]>
<![CDATA[      final deletion at a later time.  You should assume that]]>
<![CDATA[
]]>
<![CDATA[      once the object is deleted, that it is deleted forever.  If an object is deleted,]]>
<![CDATA[
]]>
<![CDATA[      it can only be restored if the repository provides a mechanism to restore the object.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      A delete failure can be ignored by using the ignoreFailure parameter.  This allows actions]]>
<![CDATA[
]]>
<![CDATA[      to continue even if the delete should fail.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISDeleteFile("/MyFolder/MyDoc.txt", false)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This returns true if MyDoc.txt is deleted, otherwise it returns false.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISDeleteFile("/MyFolder/MyDoc.txt", true)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This always returns true, even if the file could not be deleted.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      if ignoreFailure is True, the action always returns true, even if the file could not be deleted.]]>
<![CDATA[
]]>
<![CDATA[      If ignoreFailure is False, the action will return true if the file is deleted, otherwise false is returned.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="CMISDownloadFile" qi="Download a file on the CMIS server to a local hard drive.">
		<p name="cmisFileToDownload" type="string">
		</p>
		<p name="fullFileNameTarget" type="string">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisFileToDownload :]]>
			</b>
<![CDATA[ The file, with the full path, to download from the CMIS repository.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[fullFileNameTarget :]]>
			</b>
<![CDATA[ The path and file name for the downloaded file.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Smart parameters are supported for all parameters.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Downloads a file from the CMIS repository to a local hard drive.  The file in the repository is not changed.]]>
<![CDATA[
]]>
<![CDATA[      If the target file exists, it will be overwritten.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISDownloadFile("/MyCMISDir/MyCMISFile.txt", "c:\MyLocalDir\MyLocalFile.txt")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Downloads a copy of the file MyCMISFile.txt and names it MyLocalFile.txt on the local system.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Returns True, if the download is successful, otherwise False is returned.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="CMISCreateFolderCustomType" qi="Creates a folder on the CMIS server and allows specification of the folder type.">
		<p name="cmisFolderParentPath" type="string">
		</p>
		<p name="cmisFolderName" type="string">
		</p>
		<p name="cmisFolderType" type="string">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisFolderParentPath :]]>
			</b>
<![CDATA[ The path of the parent folder.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisFolderName :]]>
			</b>
<![CDATA[ The name of the new folder.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisFolderType :]]>
			</b>
<![CDATA[ The type of the new folder.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Smart parameters are supported for all parameters.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Creates a folder on the configured CMIS server. This action is identical to CMISCreateFolder with]]>
<![CDATA[
]]>
<![CDATA[      the ability to specify a custom type.  The standard type is cmis:folder.  If your CMIS server]]>
<![CDATA[
]]>
<![CDATA[      requires a different type, it can be specified in this action.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Note that objects created on the CMIS server may not be immediately accessible by the client.]]>
<![CDATA[
]]>
<![CDATA[      For example, the indexing service on your CMIS server may run on a configured interval,]]>
<![CDATA[
]]>
<![CDATA[      so your new object may not be available until the indexing service completes.]]>
<![CDATA[
]]>
<![CDATA[      If you are having trouble accessing newly created objects, check the settings and documentation]]>
<![CDATA[
]]>
<![CDATA[      of your CMIS server to determine when objects should become available.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISCreateFolderCustomType("/MyParent","MyNewFolder", "MyType")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Creates the folder "MyNewFolder" in the "MyParent" folder.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Returns True if the folder is created, otherwise it returns false.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="CMISCreateFolder" qi="Creates a folder on the CMIS server.">
		<p name="cmisFolderParentPath" type="string">
		</p>
		<p name="cmisFolderName" type="string">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisFolderParentPath :]]>
			</b>
<![CDATA[ The path of the parent folder.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[cmisFolderName :]]>
			</b>
<![CDATA[ The name of the new folder.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Smart parameters are supported for all parameters.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Creates a folder on the configured CMIS server.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Note that objects created on the CMIS server may not be immediately accessible by the client.]]>
<![CDATA[
]]>
<![CDATA[      For example, the indexing service on your CMIS server may run on a configured interval,]]>
<![CDATA[
]]>
<![CDATA[      so your new object may not be available until the indexing service completes.]]>
<![CDATA[
]]>
<![CDATA[      If you are having trouble accessing newly created objects, check the settings and documentation]]>
<![CDATA[
]]>
<![CDATA[      of your CMIS server to determine when objects should become available.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISCreateFolder("/MyParent","MyNewFolder")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Creates the folder "MyNewFolder" in the "MyParent" folder.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Returns True if the folder is created, otherwise it returns false.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="CMISRefreshClientCache" qi="Refreshes the client side cache.">
		<p name="milliseconds" type="string">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[milliseconds : ]]>
			</b>
<![CDATA[ Refreshes the object local cache if it is older than the specified number of milliseconds.]]>
<![CDATA[
]]>
<![CDATA[      A value of 0 will refresh immediately.  A value of -1 will disable this refresh feature and the CMIS interface]]>
<![CDATA[
]]>
<![CDATA[      will manage the cache itself.  By default, this refresh is disabled.]]>
<![CDATA[
]]>
<![CDATA[      Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      CMIS client side caching will first look into the session cache if an object already exists in the client cache.]]>
<![CDATA[
]]>
<![CDATA[      If the desired object is found, that object will be used without contacting the repository.]]>
<![CDATA[
]]>
<![CDATA[      It is possible that it may be a stale object.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      This action will refresh the client side cache, if it is older than the time specified in the parameter]]>
<![CDATA[
]]>
<![CDATA[      The value of 0 will refresh the cache immediately.]]>
<![CDATA[
]]>
<![CDATA[      This action will affect all subsequent CMIS actions, refreshing each object as they are used.]]>
<![CDATA[
]]>
<![CDATA[      Call this action with a value of -1 to disable this automatic refresh.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Typically this action does not need to be called.]]>
<![CDATA[
]]>
<![CDATA[      It is provided in case a specific application requires a cache refresh.]]>
<![CDATA[
]]>
<![CDATA[      If this action is not called, the CMIS interface will manage the cache as it sees fit.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Note that objects created on the CMIS server may not be immediately accessible by the client.]]>
<![CDATA[
]]>
<![CDATA[      For example, the indexing service on your CMIS server may run on a configured interval,]]>
<![CDATA[
]]>
<![CDATA[      so a new object may not be available until the indexing service completes.]]>
<![CDATA[
]]>
<![CDATA[      This refresh setting will not affect components on the CMIS server such as the indexing service interval.]]>
<![CDATA[
]]>
<![CDATA[      If you are having trouble accessing newly created objects, check the settings and documentation of]]>
<![CDATA[
]]>
<![CDATA[      your CMIS server to determine when objects should become available.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISRefreshClientCache("1000")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        Refreshes the client local cache if it is older than 1 second.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Always true.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="CMISLogDocumentTypes" qi="Logs the document types defined on the CMIS server.">
		<ap>
<![CDATA[
]]>
<![CDATA[      None.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      This action will query the CMIS server and log all of the server defined document types to]]>
<![CDATA[
]]>
<![CDATA[      the RRS log, providing that logging is enabled.]]>
<![CDATA[
]]>
<![CDATA[      This is a diagnostic action and is not intended for use in a production environment, nor is it]]>
<![CDATA[
]]>
<![CDATA[      supported in a production environment.  CMISLogin must be called prior to this action.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      It may be useful for an developer to obtain this type information during application development and has no]]>
<![CDATA[
]]>
<![CDATA[      intended use other than this limited diagnostic.]]>
<![CDATA[
]]>
<![CDATA[      Be aware that depending on the number of types and attributes defined on the CMIS server, this action may be]]>
<![CDATA[
]]>
<![CDATA[      slow and create a large log file.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CMISLogDocumentTypes()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Always true.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
</net>
</rrx>
<rrx namespace="ColorToBW" src="c:\datacap\RRS\ColorToBW.dll">

<i ref="rrunner">
</i>
<af name="C2BW_Convert" access="public" bInter="bInter" bDebug="bDebug" strParam="sParam">
</af>
<f name="C2BW_SetAttributes" access="public">
	<p name="BitsPerPixel">
	</p>
	<p name="Palette">
	</p>
	<p name="Dither">
	</p>
</f>
<help>
<![CDATA[
'************************************************************************
' Actions help for ColorToBW
'------------------------------------------------------------------------
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2013 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************************
]]>

<ref id="C2BW_Convert" access="public" bInter="bInter" bDebug="bDebug" strParam="sParam" qi="Changes the color depth of an image.">
  <ap>
    C2BW_Convert always produces a TIF image. If the source image has a TIF extension,
    use this parameter to provide an extension to use for a backup of the original file.
    If not provided, the parameter defaults to "tio".
    If the source image does not have a TIF extension, this parameter is ignored and use a TIF extension and the original image name will not be changed. <br/><br/>
    Smart parameters are supported.
  </ap>
  <h>
    Changes the color depth of an image based on a set of defined attributes, creating a new TIF image.<br/><br/>
    
    If action C2BW_SetAttributes is not called first, a black and white image will be created.
    If called at the batch level converts all images.  If called at the document level,
    images within the document are converted.  If called on the page, or field level the page is converted.<br/><br/>

    The supported input image formats are TIF (including LZW compression), PNG, BMP and JPG.
    <e>
       C2BW_SetAttributes("1","0","3")<br/>
       <b>C2BW_Convert("tic")</b>
     </e>
  </h>
  <lvl>All Levels.</lvl>
  <ret>
     Always <b>True.</b>
  </ret>
  <see>
    C2BW_SetAttributes
  </see>
</ref>


<ref id="C2BW_SetAttributes" access="public" qi="Adjusts the output of the action C2BW_Convert.">
  <p name="BitsPerPixel"/>
  <p name="Palette"/>
  <p name="Dither"/>
  <ap>
    Requires 3 numeric values to configure the output image specifications:<br/>
    1. Bits per pixel - 1, 4, 8, 24. A bit depth of 1 will produce a black and white image. 
    A bit depth of 4, 8 or 24 will produce a grayscale or color image depending on the selected palette.<br/>
    2. Palette - 0 Optimized, 1 Fixed, 2 Grayscale.<br/>
    3. Dither - 0 None, 1 Floyd-Steinberg, 2 Ordered, 3 Optimized.<br/><br/>
    Smart parameters are supported.
  </ap>
  <h>
    Optionally called before C2BW_Convert to configure the desired image output specifications.
    If this action is not called, these default values are used by C2BW_Convert:<br/>
    BitsPerPixel = 1 (Black and White)<br/>
    Palette = 0 (Optimized)<br/>
    Dither = 0 (None)<br/>
    <e>
      <b>C2BW_SetAttributes("1","0","3")</b><br/>
      C2BW_Convert(tic)
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    C2BW_Convert
  </see>
  </ref>
</help>
</rrx>
<rrx namespace="Datacap.Libraries.IBMCM" src="c:\datacap\RRS\Datacap.Libraries.IBMCM.dll">

<g>
</g>
<net ref="Datacap.Libraries.IBMCM.Actions" qi="Description of action library.">
	<method name="IBMCM_Logon" qi="Logs on to a IBM Content Manager server.">
		<p name="connectioninfo" type="string" qi="A comma-separated string consisting of three values:           1) the ID of the IBM Content Manager server           2) a valid Content Manager User ID           3) the user’s Password">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        A comma-separated string consisting of three values: ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        1) the ID of the IBM Content Manager server.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        2) a valid Content Manager User ID.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        3) the user’s Password.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for each parameter.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<h>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[        Performs the logon to the IBM Content Manager system.  This action must be called prior to the]]>
<![CDATA[
]]>
<![CDATA[        actions that communicate with the Content Manager repository.  Connectivity, based on]]>
<![CDATA[
]]>
<![CDATA[        the requirements of the IBM Content Manager server, needs to be]]>
<![CDATA[
]]>
<![CDATA[        setup on the machine which is running the Datacap rules.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_Logon("ibmcmserver,user1,password")]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_Logon("ibmcmserver,user1,+@APPVAR(values/adv/MyPassword)")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example uses the smart parameter @APPVAR to obtain the password from the]]>
<![CDATA[
]]>
<![CDATA[          advanced value section of the application manager.  The custom value name is "MyPassword".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[
]]>
<![CDATA[        Any level. Usually used at the Batch level.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        Action returns ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the log on succeeds; ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the log on is unsuccessful.]]>
<![CDATA[
]]>
<![CDATA[        The log on will be unsuccessful if the action cannot find the specified server, or if the user ID or password is invalid.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="IBMCM_CreateItem" qi="Creates a IBM CM document based on the item type.">
		<p name="itemtype" type="string" qi="Creates a IBM CM document based on the item type.">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        itemType is a string value of a valid IBM Content Manager Item Type – NOINDEX, for example. ]]>
<![CDATA[
]]>
<![CDATA[        A IBM Content Manger Item Type is equivalent to a Document Class (Index Class).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported, such as @BATCHID, @ID, @STATUS, @TYPE, @VALUE,]]>
<![CDATA[
]]>
<![CDATA[        @JOBID, @JOBNAME, @OPERATOR, @STATION, @TASKID, @TASKNAME, etc.  Please refer to]]>
<![CDATA[
]]>
<![CDATA[        the smart parameter documentation for more information and usage.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[        Creates a IBM Content Manger document based on the item type.  This action needs to be called prior to the document]]>
<![CDATA[
]]>
<![CDATA[        and page upload actions.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateItem("NOINDEX")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetMimeType("image/tiff")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_UploadDCO_DOC()]]>
				<br>
				</br>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          This example will create an IBM Content Manager document based on the NOINDEX item type,]]>
<![CDATA[
]]>
<![CDATA[          set the mime type of the uploaded document, then perform the upload.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateItem("@P.name")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create an IBM Content Manager document based on the value contained inside the Smart Parameter @P.name at the page level.          ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          Typically, there is one item for each processed document represented by a Document object of the Document Hierarchy, ]]>
<![CDATA[
]]>
<![CDATA[          or for a processed page represented by a Page object.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Document or page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the document is successfully created.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="IBMCM_CreateChildItem" qi="Create a child component under the current document created using IBMCM_CreateItem">
		<p name="Child Item Information" type="string" qi="A comma-separated string consisting of two values:           1) childItemName: Create a child component. Creates a child component specified by the childItemName, under the defined object type (IBMCM_CreateItem).           2) count: The number of child component attribute values that will be set.">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        childItemName is a string value that contains the name of a valid child componet name of the item specified by IBMCM_CreateItem.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        The count is the number of child component attributes values that will be set by IBMCM_SetChildAttributeValue.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[        This action needs to be called after IBMCM_CreateItem.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateItem("ABCInsPlc")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateChildItem("Automobiles,1")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetChildAttributeValue("Automobiles,ABCVIN,vin123")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_UploadDCO_DOC()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create an IBM Content Manager Child Item based on the name Automobiles.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Document or page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the child item is created is successfully created.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="IBMCM_CreateFolder" qi="Creates a IBM Content Manger folder in the parent folder, based on the specified item type.">
		<p name="itemType" type="string" qi="The item type (classification) to create the IBM Content Manger folder.  This parameter is required.">
		</p>
		<p name="attribute" type="string" qi="The attribute name.">
		</p>
		<p name="attributeValue" type="string" qi="The unique attribute value or folder ID.">
		</p>
		<p name="hasParent" type="bool" qi="If true then the new folder has a parent folder.">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        If hasParent is False, the new folder will be created without a parent folder and the action will ignore attribute and attributeValue.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        If hasParent is true, then it is expected that this folder will be the child of an already existing]]>
<![CDATA[
]]>
<![CDATA[        folder and that the attribute and attributeValue specify the parent.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        If hasParent is true and both attribute and attributeValue are not provided then parent folder will be set to the most recently created folder.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        If folder ID is used in the attributeValue parameter, leave the attribute parameter empty ("").]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for the string type parameters.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the folder is successfully created.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[        The action fails if a folder with the specified attribute or ID is not found.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[        Creates a folder in the IBM Content Manger repository.  IBMCM_SetAttributeValue can be called following this action]]>
<![CDATA[
]]>
<![CDATA[        to set attributes of the newly created folder.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[Important: If the new folder is based on an item type classfication that contains attributes that are required, an application should use the IBMCM_CreateFolderEx action instead.]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[IBMCM_CreateFolder will create and save the folder immediately to the repository]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateFolder("NOINDEX", "", "", False)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create an IBM Content Manger folder based on the NOINDEX item type.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          The new folder has no parent and will be placed in the root directory.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateFolder("NOINDEX", "", "A1001001A14B04B12546D00215", True)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create an IBM Content Manger folder based on the NOINDEX item type.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          The folder will be placed inside the parent folder with ID=A1001001A14B04B12546D00215.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateFolder(@B.MyItemtye, @B.MyAttribute, @B.MyAttributeValue, True)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetAttributeValue("Name,@BATCHID")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create an IBM Content Manger folder based on the type identified by @B.MyItemType and]]>
<![CDATA[
]]>
<![CDATA[          will be a child of the folder identified by values from]]>
<![CDATA[
]]>
<![CDATA[          the batch level Smart Parameters @B.MyAttribute and @B.MyAttributeValue.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateFolder(@B.MyItemtye, "", "", False)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetAttributeValue("Name,"MyFolder1")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateFolder(@B.MyItemtye, "", "", True)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetAttributeValue("Name,"MyFolder2")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create folder "MyFolder1" and folder "MyFolder2" based on the type identified by @B.MyItemType.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          The folder "MyFolder1" folder has no parent. The parent of folder "MyFolder2" is folder "MyFolder1".]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
	</method>
	<method name="IBMCM_CreateFolderEx" qi="Creates a IBM Content Manger folder in the parent folder, based on the specified item type.">
		<p name="itemType" type="string" qi="The item type (classification) to create the IBM Content Manager folder.  This parameter is required.">
		</p>
		<p name="attribute" type="string" qi="The attribute name.">
		</p>
		<p name="attributeValue" type="string" qi="The unique attribute value or folder ID.">
		</p>
		<p name="hasParent" type="bool" qi="If true then the new folder has a parent folder.">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        If hasParent is False, the new folder will be created without a parent folder and the action will ignore attribute and attributeValue.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        If hasParent is true, then it is expected that this folder will be the child of an already existing]]>
<![CDATA[
]]>
<![CDATA[        folder and that the attribute and attributeValue specify the parent.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        If hasParent is true and both attribute and attributeValue are not provided then parent folder will be set to the most recently created folder.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        If folder ID is used in the attributeValue parameter, leave the attribute parameter empty ("").]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for the string type parameters.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[Important: Use this action when the new folder is based on an item type classfication that contains attributes that are required.]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[IBMCM_CreateFolderEx will create the folder in memory and the folder will be saved to the repository once the IBMCM_SaveFolder action has been called]]>
			</b>
			<br>
			</br>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the folder is successfully created.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[        The action fails if a folder with the specified attribute or ID is not found.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[        Creates a folder in the IBM Content Manger repository.  IBMCM_SetAttributeValue can be called following this action]]>
<![CDATA[
]]>
<![CDATA[        to set attributes of the newly created folder.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateFolderEx("NOINDEX", "", "", False)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SaveFolder()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create an IBM Content Manger folder based on the NOINDEX item type.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          The new folder has no parent and will be placed in the root directory.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateFolderEx("NOINDEX", "", "A1001001A14B04B12546D00215", True)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SaveFolder()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create an IBM Content Manger folder based on the NOINDEX item type.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          The folder will be placed inside the parent folder with ID=A1001001A14B04B12546D00215.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateFolderEx(@B.MyItemtye, @B.MyAttribute, @B.MyAttributeValue, True)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetAttributeValue("Name,@BATCHID")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SaveFolder()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create an IBM Content Manger folder based on the type identified by @B.MyItemType and]]>
<![CDATA[
]]>
<![CDATA[          will be a child of the folder identified by values from]]>
<![CDATA[
]]>
<![CDATA[          the batch level Smart Parameters @B.MyAttribute and @B.MyAttributeValue.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateFolderEx(@B.MyItemtye, "", "", False)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetAttributeValue("Name,"MyFolder1")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SaveFolder()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateFolderEx(@B.MyItemtye, "", "", True)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetAttributeValue("Name,"MyFolder2")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SaveFolder()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create folder "MyFolder1" and folder "MyFolder2" based on the type identified by @B.MyItemType.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          The folder "MyFolder1" folder has no parent. The parent of folder "MyFolder2" is folder "MyFolder1".]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
	</method>
	<method name="IBMCM_SaveFolder" qi="Saves folder data from memory to IBM Content Manager.">
		<ap>
<![CDATA[
]]>
<![CDATA[        None.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[        IBMCM_SaveFolder is used to save folder creation data to IBM Content Manager that was produced by the call to the IBMCM_CreateFolderEx action.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          IBMCM_CreateFolderEx("XYZ_ClaimFolder, "", "", False)]]>
				<br>
				</br>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetAttributeValue("XYZ_ClaimNumber, 12345")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
					<b>
<![CDATA[IBMCM_SaveFolder()]]>
					</b>
					<br>
					</br>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          The sequence creates a folder, assigns that folder with an attribute value of 12345 to the XYZ_ClaimNumber attribute]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ If the action successfully saves the folder]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the action is unable to save the folder.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="IBMCM_SetDestinationFolder" qi="Set the destination folder for uploading image files to IBM Content Manger repository.">
		<p name="attribute" type="string" qi="The attribute name.">
		</p>
		<p name="attributeValue" type="string" qi="The unique attribute value or folder ID.">
		</p>
		<ap>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[         If both parameters are not provided then destination folder will be set to the most recently created folder.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[         If folder ID is used in the second parameter, leave the first parameter empty ("").]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[         Smart parameters are supported. ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[       ]]>
		</ap>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the destination folder is successfully set.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[         The action fails if a folder with the specified attribute or ID is not found.]]>
<![CDATA[
]]>
<![CDATA[       ]]>
		</ret>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[        Sets the upload destination folder in IBM Content Manger repository.  To set the destination to a newly created]]>
<![CDATA[
]]>
<![CDATA[        folder, first create the folder using IBMCM_CreateFolder and then call IBMCM_SetDestinationFolder]]>
<![CDATA[
]]>
<![CDATA[        with empty ("") paramters.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SetDestinationFolder("Department", "Human Resource")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_CreateItem("NOINDEX")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetMimeType("image/tiff")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_UploadDCO_DOC()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will set the destination folder to the folder with attribute Department="Human Resource" to upload images to it.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SetDestinationFolder("", "A1001001A14B04B12546D00215")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_CreateItem("NOINDEX")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetMimeType("image/tiff")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_UploadDCO_DOC()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will set the destination folder to the folder with folder ID=A1001001A14B04B12546D00215 to upload images to it. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          IBMCM_CreateFolder("NOINDEX", "", "A1001001A14B04B12546D00215", true)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SetDestinationFolder("", "")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_CreateItem("NOINDEX")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetMimeType("image/tiff")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_UploadDCO_DOC()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will set the destination folder to the most recently created folder to upload images to it. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
	</method>
	<method name="IBMCM_SetDestinationFolderEx" qi="Set the destination folder for uploading image files to IBM Content Manger repository.">
		<p name="itemType" type="string" qi="The item type.">
		</p>
		<p name="attribute" type="string" qi="The attribute name.">
		</p>
		<p name="attributeValue" type="string" qi="The unique attribute value or folder ID.">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        If all parameters are not provided then destination folder will be set to the most recently created folder.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the destination folder is successfully set.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[        The action fails if a folder with the specified attribute or ID is not found.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[        Sets the upload destination folder in IBM Content Manger repository.  To set the destination to a newly created]]>
<![CDATA[
]]>
<![CDATA[        folder, first create the folder using IBMCM_CreateFolder and then call IBMCM_SetDestinationFolderEx]]>
<![CDATA[
]]>
<![CDATA[        with empty ("") paramters.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        IBMCM_SetDestinationFolderEx allows the application to specify an Attribute, Attribute value combination associated with a specific item type, whereas IBMCM_SetDestinationFolder only]]>
<![CDATA[
]]>
<![CDATA[        allowed an application to specify only an Attribute and Attribute value combination.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        IBMCM_SetDestinationFolderEx does not support specifying just an item ID, use IBMCM_SetDestinationFolder instead.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SetDestinationFolderEx("NOINDEX","SOURCE","Human Resource")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_CreateItem("NOINDEX")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetMimeType("image/tiff")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_UploadDCO_DOC()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will set the destination folder to the folder with attribute Department="Human Resource" to upload images to it.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
	</method>
	<method name="IBMCM_SetAttributeValue" qi="Sets the attribute value on an IBM Content Manager document or IBM Content Manager folder.">
		<p name="attributesvalues" type="string" qi="Sets the attribute value on an IBM Content Manager document or IBM Content Manager folder.">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        attributesvalues is a string value of two comma separated variables. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[Name :]]>
			</b>
<![CDATA[ The name of the attribute to set.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[Value :]]>
			</b>
<![CDATA[ The value of the attribute.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        An IBM Content Manager Item Type is equivalent to a Document Class (Index Class).]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported, such as @BATCHID, @ID, @STATUS, @TYPE, @VALUE,]]>
<![CDATA[
]]>
<![CDATA[        @JOBID, @JOBNAME, @OPERATOR, @STATION, @TASKID, @TASKNAME, etc.  Please refer to]]>
<![CDATA[
]]>
<![CDATA[        the smart parameter documentation for more information and usage.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[        Sets the attribute value on an IBM Content Manager document or folder.  The specified attribute must already]]>
<![CDATA[
]]>
<![CDATA[        be defined on the IBM Content Manager server.  The attribute can be applied to a document or to a folder.]]>
<![CDATA[
]]>
<![CDATA[        This action must follow a previous action that created or identified a folder or document.]]>
<![CDATA[
]]>
<![CDATA[        This action can be called multiple times to set multiple attributes of the same document or folder.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          IBMCM_CreateFolder("MyFolderItemType")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SetAttributeValue("Name,@BATCHID")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create an IBM Content Manager folder and then set the "Name" ]]>
<![CDATA[
]]>
<![CDATA[          property of the folder to the ID of the current batch.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          IBMCM_CreateItem("@B.name")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SetAttributeValue("Author,@D.TheAuthor")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SetAttributeValue("Date,@DATE")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          Assuming this is running on the document level, this will create a new document using the batch]]>
<![CDATA[
]]>
<![CDATA[          level value stored in the DCO variable "name" and set the "Author" attribute to the value stored]]>
<![CDATA[
]]>
<![CDATA[          in the DCO document level variable named "TheAuthor", then it stores the current date in the]]>
<![CDATA[
]]>
<![CDATA[          "Date" property.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          IBMCM_SearchItem("EmployeeID", "3F1234D")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SetAttributeValue("FirstName,Thomas")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will search the IBM Content Manager repository for an existing IBM Content Manager document with EmployeeID=3F1234D.]]>
<![CDATA[
]]>
<![CDATA[          If the existing IBM Content Manager document is found then its attribute "FirstName" will be set to "Thomas".]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[To set a DATE attribute, make sure the date value is in one of the date formats accepted by IBM Content Manager. ]]>
<![CDATA[
]]>
<![CDATA[        The valid date formats include: ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<ul>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA["yyyy-MM-dd"]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA["yyyy/MM/dd"]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA["MM-dd-yyyy"]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA["MM/dd/yyyy"]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
			</ul>
<![CDATA[
]]>
<![CDATA[        You can reformat a date field by calling Validations.IsFieldDateWithReformat on the current field.]]>
<![CDATA[
]]>
<![CDATA[        Note that the smart parameter @DATE defaults to using the "MM/dd/yyyy" format and does not need to be reformatted.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[            ]]>
				<b>
<![CDATA[IsFieldDateWithReformat("yyyy/MM/dd")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the attribute is successfully updated.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="IBMCM_SetChildAttributeValue" qi="Assigns a child attribute value for a child item. (child component attribute value)">
		<p name="Child Attribute Information" type="string" qi="A comma-separated string consisting of three values:         1) childItemName: Create a child component. Creates a child component specified by the childItemName, under the defined object type (IBMCM_CreateItem).         2) attributeName: The attribute name of the child         3) attributeValue: The attribute value ">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        IBMCM_CreateChildItem must be called prior.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        IBMCM_SetChildAttributeValue must be called the same number of times that is specified in IBMCM_CreateChildItem otherwise the child attributes will not be saved]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported. ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[        This action needs to be called after IBMCM_CreateItem.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateItem("ABCInsPlc")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_CreateChildItem("Automobiles,2")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetChildAttributeValue("Automobiles,ABCVIN,vin123")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetChildAttributeValue("Automobiles,ABCLicensePlate,carlic123")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_UploadDCO_DOC()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will create an IBM Content Manager Child Item based on the name Automobiles and assigns two attributes]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the child attribute value is set successfully.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="IBMCM_UploadDCO_Page" qi="Uploads Image files associated with the current Page object of the Document Hierarchy to IBM Content Manager.">
		<ap>
<![CDATA[
]]>
<![CDATA[        None.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[        Uploads the Image file associated with current Page object of the Document Hierarchy to the IBM Content Manager server. ]]>
<![CDATA[
]]>
<![CDATA[        Additionally, all attributes set using IBMCM_SetAttributeValue will also be persisted.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          IBMCM_Logon("cmserver,adminPWD,adminUID")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_CreateItem("NOINDEX")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetAttributeValue("USERID, @OPERATOR")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_UploadDCO_Page()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This sequence uploads Image files associated with the current Page object of the Document Hierarchy ]]>
<![CDATA[
]]>
<![CDATA[          to IBM Content Manager, and assigns the name of the object – the value of its Type property.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ If the action successfully sends the image to the server; ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if the action is unable to save the image.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="IBMCM_UploadDCO_DOC" qi="Uploads the set of Images files associated with the current document object of the Document Hierarchy to the IBM Content Manager server.">
		<ap>
<![CDATA[
]]>
<![CDATA[        None.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[        Uploads the Image file(s) associated with current Document object of the Document Hierarchy to IBM Content Manager server.]]>
			<b>
			</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          IBMCM_Logon("cmserver,adminPWD,adminUID")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_CreateItem("NOINDEX")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetAttributeValue("USERID, @OPERATOR")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetMimeType("image/tiff")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_UploadDCO_DOC()]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          This sequence uploads the set of Images files associated with the current document object ]]>
<![CDATA[
]]>
<![CDATA[          of the Document Hierarchy to the IBM Content Manager server.           ]]>
<![CDATA[
]]>
<![CDATA[          Additionally, all attributes set using IBMCM_SetAttributeValue will also be persisted.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Document level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the document is successfully created.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="IBMCM_StoreItemIDinDCO" qi="Stores the Item ID of the most recently created folder or most recently uploaded IBM Content Manager item into a variable of the current object of the Document Hierarchy.">
		<p name="itemID" type="string" qi="Sets the attribute value on a CM document or folder.">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        Stores the Item ID of the most recently created folder or most recently uploaded ]]>
<![CDATA[
]]>
<![CDATA[        IBM Content Manager document into a variable of the current object of the DCO Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[        If the variable does not exist, it will be created on the current DCO Hierarchy object.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        It may be useful to store the item ID if the object needs to be referenced in following action, ]]>
<![CDATA[
]]>
<![CDATA[        such as setting the upload destination directory.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        IBMCM_CreateFolder("NOINDEX", "", "", False)]]>
				<br>
				</br>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[IBMCM_StoreItemIDinDCO("ItemID")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        The action above stores the ID of the new IBM Content Manger folder in a variable called “ItemID” in the current object of the DCO Hierarchy.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[        IBMCM_CreateItem("NOINDEX")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        IBMCM_SetMimeType("image/tiff")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        IBMCM_UploadDCO_DOC()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[IBMCM_StoreItemIDinDCO("ItemID")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        The action above stores the ID of the new IBM Content Manger document in a variable called “ItemID” in the current object of the DCO Hierarchy.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the Item ID is returned successfully, otherwise ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="IBMCM_SearchItem" qi="Search for the existing item in IBM Content Manger repository.">
		<p name="attribute" type="string" qi="The attribute name.">
		</p>
		<p name="attributeValue" type="string" qi="The unique attribute value or item ID.">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        Both attribute and attributeValue are required parameters.]]>
<![CDATA[
]]>
<![CDATA[        If item ID is used in the second parameter, leave the first parameter empty ("").]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the item is found.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[        Searches for the existing item in IBM Content Manger repository that matches the specified attribute and value.]]>
<![CDATA[
]]>
<![CDATA[        If an item is found, the current item will be set to it.  Otherwise the current item will be set to NULL.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        See ]]>
			<B>
<![CDATA[IBMCM_SetSearchOnlyFolderItems]]>
			</B>
<![CDATA[ action to specify whether to search for folder items only. ]]>
<![CDATA[
]]>
<![CDATA[        By default, ]]>
			<b>
<![CDATA[IBMCM_SearchItem]]>
			</b>
<![CDATA[ searches only folder items.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        IBMCM_SearchItem is used to retrieve a existing IBM Content Manger item before calling other actions to update its attributes]]>
<![CDATA[
]]>
<![CDATA[        or its content such as IBMCM_AddPages, IBMCM_DeletePages, IBMCM_ReplacePage, IBMCM_SetAttributeValue....]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SearchItem("Department", "Human Resource")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetAttributeValue("Department", "Operations")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will search for a folder item with attribute Department="Human Resource" and change to "Operations".]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetSearchOnlyFolderItems("False")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SearchItem("", "A1001001A14B04B12546D00215")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will search for a folder item or a non-folder item with the item ID: A1001001A14B04B12546D00215. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetSearchOnlyFolderItems("True")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SearchItem("", "@P.PageName")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will search only for a folder item with item ID derived from a predefined smart parameter, @P.PageName.]]>
<![CDATA[
]]>
<![CDATA[          The ]]>
				<B>
<![CDATA[VScan.Scan]]>
				</B>
<![CDATA[ action populates ]]>
				<b>
<![CDATA[@P.PageName]]>
				</b>
<![CDATA[ to be the filename of the image file without the file extension.]]>
<![CDATA[
]]>
<![CDATA[          For example, the image file A1001001A17E08B00210C00000.tif will have a PageName of "A1001001A17E08B00210C00000".]]>
<![CDATA[
]]>
<![CDATA[          This smart parameter can be used to identify the CM8 item ID if the image file name conforms to the convention.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
	</method>
	<method name="IBMCM_SearchAndDownload" qi="Search and download item content from IBM Content Manger repository.">
		<ret>
<![CDATA[
]]>
<![CDATA[              ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if any error occurred during parameter validation or searching or downloading.]]>
<![CDATA[
]]>
<![CDATA[              Otherwise, ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
		</ret>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[              Searches for items in IBM Content Manger repository that matches the specified search criteria from the ]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<b>
<![CDATA[IBMCM_SetSearchAndDownloadCriteria]]>
			</b>
<![CDATA[ action.]]>
<![CDATA[
]]>
<![CDATA[              For each matching item found, if the corresponding ICMBase parts have content, ]]>
<![CDATA[
]]>
<![CDATA[              the content file will be written to the directory set from ]]>
			<b>
<![CDATA[IBMCM_SetSearchAndDownloadDirectory]]>
			</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[              The output file name will be the CM8 item ID, and the file extension will be the same as the original file extension.]]>
<![CDATA[
]]>
<![CDATA[              If the original file did not have a file extension, the default extension will be ".tif". ]]>
<![CDATA[
]]>
<![CDATA[              If the file already exists, it will be overwritten.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              To limit the number of downloads for each IBMCM_SearchAndDownload action, you can set a limit with ]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<b>
<![CDATA[IBMCM_SetSearchAndDownloadMaximum]]>
			</b>
<![CDATA[ action. The default maximum is 1000. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              To add sorting, call ]]>
			<b>
<![CDATA[IBMCM_SetSearchAndDownloadSort]]>
			</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              To update a download status attribute for the downloaded item, call ]]>
			<b>
<![CDATA[IBMCM_SetSearchAndDownloadStatusAttribute]]>
			</b>
<![CDATA[ action.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              After ]]>
			<b>
<![CDATA[IBMCM_SearchAndDownload]]>
			</b>
<![CDATA[ has downloaded the CM8 content files, ]]>
			<b>
<![CDATA[scan()]]>
			</b>
<![CDATA[ action can be called ]]>
<![CDATA[
]]>
<![CDATA[              to read the files from the same directory.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              ]]>
			<b>
<![CDATA[Important:]]>
			</b>
<![CDATA[ to prevent downloading duplicate item content, the task that calls IBMCM_SetSearchAndDownload action should not]]>
<![CDATA[
]]>
<![CDATA[              be run in a multi-threaded configuration. Instead, use single-threaded tasks. ]]>
<![CDATA[
]]>
<![CDATA[              For information about configuring threads in Rulerunner, see Configuring Rulerunner to run tasks.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              ]]>
			<e>
<![CDATA[
]]>
<![CDATA[                      IBMCM_SetSearchAndDownloadCriteria("APT",,,,)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                      IBMCM_SetSearchAndDownloadMaximum("100")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                      IBMCM_SetSearchAndDownloadDirectory("C:\datacap\APT\images\input")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                      IBMCM_SetSearchAndDownloadSort("True","Date","ASCENDING")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                      IBMCM_SetSearchAndDownloadStatusAttribute("DCStatus")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                      ]]>
				<b>
<![CDATA[IBMCM_SearchAndDownload()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                      SetSourceDirectory("C:\datacap\APT\images\input")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                      Scan()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[              ]]>
			</e>
<![CDATA[
]]>
<![CDATA[              This example will search and download up to 100 APT CM items' content to the directory, C:\datacap\APT\images\input. ]]>
<![CDATA[
]]>
<![CDATA[              The CM query syntax is "/APT [ICMPARTS AND (@DCStatus IS NULL OR @DCStatus=0)] SORTBY(@Date ASCENDING)". ]]>
<![CDATA[
]]>
<![CDATA[              Each item content will have the item ID as the file name. For example, A1001001A17E08B00210C00000.tif. ]]>
<![CDATA[
]]>
<![CDATA[              When the scan() action runs, it will see the populated image directory and process as usual.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[          ]]>
		</h>
		<see>
<![CDATA[
]]>
<![CDATA[              IBMCM_SetSearchAndDownloadCriteria]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              IBMCM_SetSearchAndDownloadDirectory]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              IBMCM_SetSearchAndDownloadMaximum]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              IBMCM_SetSearchAndDownloadSort]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              IBMCM_SetSearchAndDownloadStatusAttribute]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              Scan]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[          ]]>
		</see>
	</method>
	<method name="IBMCM_AddPages" qi="Add new page(s) to the existing document in IBM Content Manger repository. The new page(s) will be appended to the existing page(s) in the IBM Content Manger document.">
		<p name="newPage" type="int" qi="The new page to add.">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        newPage is required when calling the action at document level.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        If newPage = 0, all new pages in the runtime DCO will be added to the existing IBM Content Manger document.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        If newPage > 0, only the new page specified by newPage is added.]]>
<![CDATA[
]]>
<![CDATA[       ]]>
		</ap>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the new page(s) is added.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
		<lvl>
<![CDATA[Doc and page level.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[        Need to retrieve the existing IBM Content Manger document from IBM Content Manger repository before calling this action to add new page(s) to it.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        The IBMCM_SearchItem action can be used to retrieve the existing IBM Content Manger document. ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          IBMCM_SearchItem("", "A1001001A14B04B12546D00215")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_AddPages(2)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will search the IBM Content Manger repository for the existing IBM Content Manger document with unique ID=A1001001A14B04B12546D00215.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          If the existing IBM Content Manger document is found, it will add the second page (TM000002) in the runtime Document DCO to the existing IBM Content Manger document.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          IBMCM_SearchItem("EmployeeID", "14B04B12")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_AddPages(0)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will search the IBM Content Manger repository for the existing IBM Content Manger document with unique attribute EmployeeID=14B04B12.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          If the existing IBM Content Manger document is found, it will add all new pages in the runtime Document DCO to the existing IBM Content Manger document. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
	</method>
	<method name="IBMCM_DeletePages" qi="Delete page(s) from an existing document in IBM Content Manger repository.">
		<p name="existingPage" type="int" qi="The existing page to be deleted.  This parameter is required.">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        existingPage is required when calling the action at document level.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        If existingPage = 0, all existing pages in the IBM Content Manger document will be deleted.  Otherwise, only the existing page specified by existingPage will be deleted.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the page(s) is deleted.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[        Need to retrieve the existing IBM Content Manger document from IBM Content Manger repository before calling this action to delete page(s) from it.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        The IBMCM_SearchItem action can be used to retrieve the existing IBM Content Manger document. ]]>
			<br>
			</br>
<![CDATA[ ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[Important Notes:]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        Be careful with this destructive action.  It should be used at the batch level to make sure it will be executed once per batch.]]>
<![CDATA[
]]>
<![CDATA[        If you need to use it at the document or page level, make sure you set filters/conditions to avoid this action being called repeatly.]]>
			<br>
			</br>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          IBMCM_SearchItem("EmployeeID", "14B04B12")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_DeletePages(2)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will search the IBM Content Manger repository for the existing IBM Content Manger document with unique attribute EmployeeID=14B04B12.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          If the existing IBM Content Manger document is found, it will delete the second page from the IBM Content Manger document. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          IBMCM_SearchItem("EmployeeID", "14B04B12")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_DeletePages(0)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will search the IBM Content Manger repository for the existing IBM Content Manger document with unique attribute EmployeeID=14B04B12.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          If the existing IBM Content Manger document is found, it will delete all existing pages from the IBM Content Manger document. ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
	</method>
	<method name="IBMCM_ReplacePage" qi="Replace an existing page in the IBM Content Manger document with a new page in the runtime DCO hierarchy.">
		<p name="existingPage" type="int" qi="The existing page in IBM Content Manger document.">
		</p>
		<p name="newPage" type="int" qi="The new page in runtime DCO hierarchy.">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        When calling at document level, both existingPage and newPage parameter are required.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        When calling at page level, the newPage parameter is ignored.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the existing page in IBM Content Manger document is replaced with the new page in runtime DCO.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
		<lvl>
<![CDATA[Document and page level.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[        Need to retrieve the existing IBM Content Manger document from IBM Content Manger repository before calling this action.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        The IBMCM_SearchItem action can be used to retrieve the existing IBM Content Manger document. ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          IBMCM_SearchItem("EmployeeID", "14B04B12")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_ReplacePage(2,3)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will search the IBM Content Manger repository for the existing IBM Content Manger document with unique attribute EmployeeID=14B04B12. ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          If the existing IBM Content Manger document is found, it will replace the second page in the existing IBM Content Manger document with the third page (TM000003) in the runtime Document DCO.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
	</method>
	<method name="IBMCM_SetMimeType" qi="Set mime type for upload document.">
		<p name="mimeType" type="string" qi="Mime type.">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        Smart parameter is supported.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the mime type is successfully set.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[        Set the mime type for upload document.  This action is needed when uploading non-tiff files.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        When calling at batch/document level, the same mime type will be applied to all files in the batch/document DCO. ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        This action needs to be called prior to the document and page upload actions.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<table>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<th>
<![CDATA[MIME Types]]>
						</th>
<![CDATA[
]]>
<![CDATA[              ]]>
						<th>
<![CDATA[File Extensions]]>
						</th>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[application/msword]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[doc, dot, rtf]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[application/octet-stream]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[bin, dms, lha, lzh, exe, class]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[application/pdf]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[pdf]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[application/rtf]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[rtf]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[application/lotus-1-2-3]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[123, wk4, wk3, wk1, wks, wg1]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[application/lotus-freelance]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[prz, pre]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[application/vnd.ms-excel]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[xls, xlt, xlm, xld, xla, xlc, xlw, xll]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[application/vnd.ms-powerpoint]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[ppt, pot, ppa, pps, pwz]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[application/vnd.visio]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[vsd]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[audio/basic]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[au, snd, ulw]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[audio/mpeg]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[mpeg, mpg, m1s, m1a, mp2, mp3, mpm, mpa, mpga]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[audio/x-aiff]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[aif, aiff, aifc]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[audio/x-midi]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[midi, mid, smf, kar]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[audio/x-wav]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[wav]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[image/bmp]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[bmp, dib]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[image/gif]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[gif]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[image/jpeg]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[jpeg, jpg, jpe, jfif, pjpeg, pjp]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[image/gif]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[gif]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[image/tiff]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[tiff, tif]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[text/html]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[html, htm, shtml, plg]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[text/plain]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[txt, text]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[text/xml]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[xml, dtd]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[video/mpeg]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[mpeg, mpg, mpe, m1s, m1v, m1a, m75, m15, mp2]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[            ]]>
					<tr>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[video/quicktime]]>
						</td>
<![CDATA[
]]>
<![CDATA[              ]]>
						<td>
<![CDATA[mov, qt]]>
						</td>
<![CDATA[
]]>
<![CDATA[            ]]>
					</tr>
<![CDATA[
]]>
<![CDATA[          ]]>
				</table>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[         ]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SetMimeType("image/tiff")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          This example will set mime type to "image/tiff".]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
	</method>
	<method name="IBMCM_SetSearchOnlyFolderItems" qi="Prepares the IBMCM_SearchItem action whether to limit the searches to only folder items.">
		<p name="strParam" type="string" qi="True or False">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[              A string or smart parameter value "True" or "False" whether the subsequent IBMCM_SearchItem actions ]]>
<![CDATA[
]]>
<![CDATA[              will limit the result to folder items. Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
		</ap>
		<ret>
<![CDATA[
]]>
<![CDATA[              ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if parameter is not a string. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[          ]]>
		</ret>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[              If "True", the subsequent IBMCM_SearchItem actions will only search for folder items.]]>
<![CDATA[
]]>
<![CDATA[              If "False", the subsequent IBMCM_SearchItem actions will search for all items that match the search criteria.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              If this action is not called or the parameter is not "True" or "False", the default value of "True" will be used, and IBMCM_SearchItem actions will only return folder items. This action should be called before IBMCM_SearchItem.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              ]]>
			<e>
<![CDATA[
]]>
<![CDATA[                  ]]>
				<b>
<![CDATA[IBMCM_SetSearchOnlyFolderItems("False")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                  IBMCM_SearchItem("", "A1001001A17E08B00210C00000")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[              ]]>
			</e>
<![CDATA[
]]>
<![CDATA[              This example will search for an item with item ID A1001001A17E08B00210C00000.]]>
<![CDATA[
]]>
<![CDATA[              If an item is found, regardless of whether it is a folder item or not,]]>
<![CDATA[
]]>
<![CDATA[              the current item will be set to it. ]]>
<![CDATA[
]]>
<![CDATA[              Otherwise if the item is not found, ]]>
<![CDATA[
]]>
<![CDATA[              the current item will be set to NULL. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              ]]>
			<e>
<![CDATA[
]]>
<![CDATA[                  ]]>
				<b>
<![CDATA[IBMCM_SetSearchOnlyFolderItems("True")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                  IBMCM_SearchItem("", "@P.PageName")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[              ]]>
			</e>
<![CDATA[
]]>
<![CDATA[              This example will search only for a folder item.]]>
<![CDATA[
]]>
<![CDATA[              If a folder item is found, the current item will be set to it.]]>
<![CDATA[
]]>
<![CDATA[              Otherwise if the item is not found or the item is not a folder item,]]>
<![CDATA[
]]>
<![CDATA[              the current item will be set to NULL. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              This example also demonstrates the use of the predefined smart parameter @PageName. ]]>
<![CDATA[
]]>
<![CDATA[              The VScan.Scan action populates @P.PageName to be the filename of the image file without the file extension. ]]>
<![CDATA[
]]>
<![CDATA[              For example, the image file A1001001A17E08B00210C00000.tif will have a PageName of "A1001001A17E08B00210C00000". This smart parameter can be used to identify the CM8 item ID if the image file name conforms to the convention.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
		</h>
	</method>
	<method name="IBMCM_SetSearchAndDownloadCriteria" qi="Sets the search criteria for IBMCM_SearchAndDownload action.">
		<p name="itemType" type="string" qi="Name of the item type">
		</p>
		<p name="attributeName" type="string" qi="Name of the attribute">
		</p>
		<p name="comparisonOperator" type="string" qi="Comparison operator">
		</p>
		<p name="attributeValue" type="string" qi="Comparison value of the attribute">
		</p>
		<p name="dataType" type="string" qi="Data type of the attribute">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[Item type name]]>
			</b>
<![CDATA[ is mandatory. The search will be limited to the specified item type.]]>
<![CDATA[
]]>
<![CDATA[        The rest of the parameters are optional. If they are not provided, ]]>
<![CDATA[
]]>
<![CDATA[        then the search will return all items from the specified item type.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        If the ]]>
			<b>
<![CDATA[attribute name]]>
			</b>
<![CDATA[ is specified, the item attribute must exist in the IBM Content Manager repository schema.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        If the ]]>
			<b>
<![CDATA[comparison operator]]>
			</b>
<![CDATA[ is not specified, but the attribute name and value are specified,]]>
<![CDATA[
]]>
<![CDATA[          then the comparisonOperator defaults to the equal operator, "=". Supported comparison operators are:]]>
<![CDATA[
]]>
<![CDATA[          "=","]]>
<![CDATA[<]]>
<![CDATA[","]]>
<![CDATA[<]]>
<![CDATA[=","]]>
<![CDATA[>]]>
<![CDATA[","]]>
<![CDATA[>]]>
<![CDATA[=","!=","LIKE","NOT LIKE","IS NULL","IS NOT NULL","IN","NOT IN".]]>
<![CDATA[
]]>
<![CDATA[          ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        The ]]>
			<b>
<![CDATA[comparison value of the attribute]]>
			</b>
<![CDATA[ is mandatory if the ]]>
			<b>
<![CDATA[attribute name]]>
			</b>
<![CDATA[ is specified.]]>
<![CDATA[
]]>
<![CDATA[        For "IS NULL" and "IS NOT NULL" operations, the attribute value and the data type are ignored. ]]>
<![CDATA[
]]>
<![CDATA[        For "LIKE" and "NOT LIKE" operations, the attribute value should include the wildcard character "%".]]>
<![CDATA[
]]>
<![CDATA[        For "IN" and "NOT IN" operations, the attribute value should be enclosed in parentheses "()" and delimited by commas. See examples below.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        The ]]>
			<b>
<![CDATA[data type of the attribute]]>
			</b>
<![CDATA[ is optional. Supported data types are: "STRING", "DATE", "NUMBER".]]>
<![CDATA[
]]>
<![CDATA[        The default is "STRING".]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for all parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if parameters are not strings or parameter validations failed. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[          Some parameter validations are done in this action, others are done in the IBMCM_SearchAndDownload() action.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[        The parameters will be used in IBMCM_SearchAndDownload action to construct the IBM Content Manager query. ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        If this action is not called and the search criteria has not been set before IBMCM_SearchAndDownload(), ]]>
<![CDATA[
]]>
<![CDATA[        IBMCM_SearchAndDownload() will return False. This action should be called before IBMCM_SearchAndDownload.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SetSearchAndDownloadCriteria("APT",,,,)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetSearchAndDownloadMaximum("100")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetSearchAndDownloadDirectory("C:\datacap\APT\images\input")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SearchAndDownload()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[        This example will search and download up to 100 APT CM items' content to the directory, C:\datacap\APT\images\input, with no sorting.]]>
<![CDATA[
]]>
<![CDATA[        The CM query syntax is "/APT [ICMPARTS]". Each item content will have the item ID as the file name. ]]>
<![CDATA[
]]>
<![CDATA[        For example, A1001001A17E08B00210C00000.tif]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[IBMCM_SetSearchAndDownloadCriteria("APT", "APT_Flag","=","NA",)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetSearchAndDownloadDirectory("@APPPATH(vscanimagedir)")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetSearchAndDownloadSort("False",,)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SearchAndDownload()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[        This example will search and download up to the default maximum number of APT CM items' ]]>
<![CDATA[
]]>
<![CDATA[        content that have not been processed by Datacap into the Smart Parameter VScan image directory. ]]>
<![CDATA[
]]>
<![CDATA[        The CM query syntax is "/APT[ICMPARTS AND @APT_Flag="NA"]". Each item content will have the item ID as the file name. ]]>
<![CDATA[
]]>
<![CDATA[        The file extension will be the same as the file extension of the original file.]]>
<![CDATA[
]]>
<![CDATA[        For example, A1001001A17E08B00210C00000.jpg]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[IBMCM_SetSearchAndDownloadCriteria("APT", "Quantity",">","5", "NUMBER")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[IBMCM_SetSearchAndDownloadCriteria("APT", "DCStatus","IS NULL",,)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[IBMCM_SetSearchAndDownloadCriteria("APT", "DCStatus","LIKE","start%",)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[IBMCM_SetSearchAndDownloadCriteria("APT", "DCStatus","IN","("started","stopped")",)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[IBMCM_SetSearchAndDownloadCriteria("APT", "Date",">","2017-01-01","DATE")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[          These are usage examples of the supported data type and comparison operators.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
	</method>
	<method name="IBMCM_SetSearchAndDownloadDirectory" qi="Sets the download directory for SearchAndDownload action.">
		<p name="path" type="string" qi="The directory where the downloaded files will reside">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        The parameter will be used as the download directory in ]]>
			<B>
<![CDATA[IBMCM_SearchAndDownload]]>
			</B>
<![CDATA[ action. ]]>
<![CDATA[
]]>
<![CDATA[        The output directory is mandatory. You must verify that the directory is valid and has write permissions.]]>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<ret>
<![CDATA[
]]>
<![CDATA[            ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if parameter is a string. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[ The directory will not be verified until the ]]>
<![CDATA[
]]>
<![CDATA[            ]]>
			<b>
<![CDATA[IBMCM_SearchAndDownload]]>
			</b>
<![CDATA[ attempts to write to the directory.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
		</ret>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[        If this action is not called and the download directory has not been set before IBMCM_SearchAndDownload(), ]]>
<![CDATA[
]]>
<![CDATA[        IBMCM_SearchAndDownload() will return False. This action must be called before IBMCM_SearchAndDownload to set the output directory.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetSearchAndDownloadCriteria("APT",,,)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetSearchAndDownloadMaximum("100")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SetSearchAndDownloadDirectory("C:\datacap\APT\images\input")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SearchAndDownload()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[        This example will search and download up to 100 APT CM items' content to the directory, C:\datacap\APT\images\input.]]>
<![CDATA[
]]>
<![CDATA[        The CM query syntax is "/APT [ICMPARTS] SORTBY(@ITEMID ASCENDING)". Each item content will have the item ID as the file name. ]]>
<![CDATA[
]]>
<![CDATA[        For example, A1001001A17E08B00210C00000.tif]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetSearchAndDownloadCriteria("APT", "APT_Flag","=","NA")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SetSearchAndDownloadDirectory("@APPPATH(vscanimagedir)")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetSearchAndDownloadSort("True","Date","ASCENDING")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SearchAndDownload()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[        This example will search and download up to the default maximum number of APT CM items' ]]>
<![CDATA[
]]>
<![CDATA[        content that have not been processed by Datacap into the Smart Parameter VScan image directory. ]]>
<![CDATA[
]]>
<![CDATA[        The CM query syntax is "/APT[ICMPARTS AND @APT_Flag="NA"] SORTBY(@Date ASCENDING)". Each item content will have the item ID as the file name. The file extension will be the same as the file extension of the original file.]]>
<![CDATA[
]]>
<![CDATA[        For example, A1001001A17E08B00210C00000.jpg]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
		</h>
	</method>
	<method name="IBMCM_SetSearchAndDownloadMaximum" qi="Sets the maximum number of downloads for SearchAndDownload action.">
		<p name="strParm" type="string" qi="The maximum number of downloads">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        The strParm sets the maximum number of downloads in the ]]>
			<b>
<![CDATA[IBMCM_SearchAndDownload]]>
			</b>
<![CDATA[ action. ]]>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<ret>
<![CDATA[
]]>
<![CDATA[             ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if parameter is a number. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[         ]]>
		</ret>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[        If this action is not called and the download maximum has not been set before IBMCM_SearchAndDownload(), ]]>
<![CDATA[
]]>
<![CDATA[        IBMCM_SearchAndDownload() will use the default maximum, which is 1000. Specify a number less than 1 to have no maximum, and IBMCM_SearchAndDownload() will return all matching items.]]>
<![CDATA[
]]>
<![CDATA[        This action should be called before IBMCM_SearchAndDownload to change the maximum download.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetSearchAndDownloadCriteria("APT",,,)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[IBMCM_SetSearchAndDownloadMaximum("100")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SetSearchAndDownloadDirectory("C:\datacap\APT\images\input")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          IBMCM_SearchAndDownload()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[        This example will search and download up to 100 APT CM items' content to the directory, C:\datacap\APT\images\input.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          IBMCM_SearchAndDownload()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[        Since this action was not called, the default maximum will be used. This example will search and download up to 1000 of content matching the IBMCM_SetSearchAndDownloadCriteria parameters. ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[            ]]>
				<b>
<![CDATA[IBMCM_SetSearchAndDownloadMaximum("0")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[            IBMCM_SearchAndDownload()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[            Since the maximum is zero, there will not be a limit to the search. This example will search and download all]]>
<![CDATA[
]]>
<![CDATA[            content matching the IBMCM_SetSearchAndDownloadCriteria parameters.]]>
<![CDATA[
]]>
<![CDATA[            ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
		</h>
	</method>
	<method name="IBMCM_SetSearchAndDownloadSort" qi="Sets the sortby and sort order for SearchAndDownload action.">
		<p name="doSort" type="string" qi="True or False to sort">
		</p>
		<p name="sortBy" type="string" qi="Item attribute name to sort by">
		</p>
		<p name="sortOrder" type="string" qi="Sort order ASCENDING or DESCENDING">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[              The ]]>
			<b>
<![CDATA[doSort]]>
			</b>
<![CDATA[ parameter takes "True" or "False" and determines whether to sort the search results ]]>
<![CDATA[
]]>
<![CDATA[              during the ]]>
			<b>
<![CDATA[IBMCM_SearchAndDownload]]>
			</b>
<![CDATA[ action.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              The ]]>
			<b>
<![CDATA[sortBy]]>
			</b>
<![CDATA[ parameter is the name of the item attribute to sort by. The item attribute must exist in the CM8 repository schema.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              The ]]>
			<b>
<![CDATA[sortOrder]]>
			</b>
<![CDATA[ parameter takes "ASCENDING" or "DESCENDING" and determines the sort order of the sort by attribute.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              Smart parameters are supported for all parameters.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
		</ap>
		<ret>
<![CDATA[
]]>
<![CDATA[              ]]>
			<b>
<![CDATA[False,]]>
			</b>
<![CDATA[ if parameters are missing or invalid. Otherwise, ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[          ]]>
		</ret>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[              If this action is not called and the sort information has not been set before IBMCM_SearchAndDownload(),]]>
<![CDATA[
]]>
<![CDATA[              IBMCM_SearchAndDownload() will not sort the returned results.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              This action should be called before IBMCM_SearchAndDownload to change the sort information.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<e>
<![CDATA[
]]>
<![CDATA[                  IBMCM_SetSearchAndDownloadCriteria("APT","Date","IS NULL",)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                  IBMCM_SetSearchAndDownloadMaximum("100")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                  IBMCM_SetSearchAndDownloadDirectory("C:\datacap\APT\images\input")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                  ]]>
				<b>
<![CDATA[IBMCM_SetSearchAndDownloadSort("True","Date","ASCENDING")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                  IBMCM_SearchAndDownload()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[              ]]>
			</e>
<![CDATA[
]]>
<![CDATA[              This example will search and download up to 100 APT CM items' content to the directory, C:\datacap\APT\images\input, sorted by the "Date" attribute in ascending order.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              ]]>
			<e>
<![CDATA[
]]>
<![CDATA[                  IBMCM_SearchAndDownload()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[              ]]>
			</e>
<![CDATA[
]]>
<![CDATA[              Since this action was not called, no sorting will be done. This example will search and download]]>
<![CDATA[
]]>
<![CDATA[              content matching the IBMCM_SetSearchAndDownloadCriteria parameters.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
		</h>
	</method>
	<method name="IBMCM_SetSearchAndDownloadStatusAttribute" qi="Sets the status attribute to update after a successful SearchAndDownload action.">
		<p name="checkStatus" type="string" qi="True or False whehter to add checking for download status">
		</p>
		<p name="attributeName" type="string" qi="The Datacap download status attribute name">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[              The ]]>
			<b>
<![CDATA[checkStatus]]>
			</b>
<![CDATA[ parameter takes "True" or "False" and determines whether to check the download status]]>
<![CDATA[
]]>
<![CDATA[              of an item during the ]]>
			<b>
<![CDATA[IBMCM_SearchAndDownload]]>
			</b>
<![CDATA[ action.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              The ]]>
			<b>
<![CDATA[attribute]]>
			</b>
<![CDATA[ must exist and must be defined for the SearchAndDownload item type as a short integer, ]]>
<![CDATA[
]]>
<![CDATA[              with no default. The attribute name is case-sensitive and must be the same as defined in the CM8 System Administration Client.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              The default behavior is ]]>
			<b>
<![CDATA[IBMCM_SetSearchAndDownloadStatusAttribute("False",).]]>
			</b>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[              Setting a status attribute is not required for the ]]>
			<B>
<![CDATA[IBMCM_SearchAndDownload]]>
			</B>
<![CDATA[ action.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
		</ap>
		<ret>
<![CDATA[
]]>
<![CDATA[              ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if parameters are string. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[ The attribute will not be verified until the]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<b>
<![CDATA[IBMCM_SearchAndDownload]]>
			</b>
<![CDATA[ attempts to update the status attribute value.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
		</ret>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<h>
<![CDATA[
]]>
<![CDATA[              The status attribute will be used two times during the ]]>
			<B>
<![CDATA[IBMCM_SearchAndDownload]]>
			</B>
<![CDATA[ action. ]]>
<![CDATA[
]]>
<![CDATA[              First, the search criteria will be appended to search for the attribute being 0 or NULL. ]]>
<![CDATA[
]]>
<![CDATA[              Second, when an item has been downloaded, the attribute will be updated to 1.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              Having a status attribute for the download is beneficial to avoid downloading duplicates with the]]>
<![CDATA[
]]>
<![CDATA[              same search criteria between batches.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              ]]>
			<e>
<![CDATA[
]]>
<![CDATA[                  IBMCM_SetSearchAndDownloadCriteria("APT",,,,)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                  IBMCM_SetSearchAndDownloadMaximum("100")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                  IBMCM_SetSearchAndDownloadDirectory("C:\datacap\APT\images\input")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                  ]]>
				<b>
<![CDATA[IBMCM_SetSearchAndDownloadStatusAttribute("True", "DCStatus")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                  IBMCM_SearchAndDownload()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[              ]]>
			</e>
<![CDATA[
]]>
<![CDATA[              In this example, the CM query syntax is "/APT [ICMPARTS AND (@DCStatus IS NULL OR @DCStatus=0)] ".]]>
<![CDATA[
]]>
<![CDATA[              During each bach, 100 items will be downloaded and their attributes changed to @DCStatus=1.]]>
<![CDATA[
]]>
<![CDATA[              Subsequent batches using the ]]>
			<b>
<![CDATA[IBMCM_SearchAndDownload]]>
			</b>
<![CDATA[ action will not return any items that have already been downloaded, since]]>
<![CDATA[
]]>
<![CDATA[              the DCStatus is no longer null.]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<e>
<![CDATA[
]]>
<![CDATA[                  IBMCM_SetSearchAndDownloadCriteria("APT","Date","]]>
<![CDATA[<]]>
<![CDATA[","2017-01-01","DATE")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                  ]]>
				<b>
<![CDATA[IBMCM_SetSearchAndDownloadStatusAttribute("True","DCStatus")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                  IBMCM_SearchAndDownload()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[              ]]>
			</e>
<![CDATA[
]]>
<![CDATA[              In this example, the CM query syntax is "/APT [ICMPARTS AND @Date ]]>
<![CDATA[<]]>
<![CDATA[ "2017-01-01" AND (@DCStatus IS NULL OR @DCStatus=0)] ".]]>
<![CDATA[
]]>
<![CDATA[              ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[              ]]>
			<e>
<![CDATA[
]]>
<![CDATA[                  IBMCM_SetSearchAndDownloadCriteria("APT","APT_Date","]]>
<![CDATA[<]]>
<![CDATA[","2017-01-01","DATE")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                  ]]>
				<b>
<![CDATA[IBMCM_SetSearchAndDownloadStatusAttribute("False",)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[                  IBMCM_SearchAndDownload()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[              ]]>
			</e>
<![CDATA[
]]>
<![CDATA[              In this example, the CM query syntax is "/APT [ICMPARTS AND @APT_Date ]]>
<![CDATA[<]]>
<![CDATA[ "2017-01-01"] ".]]>
<![CDATA[
]]>
<![CDATA[              No checking is done whether the item has been downloaded by Datacap before. Unless you do want to be able to download items]]>
<![CDATA[
]]>
<![CDATA[              that have been downloaded by Datacap before, we recommend that the application]]>
<![CDATA[
]]>
<![CDATA[              call ]]>
			<b>
<![CDATA[IBMCM_SetAttributeValue()]]>
			</b>
<![CDATA[ to update the @APT_Date value to prevent the item from matching the criteria ]]>
<![CDATA[
]]>
<![CDATA[              next time.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
	</method>
</net>
</rrx>
<rrx namespace="dcclip" src="c:\datacap\RRS\dcclip.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="dci_clipfield" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ 'During processing, clips the field on the Image file (.tif) of every source page represented by the bound Field object of the Document Hierarchy and generates a separate Image file (.tif) displaying the clipped field's contents. "]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   Two comma-separated string values:<br/>]]>
<![CDATA[
]]>
<![CDATA[ '   <b>1.</b> The Page Type that is to be assigned to the Image file containing the clipped field and its value. <b>Remember!</b>  The new Image file is represented by a new page in the current Page file.  The Page Type value you assign will be used to identify pages with clipped fields.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[ '   <b>2.</b> The Page Status to be assigned to pages with clipped images of the bound Field object of the Document Hierarchy. <b>Alert!</b> Be sure that the status you assign conforms to Page Status specifications used throughout your application.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   Both values will be picked up by the Page file (.xml) generated by the RuleRunner task that applies a rule containing this action.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  dci_clipfield = False ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim arParam ]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim arPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim L,T,R,B]]>
<![CDATA[
]]>
<![CDATA[  Dim PageObj]]>
<![CDATA[
]]>
<![CDATA[  Dim DocObj]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  arparam = split(strParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If(UBound(arParam) <> 1) Then]]>
<![CDATA[
]]>
<![CDATA[    writelog("Parameter should be comma delimited: (pagetype,pagestatus)")]]>
<![CDATA[
]]>
<![CDATA[    exit function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if ("" = Trim(arParam(0))) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Page type must not be blank")]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if ("" = Trim(arParam(1))) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Page status must not be blank")]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if (not IsNumeric(Trim(arParam(1)))) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Page status must be numeric.  Value: '" & arParam(1) & "'.")]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  writelog("Page type: '" & Trim(arParam(0)) & "'.  Page Status: '" & Trim(arParam(1)) & "'.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sPosition = CurrentObj.Variable("Position") & ",0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[  arPos = split(sPosition,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	L = arPos(0)]]>
<![CDATA[
]]>
<![CDATA[	T = arPos(1)]]>
<![CDATA[
]]>
<![CDATA[	R = arPos(2)]]>
<![CDATA[
]]>
<![CDATA[	B = arPos(3)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sClipNo           ' enumerator for clips (for reading)]]>
<![CDATA[
]]>
<![CDATA[	Dim sClipEnumerator   ' enumerator for clips (for writing)]]>
<![CDATA[
]]>
<![CDATA[  Dim nIndex            ' the position where the clip page will be added]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Position values should be greater than zero]]>
<![CDATA[
]]>
<![CDATA[  If cInt(L)<0 then L=0]]>
<![CDATA[
]]>
<![CDATA[  If cInt(R)<0 then R=0]]>
<![CDATA[
]]>
<![CDATA[  If cInt(T)<0 then T=0]]>
<![CDATA[
]]>
<![CDATA[  If cInt(B)<0 then B=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'If the Right and Bottom are 0,0 then the Zone has no area]]>
<![CDATA[
]]>
<![CDATA[  if( cInt(R) = 0 or cInt(B) = 0 ) Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position is 0,0,0,0. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  'Left and Right or Top and Bottom expected postions are reversed]]>
<![CDATA[
]]>
<![CDATA[  if( cInt(L) >= cInt(R) or cInt(T) >= cInt(B) ) Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position is inconsistent. Left and Right or Top and Bottom position values reversed. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Get the Parent Page for the calling field]]>
<![CDATA[
]]>
<![CDATA[	Set PageObj = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While PageObj.ObjectType > 2			]]>
<![CDATA[
]]>
<![CDATA[		Set PageObj = PageObj.Parent]]>
<![CDATA[
]]>
<![CDATA[		If PageObj.ObjectType = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No Parent Page Found. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Get the Source Image Name]]>
<![CDATA[
]]>
<![CDATA[	ImageCtrl.FileName = PageObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Get the Parent Document for the calling field/Page]]>
<![CDATA[
]]>
<![CDATA[	Set DocObj = PageObj]]>
<![CDATA[
]]>
<![CDATA[	While DocObj.ObjectType > 1]]>
<![CDATA[
]]>
<![CDATA[		Set DocObj = DocObj.Parent]]>
<![CDATA[
]]>
<![CDATA[		If DocObj.ObjectType = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No Parent Document Found. Using Parent Page as Root Node.")]]>
<![CDATA[
]]>
<![CDATA[      'Check for ClipNo enumeration variable. Stores counter for clip page numbering.]]>
<![CDATA[
]]>
<![CDATA[      sClipNo = PageObj.Variable("ClipNo")]]>
<![CDATA[
]]>
<![CDATA[    ElseIf DocObj.ObjectType = 1 Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Parent Document Found. Using Document as Root Node.")]]>
<![CDATA[
]]>
<![CDATA[      'Check for ClipNo enumeration variable. Stores counter for clip page numbering.]]>
<![CDATA[
]]>
<![CDATA[      sClipNo = DocObj.Variable("ClipNo")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If len(sClipNo)=0 Then ]]>
<![CDATA[
]]>
<![CDATA[    ' set initial enumerator]]>
<![CDATA[
]]>
<![CDATA[    sClipEnumerator = "01"]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[      If len(sClipNo) <> 2 Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Unexpected counter value. Must be a two character numeric value.")]]>
<![CDATA[
]]>
<![CDATA[        ' free resource]]>
<![CDATA[
]]>
<![CDATA[        ImageCtrl.FileName = ""]]>
<![CDATA[
]]>
<![CDATA[        exit function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[      if(lCase(sClipNo)="zz") Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Counter limit has been reached. (00 thru ZZ)")]]>
<![CDATA[
]]>
<![CDATA[        ' free resource]]>
<![CDATA[
]]>
<![CDATA[        ImageCtrl.FileName = ""]]>
<![CDATA[
]]>
<![CDATA[        exit function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      sClipEnumerator = IncrementDigits(sClipNo)]]>
<![CDATA[
]]>
<![CDATA[      if sClipEnumerator = "-1" Then]]>
<![CDATA[
]]>
<![CDATA[        ' free resource]]>
<![CDATA[
]]>
<![CDATA[        ImageCtrl.FileName = ""]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Counter limit has been reached. (00 thru ZZ)")]]>
<![CDATA[
]]>
<![CDATA[        exit function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[  'Create New Page name      ]]>
<![CDATA[
]]>
<![CDATA[  sClipName = Mid(PageObj.ImageName,1,Len(PageObj.ImageName) - 4) & "_" & sClipEnumerator & Mid(PageObj.ImageName,Len(PageObj.ImageName) - 3,Len(PageObj.ImageName))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Create new Page object]]>
<![CDATA[
]]>
<![CDATA[  Select Case cstr(DocObj.ObjectType)]]>
<![CDATA[
]]>
<![CDATA[    Case "1"]]>
<![CDATA[
]]>
<![CDATA[      'Create as last page in document]]>
<![CDATA[
]]>
<![CDATA[      nIndex = DocObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[    Case "0"]]>
<![CDATA[
]]>
<![CDATA[      'Create as new trailing sibling page to parent page of calling field]]>
<![CDATA[
]]>
<![CDATA[      nIndex = DocObj.FindChildIndex(PageObj.id)+1]]>
<![CDATA[
]]>
<![CDATA[    Case Else]]>
<![CDATA[
]]>
<![CDATA[      'Unexpected objecttype, default index to 'last']]>
<![CDATA[
]]>
<![CDATA[      nIndex=-1]]>
<![CDATA[
]]>
<![CDATA[  End Select]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("New Page index:" & nIndex)]]>
<![CDATA[
]]>
<![CDATA[  Set oClipPage = DocObj.AddChild(2, PageObj.ID & "_" & sClipEnumerator,nIndex)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If oClipPage is Nothing  Then]]>
<![CDATA[
]]>
<![CDATA[    ' free resource]]>
<![CDATA[
]]>
<![CDATA[    ImageCtrl.FileName = ""]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Unable to add clip page")]]>
<![CDATA[
]]>
<![CDATA[    Exit function		]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set type, status and new image name]]>
<![CDATA[
]]>
<![CDATA[  oClipPage.Variable("TYPE") = Trim(arParam(0))]]>
<![CDATA[
]]>
<![CDATA[  oClipPage.Variable("STATUS") = Trim(arParam(1))]]>
<![CDATA[
]]>
<![CDATA[  oClipPage.ImageName = sClipName]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Add some info about the calling object and source page]]>
<![CDATA[
]]>
<![CDATA[  oClipPage.Variable("SourcePage") = PageObj.ID]]>
<![CDATA[
]]>
<![CDATA[  oClipPage.Variable("SourceImage") = PageObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[  oClipPage.Variable("SourceField") = CurrentObj.ID]]>
<![CDATA[
]]>
<![CDATA[  oClipPage.Variable("SourceValue") = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call ImageCtrl.saveZone(L,T,R-L,B-T,sClipName,10)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Select Case cstr(DocObj.ObjectType)]]>
<![CDATA[
]]>
<![CDATA[    Case "1"]]>
<![CDATA[
]]>
<![CDATA[      'Save counter to document]]>
<![CDATA[
]]>
<![CDATA[      DocObj.Variable("ClipNo") = sClipEnumerator]]>
<![CDATA[
]]>
<![CDATA[    Case "0"]]>
<![CDATA[
]]>
<![CDATA[      'Save counter to page]]>
<![CDATA[
]]>
<![CDATA[      PageObj.Variable("ClipNo") = sClipEnumerator]]>
<![CDATA[
]]>
<![CDATA[    Case Else]]>
<![CDATA[
]]>
<![CDATA[      'Unexpected objecttype, do not save counter]]>
<![CDATA[
]]>
<![CDATA[  End Select]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'free resource]]>
<![CDATA[
]]>
<![CDATA[	ImageCtrl.FileName = ""]]>
<![CDATA[
]]>
<![CDATA[	dci_clipfield = true]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<help>
<![CDATA[
'************************************************************************
' DCclip Action help
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.

'************************************************************************
]]>
  
<ref id="dci_clipfield" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="During processing, clips the field on the Image file (.tif) of every source page represented by the bound Field object of the Document Hierarchy and generates a separate Image file (.tif) displaying the clipped field's contents. ">
  <ap>
    Two comma-separated string values:<br/>
    <b>1.</b> The Page Type that is to be assigned to the Image file containing the clipped field and its value. <b>Remember!</b>  The new Image file is represented by a new page in the current Page file.  The Page Type value you assign will be used to identify pages with clipped fields.<br/><br/>
    <b>2.</b> The Page Status to be assigned to pages with clipped images of the bound Field object of the Document Hierarchy. <b>Alert!</b> Be sure that the status you assign conforms to Page Status specifications used throughout your application.<br/><br/>
  </ap>
  <lvl>Field level only.</lvl>
  <ret>
    <b>False</b> if either parameter is invalid.  Otherwise <b>True.</b><br/><br/>

    If the dci_clipfield action cannot locate the target field on a source page, the action will not generate an Image file for the clipped field and will not add a corresponding page to the current Page file (.xml).
  </ret>
  <h>
    During processing, clips the field on the Image file (.tif) of every source page represented by the bound Field object of the Document Hierarchy and generates a separate Image file (.tif) displaying the clipped field's contents.<br/><br/>

    The action also adds a page representing the new Image file to the current Page file.<br/><br/>

    <b>Alert!</b> If the Image ID assigned to the Image file representing the source page has this format: tm000001.tif. The Image ID of a clipped field's Image file adds one underscore character and a two digit index and has this format: tm000001_01.tif<br/><br/>

    The second pair in the batch will have these ID's:  tm000002.tif. and tm000002_01.tif. (This assumes that a source page has only one clipped field.)	   
    <e>
      <b>dci_clipfield(OfficePens_Page, 0)</b><br/><br/>
    </e>
  </h>
</ref>
</help>

</rrx>
<rrx namespace="DCO" src="c:\datacap\RRS\DCO.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<af name="SetDCOStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	SetDCOStatus = False]]>
<![CDATA[
]]>
<![CDATA[    If Not(Isnumeric(StrParam)) then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter must be Numeric.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Status = CLng(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	SetDCOStatus = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetDCOType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	status = CurrentObj.Status ]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Type = StrParam]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Status = CLng(status)]]>
<![CDATA[
]]>
<![CDATA[	strDCOType = StrParam]]>
<![CDATA[
]]>
<![CDATA[	SetDCOType = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetPageStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetPageStatus = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    If Not(Isnumeric(Strparam)) then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter must be Numeric.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While oParent.ObjectType>2]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If (oParent.ObjectType=2) Then ]]>
<![CDATA[
]]>
<![CDATA[		oParent.Status = CLng(StrParam)]]>
<![CDATA[
]]>
<![CDATA[		SetPageStatus = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Page Object or Parent Page object found.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = Nothing ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetPageType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim PageObj]]>
<![CDATA[
]]>
<![CDATA[	Dim sNode]]>
<![CDATA[
]]>
<![CDATA[	Dim bNode]]>
<![CDATA[
]]>
<![CDATA[	Dim sType]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(Trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetPageType = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set PageObj = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While PageObj.ObjectType > 2			]]>
<![CDATA[
]]>
<![CDATA[		Set PageObj = PageObj.Parent]]>
<![CDATA[
]]>
<![CDATA[		If PageObj.ObjectType = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No Page Object Found.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	status = PageObj.Status ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	bNode = False	]]>
<![CDATA[
]]>
<![CDATA[	'Ensure Min Length requirement ]]>
<![CDATA[
]]>
<![CDATA[	If Len(Trim(StrParam))>0 Then]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[		'replace dbl quotes with single	]]>
<![CDATA[
]]>
<![CDATA[		sNode = Replace(StrParam,Chrw(34),Chrw(39))		]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		'Check If quoted value]]>
<![CDATA[
]]>
<![CDATA[		If Left(Trim(sNode),1)=Chrw(39) And Right(Trim(sNode),1)=Chrw(39) Then ]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			sNode = Trim(Replace(StrParam,Chrw(39),""))]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[			'Check If self]]>
<![CDATA[
]]>
<![CDATA[			If sNode = CurrentObj.Type Then ]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Current Object is Search Type.")]]>
<![CDATA[
]]>
<![CDATA[				If(Trim(CurrentObj.Text) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[					sType = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[					bNode = True]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Node is CurrentObj. New Value is " & sType)]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			'Check If Child of Self]]>
<![CDATA[
]]>
<![CDATA[			If Not(bNode) Then]]>
<![CDATA[
]]>
<![CDATA[				Set iChild = CurrentObj.FindChild(sNode)]]>
<![CDATA[
]]>
<![CDATA[				If Not(iChild Is Nothing) Then ]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Child Object is Search Type.")]]>
<![CDATA[
]]>
<![CDATA[					If(Trim(iChild.Text) <> "" ) Then ]]>
<![CDATA[
]]>
<![CDATA[						sType = iChild.Text]]>
<![CDATA[
]]>
<![CDATA[						bNode = True]]>
<![CDATA[
]]>
<![CDATA[						debuglog("Node is Property Object. New Value is " & sType)]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			'Check If Variable of Self]]>
<![CDATA[
]]>
<![CDATA[			If Not(bNode) Then]]>
<![CDATA[
]]>
<![CDATA[				If CurrentObj.FindVariable(sNode) >= 0 Then ]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Current Object Variable is Search Type.")]]>
<![CDATA[
]]>
<![CDATA[					If(Trim(CurrentObj.Variable(sNode)) <> "" ) Then ]]>
<![CDATA[
]]>
<![CDATA[						sType = CurrentObj.Variable(sNode)]]>
<![CDATA[
]]>
<![CDATA[						bNode = True]]>
<![CDATA[
]]>
<![CDATA[						debuglog("Node is Property Object. New Value is " & sType)]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			'Assign PageType as StrParam]]>
<![CDATA[
]]>
<![CDATA[			sType = StrParam	]]>
<![CDATA[
]]>
<![CDATA[			bNode = True				]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If(PageObj.ObjectType = 2) And bNode Then PageObj.Type = sType]]>
<![CDATA[
]]>
<![CDATA[	PageObj.Status = CLng(status)]]>
<![CDATA[
]]>
<![CDATA[	SetPageType = bNode ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetDocStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetDocStatus = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While oParent.ObjectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If (oParent.ObjectType=1) Then ]]>
<![CDATA[
]]>
<![CDATA[		oParent.Status = CLng(StrParam)]]>
<![CDATA[
]]>
<![CDATA[		SetDocStatus = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Doc Object or Parent Doc object found.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = Nothing ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetDocumentType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim DocObj]]>
<![CDATA[
]]>
<![CDATA[    dim stype]]>
<![CDATA[
]]>
<![CDATA[	SetDocumentType = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.ObjectType=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Action must be called from Document, Page or Field DCO.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set DocObj = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While DocObj.ObjectType > 1		]]>
<![CDATA[
]]>
<![CDATA[		Set DocObj = DocObj.Parent]]>
<![CDATA[
]]>
<![CDATA[		If DocObj.ObjectType = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No Document Object Found.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	status = DocObj.Status ]]>
<![CDATA[
]]>
<![CDATA[	sType=""]]>
<![CDATA[
]]>
<![CDATA[	bNode = False	]]>
<![CDATA[
]]>
<![CDATA[	'Ensure Min Length requirement ]]>
<![CDATA[
]]>
<![CDATA[	If Len(Trim(StrParam))>0 Then]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[		'replace dbl quotes with single	]]>
<![CDATA[
]]>
<![CDATA[		sNode = Replace(StrParam,Chrw(34),Chrw(39))		]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		'Check If quoted value]]>
<![CDATA[
]]>
<![CDATA[		If Left(Trim(sNode),1)=Chrw(39) And Right(Trim(sNode),1)=Chrw(39) Then ]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			sNode = Trim(Replace(StrParam,Chrw(39),""))]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[			'Check If self]]>
<![CDATA[
]]>
<![CDATA[			If sNode = CurrentObj.Type Then ]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Current Object is Source DCO.")]]>
<![CDATA[
]]>
<![CDATA[				If(Trim(CurrentObj.Text) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[					sType = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[					bNode = True]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Node is CurrentObj. New Value is " & sType)]]>
<![CDATA[
]]>
<![CDATA[                Else]]>
<![CDATA[
]]>
<![CDATA[                    Writelog("CurrentObj has no Value.")]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			'Check If Child of Self]]>
<![CDATA[
]]>
<![CDATA[			If Not(bNode) Then]]>
<![CDATA[
]]>
<![CDATA[				Set iChild = CurrentObj.FindChild(sNode)]]>
<![CDATA[
]]>
<![CDATA[				If Not(iChild Is Nothing) Then ]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Child Object is Search Type.")]]>
<![CDATA[
]]>
<![CDATA[					If(Trim(iChild.Text) <> "" ) Then ]]>
<![CDATA[
]]>
<![CDATA[						sType = iChild.Text]]>
<![CDATA[
]]>
<![CDATA[						bNode = True]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Node is Property Object. New Value is " & sType)]]>
<![CDATA[
]]>
<![CDATA[                    Else]]>
<![CDATA[
]]>
<![CDATA[                        Writelog("Child has no Value.")]]>
<![CDATA[
]]>
<![CDATA[                    End If]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			'Check If Variable of Self]]>
<![CDATA[
]]>
<![CDATA[			If Not(bNode) Then]]>
<![CDATA[
]]>
<![CDATA[				If CurrentObj.FindVariable(sNode) >= 0 Then ]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Current Object Variable is Search Type.")]]>
<![CDATA[
]]>
<![CDATA[					If(Trim(CurrentObj.Variable(sNode)) <> "" ) Then ]]>
<![CDATA[
]]>
<![CDATA[						sType = CurrentObj.Variable(sNode)]]>
<![CDATA[
]]>
<![CDATA[						bNode = True]]>
<![CDATA[
]]>
<![CDATA[						debuglog("Node is Property Object. New Value is " & sType)]]>
<![CDATA[
]]>
<![CDATA[                    Else]]>
<![CDATA[
]]>
<![CDATA[                        Writelog("Child Object Variable has no Value.")]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[            If bNode = False and sType="" then]]>
<![CDATA[
]]>
<![CDATA[                Writelog("No value found to assign as DocType. Setting Action to Return false.")]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			'Assign PageType as StrParam]]>
<![CDATA[
]]>
<![CDATA[			sType = StrParam	]]>
<![CDATA[
]]>
<![CDATA[			bNode = True				]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If(DocObj.ObjectType = 1) And bNode Then DocObj.Type = sType]]>
<![CDATA[
]]>
<![CDATA[	DocObj.Status = CLng(status)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetDocumentType = bNode ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ChkDCOStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim aStatus]]>
<![CDATA[
]]>
<![CDATA[	Dim n]]>
<![CDATA[
]]>
<![CDATA[	aStatus=Split(StrParam&",",",")]]>
<![CDATA[
]]>
<![CDATA[	ChkDCOStatus = False]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Current Component Status='" & Currentobj.Status & "'")]]>
<![CDATA[
]]>
<![CDATA[	For n = 0 to (ubound(aStatus)-1)]]>
<![CDATA[
]]>
<![CDATA[		If CurrentObj.Status = CLng(Trim(aStatus(n))) Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Matched status '" & aStatus(n) & "'")]]>
<![CDATA[
]]>
<![CDATA[			ChkDCOStatus = True]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'n ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ChkDCOType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ChkDCOType = False]]>
<![CDATA[
]]>
<![CDATA[	If(CurrentObj.Type = StrParam) Then ChkDCOType = True]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("DCO type: " & CurrentObj.Type & "; Returning: " & ChkDCOType) ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<f name="ChkLastDCOTypeEx" access="public">
	<p name="prevPageToMatch">
	</p>
	<p name="chkObjLevel">
	</p>
	<p name="ignoreTypes">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim nCurIndex]]>
<![CDATA[
]]>
<![CDATA[  Dim nPrevIndex]]>
<![CDATA[
]]>
<![CDATA[  Dim oPrevObj]]>
<![CDATA[
]]>
<![CDATA[  Dim bIgnorePage]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ChkLastDCOTypeEx = FALSE]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  prevPageToMatch = Trim(prevPageToMatch)]]>
<![CDATA[
]]>
<![CDATA[  ignoreTypes = Trim(ignoreTypes)]]>
<![CDATA[
]]>
<![CDATA[  If (Not IsNumeric(chkObjLevel)) OR (CInt(chkObjLevel) < 0) OR (CInt(chkObjLevel) > 3) Then chkObjLevel = 0]]>
<![CDATA[
]]>
<![CDATA[  chkObjLevel = CInt(chkObjLevel)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType = DCO_BATCH Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Calling Object is ROOT object for BATCH.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function	]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = CurrentObj.Parent()]]>
<![CDATA[
]]>
<![CDATA[  If oParent is Nothing then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Parent Object Returned.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  strDCOType = oParent.Type]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Parent Type is: '" & strDCOtype & "'.")	]]>
<![CDATA[
]]>
<![CDATA[  nCurrIndex = oParent.FindChildIndex(CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[  nPrevIndex = nCurrIndex - 1]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Do While (nPrevIndex > -1)]]>
<![CDATA[
]]>
<![CDATA[    bIgnorePage = False]]>
<![CDATA[
]]>
<![CDATA[    Set oPrevObj = oParent.GetChild(nPrevIndex)]]>
<![CDATA[
]]>
<![CDATA[    strDCOtype = oPrevObj.Type]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If chkObjLevel <> 0 AND oPrevObj.ObjectType <> chkObjLevel Then]]>
<![CDATA[
]]>
<![CDATA[      bIgnorePage = TRUE]]>
<![CDATA[
]]>
<![CDATA[    ElseIf ignoreTypes <> "" Then]]>
<![CDATA[
]]>
<![CDATA[      For Each ignoreType in Split(ignoreTypes, ",")]]>
<![CDATA[
]]>
<![CDATA[        If strDCOtype = Trim(ignoreType) Then bIgnorePage = TRUE : Exit For]]>
<![CDATA[
]]>
<![CDATA[      Next]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Not bIgnorePage Then Writelog("Prev Obj Type is: '" & strDCOtype & "'.") : Exit Do]]>
<![CDATA[
]]>
<![CDATA[    nPrevIndex = nPrevIndex - 1]]>
<![CDATA[
]]>
<![CDATA[  Loop]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (strDCOType = prevPageToMatch) Then ChkLastDCOTypeEx = TRUE]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("DCO last type: " & strDCOType & "; Returning: " & ChkLastDCOTypeEx)		]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[  Set oPrevObj = Nothing]]>
<![CDATA[
]]>
	</g>
</f>
<af name="ChkLastDCOType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ChkLastDCOType = ChkLastDCOTypeEx(StrParam, 0, "")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CreateDocuments" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    Dim nType]]>
<![CDATA[
]]>
<![CDATA[    Dim oChild]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[    Dim DCount]]>
<![CDATA[
]]>
<![CDATA[    Dim PCount]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    DCount=0]]>
<![CDATA[
]]>
<![CDATA[    PCount=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    CreateDocuments = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Check for existing document objects, return false if found (exit action)]]>
<![CDATA[
]]>
<![CDATA[    For i = 1 to DCO.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[        Set oChild = DCO.GetChild(i-1)]]>
<![CDATA[
]]>
<![CDATA[        If Not(oChild is nothing) then]]>
<![CDATA[
]]>
<![CDATA[            nType=oChild.ObjectType]]>
<![CDATA[
]]>
<![CDATA[            Set oChild=nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            If nType=1 then]]>
<![CDATA[
]]>
<![CDATA[                DCount=DCount+1         ]]>
<![CDATA[
]]>
<![CDATA[            ElseIf nType=2 then]]>
<![CDATA[
]]>
<![CDATA[                PCount=PCount+1                ]]>
<![CDATA[
]]>
<![CDATA[            End if   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            If DCount>1 then]]>
<![CDATA[
]]>
<![CDATA[                Writelog("Batch Already Contains a Multi-Document structure.") ]]>
<![CDATA[
]]>
<![CDATA[                Exit Function     ]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            If DCount=1 and PCount>=1 then]]>
<![CDATA[
]]>
<![CDATA[                Writelog("Batch root contains Page and Document components. Must have all Pages at Batch Root or under a single Document at Batch Root.")]]>
<![CDATA[
]]>
<![CDATA[                Exit Function]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[    Next 'i ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CreateDocuments = CBool(DCO.CreateDocuments()) ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="CreateFields" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  CreateFields=True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim oDocSetupNode]]>
<![CDATA[
]]>
<![CDATA[  Dim oChildNode]]>
<![CDATA[
]]>
<![CDATA[  Dim oChildName]]>
<![CDATA[
]]>
<![CDATA[  Dim oChildField]]>
<![CDATA[
]]>
<![CDATA[  Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[  Dim NameIndex]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType = 1 Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Document Object Detected")]]>
<![CDATA[
]]>
<![CDATA[    Set oDocSetupNode = CurrentObj.SetupNode()]]>
<![CDATA[
]]>
<![CDATA[    nChildren = oDocSetupNode.NumOfRules()]]>
<![CDATA[
]]>
<![CDATA[    If nChildren>0 then]]>
<![CDATA[
]]>
<![CDATA[      For i = 1 to nChildren]]>
<![CDATA[
]]>
<![CDATA[        If oDocSetupNode.RuleObjectType(i-1)=3 then]]>
<![CDATA[
]]>
<![CDATA[           Set oChildNode = oDocSetupNode.GetRule(i-1)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          'check if field already exists add second field type(?) << no just skip!]]>
<![CDATA[
]]>
<![CDATA[  '        NameIndex = 0            ]]>
<![CDATA[
]]>
<![CDATA[  '        oChildName=oChildNode.Name]]>
<![CDATA[
]]>
<![CDATA[  '        While CurrentObj.FindChildIndex(oChildName)>=0]]>
<![CDATA[
]]>
<![CDATA[  '          NameIndex = NameIndex+1]]>
<![CDATA[
]]>
<![CDATA[  '          oChildName = oChildNode.Name & ctr(NameIndex)]]>
<![CDATA[
]]>
<![CDATA[  '        Wend]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          oChildName=oChildNode.Name]]>
<![CDATA[
]]>
<![CDATA[          If CurrentObj.FindChildIndex(oChildName)<0 then]]>
<![CDATA[
]]>
<![CDATA[              Set oChildField = CurrentObj.AddChild(3, oChildName,-1) ]]>
<![CDATA[
]]>
<![CDATA[              oChildField.Type = oChildNode.Name]]>
<![CDATA[
]]>
<![CDATA[              oChildStatus = oChildNode.Variable("STATUS")]]>
<![CDATA[
]]>
<![CDATA[              if oChildStatus<>"" then oChildField.Status=oChildStatus ]]>
<![CDATA[
]]>
<![CDATA[          End if]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      Next 'i]]>
<![CDATA[
]]>
<![CDATA[    End if  ]]>
<![CDATA[
]]>
<![CDATA[    If Err.Number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      CreateFields=False]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Err: " & Err.number & " " & Err.Description)]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  	CreateFields = CBool(CurrentObj.CreateFields())]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	writelog("Log:" & CurrentObj.GetLastError())]]>
<![CDATA[
]]>
<![CDATA[	writelog("Num of Children:" & CurrentObj.numofchildren()) ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="RefreshFields" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("RefreshFlag") = "True"]]>
<![CDATA[
]]>
<![CDATA[	RefreshFields = CBool(CurrentObj.CreateFields())]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.DeleteVariable("RefreshFlag")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	writelog("Log:" & CurrentObj.GetLastError())]]>
<![CDATA[
]]>
<![CDATA[	writelog("Num of Children:" & CurrentObj.numofchildren()) ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<f name="AddDCONode" access="public">
	<p name="ObjectType">
	</p>
	<p name="ID">
	</p>
	<p name="NameType">
	</p>
	<p name="Status">
	</p>
	<p name="Index">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      '"Adds new Node (Document, Page or Field) to the Runtime DCO"]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[          AddDCONode=True]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[          Dim oChild]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[          ID=trim(ID)]]>
<![CDATA[
]]>
<![CDATA[          ID=MetaWord(ID)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          NameType=trim(NameType)]]>
<![CDATA[
]]>
<![CDATA[          NameType=MetaWord(NameType)]]>
<![CDATA[
]]>
<![CDATA[                    ]]>
<![CDATA[
]]>
<![CDATA[          ObjectType=trim(ObjectType)         ]]>
<![CDATA[
]]>
<![CDATA[          ObjectType=MetaWord(ObjectType)]]>
<![CDATA[
]]>
<![CDATA[          If ObjectType="" then ObjectType=3]]>
<![CDATA[
]]>
<![CDATA[          bBadOT=False]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If Not(Isnumeric(ObjectType)) then ]]>
<![CDATA[
]]>
<![CDATA[            bBadOT=True]]>
<![CDATA[
]]>
<![CDATA[          Else]]>
<![CDATA[
]]>
<![CDATA[            If (clng(ObjectType)<>3) or (clng(ObjectType)<>2) or (clng(ObjectType)<>1) then bBadOT=True]]>
<![CDATA[
]]>
<![CDATA[          End if]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If bBadOT=True then]]>
<![CDATA[
]]>
<![CDATA[            Writelog("ObjectType Parameter must be a Numeric value of 1,2 or 3. Defaulting value to '3' (Field).")]]>
<![CDATA[
]]>
<![CDATA[            ObjectType=3]]>
<![CDATA[
]]>
<![CDATA[          Else]]>
<![CDATA[
]]>
<![CDATA[            ObjectType=clng(ObjectType)]]>
<![CDATA[
]]>
<![CDATA[          End if]]>
<![CDATA[
]]>
<![CDATA[                    ]]>
<![CDATA[
]]>
<![CDATA[          Status=trim(Status)         ]]>
<![CDATA[
]]>
<![CDATA[          Status=MetaWord(Status)]]>
<![CDATA[
]]>
<![CDATA[          If Status="" then Status="0"]]>
<![CDATA[
]]>
<![CDATA[          If Not(Isnumeric(Status)) then]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Status Parameter must be Numeric. Defaulting value to '0' (Zero).")]]>
<![CDATA[
]]>
<![CDATA[            Status="0"]]>
<![CDATA[
]]>
<![CDATA[          End if]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          Index=trim(Index)]]>
<![CDATA[
]]>
<![CDATA[          Index=MetaWord(Index)]]>
<![CDATA[
]]>
<![CDATA[          If Index="" then Index=-1]]>
<![CDATA[
]]>
<![CDATA[          If Not(Isnumeric(Index)) then]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Index Parameter must be Numeric. Defaulting value to '-1'.")]]>
<![CDATA[
]]>
<![CDATA[            Index=-1]]>
<![CDATA[
]]>
<![CDATA[          Else]]>
<![CDATA[
]]>
<![CDATA[            Index=clng(Index)]]>
<![CDATA[
]]>
<![CDATA[          End if]]>
<![CDATA[
]]>
<![CDATA[                                                   ]]>
<![CDATA[
]]>
<![CDATA[          If CurrentObj.FindChildIndex(ID)<0 then]]>
<![CDATA[
]]>
<![CDATA[              If Index>clng(CurrentObj.NumOfChildren) then Index=-1]]>
<![CDATA[
]]>
<![CDATA[              Set oChild = CurrentObj.AddChild(ObjectType, ID, Index) ]]>
<![CDATA[
]]>
<![CDATA[              If IsAlive(oChild) then]]>
<![CDATA[
]]>
<![CDATA[                oChild.Type = NameType]]>
<![CDATA[
]]>
<![CDATA[                oChild.Variable("STATUS")=Status ]]>
<![CDATA[
]]>
<![CDATA[              Else]]>
<![CDATA[
]]>
<![CDATA[                AddDCONode=False]]>
<![CDATA[
]]>
<![CDATA[              End if]]>
<![CDATA[
]]>
<![CDATA[          Else]]>
<![CDATA[
]]>
<![CDATA[              Writelog("A DCO Node with ID of " & ID & " exists.  No action taken.")]]>
<![CDATA[
]]>
<![CDATA[          End if]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[          If len(CurrentObj.GetLastError())>0 then writelog("Log:" & CurrentObj.GetLastError())]]>
<![CDATA[
]]>
<![CDATA[          If Err.number<>0 then AddDCONode=False]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<af name="SetPageFingerprintID" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	SetPageFingerprintID = False]]>
<![CDATA[
]]>
<![CDATA[	If(CurrentObj.ObjectType = 2) Then]]>
<![CDATA[
]]>
<![CDATA[			CurrentObj.Variable("TemplateID") = StrParam]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Setting TemplateID to: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Current object is not a page. Action Failed")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	SetPageFingerprintID = True ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="ChkIntegrity" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim rValue]]>
<![CDATA[
]]>
<![CDATA[	Dim oProbParent]]>
<![CDATA[
]]>
<![CDATA[	Dim sMsg]]>
<![CDATA[
]]>
<![CDATA[	Dim oProbObj]]>
<![CDATA[
]]>
<![CDATA[	Dim index]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ChkIntegrity = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	rValue = DCO.CheckIntegrity(oProbObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If rValue > 0 Then]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Structure check failed")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Select Case rValue ]]>
<![CDATA[
]]>
<![CDATA[			'Case 0: sMsg="No Integrity Problems Found."]]>
<![CDATA[
]]>
<![CDATA[			Case 1: sMsg="More Children than expected."]]>
<![CDATA[
]]>
<![CDATA[			Case 2: sMsg="Less Children than expected."]]>
<![CDATA[
]]>
<![CDATA[			Case 3: sMsg="an Invalid or unexpected Child object."]]>
<![CDATA[
]]>
<![CDATA[			Case 4: sMsg="a Wrong Child Position."]]>
<![CDATA[
]]>
<![CDATA[		End Select]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Set oProbParent = oProbObj.parent()]]>
<![CDATA[
]]>
<![CDATA[		If Not(oProbParent is Nothing) Then ]]>
<![CDATA[
]]>
<![CDATA[			If oProbParent.GetChild(oProbParent.NumOfChildren-1) is oProbObj Then ]]>
<![CDATA[
]]>
<![CDATA[				Set oProbObj = oProbParent]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[				index = oProbParent.FindChildIndex(oProbObj.ID)]]>
<![CDATA[
]]>
<![CDATA[				Set oProbObj = oProbParent.GetChild(clng(Index+1))]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		ChkIntegrity = False]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Integrity Failed. '" & oProbObj.ID & "' has " & sMsg)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Set oProbObj = Nothing ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="CopyPD2DD" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[ 	nChild = CurrentObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	for i=0 to nChild -1]]>
<![CDATA[
]]>
<![CDATA[	  Set oChild = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[	  if(Not oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[		if(oChild.ObjectType = 2) Then]]>
<![CDATA[
]]>
<![CDATA[		   if( oChild.Variable("PD") <> "" ) Then]]>
<![CDATA[
]]>
<![CDATA[		      CurrentObj.Variable("DD") = oChild.Variable("PD")]]>
<![CDATA[
]]>
<![CDATA[                      writelog("Set DD(DocumentData) as PD(PageData)")]]>
<![CDATA[
]]>
<![CDATA[ 	              CopyPD2DD = True		   ]]>
<![CDATA[
]]>
<![CDATA[		      Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[		      exit function]]>
<![CDATA[
]]>
<![CDATA[		   end if]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[          end if]]>
<![CDATA[
]]>
<![CDATA[        next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CopyPD2DD = False ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="PropagateToAltText" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	sVal = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[	sConf = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	n = Cint(strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.AltText(n) = sVal]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.AltConfidenceString(n) = sConf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("AltText(" & strParam & ") set to: " & sVal)]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("AltConf(" & strParam & ") set to: " & sConf)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	PropagateToAltText = True ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="ClearAltText" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	n = Cint(strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.AltText(n) = ""]]>
<![CDATA[
]]>
<![CDATA[	'CurrentObj.AltConfidenceString(n) = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ClearAltText = True ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="SetPageTemplateID" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	SetPageTemplateID=SetPageFingerprintID(bInter, bDebug, strParam) ]]>
	</g>
</af>
<af name="ClearDCO" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim nNumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	Dim nNumOfVars]]>
<![CDATA[
]]>
<![CDATA[	Dim nIndex]]>
<![CDATA[
]]>
<![CDATA[	Dim nObjCounter]]>
<![CDATA[
]]>
<![CDATA[	Dim nVarCounter]]>
<![CDATA[
]]>
<![CDATA[	Dim sVarname]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ClearDCO = False]]>
<![CDATA[
]]>
<![CDATA[	nObjCounter = 0]]>
<![CDATA[
]]>
<![CDATA[	nVarCounter = 0]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Clear/Remove all Fields & Characters]]>
<![CDATA[
]]>
<![CDATA[	nNumOfChildren = CurrentObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Child Objects to Delete:'" & nNumOfChildren & "'")	]]>
<![CDATA[
]]>
<![CDATA[	For nIndex = nNumOfChildren to 1 Step -1]]>
<![CDATA[
]]>
<![CDATA[		If CurrentObj.Deletechild(nIndex-1)=True then]]>
<![CDATA[
]]>
<![CDATA[			nObjCounter = nObjCounter + 1]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'nIndex]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Child Objects Deleted: '" & nObjCounter & "'")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[       'Clear/Remove all Variables ]]>
<![CDATA[
]]>
<![CDATA[	nNumOfVars = CurrentObj.NumOfVars	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Variables to Delete:'" & nNumOfVars & "'")]]>
<![CDATA[
]]>
<![CDATA[	For nIndex = nNumOfVars to 1 Step -1]]>
<![CDATA[
]]>
<![CDATA[        sVarname = CurrentObj.GetVariableName(nIndex-1)]]>
<![CDATA[
]]>
<![CDATA[		If CurrentObj.DeleteVariable(sVarname)=True then]]>
<![CDATA[
]]>
<![CDATA[			nVarCounter = nVarCounter + 1]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'nIndex]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Variables Deleted: '" & nVarCounter & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (nVarCounter + nObjCounter) = (nNumOfVars + nNumOfChildren) then]]>
<![CDATA[
]]>
<![CDATA[		ClearDCO = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Deleted Counts do not match Child + Variable count.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ErrorHandler("End Function ClearDCO") ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="DeleteFields" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim nNumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	Dim nNumOfVars]]>
<![CDATA[
]]>
<![CDATA[	Dim nIndex]]>
<![CDATA[
]]>
<![CDATA[	Dim nObjCounter]]>
<![CDATA[
]]>
<![CDATA[	Dim nVarCounter]]>
<![CDATA[
]]>
<![CDATA[	Dim sFileName]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	DeleteFields = False]]>
<![CDATA[
]]>
<![CDATA[	nObjCounter = 0]]>
<![CDATA[
]]>
<![CDATA[	sFileName = ""]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType = 2 Then]]>
<![CDATA[
]]>
<![CDATA[		sFileName = Trim(CurrentObj.Variable("DATAFILE"))]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	nNumOfChildren = CurrentObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Clear/Remove all Fields & Characters]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Child Objects to Delete:'" & nNumOfChildren & "'")	]]>
<![CDATA[
]]>
<![CDATA[	For nIndex = nNumOfChildren to 1 Step -1]]>
<![CDATA[
]]>
<![CDATA[		If CurrentObj.Deletechild(nIndex-1)=True then]]>
<![CDATA[
]]>
<![CDATA[			nObjCounter = nObjCounter + 1]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'nIndex]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Child Objects Deleted: '" & nObjCounter & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If (nObjCounter = nNumOfChildren) then]]>
<![CDATA[
]]>
<![CDATA[		DeleteFields = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Deleted Count does not match original Child count.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Len(sFileName)<>0 then]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If isobject(pTM) Then]]>
<![CDATA[
]]>
<![CDATA[			'TM web Session]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Web DATAFILE:'" & sFileName & "'")]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Web sLocalBatchDir:'" & sLocalBatchDir & "'")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			'? temp for test]]>
<![CDATA[
]]>
<![CDATA[			'bRes = pTM.FSIO.RemoveFile(sFileName)]]>
<![CDATA[
]]>
<![CDATA[			'If bRes = False Then Writelog("Unable to Delete Data File:'" & sFileName & "'")	]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			'Thick Client Session]]>
<![CDATA[
]]>
<![CDATA[			If FileMgr.FileExists(sFileName) then]]>
<![CDATA[
]]>
<![CDATA[				Call FileMgr.DeleteFile(sFileName,True)]]>
<![CDATA[
]]>
<![CDATA[				If Err.number<>0 Then Writelog("Unable to Delete Data File:'" & sFileName & "'")			]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Unable to Find Data File:'" & sFileName & "'")]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ErrorHandler("End Function DeleteFields") ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="ChkConfidence" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim MinLevel]]>
<![CDATA[
]]>
<![CDATA[	Dim LCStatus]]>
<![CDATA[
]]>
<![CDATA[	Dim HCStatus]]>
<![CDATA[
]]>
<![CDATA[	Dim bExit]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[	Dim dNodeDict]]>
<![CDATA[
]]>
<![CDATA[	Dim oSetupDCO]]>
<![CDATA[
]]>
<![CDATA[	Dim oChild]]>
<![CDATA[
]]>
<![CDATA[	Dim RegEx]]>
<![CDATA[
]]>
<![CDATA[	Dim sReqConf]]>
<![CDATA[
]]>
<![CDATA[	Dim i]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ChkConfidence=True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & ",,",",")]]>
<![CDATA[
]]>
<![CDATA[	MinLevel = trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	LCStatus = trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsNumeric(MinLevel) then MinLevel=-1]]>
<![CDATA[
]]>
<![CDATA[	If cint(MinLevel)<1 or cint(MinLevel)>10 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("First Parameter 'MinLevel' must be a numeric value between 1 and 10.")]]>
<![CDATA[
]]>
<![CDATA[		bExit = True]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(LCStatus) and len(LCStatus)>0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Second Parameter 'Low Confidence Status' must be numeric.")]]>
<![CDATA[
]]>
<![CDATA[		bExit = True]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Pages with status Failed (" & cstr(nFail) & ") will NOT be checked for low confidence fields.")]]>
<![CDATA[
]]>
<![CDATA[	ChkStatus=""]]>
<![CDATA[
]]>
<![CDATA[	For i = 2 to Ubound(aStrParam)]]>
<![CDATA[
]]>
<![CDATA[		If len(Trim(aStrParam(i)))>0 And isNumeric(Trim(aStrParam(i))) Then]]>
<![CDATA[
]]>
<![CDATA[			ChkStatus = ChkStatus & trim(aStrParam(i)) & ","]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Pages with status '" & aStrParam(i) & "' will be checked for low confidence fields.")]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'i]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If len(ChkStatus)=0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Pages with status '" & cstr(nPass) & "' will be checked for low confidence fields.")	]]>
<![CDATA[
]]>
<![CDATA[                ChkStatus=nPass & ","]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If bExit = True then ]]>
<![CDATA[
]]>
<![CDATA[		ChkConfidence=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Populate Dictionary object with list of Fields and ReqConf pattern value.]]>
<![CDATA[
]]>
<![CDATA[	Set dNodeDict = CreateObject("Scripting.Dictionary")]]>
<![CDATA[
]]>
<![CDATA[	Set oSetupDCO = DCO.SetupObject]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Reading Setup DCO confidence settings...")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	For i = 1 to oSetupDCO.NumOfNodes(3)]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = oSetupDCO.GetNode(3,i-1)]]>
<![CDATA[
]]>
<![CDATA[		If oChild is Nothing then]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Child " & i & " returned as Nothing")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			If cstr(oChild.Variable("STATUS"))<>"-1" then]]>
<![CDATA[
]]>
<![CDATA[				sReqConf = Trim(oChild.Variable("ReqConf"))]]>
<![CDATA[
]]>
<![CDATA[				If IsNumeric(sReqConf) Then]]>
<![CDATA[
]]>
<![CDATA[					Call dNodeDict.Add(oChild.Name,"[" & sReqConf-1 & "-9]*")]]>
<![CDATA[
]]>
<![CDATA[					Writelog(Space(5) & "Child '" & ochild.Name & "' added to dictionary. ReqConf: [" & sReqConf & "-9].")]]>
<![CDATA[
]]>
<![CDATA[				Else]]>
<![CDATA[
]]>
<![CDATA[					Call dNodeDict.Add(oChild.Name,"[" & MinLevel-1 & "-9]*")]]>
<![CDATA[
]]>
<![CDATA[					Writelog(Space(5) & "Child '" & ochild.Name & "' added to dictionary. ReqConf: [" & MinLevel & "-9].")]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'i]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oSetupDCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Writelog("---------------------------------------------")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Set	RegEx = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Loop through DCO tree]]>
<![CDATA[
]]>
<![CDATA[	ChkConfidence = EvalDCOConf(CurrentObj, LCStatus, ChkStatus, dNodeDict, RegEx)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set dNodeDict = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set RegEx = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="SetFldConfidence" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim sFieldName     'String of the field name to change, (empty means current field.???)]]>
<![CDATA[
]]>
<![CDATA[  Dim sNewConf       'Confidence Level 1 - 10.  Sets all confidence characters to this value.]]>
<![CDATA[
]]>
<![CDATA[  Dim aParam         'Split Input "field name" "Confidence"]]>
<![CDATA[
]]>
<![CDATA[  Dim numChars       'Length of the value which implies the length of the confidence string.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' If setting of the confidence fails, we will still return success, but log that the confidence]]>
<![CDATA[
]]>
<![CDATA[  ' was not adjusted.]]>
<![CDATA[
]]>
<![CDATA[  SetFldConfidence = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' A little trick to guarantee that there are two parameters by appending an extra blank parameter.]]>
<![CDATA[
]]>
<![CDATA[  ' Default the 2nd parameter to 10 if only a single parameter is passed in.]]>
<![CDATA[
]]>
<![CDATA[  aParam = Split(StrParam & ",10",",") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Pull out the 1st and 2nd parameters]]>
<![CDATA[
]]>
<![CDATA[  sFieldName = trim(aParam(0))]]>
<![CDATA[
]]>
<![CDATA[  sNewConf   = trim(aParam(1))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (sFieldName = "") Then]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Field Parameter is empty.  Character confidence values were not changed.")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Validate that sNewConf is 1 or 2 characters]]>
<![CDATA[
]]>
<![CDATA[  numChars = Len(sNewConf)]]>
<![CDATA[
]]>
<![CDATA[  if ((NumChars <> 1) and (NumChars <> 2)) Then ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Field Parameter length is wrong, must be value 1-10:" & sNewConf)]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Character confidence values for field: " & sFieldName & " were not changed!")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Validate that cConfidence is between 1 and 10]]>
<![CDATA[
]]>
<![CDATA[  if (not IsNumeric(sNewConf)) Then]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Field Parameter must be a single digit:" & sNewConf)]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Character confidence values for field: " & sFieldName & " were not changed!")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  iConfidence = CInt(sNewConf) - 1]]>
<![CDATA[
]]>
<![CDATA[  if ((iConfidence < 0) or (iConfidence > 9)) Then]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Field Parameter must be a 1-10:" & sNewConf)]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Character confidence values for field: " & sFieldName & " were not changed!")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oDcoObj = DCONav(sFieldName)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Check that oDcoObj is not empty, Not Null and nothing]]>
<![CDATA[
]]>
<![CDATA[  if (not IsAlive(oDcoObj)) then]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Could not locate field:" & sFieldName & ".  Character confidence values were not changed!")]]>
<![CDATA[
]]>
<![CDATA[     oDcoObj = NULL]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("Located Field: " & sFieldName & " containing value: " & oDcoObj.text)]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("Original Confidence: " & oDcoObj.ConfidenceString & ". New character confidence: " & iConfidence)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' Obtain the length of the field so we can set the confidence for each character.]]>
<![CDATA[
]]>
<![CDATA[  numChars = len(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' Set new confidence value]]>
<![CDATA[
]]>
<![CDATA[  oDcoObj.ConfidenceString = String(clng(numChars), trim(cStr(iConfidence)))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("SetFldConfidence")]]>
<![CDATA[
]]>
<![CDATA[  oDcoObj = NULL]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<f name="IsDocumentCountMoreThan" access="public">
	<p name="count">
	</p>
	<p name="returnTrueIfMore">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' count = comparison value Supports smart paramaters]]>
<![CDATA[
]]>
<![CDATA[  ' returnTrueIfMore - True returns true if more, false returns false if more.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  on error resume next]]>
<![CDATA[
]]>
<![CDATA[  IsDocumentCountMoreThan = false]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  count = MetaWord(count)]]>
<![CDATA[
]]>
<![CDATA[  returnTrueIfMore = MetaWord(returnTrueIfMore)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  writelog "Count = "  & count & ". returnTrueIfMore = " & returnTrueIfMore]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  set oParent= currentobj]]>
<![CDATA[
]]>
<![CDATA[  'write log "starting object " & currentobj.type]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  do while oParent.objecttype>0]]>
<![CDATA[
]]>
<![CDATA[  	writelog "parent was" & oparent.type]]>
<![CDATA[
]]>
<![CDATA[  	set oParent=oParent.parent]]>
<![CDATA[
]]>
<![CDATA[  loop]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  writelog "ending object type " & oParent.type & oParent.numofchildren]]>
<![CDATA[
]]>
<![CDATA[  docTotal = 0]]>
<![CDATA[
]]>
<![CDATA[  for i=0 to oParent.numofchildren-1  	]]>
<![CDATA[
]]>
<![CDATA[  	if err.number > 0 then]]>
<![CDATA[
]]>
<![CDATA[  		writelog err.description]]>
<![CDATA[
]]>
<![CDATA[  	end if]]>
<![CDATA[
]]>
<![CDATA[  	if oParent.getchild(i).objecttype =1 then]]>
<![CDATA[
]]>
<![CDATA[  		docTotal =docTotal + 1]]>
<![CDATA[
]]>
<![CDATA[		writelog "Doc ID" & oParent.getchild(i).ID]]>
<![CDATA[
]]>
<![CDATA[  	end if]]>
<![CDATA[
]]>
<![CDATA[  	i=i+1]]>
<![CDATA[
]]>
<![CDATA[  next 'i]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if cint(docTotal)>cint(count) then]]>
<![CDATA[
]]>
<![CDATA[  	IsDocumentCountMoreThan = true]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if (LCase(returnTrueIfMore) = "false") then]]>
<![CDATA[
]]>
<![CDATA[    IsDocumentCountMoreThan = NOT(IsDocumentCountMoreThan)]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  writelog "There are " & docTotal & " documents"]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("IsDocumentCountMoreThan")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</f>
<af name="RemoveDocumentStructure" access="public" bInter="bInter" bDebug="bDebug" qi="Removes the document hierarchy from the batch.">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    RemoveDocumentStructure = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    For i = 0 to DCO.NumOfChildren - 1            'loop through the objects that are children of the batch	]]>
<![CDATA[
]]>
<![CDATA[        if DCO.GetChild(i).ObjectType = 1 then    'found a document]]>
<![CDATA[
]]>
<![CDATA[            Set oDoc = DCO.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[            While oDoc.NumOfChildren > 0]]>
<![CDATA[
]]>
<![CDATA[                Call oDoc.GetChild(0).MoveIn(DCO,-1)]]>
<![CDATA[
]]>
<![CDATA[            Wend]]>
<![CDATA[
]]>
<![CDATA[        end if]]>
<![CDATA[
]]>
<![CDATA[    next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'remove the documents]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For i = DCO.NumOfChildren - 1   to 0 Step - 1]]>
<![CDATA[
]]>
<![CDATA[        if DCO.GetChild(i).ObjectType = 1 then]]>
<![CDATA[
]]>
<![CDATA[            Call DCO.DeleteChild(i)]]>
<![CDATA[
]]>
<![CDATA[        end if]]>
<![CDATA[
]]>
<![CDATA[    Next 'i  	   ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Structure removed")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CountPagesToDocumentVar" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Counts the number of pages in the document.">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[    Dim PageCount]]>
<![CDATA[
]]>
<![CDATA[    CountPagesToDocumentVar = TRUE]]>
<![CDATA[
]]>
<![CDATA[    if CurrentObj.ObjectType <> 1 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Action must be on a document object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    PageCount = 0]]>
<![CDATA[
]]>
<![CDATA[    For i = 0 to CurrentObj.NumOfChildren -1]]>
<![CDATA[
]]>
<![CDATA[        if CurrentObj.GetChild(i).ObjectType = 2 then]]>
<![CDATA[
]]>
<![CDATA[            PageCount = PageCount + 1]]>
<![CDATA[
]]>
<![CDATA[        end if]]>
<![CDATA[
]]>
<![CDATA[    next 'i]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable(StrParam) = cStr(PageCount)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<f name="JoinPreviousDocument" access="public" qi="Combines the previous document into the current document.">
	<p name="DocTypeToCombine">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim oCurrentDoc]]>
<![CDATA[
]]>
<![CDATA[    Dim oPreviousDoc]]>
<![CDATA[
]]>
<![CDATA[    Dim oPageToMove]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    JoinPreviousDocument = TRUE       'Actions must always return a TRUE or FALSE.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.ObjectType <> 1 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("This action goes on a DOCUMENT type object (the first page of the document you want to combine the previous document into")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Set oCurrentDoc = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    CurrentDocIndex = oCurrentDoc.Parent.FindChildIndex(oCurrentDoc.ID)]]>
<![CDATA[
]]>
<![CDATA[    Writelog("CurrentDocIndex: " & cStr(CurrentDocIndex) )]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    if CurrentDocIndex = 0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("This is the first document in the batch, so there are no previous documents.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Set oPreviousDoc = oCurrentDoc.Parent.GetChild(CurrentDocIndex - 1) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    if oPreviousDoc.Type <>  DocTypeToCombine then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("The previous document was the wrong type to combine: " & oPreviousDoc.Type & ".  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function  ]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    For i = oPreviousDoc.NumOfChildren - 1 to 0 Step - 1]]>
<![CDATA[
]]>
<![CDATA[        Set oPageToMove = oPreviousDoc.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Attempting to move: " & oPageToMove.ID)]]>
<![CDATA[
]]>
<![CDATA[        If oPageToMove.MoveIn(oCurrentDoc,0) then]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Moved successfully")]]>
<![CDATA[
]]>
<![CDATA[        else]]>
<![CDATA[
]]>
<![CDATA[            writelog("Unable to move document")]]>
<![CDATA[
]]>
<![CDATA[        end if]]>
<![CDATA[
]]>
<![CDATA[    next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Delete oPreviousDocument if empty]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Moves done.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    if oPreviousDoc.NumOfChildren = 0 then]]>
<![CDATA[
]]>
<![CDATA[        Call oPreviousDoc.Parent.DeleteChild(CurrentDocIndex - 1)]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Successfully moved page(s) and deleted document")]]>
<![CDATA[
]]>
<![CDATA[    else]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Not all pages were moved.  Did not delete document")]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="IsFirstPageInBatch" access="public" qi="Checks to see if this is the first page in the batch">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim oFirst]]>
<![CDATA[
]]>
<![CDATA[  Dim oPage]]>
<![CDATA[
]]>
<![CDATA[  IsFirstPageInBatch = FALSE]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType <> DCO_PAGE Then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("IsFirstPageInBatch must be called at page level.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  For i = 0 To DCO.NumOfChildren-1]]>
<![CDATA[
]]>
<![CDATA[    Set oFirst = DCO.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[    If oFirst.ObjectType = DCO_DOCUMENT Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Document type is found. Process further for pages.")]]>
<![CDATA[
]]>
<![CDATA[      For j = 0 To oFirst.NumOfChildren-1 'Shallow search only]]>
<![CDATA[
]]>
<![CDATA[        Set oPage = oFirst.GetChild(j)]]>
<![CDATA[
]]>
<![CDATA[        If oPage.ObjectType = DCO_PAGE Then Set oFirst = oPage : Exit For]]>
<![CDATA[
]]>
<![CDATA[      Next]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    If oFirst.ObjectType = DCO_PAGE Then Exit For]]>
<![CDATA[
]]>
<![CDATA[  Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  IsFirstPageInBatch = (CurrentObj.ID = oFirst.ID)]]>
<![CDATA[
]]>
	</g>
</f>
<f name="IsFirstDocumentInBatch" access="public" qi="Checks to see if this is the first document in the batch">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[    Set oDoc = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    While oDoc.ObjectType > 1]]>
<![CDATA[
]]>
<![CDATA[        Set oDoc = oDoc.Parent]]>
<![CDATA[
]]>
<![CDATA[    Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    if oDoc.ObjectType = 0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("No document object found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    if DCO.GetChild(0).ID = oDoc.ID then]]>
<![CDATA[
]]>
<![CDATA[        IsFirstDocumentInBatch = TRUE]]>
<![CDATA[
]]>
<![CDATA[    else]]>
<![CDATA[
]]>
<![CDATA[        IsFirstDocumentInBatch = FALSE]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<help>
  <![CDATA[
'****************************************************************************************
' DCO help.xml

' Licensed Materials - Property of IBM
' "Restricted Materials of IBM"
' 5725-C15 5725-C69
'
' Â©Copyright IBM Corp. 1994, 2017 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'
'****************************************************************************************
]]>
  
<ref id="SetDCOStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Assigns a value to the Status property of the current object of the Document Hierarchy.">
  <ap>An Integer representing the new status.</ap>
  <h>
    Assigns a value to the Status property of the current object of the Document Hierarchy.
    <e>
      <scr>ChkDCOType(Invoice)</scr><br/>
      <b>SetDCOStatus(1)</b><br/><br/>

      This sequence checks to see if the current object of the Document Hierarchy is a Page
      object - in this example, an Invoices page.  If so, the value of the Page object's Status
      property is set to "1".
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    <scr>SetDCOType, SetPageType</scr>
  </see>
</ref>
	
<ref id="SetDCOType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Assigns a value to the Type property of the current object of the Document Hierarchy.">
  <ap>A String value you're assigning to the current object's Type property.</ap>
  <h>
    Assigns a value to the Type property of the current object of the Document Hierarchy.
    <e>
      <scr>ChkLastDCOType(Separator)</scr><br/>
      <b>SetDCOType(Invoice)</b><br/><br/>

      This sequence checks to see if the previous object of the Invoices application's 
      Document Hierarchy was a Page object - in this case, a Separator page. If so, it 
      sets Invoice as the Type property of the current object.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    <scr>SetDCOStatus, SetPageStatus, SetDocumentType</scr>
  </see>
</ref>
	
<ref id="SetPageStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="The action assigns a page status to an object of the Document Hierarchy.">
  <ap>
    Numeric value representing the status.<br/><br/>

    The Invoices application (as an example) employs three default Page Statuses:<br/>
    49 = ScanOK<br/>
    1 = Incomplete/Not validated<br/><br/>
    0 = Complete<br/>

    You can define your own statuses by using the Filter tab of a task's Task Settings dialog.
  </ap>
  <h>
    The action assigns the page status you enter to the page object of the Document Hierarchy.
    The current object can be the page or field.  If the current object is a field object,
    it will set the page status for its parent page object.
    <e>
      A scan task might assign Other as the Page Type and 49 as the default Page Status
      for every successfully scanned image in the batch.<br/><br/>

      The sequence below is an example of a rule that converts Other pages to Invoices pages,
      and assigns a Page Status to each:<br/>
      <scr>SetPageType(Invoice)</scr><br/>
      <b>SetPageStatus(1)</b><br/><br/>

      This combination establishes the page as an Invoices page, and gives it a status of 1.
      This means that the page has not yet been validated and must be processed by a task which
      applies Validation rules (a Recognition or Verification task, for example).
    </e>
  </h>
  <lvl>Page or field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    <scr>SetPageType, SetDCOStatus, SetDCOType, SetDocumentStatus</scr>
  </see>
</ref>
	
<ref id="SetPageType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="The action assigns a Page Type to the current Page object of the Document Hierarchy.">
  <ap>
    A String value representing the Page Type. The Page Type parameter supports SmartParameters.<br/><br/>

    You can also designate a field in a Page object's Data file, and use its text value to set the Page Type.  Simply enter the name of a valid Field object and surround it with single quotes. For example: 'PageCode'.
  </ap>
  <h>
    Similar to the <scr>SetDCOType</scr> action, but works at the Page or Field level.<br/><br/>

    The action assigns the Page Type you enter as a parameter to the current Page object of the Document Hierarchy.  You can also use a Field object's value to set the Page Type. (See the Parameter section above.)
    <e>
      The application's scan task typically assigns Other as the Page Type and 49 as the default
      Page Status for every successfully scanned image in the batch.<br/><br/>

      The sequence below is an example of a rule that converts Other pages to Invoices pages, and assigns a Page Status to each:<br/>
      <b>SetPageType(Invoice)</b><br/>
      <scr>SetPageStatus(1)</scr><br/><br/>

      This combination sets the page as an Invoices page, and gives it a status of 1. This means that the page has not yet been validated and must be processed by a task which applies Validation rules (a RuleRunner Task, for example).
    </e>
  </h>
  <lvl>Page and Field levels.</lvl>
  <ret>
    <b>False</b> if there are no Page objects in the Page file, or if the parameter 
    is invalid.  Otherwise, <b>True.</b>
  </ret>
  <see>
    <scr>SetPageStatus, SetDCOStatus, SetDCOType</scr>
  </see>
</ref>
	
<ref id="SetDocStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Assigns a status to the current document.">
  <ap>
    String value representing the status to be assigned to the current document.<br/>
    Typically:<br/>
    "0" = Complete.<br/>
    "1" = Incomplete.
  </ap>
  <h>
    Assigns a status to the current document.
    <e>
      <b>SetDocStatus(DocOK)</b>
    </e>
  </h>
  <lvl>Document level.</lvl>
  <ret>
    <b>False</b> if the ruleset is not bound to a Document object, or the current
    object is not a document. Otherwise, <b>True.</b>
  </ret>
</ref>
	
<ref id="SetDocumentType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="The action assigns a Document Type to the current Document object of the Document Hierarchy.">
  <ap>
    The value you want to assign as the Document object's Type property.<br/><br/>

    You can also designate a field in a Page object's Data file, and use its text
    value to set the Document Type.  Simply enter the name of a valid Field object and surround
    it with single quotes. For example: 'Number'.
  </ap>
  <h>
    Similar to the <scr>SetDCOType</scr> action but works at the Document, Page or Field level.<br/><br/>

    The action assigns the Document Type you enter as a parameter to the current Document object of
    the Document Hierarchy. You can also use a Field object's value to set the Document Type.
    (Refer to the Parameter section.)
    <e>
      <b>SetDocumentType('Number')</b><br/>
      or<br/>
      <b>SetDocumentType(Invoice_Document)</b>
    </e>
  </h>
  <lvl>Document, Page, and Field levels.</lvl>
  <ret>
    <b>False</b> if there are no Document objects in the Data file, or if the parameter is invalid.  Otherwise, <b>True.</b>
  </ret>
  <see>
    <scr>SetDCOType, SetPageType</scr>
  </see>
</ref>
	
<ref id="ChkDCOStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Confirms that the status of the Document Hierarchy's current object is identical to the status entered as the parameter.">
  <ap>The Numeric value of the status you're checking.</ap>
  <h>
    Confirms that the status of the Document Hierarchy's current object is identical
    to the status entered as the parameter.
    <e>
      <b>ChkDCOStatus(0)</b> returns <b>True</b> if the current object has a
      status equal to 0, and <b>False</b> if it does not.<br/><br/>

      <b>ChkDCOStatus(48)</b> returns <b>True</b> if the current object has a status
      equal to 48, and <b>False</b> if it does not.
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    <b>True</b> if the DCO status matches the parameter value. Otherwise, <b>False.</b>
  </ret>
  <see>
    <scr>SetDCOStatus, ChkDCOType</scr>
  </see>
</ref>
	
<ref id="ChkDCOType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Confirms that the Type property of the Document Hierarchy's current object is identical to the type entered as the parameter.">
  <ap>The String value of the Type property of the object you're checking.</ap>
  <h>
    Confirms that the Type property of the Document Hierarchy's current object is identical
    to the type entered as the parameter.
    <e>
      <b>ChkDCOType(Invoice)</b><br/><br/>
      <scr>SetPageStatus(1)</scr><br/><br/>

      Applied at the Page level, the action above returns <lit>True</lit> if the current
      object is an Invoices Page object (using the Invoices application as an example),
      and <lit>False</lit> if it is not.  This action will confirm the current DCO Type matches
      an expected type and take additional subsequent actions that follow this action.  In this
      case, if the current DCO Type is "Invoice", the page status is set to 1.
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    <b>True</b> if the value of the DCO Type matches the parameter.  Otherwise, <b>False.</b>
  </ret>
  <see>
    <scr>SetDCOType, ChkDCOStatus, ChkLastDCOType</scr>
  </see>
</ref>
  
<ref id="ChkLastDCOTypeEx" access="public" qi="Checks that the Type property of the Document Hierarchy's previous object is identical to the type entered as the parameter.">
  <p name="prevPageToMatch"/>
  <p name="chkObjLevel"/>
  <p name="ignoreTypes"/>
  <ap>
    Three parameters:<br/><br/>
    <b>1.</b> The previous object's DCO Type to compare, case sensitive.<br/><br/>
    
    <b>2.</b> (Optional) Objects to compare:<br/>
    0 - All<br/>
    1 - Documents only<br/>
    2 - Pages only<br/>
    3 - Fields only<br/><br/>
    
    <b>3.</b> (Optional) Type or comma-delimited list of Types to skip evaluation.  If the prior object's Type is listed
    within the parameter then it will be skipped and if present, objects prior to it will be checked.
  </ap>
  <h>
    Checks that the Type property of the Document Hierarchy's previous object is identical to
    the type entered as the parameter.  This action allows you to test the last DCO Type
    encountered so you can take specific subsequent steps based on that type.<br/><br/>
    
    The example below is applied at the Page level and checks to see if the previous Page
    object's type matches the parameter (Separator).<br/><br/>
    <e>
      <b>ChkLastDCOTypeEx(Separator,,)</b><br/>
      <scr>SetPageType(Invoice)</scr><br/>
      <scr>SetPageStatus(1)</scr><br/><br/>
      
      Applied at the Page level, this sequence checks to see if the previous object was a Separator page.
      If so, the type and status of the current page are set to Invoice and 1.
      If the previous object's type was not a separator, the subsequent actions will not execute.<br/><br/>
      Note that this example does not limit checks to page types, to do that it would set the second parameter to 2.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True</b> if the Type property of the Document Hierarchy's previous non-skipped object
    matches the page type attempting to be matched.  Otherwise, <b>False.</b>
  </ret>
  <see>
    <scr>SetDCOType, ChkDCOType</scr>
  </see>
</ref>
  
<ref id="ChkLastDCOType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by ChkLastDCOTypeEx.">
  <ap>The previous object's DCO Type to compare.</ap>
  <h>
    This Action has been marked for Deprecation and will removed in a future release. It has been replaced with Action <b>ChkLastDCOTypeEx</b>.
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True</b> if the Type property of the Document Hierarchy's previous object
    matches the parameter. Otherwise, <b>False.</b>
  </ret>
  <see>
    <scr>ChkLastDCOTypeEx, SetDCOType, ChkDCOType</scr>
  </see>
</ref>
	
<ref id="CreateDocuments" access="public" bInter="bInter" bDebug="bDebug" qi="Arranges the contents of a task's Page file (for example, Recognition.xml,) into documents based on the Document Integrity rules (min, max and order)specified in your application's Document Hierarchy, and assembles documents from the pages in the batch. ">
  <ap>None.</ap>
  <h>
    Arranges the contents of a task's Page file (for example, Recognition.xml) into documents
    based on the Document Integrity rules for <b>min</b>, <b>max</b>, and <b>order</b> properties
    specified in your application's Document Hierarchy, and assembles documents from the pages in the batch.<br/><br/>

    Batches containing existing document structures will cause this action to return False,
    with no affect to the existing document structure.<br/><br/>

    Note: During document creation, temporary IDs are assigned (with a different format than real Document IDs) , 
    and if the action fails, these temporary IDs remain.<br/><br/>

    <b>Alert!</b> This action is applied at the Batch level, and generally in its own Ruleset (in a CreateDocs ruleset, for example.)
    <e>
      <b>CreateDocuments()</b>
    </e>
  </h>
  <lvl>Batch level only.</lvl>
  <ret>
    <b>True</b> if successful. Otherwise, <b>False.</b>
  </ret>
</ref>

<ref id="CreateFields" access="public" bInter="bInter" bDebug="bDebug" qi="Creates the Data file for a page in a batch. The Data file for the first page in the batch, tm000001, as an example, is tm000001.xml.">
  <ap>None.</ap>
  <h>
    Creates the Data file for a page in a batch. The Data file for the first page
    in the batch, tm000001, as an example, is tm000001.xml.<br/><br/>

    This Data file lists all fields for the current page based on the fields listed
    in the setup Document Hierarchy. Each field has an ID (for an Invoices page, for
    example, the Date field's ID is Date), and three properties with default values:
    TYPE, Position, and Status.<br/><br/>

    Later, actions of various kinds (Locate, Zone, Validation, DCO, etc.) can assign
    other values to these properties.  These actions can also add properties (variables)
    and values to the Data file, or remove properties and values.
    <e>
      <scr>AnalyzeImage()</scr><br/>
      <scr>RotateImageRecognizePageOCR_S()</scr><br/>
      <scr>SetSearchArea(0.5)</scr><br/>
      <scr>SetProblemValue(0.3)</scr><br/>
      <scr>SetTemplateDir(\ParentDirectory\Invoice\Template)</scr><br/>
      <scr>FindFingerprint(True)</scr><br/>
      <b>CreateFields()</b><br/><br/>

      This Invoices application sequence sets up the current page for processing,
      recognizes the words on the page, associates the page with a fingerprint,
      and finally creates a Data file with blank fields for the page.
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True</b> if successful. Otherwise, <b>False.</b>
  </ret>
</ref>

<ref id="RefreshFields" access="public" bInter="bInter" bDebug="bDebug" qi="Updates the Data file for a page in a batch with new fields and also preserves the data for previously created fields.">
  <ap>None.</ap>
  <h>
      Updates the Data file for a page in a batch with new fields and also preserves the data for previously created fields.<br/><br/>

      This action is similar to CreateFields except that if there is already a Data file for a page then it will not 
      erase the previously created fields and will just add new fields to the page.
      <e>
        <scr>SetPageType("Main_Page")</scr><br/>
        <b>RefreshFields()</b><br/><br/>
      </e>
  </h>
  <lvl>Page level.</lvl>
    <ret>
      <b>True</b> if successful. Otherwise, <b>False.</b>
  </ret>
</ref>

<ref id="AddDCONode" access="public" qi="Adds new Node (Document, Page or Field) to the Runtime DCO">
    <p name="ObjectType"/>
    <p name="ID"/>
    <p name="FieldType"/>
    <p name="Status"/>
    <p name="Index"/>
    <ap>
      <br/>
      <b>2.</b> The DCO Node Object Type: 3=Field, 2=Page, 1=Document, or a Smart Parameter that designates the Object Type.<br/><br/>
      <b>2.</b> The Node's ID, or a Smart Parameter that designates the field.<br/><br/>
      <b>3.</b> The Node's Type, or a Smart Parameter that designates the Type.<br/><br/>
      <b>4.</b> The Node's Numeric Status, or a Smart Parameter that designates the Status. Optional, Defaults to '0'.<br/><br/>
      <b>5.</b> The Node's Zero based Index, or a Smart Parameter that designates the Index. Optional, Defaults to last (-1).<br/><br/>
    </ap>
   <h>
     Creates a DCO node of the type indicated by the first argument (A Field, Page or Document).<br/><br/>
     If a node of the same type and ID exists no new node will be created and the Action will return True.<br/><br/>
     Restrictions: Documents can only have child Documents, Pages and Fields.  Pages can only have child Pages, and Fields.
     Fields can only have child fields. <br/>
     <e>
       <scr>AddDCONode("3","NewField","NewField","0","-1")</scr>
       <br/><br/>
     </e>
   </h>
   <lvl>All.</lvl>
   <ret>
     <b>True</b> if the node is successfully created.  Otherwise, <b>False.</b>
   </ret>
 </ref>
  
<ref id="SetPageFingerprintID" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Assigns a value to the FingerprintID property of the selected Page object of the Document Hierarchy.">
  <ap>The String value of the Fingerprint ID.</ap>
  <h>
    Assigns a value to the FingerprintID property of the selected Page object of the Document Hierarchy.<br/><br/>
 
    <b>Alert!</b> <scr>
      The <b>SetPageFingerprintID</b> action
    </scr> will create a FingerprintID property of the current Page object if it does not already exist.
    <e>
      <scr>WordFind(MQSW)</scr><br/>
      <b>SetPageFingerprintID(1010)</b><br/><br/>

      In this sequence, if the WordFind action locates "MQSW" on the current page, 
      the <scr>SetPageFingerprintID</scr> action assigns "1010" as the page's 
      Fingerprint ID. This links the page to a fingerprint with a Fingerprint ID of "1010".
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True</b> if the rule is applied at the Page level.  Otherwise, <b>False.</b>
  </ret>
</ref>
	
<ref id="ChkIntegrity" access="public" bInter="bInter" bDebug="bDebug" qi="Checks that  the integrity of the batch, as detailed in the Page file of the current task, meets the integrity requirements set within the Document Hierarchy (Setup DCO).">
  <ap>None.</ap>
  <h>
    Checks that the integrity of the batch, as detailed in the Page file
    of the current task, meets the integrity requirements set within the
    Document Hierarchy (Setup DCO).<br/><br/>

    "Integrity" refers to the correct types and numbers of pages within each document
    in the batch and the correct order of the pages in each document.<br/><br/>
    
    This action performs an integrity check on the entire batch regardless of the DCO level on which it is called.
    <e>
      <b>ChkIntegrity()</b>
    </e>
  </h>
  <lvl>Any level, but usually called at the batch level.</lvl>
  <ret>
    Returns <b>True</b> if no integrity problems are found.  Otherwise, <b>False.</b>
  </ret>
</ref>
	
<ref id="CopyPD2DD" access="public" bInter="bInter" bDebug="bDebug" qi="Assigns the value in a Page object's PD(Page Data) variable to the Document object's DD (Doc Data) variable.">
  <ap>None.</ap>
  <h>
    Assigns the value in a Page object's PD (Page Data) variable to the 
    Document object's DD (Doc Data) variable.
    <e>
      <b>CopyPD2DD()</b>
    </e>
  </h>
  <lvl>Document level.</lvl>
  <ret>
    <b>False</b> if the action is not at the Document level, or if the PD 
    variable at page level has no value.  Otherwise, <b>True.</b>
  </ret>
</ref>
	
<ref id="PropagateToAltText" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="Copies the character and confidence values from the first index of the Character Array (index 0) to the index specified by the parameter.">
  <ap>The index of the Character Array where you want to copy the character and confidence values. 0 is the first index, followed by 1, etc.</ap>  
  <h>
    Copies the character and confidence values from the first index of the Character Array (index 0)
    to the index specified by the parameter. (The character "node" of a page's Data file is an array
    that can hold many recognized character values, and their corresponding confidence values.)<br/><br/>

    <b>Note:</b> Rules will only work with characters and confidence values located in the 
    first position of the Character Array (index 0).<br/><br/>

    The <scr>PropagateToAltText</scr> action is used with the User Application 
    Web's Advanced Index task, for "Double Blind" data entry.
    <e>
      <b>PropagateToAltText(1)</b><br/>
      <scr>ClearAltText(0)</scr><br/><br/>

      All characters in the first index of the Character Array will be copied to the second index.
      Then, the second action will clear the character and confidence values from the first index.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    <scr>ClearAltText</scr>
  </see>
</ref>
	
<ref id="ClearAltText" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="Clears character and confidence values from the Character Array position specified by the parameter. ">
  <ap>
    The index in the Character Array where you want to clear the character and confidence values.  0 is the first index, followed by 1, etc.
  </ap>  
  <h>
    Clears character and confidence values from the Character Array position specified by the parameter.  
    When cleared, the confidence values are set to 10 (high confidence).
    (A field in the Data file can hold more than one representation of the field's value.
    Values other than the current, visible value are accessed via an index number.
    The current value is at index 0, the next value is at index 1.  Each additional
    value also has corresponding character confidences.)<br/><br/>

    <b>Note:</b> Most actions only work with characters and confidence values located in the first position of the Character Array (position 0).
    The ClearAltTex action is used with User Application Web's Advanced Index task, for "Double Blind" data entry.
    <e>
      PropagateToAltText(1)<br/>
      <b>ClearAltText(0)</b><br/><br/>

      In this example, all characters at the first index (0) of the Character Array will be copied to the second index (1).  
      The second action will then clear character and confidence values from the first index in the Character Array.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    <scr>PropagateToAltText</scr>
  </see>
</ref>
	
<ref id="SetPageTemplateID" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
  <ap>The String value of the Fingerprint ID.</ap>
  <h>
    Assigns a value to the FingerprintID property of the selected Page object of the Document Hierarchy.<br/><br/>

    <b>Alert!</b> The <b>SetPageTemplateID</b> action will create a FingerprintID 
    property of the current Page object if it does not already exist.
    <e>
      <scr>WordFind(MQSW)</scr><br/>
      <b>SetPageTemplateID(1010)</b><br/><br/>

      In this sequence, if the WordFind action locates "MQSW" on the current 
      page, the <scr>SetPageTemplateID</scr> action assigns "1010" as the page's 
      Fingerprint ID. This links the page to a fingerprint with a Fingerprint ID of "1010".
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True</b> if the rule is applied at the Page level.  Otherwise, <b>False.</b>
  </ret>
</ref>
	
<ref id="ClearDCO" access="public" bInter="bInter" bDebug="bDebug" qi="Clears all objects of the Document Hierarchy which are children of the bound object, and their variables.">
  <ap>None.</ap>
  <h>
    Removes all DCO children and variable references from the bound object.
    <e>
      CreateFields()<br/>
      <b>ClearDCO()</b><br/><br/>

      Applied at the Page level, the example will first add fields to the page and then remove them.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True</b> if all child objects and their variables are removed, otherwise <b>False.</b>
  </ret>
</ref>
	
<ref id="DeleteFields" access="public" bInter="bInter" bDebug="bDebug" qi="Deletes all child fields and characters from calling object of the Document Hierarchy.">
  <ap>None.</ap>
  <h>
    Deletes all fields and characters that are children of the bound object of the Document
    Hierarchy. This action will also remove the Data file (.xml) from the batch 
    if called from a Page object.
    <e>
      <b>DeleteFields()</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True</b> if successful, otherwise <b>False.</b>
  </ret>
</ref>
	
<ref id="ChkConfidence" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Checks the confidence of all field data on child pages against a minimum acceptable confidence value (Parameter 1). If any fields in a page contain Low Confidence data, assigns the Page Status specified in Parameter 2 to the page.">
  <ap>
    Two or three comma-separated values:<br/><br/>
    <b>1.</b> The Numeric value of the minimum confidence required. This value will be superseded on a field-by-field basis, if the field's ReqConf variable is set.<br/>
    <b>2.</b> The Numeric Page Status code to assign to any page that has one or more fields with Low Confidence data: if a field's ConfidenceString property contains a value lower than the first parameter.  Subfields, line items, etc are included.  Typically, "1" (Problem) is the value of this parameter.

    If only two parameters are specified, only pages with Status=0 will be checked by this action.<br/>
    <b>3.</b> If a third parameter is supplied, these parameters specify the list of Page Statuses to be checked.
  </ap>
  <h>
    Checks the confidence of all field data on selected pages, selected by Page Status, against a minimum acceptable confidence value (Parameter 1).
    If any fields contain Low Confidence data, the page is marked with the status specified as a parameter.<br/>
    Optionally, checks only pages of the status specified as Parameter 3.
    <e>
      <b>ChkConfidence(8,1)</b>
    </e>
  </h>
  <lvl>
    All levels. This action operates on the entire batch regardless of the level 
    to which its rule is bound. 
  </lvl>
  <ret>
    <b>True</b> if all fields in all source pages are High Confidence.<br/>
    <b>False</b> if any field has Low Confidence data, or if the parameters are not Numeric.
  </ret>
  <see>
    <scr>ChkDocStatus</scr>
  </see>
</ref>

<ref id="SetFldConfidence" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam"
     qi="For a specific field, sets the confidence for all characters in the field to the same value.">
  <ap>
    A comma-separated value consisting of: <br/>
    <br/>
    <b>1.</b> The field's name, or a Smart Parameter that designates the field.<br/><br/>
    <b>2.</b> The confidence value (1-10) to be assigned to the field's characters.
  </ap>
  <h>
    This action unconditionally sets the confidence values for every character within a field to a specific level.  This action can help
    change confidence levels when the preceding actions are all successful.<br/><br/>
    For example, if a set of calculations involving one or more fields is
    successful, this may indicate that the confidence level of those fields' values should be high - regardless of the
    confidence set by the recognition engine.  After the success of the calculation, you can call
    <b>SetFldConfidence</b>to unconditionally re-set the confidence values of the fields.<br/><br/>
    The first parameter is the name of the field that will have its confidence level set.<br/>
    The second parameter is the desired confidence level, between 1 and 10.  If the second parameter is not passed in, 10 is used as the default.<br/><br/>
    <b>Please note:</b>This function supports smart parameters for the field name (see the examples below).<br/>
    <e>

      Example 1:<br/>
      To set all characters in the field "GrossSalary" to a confidence of 9.<br/>
      <b>SetFldConfidence(@P\GrossSalary,10)</b><br/><br/>

      Example 2:<br/>
      To set all characters in the field "AdjustedPay" to a confidence of 1.<br/>
      <b>SetFldConfidence(@P\AdjustedPay,1)</b><br/><br/>

      Example 3: <br/>
      In the context of a test run before setting the confidence.<br/><br/>
      Calculate("'1TotalWages' + '2TaxableInterest' + "3Unemployment' = '4AdjustedGross'")<br/><br/>
      If this calculation works, the application can assume that all of the characters are read
      correctly and <b>SetFldConfidence</b> can adjust the fields to high confidence.<br/><br/>
      Note, you might also want to add a check
      that the values are all non-zero just to eliminate a completely "bad read".<br/><br/>
      <b>SetFldConfidence("@P\1totalWages,10")</b><br/>
      <b>SetFldConfidence("@P\2TaxableInterest,10")</b><br/>
      <b>SetFldConfidence("@P\3Unemployment,10")</b><br/>
      <b>SetFldConfidence("@P\4AdjustedGross,10")</b><br/>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b> If an input parameter is invalid, no confidence levels 
    are changed and a message is logged.
  </ret>
  </ref>

  <ref id="IsDocumentCountMoreThan">
    <ap>
      <b>count</b> : The document count to compare.<br/>
      <b>returnTrueIfMore</b> : Controls if the action returns true or false based on the comparison.<br/><br/>

      Smart parameters are supported.
    </ap>
    <h>
      Compares the current batch document with the parameter provided and returns true or false
      depending on if the count is exceeded by the provided parameter.<br/><br/>
      
      <e>
        <b>IsDocumentCountMoreThan(1, true)</b><br/>
        This example returns true if there are more than 1 documents in the batch.<br/><br/>

        <b>IsDocumentCountMoreThan(1, false)</b><br/>
        This example returns false if there are more than 1 documents in the batch.<br/><br/>
      </e>
    </h>
    <lvl>Any level.</lvl>
    <ret>
      if returnTrueIfMore is <b>true,</b> the action returns true if the document count exceeds the parameter, othewise <b>false</b> is returned.<br/><br/>
      if returnTrueIfMore is <b>false,</b> the action returns false if the document count exceeds the parameter, othewise <b>true</b> is returned.<br/>
    </ret>
  </ref>

  <ref id="RemoveDocumentStructure" access="public" bInter="bInter" bDebug="bDebug" qi="Removes the document hierarchy from the batch.">
    <ap>
      None.
    </ap>
    <h>
      This action will flatten the document - page hierarchy from the batch.  If the batch consists of multiple documents,
      each with a set of pages, the document level is removed and all of the pages become a flat structure.
      Once complete, there is no distinction of sets of pages within a document.
      <e>
        <b>RemoveDocumentStructure()</b>
      </e>
    </h>
    <lvl>Batch level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

  <ref id="CountPagesToDocumentVar" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Counts the number of pages in the document.">
    <ap>
      The variable that will hold the page count.
    </ap>
    <h>
      This action will count the number of page objects in a document and write the result in a document variable.
      <e>
        <b>CountPagesToDocumentVar("MyVarName")</b>
      </e>
    </h>
    <lvl>Document level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

  <ref id="JoinPreviousDocument" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Combines the previous document into the current document.">
    <ap>
      Document Type of previous document (to be joined with the current document).<br/>
    </ap>
    <h>
      Copies the pages of the previous named document into the front of this docuemnt.<br/>
      <e>
        <b>JoinPreviousDocument("SeparatorDoc")</b>
        <br/>
      </e>
    </h>
    <lvl>
      Document Level Only.
    </lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

  <ref id="IsFirstPageInBatch" access="public" bInter="bInter" bDebug="bDebug" qi="Checks to see if this page is the first in the batch.">
    <ap>
      None.<br/>
    </ap>
    <h>
      Checks to see if this page is the first in the batch.<br/>
      <e>
        <b>IsFirstPageInBatch()</b>
        <br/>
      </e>
    </h>
    <lvl>
      Page Level Only.
    </lvl>
    <ret>
      <b>True</b> if it is the first page.  Otherwise <b>False.</b>
    </ret>
  </ref>
  
  <ref id="IsFirstDocumentInBatch" access="public" bInter="bInter" bDebug="bDebug" qi="Checks to see if this is the first document in the batch.">
    <ap>
      None.<br/>
    </ap>
    <h>
      Checks to see if this is on an object in the first document in a batch.<br/>
      <e>
        <b>IsFirstDocumentInBatch()</b>
        <br/>
      </e>
    </h>
    <lvl>
      Document, Page or Field.
    </lvl>
    <ret>
      <b>True</b> if on the first document, or an object in the first document.  Otherwise <b>False.</b>
    </ret>
  </ref>

</help>
</rrx>
<rrx namespace="dcpdf" src="c:\datacap\RRS\dcpdf.dll">

<i ref="rrunner">
</i>
<af name="dcpdf_UseAltConversionMethod" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="dcpdf_SetImageResolution" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
</af>
<af name="dcpdf_SetImageBitcount" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
</af>
<af name="dcpdf_SetImageCompression" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
</af>
<af name="dcpdf_MaxSizeToReconvert" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
</af>
<af name="dcpdf_SetImageQuality" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
</af>
<af name="dcpdf_SetImageGrayscale" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
</af>
<af name="dcpdf_CreateTiffFromPDF_CreateDocs" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
</af>
<af name="dcpdf_CreateTiffFromPDF" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="dcpdf_MakePDFDoc" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
</af>
<af name="dcpdf_SetTitle" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
</af>
<af name="dcpdf_SetSubject" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
</af>
<af name="dcpdf_SetAuthor" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
</af>
<af name="dcpdf_SetProducer" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
</af>
<af name="dcpdf_SetKeywords" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
</af>
<af name="dcpdf_SetApplication" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
</af>
<help>
  <![CDATA[
'****************************************************
' dcpdf.rrx - a description of the library

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2016 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.

'****************************************************

]]>


  <ref id="dcpdf_UseAltConversionMethod">
    <ap>
      None.
    </ap>
    <h>
      There are two internal algorithms that are used to convert a PDF to a TIFF.  This action enables the alternate
      algorithm.  It is recommended that the alternate algorithm is used.  Testing has shown that it produces
      cleaner TIFF images.  This action must be called prior to dcpdf_CreateTiffFromPDF or dcpdf_CreateTiffFromPDF_CreateDocs.
      <e>
        <b>dcpdf_UseAltConversionMethod()</b><br/>
        dcpdf_CreateTiffFromPDF()
      </e>
    </h>
    <lvl>Batch or Document level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>


  <ref id="dcpdf_SetImageResolution">
    <ap>
      Two comma-separated <i>Numeric</i> values specifying X resolution and Y resolution (in that order.)
      The values are expressed in Dots (pixels) Per Inch (DPI).<br/>
      Smart parameters are supported.
    </ap>
    <h>
      This action sets the X and Y resolution for the pages of a PDF that is converted to TIFF.  If this action is not called,
      the default of 200 x 200 wil be used.  It is strongly recommended that the X and Y resolutions are always set
      the same to produce an isotropic image, which will allow for better fingerprinting and recognition.  If this action
      is used, it must be called before dcpdf_CreateTiffFromPDF or dcpdf_CreateTiffFromPDF_CreateDocs.
      <e>
        <b>dcpdf_SetImageResolution("300,300")</b><br/>
        dcpdf_CreateTiffFromPDF()
      </e>
    </h>
    <lvl>Batch or Document level.</lvl>
    <ret>
      <b>False,</b> if the parameters are not Numeric. Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="dcpdf_SetImageBitcount" >
    <ap>
      <i>Numeric</i>value of the BitCount of any image in a PDF document. The action's acceptable values are:
      <br/><br/>
      <b>1</b> for Black and White images (a typical value).<br/>
      <b>8</b> for Grayscale images.<br/>
      <b>24</b>	for Color images.<br/>
      Smart parameters are supported
    </ap>
    <h>
      Sets the BitCount of any image identified in a PDF file by an action such as CreateTiffFromPDF. The parameter's value for the action typically reflects the nature of the images in the PDF file. The default value is 1 (Black and white images)

      Note: The BitCount is the standard number of bits per pixel throughout an image.<br/><br/>
      <e>
        dcpdf_SetImageBitCount("1")				    black and white images.
        <br/>dcpdf_SetImageBitCount("8")			grayscale images.
        <br/>dcpdf_SetImageBitCount("24")			color images.
      </e>
    </h>
    <lvl>Batch or Document level.</lvl>
    <ret>
      <b>False,</b> if the parameter is not <i>Numeric</i>. Otherwise, <b>True.</b>
    </ret> 
  </ref>


  <ref id="dcpdf_SetImageCompression" >
    <ap>
      A <i>Numeric</i>value representing one the following Compressions:<br/><br/>
      1 = NONE	(DUMP MODE)<BR/>
      2 = CCITTRLE (CCITT modified Huffman RLE)<BR/>
      3 = CCITTFAX3 (CCITT Group 3 fax encoding)<BR/>
      4 = CCITTFAX4 (CCITT Group 4 fax encoding)<br/>
      5 = COMPRESSION_LZW (Lempel-Ziv and Welch)<br/>
      7 = JPEG (%JPEG DCT compression)<br/>
      32773 = PACKBITS (Macintosh RLE)<br/>
      Smart parameters are supported
    </ap>
    <h>
      Sets the compression that will be used when converting a page from a PDF file to a TIFF file.  Group 4 Fax is the most
      common compression used for text recognition.  It produces a lossless compressed black and white image. The default compression value is 4 (CCITT Group 4 fax encoding).
      <e>
        <b>dcpdf_SetImageCompression("7")</b><br/>
        dcpdf_CreateTiffFromPDF("True")
      </e>
    </h>
    <lvl>Batch or Document level.</lvl>
    <ret>
      <b>False,</b> if the parameter is not <i>Numeric</i>. Otherwise, <b>True.</b>
    </ret> 
  </ref>


  <ref id="dcpdf_MaxSizeToReconvert" >
    <ap>
      A <i>Numeric</i> value representing the maximum image size in
      KB before attempting to convert with an alternate algorithm.  If the value is 0, then the alternate
      algorithm will never be used.<br/>
      Smart parameters are supported.
    </ap>
    <h>
      Causes dcpdf_CreateTiffFromPDF to use a different algorithm based on the configured file size. <br/><br/>

      The conversion of PDF to TIFF usually works fast and produces clean images.  From time to time, the
      resulting TIFF may become unusually large.  A reason for this has been due to the background becoming a dithered
      light gray background instead of a pure white.  This leads to very large image sizes because compression is now
      less efficient.  It also could lead to reduced recognition quality.<br/><br/>

      To compensate for these rare situations, this action can be used to produce a clean TIFF from a PDF that compresses well.
      When a TIFF is created from a PDF, the file size is checked to see if it exceeds the value set by this action.  If file
      size is smaller, then is considered a successful conversion.  If the file size is larger, then this alternate method
      is performed.<br/><br/>
      This action must be called prior to dcpdf_CreateTiffFromPDF.  If this action is not called, the default value of 2000KB is used.
      Calling dcpdf_SetImageGrayscale(TRUE) will cause dcpdf_CreateTiffFromPDF(True) to always use the alternate algorithm.
      <e>
        <b>dcpdf_SetMaxImageSize("10000")</b><br/>
        dcpdf_CreateTiffFromPDF("True")<br/><br/>
        This example will cause the alternate conversion algorithm to be used if the initial conversion produces
        a TIFF image that is larger than 10000KB.
      </e>
    </h>
    <lvl>Batch or Document level.</lvl>
    <ret>
      False if the parameter is not <i>Numeric</i>. Otherwise, True.
    </ret> 
  </ref>


  <ref id="dcpdf_SetImageQuality" >
    <ap>
      <i>Numeric</i>value, between 1 and 100, of the Image Quality standard for images in the PDF file.<br/>
      Smart parameters supported.
    </ap>
    <h>
      This action determines the resulting image quality when creating a TIFF from a PDF file.  A higher number will produce
      a better looking image, but may require more processing time. The default value is 100.
      <e>
        <b>dcpdf_SetImageQuality("75")</b><br/>
        dcpdf_CreateTiffFromPDF("True")<b/>
      </e>
    </h>
    <lvl>Batch or Document level.</lvl>
    <ret>
      <b>False,</b> if the parameter is not <i>Numeric.</i>  Otherwise, <b>True.</b>
    </ret> 
  </ref>


  <ref id="dcpdf_SetImageGrayscale" >
    <ap>
      The parameter can be True or False.<br/><br/>
      <b>True:</b> gray areas of the image should not be dithered.<br/>
      <b>False:</b> gray areas of the image should be dithered.  This is the default.<br/>
      Smart parameters are supported.
    </ap>
    <h>
      Sets a Grayscale flag for images in a PDF file generated by an action such as dcpdf_CreateTiffFromPDF. <br/><br/>

      This action controls how gray areas of a grayscale image are handled when converted to black and white.  For example, if
      you have a text document with a gray background, it is recommended to call this action and pass "True".  This will
      cause the gray area below a predefined tolerance to be converted to white, producing an image that can recognize well.
      If you have a grayscale image and this action set to false, gray areas will be dithered to simulate gray in the resulting
      TIFF image. The default value is false.<br/><br/>
      If this action is used, it must be called before dcpdf_CreateTiffFromPDF or dcpdf_CreateTiffFromPDF_CreateDocs.

      <e>
        <b>dcpdf_SetImageGrayscale("True")</b><br/>
        dcpdf_CreateTiffFromPDF("True")
      </e>
    </h>
    <lvl>Batch or Document.</lvl>
    <ret>
      <b>False</b> if the parameter is invalid.  Otherwise, <b>True.</b>
    </ret> 
  </ref>

  <ref id="dcpdf_CreateTiffFromPDF_CreateDocs" >
    <ap>
      The parameter can be True or False.<br/><br/>
      <b>True:</b> Causes a document hierarchy to be created when TIFF pages are created from a PDF file.<br/><br/>
      <b>False:</b> A document hierarchy will not be created, making this action operate exactly like dcpdf_CreateTiffFromPDF.<br/>
      Smart parameters supported.
    </ap>
    <h>
      This action converts the pages in a PDF file to TIFFs, like dcpdf_CreateTiffFromPDF.  The difference is that if
      the parameter is True, a document hierarchy will be created for each PDF to group each of the pages from a single PDF into
      their own document.<br/>
      <br/>
      <b>Important:</b><br/><br/>
      The font mapping file, used by the convert actions to extract images from PDF, uses "Lucida Sans Unicode" as the default font.  The Lucida Sans Unicode font is installed by default in the Windows OS, making it a reliable default font setting.  It is possible that the font "Arial Unicode MS" may perform better in some instances when converting from PDF to image.  You can change the configuration file to use this font, or other fonts, instead of the default font.  However, if the specified font is not installed on the machine that is performing the conversion the text will render as blank on the final image.<br/>
      <br/>
      To change the font that is used to render a PDF to image, modify the fontfile.map file. In 64-bit Windows, this file is located in the Windows "SysWow64" directory. In 32-bit Windows, this file is located in the Windows "system32" directory. To change the default font:<br/>
      <br/>
      - Open fontfile.map in any text editor<br/>
      - Change the <b>defaultwinfont</b> value from:<br/><br/>
      <i>
        <b>L_10646.ttf</b>
      </i> to <i>
        <b>ARIALUNI.TTF (this is the font used in previous Taskmaster versions)</b>
      </i><br/><br/>
      - Save the changes and exit.<br/>
      <br/>
      This example will change the default font from "Lucida Sans Unicode" to "Arial Unicode MS".<br/>
      <br/>
      Previous versions of the Convert actions used Arial Unicode MS as the default font. This was changed in current versions since this font is not installed by default in the OS. <br/>
      <br/><br/>
      <e>
        <b>dcpdf_CreateTiffFromPDF_CreateDocs("True")</b>
        <br/>
        <br/>In this example, the action uses a primary algorithm to establish a runtime Document for each
        source document in the PDF file – and assign pages to the runtime Documents according to their
        placement in the source PDF files.
      </e>
    </h>
    <lvl>Batch Level.</lvl>
    <ret>
      <b>False,</b> if the action is not run at the Batch level, or if the source PDF file does not have a
      minimum number of pages (0). Otherwise, <b>True.</b>
    </ret> 
  </ref>

  <ref id="dcpdf_CreateTiffFromPDF">
    <ap>
      None.
    </ap>
    <h>
      This action looks for PDF files in the current batch; creates Image files (.tiff) for each page in the PDF file;
      and creates one document for the PDF file.<br/><br/>

      Note: dcpdf_MaxSizeToReconvert can be used to control how this action creates a TIFF file.  PDFs are converted to
      TIFF using a fast algorithm.  With some occasional input documents, this may produce images that are large and
      may not recognize well, causing them to be automatically reconverted to TIFF using a cleaner but slightly slower
      algorithm.  See the help for dcpdf_MaxSizeToReconvert for more information.<br/>
      <br/>
      <b>Important:</b><br/><br/>
      The font mapping file, used by the convert actions to extract images from PDF, uses "Lucida Sans Unicode" as the default font.  The Lucida Sans Unicode font is installed by default in the Windows OS, making it a reliable default font setting.  It is possible that the font "Arial Unicode MS" may perform better in some instances when converting from PDF to image.  You can change the configuration file to use this font, or other fonts, instead of the default font.  However, if the specified font is not installed on the machine that is performing the conversion the text will render as blank on the final image.<br/>
      <br/>
      To change the font that is used to render a PDF to image, modify the fontfile.map file. In 64-bit Windows, this file is located in the Windows "SysWow64" directory. In 32-bit Windows, this file is located in the Windows "system32" directory. To change the default font:<br/>
      <br/>
      - Open fontfile.map in any text editor<br/>
      - Change the <b>defaultwinfont</b> value from:<br/><br/>
      <i>
        <b>L_10646.ttf</b>
      </i> to <i>
        <b>ARIALUNI.TTF (this is the font used in previous Taskmaster versions)</b>
      </i><br/><br/>
      - Save the changes and exit.<br/>
      <br/>
      This example will change the default font from "Lucida Sans Unicode" to "Arial Unicode MS".<br/>
      <br/>
      Previous versions of the Convert actions used Arial Unicode MS as the default font. This was changed in current versions since this font is not installed by default in the OS. <br/>
      <br/>
      <e>
        <b>dcpdf_CreateTiffFromPDF()</b><br/><br/>
        When the action in this example encounters a PDF file in the batch, it creates
        a corresponding Image file (.tiff) and gives the Image file the PDF file’s name.
      </e>
    </h>
    <lvl>Batch only.</lvl>
    <ret>
      <b>False,</b> if the action is not run at the Batch level; if there are no PDF files in the batch;
      or if an error occurs while TIFF files are being created. Otherwise, <b>True.</b>
    </ret>
  </ref>


  <ref id="dcpdf_MakePDFDoc" >
    <ap>
      Comma separated parameters: IncludeFieldText,PageTypes.<br/><br/>

      The IncludeFieldText is optional and can be either True or False.<br/>
      <b>True:</b> stores recognized field data associated with each page’s TIFF image in the PDF file, to make a searchable PDF.
      (The text data is not visible, but it is searchable.)<br/>
      <b>False:</b> inserts the image of a page into the PDF file, the recognized text is not inserted. <br/><br/>

      The PageTypes parameter is a list of one or more page types to include in the output PDF, separated by commas.<br/><br/>

      If no parameters are provided, IncludeFieldText will default to False and all document pages will be included in the PDF.<br/>
      If only the IncludeFieldText parameter is provided, all document pages will be included in the PDF.<br/>
      Smart parameters are supported.
    </ap>
    <h>
      Creates a PDF document containing one or more pages of a document. The PDF format can contain only the
      original image or it can contain the image along with the recognized text to make the PDF searchable.<br/><br/>

      Only zoned field text will be included. if the input parameter is "True", and is searchable within the PDF.
      The searchable text may not accurately reflect the text position within the original input image.
      If you need the entire page text included as searchable text, or more accurate alignment,
      use one of the recognition actions to create the PDF, such as RecognizeDocToPDDF from the OCR_S library.<br/><br/>


      To exclude specific page types, set the variable "typesToExclude" to a comma delimited list of page types to exclude from the pdf. <br/><br/>
      To include specific page types, set the variable "typesToInclude" to a comma delimited list of page types to include from the pdf. <br/><br/>
      To exclude specific page status, set the variable "statusToExclude" to a comma delimited list of page status to exclude from the pdf. <br/><br/>
      When more than one filter is specified, the following order of precedence takes place: <br/>
      - "statusToExclude" overrides "typesToInclude" <br/>
      - "typesToInclude" overrides "typesToExclude" <br/><br/>

      If calling the action at the document level, the types and status filters apply to both the documents and child pages. <br/>
      If calling the action at the page level, the types and status filters apply to the page only. <br/><br/>

      These variables must be set before calling the action "RecognizeToPDFOCR_A"<br/><br/>

      Note: The "dcpdf_MakePDFDoc" action supports only the English language for searchable text and metadata.<br/><br/>

      <e>
        rrSet("75","@D.statusToExclude) <br/>
        rrSet("Blank","@D.typesToExclude) <br/>
        rrSet("Page1","@D.typesToInclude) <br/>
        dcpdf_SetTitle("MedicalClaims")<br/>
        dcpdf_SetSubject("Validated")<br/>
        dcpdf_SetAuthor("Steven Moffat")<br/>
        dcpdf_SetProducer("Russell Davies")<br/>
        dcpdf_SetApplication("MClaims")<br/>
        <b>dcpdf_MakePDFDoc("True")</b><br/>
        <br/>
        This example sets several properties of the PDF file and creates a PDF that contains the
        recognized text along with all of the page images for the current document. Pages whose type is "Blank" and status is "75" are skipped, and Page type "Page1" is included.<br/><br/>

        <b>dcpdf_MakePDFDoc("False,Main_Page")</b><br/>
        This example does not include the field text and will only export pages of type Main_Page.<br/><br/>

        <b>dcpdf_MakePDFDoc("True,Main_Page,Trailing_Page")</b><br/>
        This example does include the field text and will only export pages of type Main_Page or Trailing_Page.<br/><br/>
      </e>
    </h>
    <lvl>Document Level.</lvl>
    <ret>
      <b>False,</b> if the action is not run at the Document level, or
      if there are no pages in the document, or if an error occurs while the PDF file is being created.  Otherwise, <b>True.</b>
      If there are pages in the document but non of them match the specified page type, the action will not create
      a PDF file and will still return <b>True.</b>
    </ret>
  </ref>




  <ref id="dcpdf_SetTitle" >
    <ap>
      <i>String</i> value of the Title.<br/><br/>
      Smart parameters are supported.
    </ap>
    <h>

      This action sets the Title property of a PDF document generated by a subsequent <b>dcpdf_MakePDFDoc</b>action.<br/><br/>
      The Title is a searchable value for the page or document.  If this action is not called prior to dcpdf_MakePDFDoc,
      the value will default to “Untitled”.
      <e>
        <b>dcpdf_SetTitle("NewInvoice")</b><br/>
        dcpdf_MakePDFDoc("True")
      </e>
    </h>
    <lvl>Batch or Document level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret> 
  </ref>

  <ref id="dcpdf_SetSubject"  >
    <ap>
      <i>String</i>value of the Subject.<br/><br/>
      Smart parameters are supported.
    </ap>
    <h>
      This action sets the Subject property of PDF generated by a subsequent <b>dcpdf_MakePDFDoc</b> action.<br/><br/>
      The Subject is a searchable value for the page or document. If this action is not called,
      the value of the subject will be left blank in the resulting document.
      <e>
        <b>dcpdf_SetSubject("HealthClaimDoc")</b><br/>
        dcpdf_SetAuthor("Harriet Jones")<br/>
        dcpdf_MakePDFDoc("True")
      </e>
    </h>
    <lvl>Batch or Document.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

  <ref id="dcpdf_SetAuthor" >
    <ap>
      <i>String</i>value of the Author.<br/><br/>
      If you do not call this action, the value will default to “Should be a Task Name”.<br/>
      Smart parameters are supported.
    </ap>
    <lvl>Batch or Document level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <h>
      This action attaches the Author’s name (or a related value) to a PDF page or document generated by a subsequent <b>dcpdf_MakePDFDoc</b>action.<br/><br/>
      <br/>
      <e>
        <b>dcpdf_SetAuthor("Harriet Jones")</b><br/>
        dcpdf_SetProducer("Russell Davies")<br/>
        dcpdf_SetApplication("Invoices")<br/>
        dcpdf_MakePDFDoc("True")
      </e>
    </h>
  </ref>

  <ref id="dcpdf_SetProducer" >
    <ap>
      <i>String</i>value of the Producer ID.<br/>
      Smart parameters are supported.
    </ap>
    <h>
      Sets the producer value of the PDF document.  This action must be called prior to calling dcpdf_MakePDFDoc.
      If this action is not called, the value will default to 'Producer'.
      <e>
        dcpdf_SetAuthor("Steven Moffat")<br/>
        <b>dcpdf_SetProducer("Russell Davies")</b><br/>
        dcpdf_SetApplication("Invoices")<br/>
        dcpdf_MakePDFDoc("True")
      </e>
    </h>
    <lvl>Batch or Document level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

  <ref id="dcpdf_SetKeywords">
    <ap>
      <i>String</i> value of the Keyword.<br/><br/>
      If you do not call this action, the keyword value will be left blank.<br/>
      Smart parameters are supported.
    </ap>
    <h>
      This action assigns a single Keyword to a PDF page or document generated by a subsequent <b>dcpdf_MakePDFDoc</b>action.<br/><br/>
      Use this action repeatedly within a rule to assign additional Keywords. <br/><br/>
      <b>
        <i>Important!</i>
      </b> This action must precede the <b>dcpdf_MakePDFDoc</b>action.
      <e>
        dcpdf_SetKeywords("Invoices")<br/>
        <b>dcpdf_MakePDFDoc("True")</b>
      </e>
    </h>
    <lvl>Batch or Document level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

  <ref id="dcpdf_SetApplication">
    <ap>
      <i>String</i>value of the Application ID.<br/><br/>
      Smart paramaters are supported.
    </ap>
    <h>
      This sets the Application ID property of a PDF document generated by a subsequent <b>dcpdf_MakePDFDoc</b> action.<br/>
      If this action is not called, the value will default to "Application".
      <e>
        <b>dcpdf_SetApplication("Invoices")</b><br/>
        dcpdf_SetAuthor("Harriet Jones")<br/>
        dcpdf_MakePDFDoc("True")
      </e>
    </h>
    <lvl>Batch or Document level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

</help>

</rrx>
<rrx namespace="DocumentAnalytics" src="c:\datacap\RRS\DocumentAnalytics.dll">

<net ref="DocumentAnalytics.Actions">
	<h>
<![CDATA[
]]>
<![CDATA[      The document analytics actions take advantage of the document’s layout and font attributes to use analytics to extract data.  Actions that rely on the document’s layout require you to recognize the document using an action that produces a layout XML file such as tm000001_layout.xml.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
		<br>
		</br>
<![CDATA[The layout XML file groups text into blocks as a person would looking at the document.  Each block may have the default type of block or a specific type such as title or table.  There are locate actions available to navigate the block structure such as GoSiblingBlockNext.  This is in contrast to the CCO file produced by other actions that groups text into lines that span the width of the page.  The layout XML file also retains font and color attributes, saved in CSS format, for the text which is used for extracting data and reconstructing the document in a new format.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
		<br>
		</br>
<![CDATA[Actions that can produce the layout XML include OCR_SR.Recognize and OCR_A.Recognize, both of which can process color images and PDF files.  To use the Locate actions and perform click'n'key during verification, use the action CreateCcoFromLayout from the SharedRecognitionTools library to create a CCO file for the page after producing the layout XML file.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
		<br>
		</br>
<![CDATA[
]]>
<![CDATA[      Block Type/XML Node]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Block/Block]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Header/Header]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Footer/Footer]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Title/Title]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Heading1/H1]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Heading2/H2]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Heading3/H3]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Picture/Picture]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Barcode/Barcode]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Space/S]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Tab/Tab]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Table/Table]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Row/Row]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Cell/Cell]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Paragraph/Para]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Line/L]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Sentence/Sent]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Word/W]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		<br>
		</br>
<![CDATA[Character/C]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</h>
	<method name="CopyAllBlocks">
		<h>
<![CDATA[
]]>
<![CDATA[        Creates fields in the batch document hierarchy for each block of text.  You can use this action to visualize the blocks (as fields) within Datacap Studio, Datacap Desktop or similar tool. This action is not a prerequisite to any other DocumentAnalytics action.]]>
<![CDATA[
]]>
<![CDATA[        The field ID is the type of block that was found combined with a unique number (for example: block-1).  The field type is the block type (for example: block or title).  The font and color attributes are saved in CSS format to the style variable.  The text contents of the block will be the field’s text value.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[Entities found using the ExtractedText, FindLabelValuePairs and ExtractedTextAlchemyLanguage actions are copied as new fields.  AlchemyAPI entities fields are saved as field variables unless the field name is text.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[CopyAllBlocks requires a previously created layout file (for example: tm000001_layout.xml) where text is grouped into blocks.    See the DocumentAnalytics help introduction for information on the layout XML file.  CopyAllBlocks is useful for visualizing the layout, but it is not required when using other DocumentAnalytics actions.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[CopyAllBlocks()]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Page]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="CreateHTML">
		<h>
<![CDATA[
]]>
<![CDATA[        Creates an HTML document using the text and format in the layout XML file.  This is helpful in cases where a well-formatted HTML representation of the document is useful for processing or viewing of the document in another product after capture is complete.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[CreateHTML requires a previously created layout file (for example: tm000001_layout.xml) where text is grouped into blocks.  See the DocumentAnalytics help introduction for information on the layout XML file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[CreateHTML()]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Page]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the HTML document is created. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="AnalyzeLayout">
		<h>
<![CDATA[
]]>
<![CDATA[        AnalyzeLayout improves the grouping of text into blocks by merging adjacent blocks that are sufficiently similar. This action also changes the type of blocks that meet its criteria from Block to Paragraph or Title.  This action helps extract data with FindLabelValuePairs where the value to be extracted spans multiple lines.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[AnalyzeLayout  requires a previously created layout file (for example: tm000001_layout.xml) where text is grouped into blocks.  See the DocumentAnalytics help introduction for information on the layout XML file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[AnalyzeLayout()]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Page]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="FindLabelValuePairs">
		<h>
<![CDATA[
]]>
<![CDATA[        FindLabelValuePairs searches the layout XML for labels and their associated values which can subsequently be used by other actions to populate fields.  The label and value pairs are determined using font attributes and relative positioning of labels to values to identify what is a label and what is a value.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[The prepared results can be used by FindLabelValuePair or CopyLabelValuePairs and may be used instead of or in conjunction with locate actions.   The results are also saved to the layout XML file, allowing an application developer to easily review the identified pairs and then determine how they should be used within the application.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[For example if the document contains “Total: $100.00” a label value pair will be created with the label “Total” and the value “$100”. You may then use the action FindLabelValuePair to populate a specific fields with found values. You may call the action CopyLabelValuePairs to create a field and value for each match found.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[FindLabelValuePairs requires a previously created layout file (for example: tm000001_layout.xml) where text is grouped into blocks.  See the DocumentAnalytics help introduction for information on the layout XML file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[FindLabelValuePairs()]]>
				</b>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          FindLabelValuePair(Total,@P\Total)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Page or Document]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="FindLabelValuePair">
		<p name="Regex" type="string" qi="Smart parameter for the regular expression to find a matching label.  For example, to search for the label 'Total' use 'Total'.">
		</p>
		<p name="Target" type="string" qi="Smart parameter for the target object to save the value to.  If used on a field use '@F' to update the current field.">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        Populates a field using a value found using the FindLabelValuePairs action.  The label and values are distinguished using font attributes and relative positioning of labels to values to identify what is a label and what is a value.  Used instead of or in conjunction with locate actions.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[FindLabelValuePair requires a previously created layout file (for example: tm000001_layout.xml) where text is grouped into blocks.  See the DocumentAnalytics help introduction for information on the layout XML file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          FindLabelValuePairs()]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[FindLabelValuePair(Total,@P\Total)]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Page]]>
		</lvl>
		<lvl>
<![CDATA[Field]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the keyword is found and the following node is a table or if the keyword is found in a table cell. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="CopyLabelValuePairs">
		<h>
<![CDATA[
]]>
<![CDATA[        After calling FindLabelValuePairs, this action creates fields in the batch hierarchy for each pair that was found.  The field ID is the identified label combined with a unique number (for example: Last Name-1).  The field type is the block type (for example: block or title).  The font and color attributes are saved in CSS format to the style variable.  Use CopyLabelValuePairs during development to see if the FindLabelValuePairs and FindLabelValuePair actions can be used to find the fields to be extracted.  You can also use this action to create an application where the unwanted fields will be deleted.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[CopyLabelValuePairs requires a previously created layout file (for example: tm000001_layout.xml) where text is grouped into blocks.  See the DocumentAnalytics help introduction for information on the layout XML file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          FindLabelValuePairs()]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[CopyLabelValuePairs()]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Page]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="FindPatterns">
		<p name="patternsFilePath" type="string" qi="Path to xml file containing patterns to match.">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        Finds character sequences defined by regular expressions, and creates a new field on the page for each match in the recognized text.  ]]>
<![CDATA[
]]>
<![CDATA[        The pattern file named in the parameter must contain a list of regular expression patterns with additional attributes.]]>
<![CDATA[
]]>
<![CDATA[        The value of each pattern node is a .NET syntax regular expression.]]>
<![CDATA[
]]>
<![CDATA[        Each pattern must have a unique ]]>
			<b>
<![CDATA[id]]>
			</b>
<![CDATA[ attribute and a ]]>
			<b>
<![CDATA[type]]>
			</b>
<![CDATA[ attribute. The action creates a new field for each match found.  Each new field's name starts with the match pattern's ]]>
			<b>
<![CDATA[type]]>
			</b>
<![CDATA[ attribute, followed by the count of matches on this page so far, such that the field name is unique (e.g. us_zipcode1).]]>
<![CDATA[
]]>
<![CDATA[        A new field is created for each matching text string, the field type is "Pattern" and its variable "PatternMatched" contains the pattern ]]>
			<b>
<![CDATA[id]]>
			</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
			<b>
<![CDATA[Restriction:]]>
			</b>
<![CDATA[ this action does not support regular expressions containing a line break or tab expression.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[FindPatterns requires a previously created layout file (for example: tm000001_layout.xml) where text is grouped into blocks.  See the DocumentAnalytics help introduction for information on the layout XML file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        The format of each pattern node in the pattern xml file is:]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        «Pattern id="uniqueString" type="documentHierarchyFieldType" enabled="true"»regularExpression«/Pattern»]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        Where the characters « and » are replaced by less than (]]>
<![CDATA[<]]>
<![CDATA[) and greater than (]]>
<![CDATA[>]]>
<![CDATA[) symbols, respectively.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        Example of a pattern xml file:]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        «Patterns»]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        «Pattern id="zipcodePattern" type="us_zipcode" enabled="true"»[^:,\s]\d{5}(?:[-\s]\d{4})?[$.:,\s]«/Pattern»]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        «Pattern id="phonePattern" type="phone_number" enabled="true"»[^:,\s](\+\d{1,2}\s)?\(?\d{3}\)?[\s.-]\d{3}[\s.-]\d{4}[$.:,\s]«/Pattern»]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        «Pattern id="ssnPattern" type="us_SSN" enabled="true"»[^:,\s](?!000|666)[0-8][0-9]{2}-(?!00)[0-9]{2}-(?!0000)[0-9]{4}[$.:,\s]«/Pattern»]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        «Pattern id="addressPattern1" type="us_address" enabled="true"»(\d{1,5}.{1,16}(Alley|Avenue|(Ave\.?)|(Bvd\.?)|Blvd|Boulevard|Circle|(Cir\.?)|Street|(St\.?)|([P]\.?\s*?[O]\.?\s*?Box)|Drive|(Dr\.?)|(Cres\.?)|Crescent|Court|(Ct\.?)|Way|(Tr\.?)|Terrace|Trail|(Rd\.?)|Road|Lane|Highway|(Hwy\.?)|(Apt\.?)|(Pl\.?)|Place).*?((?:(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY]))|(Alabama|Alaska|Arizona|Arkansas|California|Colorado|Connecticut|Delaware|Florida|Georgia|Hawaii|Idaho|Illinois|Indiana|Iowa|Kansas|Kentucky|Louisiana|Maine|Maryland|Massachusetts|Michigan|Minnesota|Mississippi|Missouri|Montana|Nebraska|Nevada|New\s?(Hampshire|Jersey|Mexico|York)|North\s?(Carolina|Dakota)|Ohio|Oklahoma|Oregon|Pennsylvania|Rhode\s?Island|South\s?(Carolina|Dakota)|Tennessee|Texas|Utah|Vermont|Virginia|Washington|West\s?Virginia|Wisconsin|Wyoming)|(ALABAMA|ALASKA|ARIZONA|ARKANSAS|CALIFORNIA|COLORADO|CONNECTICUT|DELAWARE|FLORIDA|GEORGIA|HAWAII|IDAHO|ILLINOIS|INDIANA|IOWA|KANSAS|KENTUCKY|LOUISIANA|MAINE|MARYLAND|MASSACHUSETTS|MICHIGAN|MINNESOTA|MISSISSIPPI|MISSOURI|MONTANA|NEBRASKA|NEVADA|NEW\s?(HAMPSHIRE|JERSEY|MEXICO|YORK)|NORTH\s?(CAROLINA|DAKOTA)|OHIO|OKLAHOMA|OREGON|PENNSYLVANIA|RHODE\s?ISLAND|SOUTH\s?(CAROLINA| DAKOTA)|TENNESSEE|TEXAS|UTAH|VERMONT|VIRGINIA|WASHINGTON|WEST\s?VIRGINIA|WISCONSIN|WYOMING))\s*\d{5}((\-|\s*)\d{4})?)«/Pattern»]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        «Pattern id="datePattern1" type="date" enabled="true"»(((?:J(anuary|u(ne|ly))|February|Ma(rch|y)|A(pril|ugust)|(((Sept|Nov|Dec)em)|Octo)ber)|(Jan|Feb|Mar|Apr|May|Aug|Sep|Sept|Oct|Nov|Dec))(\s*|\-)\d{1,2}\,?(\s*|\-)\d{4})|(\d{2}\/\d{2}\/\d{4})|(\d{2}th\s*((?:J(anuary|u(ne|ly))|February|Ma(rch|y)|A(pril|ugust)|(((Sept|Nov|Dec)em)|Octo)ber)|(Jan|Feb|Mar|Apr|May|Aug|Sep|Sept|Oct|Nov|Dec))[\s*\,]\d{4})«/Pattern»]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        «/Patterns»]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[FindPatterns("@APPVAR(values/gen/patternsPath)")]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Page]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="ExtractText">
		<p name="extractors" type="string" qi="Smart parameter for a comma separated list of extractors to process.">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        Finds entities such as names and addresses in the text using text analytics.   The results are saved and can then be used by subsequent actions, such as FindExtractedText.]]>
<![CDATA[
]]>
<![CDATA[        To extract from non-English text, set the page variable hr_locale to the desired language before calling this action e.g. for Japanese call rrset("ja","@P.hr_locale")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[The entities to be found are determined by AQL extractors.  Datacap provides a set of pre-built extractors. You can create additional AQL extractors using the IBM BigInsights tools.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[Extractors are saved in compiled files with the extension tam. All tam files present in the \rrs\aql folder will be loaded. You can add or remove tam, dictionary and table files to the \rrs\aql folder to control if they are executed or not.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[All of the loaded extractors are run on the document or page.  ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
			<b>
<![CDATA[Important: ]]>
			</b>
<![CDATA[The results will be saved to the layout XML file, for example tm000001_layout.xml, which can be opened in a text editor to see the entities and the entitiy fields that can be copied into document hierarchy fields. "]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
			<b>
<![CDATA[Important: ]]>
			</b>
<![CDATA[The results from ExtractText will be saved to the layout XML file, for example tm000001_layout.xml which can be opened in a text editor to see the available entities and the entitiy fields that can be copied into document hierarchy fields. You can search for an entity in the layout XML using its name such as Address or Person."]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
			<b>
<![CDATA[Important:]]>
			</b>
<![CDATA[ This action requires a 32 bit Java run time environment.  The default location will be \Datacap\dcshared\jre or else the path specified in the JAVA_HOME system variable will be used.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[ExtractText requires a previously created layout file (for example: tm000001_layout.xml) where text is grouped into blocks.  See the DocumentAnalytics help introduction for information on the layout XML file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[		]]>
			<p>
				<b>
<![CDATA[Support for external dictionaries]]>
				</b>
			</p>
<![CDATA[
]]>
<![CDATA[		]]>
			<p>
<![CDATA[The ExtractText action supports AQL external dictionary. Using this feature, you can write annotators that do not need to be recompiled when a change is needed.]]>
			</p>
<![CDATA[
]]>
<![CDATA[		]]>
			<p>
<![CDATA[You can export from the IBM InfoSphere BigInsights web tools and place the exported folders into rrs\aql\src location. Copy the IEWTDocument.tam file in RRS\AQL folder. The AQL is compiled at the run time. ]]>
			</p>
<![CDATA[
]]>
<![CDATA[		]]>
			<b>
<![CDATA[By any means if generated TAMs files get deleted the existing SRC folder AQL will not generate TAMs again. Repeat the above step to get TAMs generated by Datacap.]]>
			</b>
<![CDATA[
]]>
<![CDATA[		]]>
			<p>
<![CDATA[
]]>
<![CDATA[      ]]>
				<b>
<![CDATA[Note:]]>
				</b>
<![CDATA[ You need to manually copy any external dictionaries and tables to the \rrs\aql location.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[     ]]>
				<br>
				</br>
<![CDATA[ A good idea to keep a back up of RRS folder in case if any file or folder gets corrupted at the time of copying or misconfiguration.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[    ]]>
				<br>
				</br>
<![CDATA[ Detailed steps to configure Custom annotators in Datacap:]]>
<![CDATA[
]]>
<![CDATA[    ]]>
				<br>
				</br>
<![CDATA[ 1. Once done creating Custom Extractor using BigInsights Web tool, export the extractor as "Executables" . Including "Source files" is optional . Export in a zip format.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
				<br>
				</br>
<![CDATA[ 2. Copy TAMs file from export to the \RRS\AQL folder. Do NOT copy the InputDocumentProcessor.TAM file. Leave the original in RRS\AQL folder itself.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
				<br>
				</br>
<![CDATA[ 3. Copy the SRC folder from Export (one from exported zip) folder to RRS\AQL in case if you want Datacap to compiles any AQL.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
				<br>
				</br>
<![CDATA[ 4. Make sure to copy all the supported *.DICT files provided by BigInsights in RRS\AQL folder.]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
				<br>
				</br>
<![CDATA[ ]]>
				<b>
<![CDATA[Custom extractors must be called with ExtractText action in the format ModuleName.Viewname. ]]>
				</b>
<![CDATA[
]]>
<![CDATA[    ]]>
				<br>
				</br>
<![CDATA[ Verify the modulename from corresponding AQL file. ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
				<br>
				</br>
<![CDATA[ For e.g. ZIPCODE_BasicFeatures.ZCView    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
			</p>
<![CDATA[
]]>
<![CDATA[		]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[Pre-Built Extractors:]]>
			</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[Address]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[City]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[Continent]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[Country]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[Date]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[DateTime]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[EmailAddress]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[Facility]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[FinancialAnnouncements   ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[FinancialEvents]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[Location]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[NotesEmailAddress]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[Organization]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[Person]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[PhoneNumber]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[StateOrProvince]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[URL]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[WaterBody]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[ZipCode]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<b>
<![CDATA[For pre-built extractors prefix Named_Entity_Recognition. For e.g. Named_Entity_Recognition.Address]]>
			</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[BigInsightsChineseNER.PersonChinese;]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[BigInsightsChineseNER.LocationChinese;]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[BigInsightsChineseNER.OrganizationChinese;]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[BigInsightsJapaneseNER.PersonJapanese;]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[BigInsightsJapaneseNER.LocationJapanese;]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[BigInsightsJapaneseNER.OrganizationJapanese;]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          This example will populate the city field with the first instance of an address where the state is California.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[ExtractText(Named_Entity_Recognition.DateTime,Named_Entity_Recognition.Address)]]>
				</b>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[FindExtractedText(@P\City,First,Address,city,stateorprovince,(California)|(CA))]]>
<![CDATA[
]]>
<![CDATA[		  ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[		   ]]>
				<b>
<![CDATA[ Check the data in Layout xml to get the correct field name.]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Document or Page]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="ExtractTextLogEnable" qi="Call to enable logging to the specified path and file name.">
		<p name="Target" type="string" qi="Smart parameter of the path and file name to log to.">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        Enables additional logging during text extraction.  This is used for debugging during system configuration.  The file will grow until deleted.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[ExtractTextLogEnable(c:\datacap\extract.log)]]>
				</b>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[ExtractText(DateTime.DateTime,Address.Address)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Any]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="FindExtractedText">
		<p name="Target" type="string" qi="Smart parameter for the target object to save the value to.  If used on a field use '@F' to update the current field.">
		</p>
		<p name="Scope" type="string" qi="Smart parameter first|Last|All - Populates the target using the match(es) using the specified entity type, search field and search expression.  If First is specified the first match is used.  If Last is specified the last match is used.  If All is specified a sub field will be created for all matches.  All is only supported when the target is DCO object and is not supported for variable.">
		</p>
		<p name="Entity" type="string" qi="Smart parameter name of the entity to match.  For example: Address.Address for a result from the ExtractText action, or Person for a result from the ExtractTextAlchemyLanguage action.  The format of the entity name is Module.OutputView for the ExtractText action. The entity name can be at any level of the ExtractTextAlchemyLanguage action results.">
		</p>
		<p name="Source" type="string" qi="Smart parameter entity Name|Field Name - If the entity name is specified sub fields used on the target for each field in the entity.  If an entity field name is sepcified the entity field will be used to update the target.">
		</p>
		<p name="SearchField" type="string" qi="Optional.  Smart parameter name of the entity field to match.  For example city. If specified matching will be limited to the specified field.  If the Entity parameter is set to Field this field's value will be used to update the target.">
		</p>
		<p name="SearchRegex" type="string" qi="Optional.  Smart parameter regular expression to search for.  To search for a word use '(SearchWord)'.">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        Populates a field or variable using a value found using the ExtractText and ExtractTextAlchemyLanguage actions.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
			<b>
<![CDATA[Important: ]]>
			</b>
<![CDATA[The results from the ExtractText and ExtractTextAlchemyLanguage actions will be saved to the layout XML file (for example: tm000001_layout.xml) which can be opened in a text editor to see the available entities and the entitiy fields that can be copied into document hierarchy fields. You can search for an entity in the layout XML using its name such as Address.Address, or Person.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        Source is entity:]]>
<![CDATA[
]]>
<![CDATA[	]]>
			<ul>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA[This can be used to create the line item detail structure in the run time hierarchy for capturing a list of items to be exported.]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA[If the Target has sub fields defined and the sub field types match the entity field names they will be populated.]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA[If the Target has sub fields and the sub fields have a variable named "entityMap" with a value that is the same as the entity field name in the layout.xml file the sub field of the target will be populated.]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA[If the Target does not have a sub field mapped to an entity field name a variable will be created using the entity field name.]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
			</ul>
<![CDATA[
]]>
<![CDATA[        FindExtractedText requires a previously created layout file (for example: tm000001_layout.xml).]]>
<![CDATA[
]]>
<![CDATA[        See the DocumentAnalytics help introduction for information on the layout XML file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[Example 1]]>
				</b>
<![CDATA[
]]>
<![CDATA[          ExtractText - This example will populate a page field called City with the first address in California.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ExtractText(Address.Address)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[FindExtractedText(@P\City,First,Address.Address,city,stateorprovince,(California)|(CA))]]>
				</b>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[Example 2]]>
				</b>
<![CDATA[
]]>
<![CDATA[          ExtractText - This example will create a line item for each address found in the document.  The following document hierarchy is expected to be defined.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[Field AddressDetail]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[    Field LineItem]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[        Field City]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[             Variable entityMap=city]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[        Field State]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[             Variable entityMap=stateorprovince]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ExtractText(Address.Address)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[FindExtractedText(@P\AddressDetail,All,Address.Address,,,)]]>
				</b>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[Example 3]]>
				</b>
<![CDATA[
]]>
<![CDATA[          ExtractText - This example will populate variables city, stateorprovince, zip and address on the target field AddressDetail.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ExtractText(Address.Address)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[FindExtractedText(@P\AddressDetail,First,Address.Address,,,)]]>
				</b>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[Example 4]]>
				</b>
<![CDATA[
]]>
<![CDATA[          ExtractTextAlchemyLanguage - This example will populate a page field called Person with the first Person returned by AlchemyAPI.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ExtractTextAlchemyLanguage(entity)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[FindExtractedText(@P\Person,First,enity,text,type,Person)]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Any]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if a match is found. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="ExtractTextAlchemyLanguage">
		<p name="options" type="string" qi="Comma separated list of text features to call. Smart parameters supported.">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[	  ]]>
			<b>
<![CDATA[*** This Action Is Deprecated ***]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      This action has been deprecated and is scheduled to be removed in a future release.]]>
<![CDATA[
]]>
<![CDATA[      With reference to announcement from IBM regarding retirement of AlchemyAPI https://www.ibm.com/blogs/bluemix/2017/03/bye-bye-alchemyapi/, it is recommended that you no longer use this action.]]>
<![CDATA[
]]>
<![CDATA[      As per the announcement, you will no longer be able to provision new AlchemyAPI instances after April 7 2017. However all existing instances will continue to be supported by AlchemyAPI till March 7 2018.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        The action calls the AlchemyAPI Combined Call feature and passes in text from one page at a time.]]>
<![CDATA[
]]>
<![CDATA[        The results are saved as entities in the page's layout XML file.  Use the FindExtractedText action to populate fields with results of this action.]]>
<![CDATA[
]]>
<![CDATA[        To extract from non-English text, set the page variable hr_locale to the desired language before calling this action e.g. for Japanese call rrset("ja","@P.hr_locale")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<dl>
				<dlentry>
<![CDATA[
]]>
<![CDATA[	]]>
					<dt>
<![CDATA[Parameter text features:]]>
					</dt>
<![CDATA[
]]>
<![CDATA[	]]>
					<dd>
<![CDATA[No parameter - returns all results]]>
					</dd>
<![CDATA[
]]>
<![CDATA[	]]>
				</dlentry>
<![CDATA[
]]>
<![CDATA[	]]>
			</dl>
<![CDATA[
]]>
<![CDATA[	 ]]>
			<ul>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
				<li>
<![CDATA[entity]]>
				</li>
<![CDATA[
]]>
				<li>
<![CDATA[keyword]]>
				</li>
<![CDATA[
]]>
				<li>
<![CDATA[taxonomy]]>
				</li>
<![CDATA[
]]>
				<li>
<![CDATA[concept]]>
				</li>
<![CDATA[
]]>
				<li>
<![CDATA[relation]]>
				</li>
<![CDATA[
]]>
				<li>
<![CDATA[doc-sentiment]]>
				</li>
<![CDATA[
]]>
				<li>
<![CDATA[doc-emotion]]>
				</li>
<![CDATA[
]]>
				<li>
<![CDATA[dates]]>
				</li>
<![CDATA[
]]>
			</ul>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[Important:]]>
			</b>
<![CDATA[ You must have an enterprise AlchemyAPI license to use this action. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[This license is obtained by creating an account on bluemix.net and adding the AlchemyAPI service to a workspace.  The URL and key are shown on the Service Credentials page.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[In Datacap Application Manager:]]>
<![CDATA[
]]>
<![CDATA[	]]>
			<ul>
<![CDATA[
]]>
<![CDATA[	]]>
				<li>
<![CDATA[Save the URL in your application's general section in a variable called AlchemyApiUrl.]]>
				</li>
<![CDATA[
]]>
<![CDATA[    The URL must end in /calls/.  The default URL if the AlchemyApiUrl is not updated is https://gateway-a.watsonplatform.net/calls/.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
				<li>
<![CDATA[Save the license key in your application's advanced section in a variable called AlchemyApiKey.]]>
				</li>
<![CDATA[
]]>
<![CDATA[	]]>
			</ul>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
			<b>
<![CDATA[Response:]]>
			</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[Entities are named using the format AlchemyFeature.ResponseNode.  For example, an entity result for a person will have the name Entity.Person.  Most entity fields will be named using the node returned by AlchemyAPI.  Nested responses are flattened to one level.  For example, the disambiguated sub type will be named subTypes and the results will be saved as a comma-separated list.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
			<b>
<![CDATA[Variables:]]>
			</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			<dl>
<![CDATA[
]]>
<![CDATA[	]]>
				<dlentry>
					<dt>
<![CDATA[Timeout]]>
					</dt>
<![CDATA[
]]>
<![CDATA[	]]>
					<dd>
<![CDATA[The default timeout is 100 seconds.  You can specify the timeout by saving a page variable called ]]>
						<b>
<![CDATA[alchTimeout]]>
						</b>
<![CDATA[ and specifying the time in milliseconds.]]>
					</dd>
<![CDATA[
]]>
<![CDATA[	]]>
				</dlentry>
<![CDATA[
]]>
<![CDATA[        ]]>
				<dlentry>
					<dt>
<![CDATA[Save Response]]>
					</dt>
<![CDATA[
]]>
<![CDATA[	]]>
					<dd>
<![CDATA[The response from AlchemyAPI can be saved by setting the variable ]]>
						<b>
<![CDATA[alchSaveResponse]]>
						</b>
<![CDATA[ to 1.]]>
					</dd>
<![CDATA[
]]>
<![CDATA[	]]>
				</dlentry>
<![CDATA[
]]>
<![CDATA[        ]]>
			</dl>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[When called on the document or page, the text of the layout XML file specified in the calling object's layout variable will be sent to AlchemyAPI.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[The results will be saved to the entities list of the page in the layout XML file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[To populate a field with a result of this action, use the FindExtractedText action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          AnalyzeLayout()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[ExtractTextAlchemyLanguage()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          FindExtractedText()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          AnalyzeLayout()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[ExtractTextAlchemyLanguage()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          CobyAllBlocks()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Document or Page.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the layout is loaded and there are no errors. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="FindTableValueRegEx">
		<p name="FindHeadingValue" type="string" qi="Regular expression to search in the table header.">
		</p>
		<p name="FindRowValue" type="string" qi="Regular expression to search in the table rows.">
		</p>
		<p name="QueryColumn" type="string" qi="Regular expression to search in the table header.">
		</p>
		<p name="RowName" type="string" qi="The new field name for field that will contain text from a specific row.">
		</p>
		<p name="CellName" type="string" qi="The new field name for the found text.">
		</p>
		<p name="ValueStoreLocation" type="string" qi="The target DCO location for the found text.">
		</p>
		<p name="FailMissingResults" type="string" qi="Controls the return value of the action when a search is not successful.">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[FindHeadingValue]]>
			</b>
<![CDATA[ : A regular expression to identify a specific column within the table heading.]]>
<![CDATA[
]]>
<![CDATA[        This is the column that will be used to find the row containing the FindRowValue search expression.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[FindRowValue]]>
			</b>
<![CDATA[ : A regular expression to identify a specific row within a table heading.]]>
<![CDATA[
]]>
<![CDATA[        This search will only be performed in the column identified by the FindHeadingValue parameter.]]>
<![CDATA[
]]>
<![CDATA[        Every row that matches the search expression will have the value saved from the column that matches ]]>
<![CDATA[
]]>
<![CDATA[        the column located by QueryColumn.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[QueryColumn]]>
			</b>
<![CDATA[ : A regular expression to identify a specific column within the table heading.]]>
<![CDATA[
]]>
<![CDATA[        This is the column that will be used to retrieve the desired table cell value.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[RowName]]>
			</b>
<![CDATA[ : The name of the new field that will contain all of the cell fields for a specific row.]]>
<![CDATA[
]]>
<![CDATA[        If this is left blank, the default value "Row" will be used.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[CellName]]>
			</b>
<![CDATA[ : The name of the new field that will contain the search result.]]>
<![CDATA[
]]>
<![CDATA[        This new field will be created under the row field that contained the search result.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[ValueStoreLocation]]>
			</b>
<![CDATA[ : The target DCO location to store the found text.]]>
<![CDATA[
]]>
<![CDATA[        The parameter must specify a batch, document, page or field object in the DCO.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[FailMissingResults]]>
			</b>
<![CDATA[ : This setting controls the return value of the action if the]]>
<![CDATA[
]]>
<![CDATA[        search fails to find a result.  If set to True, then the action will return False if]]>
<![CDATA[
]]>
<![CDATA[        the search does not find a result.  For example, if the search for the FindRowValue]]>
<![CDATA[
]]>
<![CDATA[        expression does not match a row, the QueryColumn expression does not match a column or]]>
<![CDATA[
]]>
<![CDATA[        if a cell does not exist in the row/column location of the target text.  If set to False,]]>
<![CDATA[
]]>
<![CDATA[        then a failure to find a search result will still cause the action to return true.]]>
<![CDATA[
]]>
<![CDATA[        This can be handy ignore missing search results allowing the application]]>
<![CDATA[
]]>
<![CDATA[        to perform multiple searches in a single function]]>
<![CDATA[
]]>
<![CDATA[        and to continue with following actions even if a value is not found.]]>
<![CDATA[
]]>
<![CDATA[        If there is an error other than a search not found, such as a the page layout not containing a table or]]>
<![CDATA[
]]>
<![CDATA[        another type of error that prevents the search from occurring, then the action will always return false.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for all parameters.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[        FindTableValueRegEx searches a table, extracts a value from a table cell and stores it in the DCO.]]>
<![CDATA[
]]>
<![CDATA[        Using search conditions to identify two columns and a row, it will return the text contained]]>
<![CDATA[
]]>
<![CDATA[        in the intersecting location and store it in the location specified by the ValueStoreLocation.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        To find the location of the text to return, several searches are performed using regular expression]]>
<![CDATA[
]]>
<![CDATA[        syntax. The first row of the table is considered to be the header row. The FindHeadingValue]]>
<![CDATA[
]]>
<![CDATA[        search expression finds a column within the table header row. Using that column location, it]]>
<![CDATA[
]]>
<![CDATA[        then searches each row of the table to match the FindRowValue expression. The row found is the row]]>
<![CDATA[
]]>
<![CDATA[        that will be used to obtain the final returned value, for each row that matches the ]]>
<![CDATA[
]]>
<![CDATA[        FindRowValue search expression.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The table header row is searched to find the column matches the QueryColumn expression.]]>
<![CDATA[
]]>
<![CDATA[        The column that matches this search is the column that will be used to obtain the final]]>
<![CDATA[
]]>
<![CDATA[        returned value.  Using the found column and found row, the text form the]]>
<![CDATA[
]]>
<![CDATA[        intersecting cell is then stored in the specified location.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[Table Requirement]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        The page must have an associated layout file. The recognition engine must have recognized]]>
<![CDATA[
]]>
<![CDATA[        a table on the page and identified it as a table in the layout file.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        The ability of a recognition engine to identify a table is dependent on the source document.]]>
<![CDATA[
]]>
<![CDATA[        In most cases, grid lines that define the table and its rows and columns are required for a table to be recognized]]>
<![CDATA[
]]>
<![CDATA[        and tagged appropriately within the layout file. You may find that one recognition engine does a better job]]>
<![CDATA[
]]>
<![CDATA[        on your type of tables vs. another recognition engine.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        The first row of the table is considered to be the header]]>
<![CDATA[
]]>
<![CDATA[        row.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        In some cases the recognition engine might recognize a table without grid lines. If it does recognize a table,]]>
<![CDATA[
]]>
<![CDATA[        the identification of the table's rows and columns is likely to be less accurate, even if the]]>
<![CDATA[
]]>
<![CDATA[        table is understandable to the human eye.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Not all recognition engines support table identification, and the table detection accuracy]]>
<![CDATA[
]]>
<![CDATA[        can vary between each engine.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[Multiple Tables]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        If the layout file contains multiple tables, only the first table will be searched with this action.]]>
<![CDATA[
]]>
<![CDATA[        To search tables other than the first table, the Locate action library action CreateVirtualPage]]>
<![CDATA[
]]>
<![CDATA[        has the ability to separate out sections of a page into unique pages.  Depending on the contents]]>
<![CDATA[
]]>
<![CDATA[        of the expected documents, this action can be used to break out tables into separate pages]]>
<![CDATA[
]]>
<![CDATA[        allowing FindTableValueRegEx to be used to search that new page containing only the]]>
<![CDATA[
]]>
<![CDATA[        table of interest.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[DCO Fields]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        The search results will be placed into DCO fields off of the DCO node specified by the]]>
<![CDATA[
]]>
<![CDATA[        ValueStoreLocation parameter.  For each table cell found by the search, a row field]]>
<![CDATA[
]]>
<![CDATA[        is created directly off of the parent dco node and then the found cell is created ]]>
<![CDATA[
]]>
<![CDATA[        as a child of the row.  This occurs for each row where a search value is found.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Here is a generic example of search results where the target DCO object is a field called "Table" (@P\Table)]]>
<![CDATA[
]]>
<![CDATA[        and assuming the specified CellName is "Cell":]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Table]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- Row2]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- --- Cell]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- Row3]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- --- Cell]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- Row5]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- --- Cell]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Note that it is possible to run additional searches and add additional found text]]>
<![CDATA[
]]>
<![CDATA[        to the field structure.  For example, assuming that a follow on search searches for]]>
<![CDATA[
]]>
<![CDATA[        a CellName "ZipCode", here is a possible field structure after the second search on the table:]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Table]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- Row2]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- --- Cell]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- --- Zip]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- Row3]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- --- Cell]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- --- Zip]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- Row4]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- --- Zip]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- Row5]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- --- Cell]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        --- --- Zip]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[DCO Variables]]>
			</b>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        Variables are created in the target DCO node that contain the found text.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        FindTableResultCount_xxxx : The number of found search results.  XXXX = the CellName]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        FindTableResult_xxxx_yyyy : The found text from the search. XXXX = the CellName,]]>
<![CDATA[
]]>
<![CDATA[        YYYY = result number.]]>
<![CDATA[
]]>
<![CDATA[        A unique variable is created]]>
<![CDATA[
]]>
<![CDATA[        for each matching row of data, starting with 0.  For example: FindTableResult_MyCell_0,]]>
<![CDATA[
]]>
<![CDATA[        FindTableResult_MyCell_1, FindTableResult_MyCell_2, etc. until the count is reached.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[Example 1:]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          CreateCcoFromLayout()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[FindTableValueRegEx("Heading01", "MyValue21", "Heading04", "Row", "MyCell", "@P\MyField", "True")]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          For this example, assume the following table exists:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Heading01 Heading02 Heading03 Heading04]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          MyValue11 MyValue12 MyValue13 MyValue14]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          MyValue21 MyValue22 MyValue23 MyValue24]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          MyValue31 MyValue32 MyValue33 MyValue34]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          The search criteria will identify the 3rd row of the table and the 4th]]>
<![CDATA[
]]>
<![CDATA[          column and obtain the text "MyValue24" and store it in a the variable FindTableResult_MyCell_0 of field "MyField".]]>
<![CDATA[
]]>
<![CDATA[          The variable FindTableResultCount_MyCell will be created with the value of 1.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Fields will be created in the target DCO node that can be manipulated with subsequent actions]]>
<![CDATA[
]]>
<![CDATA[          or used for verification.  For the above example, it is required that the field MyField]]>
<![CDATA[
]]>
<![CDATA[          exists and the following DCO field hierarchy will be created under it:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          MyField]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- Row3]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- --- MyCell]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          The text value of MyCell will be "MyValue24".]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[Example 2:]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          CreateCcoFromLayout()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[FindTableValueRegEx("Heading01", "MyValueBB", "Heading04", "Row", "MyCell", "@P\Table")]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          For this example, assume the following table exists:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Heading01 Heading02 Heading03 Heading04]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          MyValueAA MyValue12 MyValue13 MyValue14]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          MyValueBB MyValue22 MyValue23 MyValue24]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          MyValueBB MyValue32 MyValue33 MyValue34]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          MyValueCC MyValue42 MyValue43 MyValue44]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          MyValueBB MyValue42 MyValue53 MyValue54]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          The search criteria will identify the 3rd, 4th and 6th row of the table and the 4th]]>
<![CDATA[
]]>
<![CDATA[          column and obtain the text "MyValue24" and store it in a the variable FindTableResult_MyCell_0 of]]>
<![CDATA[
]]>
<![CDATA[          the field "Table", store "MyValue34"in the variable FindTableResult_MyCell_1 and store "MyValue54"]]>
<![CDATA[
]]>
<![CDATA[          into the variable FindTableResult_MyCell_2.  The variable FindTableResultCount_MyCell will be]]>
<![CDATA[
]]>
<![CDATA[          created with the value of 3.]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          For the above example, it is expected that the field Table already exists and]]>
<![CDATA[
]]>
<![CDATA[          the following DCO field hierarchy will be created under it:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Table]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- Row3]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- --- MyCell]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- Row4]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- --- MyCell]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- Row6]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- --- MyCell]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          The text value of MyCell under row3 will be "MyValue24".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          The text value of MyCell under row4 will be "MyValue34".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          The text value of MyCell under row6 will be "MyValue54".]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[Example 3:]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          CreateCcoFromLayout()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[FindTableValueRegEx("Heading01", "MyValueBB", "Heading03", "Row", "SSN", "@P\Table")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[FindTableValueRegEx("Heading01", "MyValueBB", "Heading04", "Row", "ZIP", "@P\Table")]]>
				</b>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          For this example, assume the following table exists:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Heading01 Heading02 Heading03 Heading04]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          MyValueAA MyValue12 MyValue13 MyValue14]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          MyValueBB MyValue22 MyValue23 MyValue24]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          MyValueBB MyValue32 MyValue33 MyValue34]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          MyValueCC MyValue42 MyValue43 MyValue44]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          MyValueBB MyValue42 MyValue53 MyValue54]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Notice that this example performs two searches on the same table and stores the]]>
<![CDATA[
]]>
<![CDATA[          result in the same DCO object, building on the same field structure.]]>
<![CDATA[
]]>
<![CDATA[          For the above example, it is expected that the field Table already exists and]]>
<![CDATA[
]]>
<![CDATA[          the following DCO field hierarchy will be created under it:]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Table]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- Row3]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- --- SSN]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- --- ZIP]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- Row4]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- --- SSN]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- --- ZIP]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- Row6]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- --- SSN]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          --- --- ZIP]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          The text value of SSN under row3 will be "MyValue23".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          The text value of SSN under row4 will be "MyValue33".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          The text value of SSN under row6 will be "MyValue53".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          The text value of ZIP under row3 will be "MyValue24".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          The text value of ZIP under row4 will be "MyValue34".]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          The text value of ZIP under row6 will be "MyValue54".]]>
				<br>
				</br>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        If FailMissingResults is "True", then the action ]]>
<![CDATA[
]]>
<![CDATA[        returns ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if text is located. Returns ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ if there is an error]]>
<![CDATA[
]]>
<![CDATA[        or if the text is not located.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If FailMissingResults is "False", then the action]]>
<![CDATA[
]]>
<![CDATA[        returns ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if text is located or if the search conditions do not find a match. Returns ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[        if there is an error performing the search.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
		<see>
<![CDATA[CreateVirtualPage (Locate), SetVirtualPageStartPosition (Locate), SetVirtualPageEndPosition (Locate), ]]>
<![CDATA[
]]>
<![CDATA[      CreateCcoFromLayout (Locate), MergeLayoutByType (Autodoc), Recognize (OCRA), Recognize (OCRS)]]>
		</see>
	</method>
	<method name="ExtractTextNLP">
		<p name="options" type="string" qi="Comma separated list of text features to call. Smart parameters supported.">
		</p>
		<p name="model" type="string" qi="ID of a deployed Watson Knowledge Studio custom model to override the default model">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        The action calls the Natural Lanuguage Prcessing(NLP) API and passes in text from one page at a time.]]>
<![CDATA[
]]>
<![CDATA[        The results are saved as entities in the page's layout XML file. Use the FindExtractedText action to populate fields with results of this action.]]>
<![CDATA[
]]>
<![CDATA[        To extract from non-English text, set the page variable hr_locale to the desired language before calling this action e.g. for Japanese call rrset("ja","@P.hr_locale")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<dl>
<![CDATA[
]]>
<![CDATA[          ]]>
				<dlentry>
<![CDATA[
]]>
<![CDATA[            ]]>
					<dt>
<![CDATA[Parameter text features:]]>
					</dt>
<![CDATA[
]]>
<![CDATA[            ]]>
					<dd>
<![CDATA[No parameter - returns all results]]>
					</dd>
<![CDATA[
]]>
<![CDATA[          ]]>
				</dlentry>
<![CDATA[
]]>
<![CDATA[        ]]>
			</dl>
<![CDATA[
]]>
<![CDATA[        ]]>
			<ul>
<![CDATA[
]]>
<![CDATA[          ]]>
				<li>
<![CDATA[entities]]>
				</li>
<![CDATA[
]]>
<![CDATA[          ]]>
				<li>
<![CDATA[keywords]]>
				</li>
<![CDATA[
]]>
<![CDATA[          ]]>
				<li>
<![CDATA[categories]]>
				</li>
<![CDATA[
]]>
<![CDATA[          ]]>
				<li>
<![CDATA[concepts]]>
				</li>
<![CDATA[
]]>
<![CDATA[          ]]>
				<li>
<![CDATA[semantic_roles]]>
				</li>
<![CDATA[
]]>
<![CDATA[          ]]>
				<li>
<![CDATA[relations]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
			</ul>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[Important:]]>
			</b>
<![CDATA[ You must have an enterprise NLP license to use this action. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[This license is obtained by creating an account on bluemix.net and adding the NLP service to a workspace.  The URL and credentials are shown on the Service Credentials page.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[In Datacap Application Manager:]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<ul>
<![CDATA[
]]>
<![CDATA[          ]]>
				<li>
<![CDATA[Save the URL in your application's general section in a variable called NLPApiUrl.]]>
				</li>
<![CDATA[
]]>
<![CDATA[          The default URL of the NLPApiUrl if not updated is https://gateway.watsonplatform.net/natural-language-understanding/api/v1/analyze?version=2017-02-27.]]>
<![CDATA[
]]>
<![CDATA[          You can also pass a custom model id as second parameter of the action.]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				<li>
<![CDATA[Save the username in your application's gen section in a variable called NLPApiUsername.]]>
				</li>
<![CDATA[
]]>
<![CDATA[          ]]>
				<li>
<![CDATA[Save the password in your application's adv section in a variable called NLPApiPassword.]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
			</ul>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
			<b>
<![CDATA[Response:]]>
			</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[Entities are named using the format NLPFeature.ResponseNode.  For example, an entity result for a person will have the name Entity.Person.  Most entity fields will be named using the node returned by NLPAPI.  Nested responses are flattened to one level.  For example, the disambiguated sub type will be named subTypes and the results will be saved as a comma-separated list.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
			<b>
<![CDATA[Variables:]]>
			</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			<dl>
<![CDATA[
]]>
<![CDATA[          ]]>
				<dlentry>
<![CDATA[
]]>
<![CDATA[            ]]>
					<dt>
<![CDATA[Timeout]]>
					</dt>
<![CDATA[
]]>
<![CDATA[            ]]>
					<dd>
<![CDATA[
]]>
<![CDATA[              The default timeout is 150 seconds.  You can specify the timeout by saving a page variable called ]]>
						<b>
<![CDATA[nlpTimeout]]>
						</b>
<![CDATA[ and specifying the time in milliseconds.]]>
<![CDATA[
]]>
<![CDATA[            ]]>
					</dd>
<![CDATA[
]]>
<![CDATA[          ]]>
				</dlentry>
<![CDATA[
]]>
<![CDATA[          ]]>
				<dlentry>
<![CDATA[
]]>
<![CDATA[            ]]>
					<dt>
<![CDATA[Save Response]]>
					</dt>
<![CDATA[
]]>
<![CDATA[            ]]>
					<dd>
<![CDATA[
]]>
<![CDATA[              The response from NLPAPI can be saved by setting the variable ]]>
						<b>
<![CDATA[nlpSaveResponse]]>
						</b>
<![CDATA[ to 1.]]>
<![CDATA[
]]>
<![CDATA[            ]]>
					</dd>
<![CDATA[
]]>
<![CDATA[          ]]>
				</dlentry>
<![CDATA[
]]>
<![CDATA[        ]]>
			</dl>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[When called on the document or page, the text of the layout XML file specified in the calling object's layout variable will be sent to NLPAPI.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[The results will be saved to the entities list of the page in the layout XML file.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[To populate a field with a result of this action, use the FindExtractedText action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          AnalyzeLayout()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[ExtractTextNLP()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          FindExtractedText()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          Recognize()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          AnalyzeLayout()]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[ExtractTextNLP()]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          CobyAllBlocks()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Document or Page.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[ if the layout is loaded and there are no errors. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
</net>
<com ref="DocumentAnalytics.VisualRecognitionActions" qi="IBM Watson Visual Recognition Actions.">
	<h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Visual Recognition Classifier is an IBM Watson service which can be trained to classify image based documents.]]>
<![CDATA[
]]>
<![CDATA[	]]>
		<br>
		</br>
		<br>
		</br>
<![CDATA[
]]>
<![CDATA[    You could use the default classifier to do the classification, or you could first create and train a custom classifier by using some representative set of training data.]]>
<![CDATA[
]]>
<![CDATA[    The uploaded training data must contain at least two compressed (.zip) files each containing sample images of a particular class]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<br>
		</br>
		<br>
		</br>
<![CDATA[
]]>
<![CDATA[	Once the classifier has been trained, you can give it other similar documents and classifier will attempt to classify them according to its training.  ]]>
<![CDATA[
]]>
<![CDATA[	The Classifier will return a confidence score associated with the classification.]]>
<![CDATA[
]]>
<![CDATA[	]]>
		<br>
		</br>
		<br>
		</br>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</h>
	<method name="VisualRecogClassify">
		<p name="ClassifierName" type="string" qi="Name of the Classifier to be used">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[      Classify image using IBM Watson Visual Recognition API.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	  This action identifies a page using the IBM Visual Recognition technology. This technology analyzes the image based full page and attempts to find match within]]>
<![CDATA[
]]>
<![CDATA[      the classes that have been defined for the selected classifier. If a match is found, the Page type is populated with the ID of the category that was matched.]]>
			<br>
			</br>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	  If a match is not found, the page type is set to "Other". ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	  When classification is complete, a list of matches and their confidence values are stored in the ]]>
			<b>
<![CDATA["MatchingCategoryX"]]>
			</b>
<![CDATA[ and ]]>
			<b>
<![CDATA["MatchingCategoryConfX"]]>
			</b>
<![CDATA[ variables. ]]>
<![CDATA[
]]>
<![CDATA[	  The number of matches is stored in the variable ]]>
			<b>
<![CDATA["MatchingCategoriesCount"]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  To run classification without updating the page type, set the variable "UpdateDCOType" to "0" prior to calling this action. ]]>
<![CDATA[
]]>
<![CDATA[	  In this case classification will not update the page type, but the variables mentioned above will still be populated.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	  Because the pages must be the image file (.jpg, or .png) or compressed (.zip) file of images, ]]>
			<b>
<![CDATA[ConvertToJPEG]]>
			</b>
<![CDATA[ must be called prior to using the Classify action. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The ]]>
			<b>
<![CDATA[ClassifierName]]>
			</b>
<![CDATA[ can be a smart parameter.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
			<e>
<![CDATA[
]]>
<![CDATA[	    VisualRecogSetCredentials( "@APPVAR(values/adv/VRAPIKey)")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[VisualRecogClassify("@APPVAR(values/gen/VRClassifierName)")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="VisualRecogSetCredentials">
		<p name="APIKey" type="string" qi="Unique API Key">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[      Sets the credentials to be used to do the classification]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[      The ]]>
			<b>
<![CDATA[APIKey]]>
			</b>
<![CDATA[ can be Smart Parameters]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[VisualRecogSetCredentials( "@APPVAR(values/adv/VRAPIKey)")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[		VisualRecogClassify("@APPVAR(values/gen/VRClassifierName)") ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Batch level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="VisualRecogTrain">
		<p name="ZIPDirectory" type="string" qi="Directory where this action will store the zip file with the training data.                                                  the zip file will have the name of the classifier.  This parameter supports                SmartParameters.">
		</p>
		<p name="Name" type="string" qi="Name to give the classifier.  This name will be used when you later try to classify a page.                                     This parameter supports SmartParameters.">
		</p>
		<p name="deleteExisting" type="string" qi="Delete the classifier of the same name if it exists. If this flag is set to                                                 true, it will delete the classifier of the same name, if it exists. If this                flag is set to false and a classifier with the same name exists, this action                will add the training data to the existing classifier.  This parameter supports S               martParameters.  The type of this parameter is string only to support                SmartParameters.  Internally, it is treated as a boolean.  Specify '1' for true                and '0' for false.  Any other value will be ignored and the action will default to false.">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[		This action will create/replace a Visual Recognition Classifier.  Pages of the batch will be used as the ]]>
<![CDATA[
]]>
<![CDATA[        training data.  It is expected that the batch will be in a certain format.  In particular, ]]>
<![CDATA[
]]>
<![CDATA[		the batch needs be divided into set documents where the 'Type' associated with the document]]>
<![CDATA[
]]>
<![CDATA[        will be class that will be created in the Visual Recognition Service.  All of pages in that document ]]>
<![CDATA[
]]>
<![CDATA[        will be treated as training data for that class.  So, for example, if you wanted to train the classifier to ]]>
<![CDATA[
]]>
<![CDATA[        recognize the main page and the trailing pages of a mortgage application, you would create a ]]>
<![CDATA[
]]>
<![CDATA[        batch with two documents:  Main_Page and Trailing_Page.  Put all of the training page for the ]]>
<![CDATA[
]]>
<![CDATA[		main page under the Main_Page document and the trailing pages under Trailing_Page document.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          VisualRecogSetCredentials("@APPVAR(values/adv/VRAPIKey)")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[VisualRecogTrain("@APPPATH(runtime)+\+..+\+ZIP","@APPVAR(values/gen/VRClassifierName)","1")]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Batch Level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ action is successful. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="VisualRecogSetMinConfidence" qi="Sets the minimum confidence score for classification matching.">
		<p name="MinScore" type="string" qi="Minimum score for classification matching. Valid values are fractional values between zero and one (for example: 0.0 and 1.0) ">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        When Classify searches for a classification match, a score between zero (no match) and one (a]]>
<![CDATA[
]]>
<![CDATA[        positive match) is calculated. This action sets the minimum score that a match must have]]>
<![CDATA[
]]>
<![CDATA[        to be considered a match. Any matches with a score less than the value specified is rejected.]]>
<![CDATA[
]]>
<![CDATA[        With this action, you can control the tolerance for documents matching an existing example. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        When setting up the parameter in your application, use the decimal character from the system locale defined]]>
<![CDATA[
]]>
<![CDATA[        for the application in the Taskmaster Application Manager.  For example, when the decimal character is]]>
<![CDATA[
]]>
<![CDATA[        a period, use a value from 0.0 to 1.0.  When the decimal character is a comma, use a value from 0,0 to 1,0.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		The ]]>
			<b>
<![CDATA[MinScore]]>
			</b>
<![CDATA[ can be a Smart Parameter]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before the Classify action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          VisualRecogSetCredentials("@APPVAR(values/adv/VRAPIKey)")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[VisualRecogSetMinConfidence(0.9)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          VisualRecogClassify("@APPVAR(values/gen/VRClassifierName")) ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True ]]>
			</b>
<![CDATA[if the parameter value is between the valid range of zero to one (0.0 and 1.0) Otherwise, ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
</com>
<com ref="DocumentAnalytics.NaturalLanguageClassifierActions" qi="IBM Watson Natural Language Classifier Actions.">
	<h>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Natural Language Classifier is an IBM Watson service which can be trained to classify documents or sections of ]]>
<![CDATA[
]]>
<![CDATA[	documents based on the text contained in the document or the section of a document.]]>
<![CDATA[
]]>
<![CDATA[	]]>
		<br>
		</br>
		<br>
		</br>
<![CDATA[
]]>
<![CDATA[	To do this, you must first create and train a classifier using some representative set of training data containing]]>
<![CDATA[
]]>
<![CDATA[	text from a set of sample documents.  Once the classifier has been trained, you can give it other similar documents]]>
<![CDATA[
]]>
<![CDATA[	and classifier will attempt to classify them according to its training.  The Classifier will return a confidence]]>
<![CDATA[
]]>
<![CDATA[	score associated with the classification.]]>
<![CDATA[
]]>
<![CDATA[	]]>
		<br>
		</br>
		<br>
		</br>
<![CDATA[
]]>
<![CDATA[	Because Natural Language Classifier works on the text of the document, you must first perform OCR on the document]]>
<![CDATA[
]]>
<![CDATA[	prior to calling the Classify action to do the classification]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</h>
	<method name="NLCClassify">
		<p name="ClassifierName" type="string" qi="Name of the Classifier to be used">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        This action identifies a page using the IBM Natural Language technology. This technology analyzes the full text of pages and attempts to find match within]]>
<![CDATA[
]]>
<![CDATA[        the classes that have been defined for the selected classifier. If a match is found, the Page type is populated with the ID of the category that was matched.]]>
			<br>
			</br>
<![CDATA[ If a match is not]]>
<![CDATA[
]]>
<![CDATA[        found, the page type is set to "Other". ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        When classification is complete, a list of matches and their confidence values are stored in the ]]>
			<b>
<![CDATA["MatchingCategoryX"]]>
			</b>
<![CDATA[ and ]]>
			<b>
<![CDATA["MatchingCategoryConfX"]]>
			</b>
<![CDATA[ variables. The number of matches is stored in the variable ]]>
			<b>
<![CDATA["MatchingCategoriesCount"]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        To run classification without updating the page type, set the variable "UpdateDCOType" to "0" prior to calling this action. In this case classification will not update the page type, but the variables mentioned above will still be populated.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Because the matching relies on a page's full text, a full page recognition action must be called prior to using the Classify action. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		This action will get the text for the page in the following order:]]>
<![CDATA[
]]>
<![CDATA[		]]>
			<ul>
<![CDATA[
]]>
<![CDATA[		]]>
				<li>
<![CDATA[ from the layout.xml file generated by the ]]>
					<b>
<![CDATA[Recognize]]>
					</b>
<![CDATA[ action ]]>
				</li>
<![CDATA[
]]>
<![CDATA[		]]>
				<li>
<![CDATA[ from the .txt file generated by the ]]>
					<b>
<![CDATA[RecognizeToFile]]>
					</b>
<![CDATA[ action ]]>
				</li>
<![CDATA[
]]>
<![CDATA[		]]>
				<li>
<![CDATA[ from the .cco file generated by the ]]>
					<b>
<![CDATA[RecognizePage]]>
					</b>
<![CDATA[ action ]]>
				</li>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[		]]>
			</ul>
<![CDATA[
]]>
<![CDATA[        The ]]>
			<b>
<![CDATA[ClassifierName]]>
			</b>
<![CDATA[ can be a smart parameter.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          NLCSetLanguage("en")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          NLCSetCredentials("@APPVAR(values/gen/NLCUserName)","@APPVAR(values/adv/NLCPassword)")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          NLCSetMinConfidence(0.9)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          Recognize() ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[NLCClassify("@APPVAR(values/gen/NLCClassifierName)")]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Page level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ action is successful. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="NLCClassifyText">
		<p name="ClassifierName" type="string" qi="Name of the Classifier to be used">
		</p>
		<p name="TextToClassify" type="string" qi="Text to be classified using the Natural Language Classifier.  This parameter supports                SmartParameters.">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        This action classifies the specified text using the IBM Natural Language technology. This technology analyzes the text specified and attempts to find match within]]>
<![CDATA[
]]>
<![CDATA[        the classes that have been defined for the selected classifier. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        When classification is complete, a list of matches and their confidence values are stored in the ]]>
			<b>
<![CDATA["MatchingCategoryX"]]>
			</b>
<![CDATA[ and ]]>
			<b>
<![CDATA["MatchingCategoryConfX"]]>
			</b>
<![CDATA[ variables. The number of matches is stored in the variable ]]>
			<b>
<![CDATA["MatchingCategoriesCount"]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Both ]]>
			<b>
<![CDATA[ClassifierName]]>
			</b>
<![CDATA[ and ]]>
			<b>
<![CDATA[TextToClassify]]>
			</b>
<![CDATA[ can be smart parameters]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          NLCSetCredentials("@APPVAR(values/gen/NLCUserName)","@APPVAR(values/adv/nlcpassword)")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          NLCSetMinConfidence(0.9)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[NLCClassifyText("@APPVAR(values/gen/NLCClassifierName)","Sample Text")]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ action is successful. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="NLCTrain">
		<p name="CSVDirectory" type="string" qi="Directory where this action will store the csv file with the training data.                                                  CSV file will have the name of the classifier.  This parameter supports                SmartParameters.">
		</p>
		<p name="Name" type="string" qi="Name to give the classifier.  This name will be used when you later try to classify a page.                                     This parameter supports SmartParameters.">
		</p>
		<p name="deleteExisting" type="string" qi="Delete the classifier of the same name if it exists. If this flag is set to                                                 true, it will delete the classifier of the same name, if it exists. If this                flag is set to false and a classifier with the same name exists, this action                will return false.  This parameter supports SmartParameters.  The type of this             parameter is string only to support SmartParameters.  Internally, it is treated             as a boolean.  Specify '1' for true and '0' for false.  Any other value will             be ignored and the action will default to false.">
		</p>
		<p name="appendToCSV" type="string" qi="If an existing csv file found, this parameter indicates if the training data                                              from this batch should be appended to it or that it should be overwritten. If                true, the classifier will be trained with the data in the csv file and the new                data from this batch.  If false, the existing data in the csv file will be                overwritten and the classifier will be trained with just the data in this batch.                 This parameter supports SmartParameters.  The type of the parameter is string                only to support SmartParameters.  Internally, it is treated as a boolean.                 Specify '1' for true and '0' for false.  Any other value will be ignored and the                action will default to true.">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[		This action will create/replace an NLC Classifier.  Pages of the batch will be used as the ]]>
<![CDATA[
]]>
<![CDATA[        training data.  It is expected that the batch will be in a certain format.  In particular, ]]>
<![CDATA[
]]>
<![CDATA[		the batch needs be divided into set documents where the 'Type' associated with the document]]>
<![CDATA[
]]>
<![CDATA[        will be class that will be created in NLC.  All of pages in that document will be treated as ]]>
<![CDATA[
]]>
<![CDATA[        training data for that class.  So, for example, if you wanted to train the classifier to ]]>
<![CDATA[
]]>
<![CDATA[        recognize the main page and the trailing pages of a mortgage application, you would create a ]]>
<![CDATA[
]]>
<![CDATA[        batch with two documents:  Main_Page and Trailing_Page.  Put all of the training page for the ]]>
<![CDATA[
]]>
<![CDATA[		main page under the Main_Page document and the trailing pages under Trailing_Page document.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          NLCSetLanguage("en")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          NLCSetCredentials("@APPVAR(values/gen/NLCUserName)","@APPVAR(values/adv/NLCPassword)")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[NLCTrain("@APPPATH(runtime)+\+..+\+CSV","@APPVAR(values/gen/NLCClassifierName)","1","1")]]>
				</b>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[Batch Level.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ action is successful. Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
	<method name="NLCSetCredentials">
		<p name="UserName" type="string" qi="UserName">
		</p>
		<p name="Password" type="string" qi="Password">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[      Sets the credentials to be used to do the classification]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[	  The ]]>
			<b>
<![CDATA[UserName]]>
			</b>
<![CDATA[ and ]]>
			<b>
<![CDATA[password]]>
			</b>
<![CDATA[ can be Smart Parameters]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[	  In order to protect the secrecy of the ]]>
			<b>
<![CDATA[Password]]>
			</b>
<![CDATA[ , it is ]]>
<![CDATA[
]]>
<![CDATA[	  recommended that you store it as an Advanced custom value in the]]>
<![CDATA[
]]>
<![CDATA[	  Datacap Application Manager ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          NLCSetLanguage("en")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[NLCSetCredentials("@APPVAR(values/gen/NLCUserName)","@APPVAR(values/adv/NLCPassword)")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          NLCSetMinConfidence(0.9)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          Recognize() ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          NLCClassify("@APPVAR(values/gen/NLCClassifierName)")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="NLCSetLanguage" qi="Sets the language of the page to be classified.">
		<p name="LanguageCode" type="string" qi="The two-letter code associate with the language of the page to be classified">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        This action sets the language of the page to be classified.]]>
<![CDATA[
]]>
<![CDATA[		The ]]>
			<b>
<![CDATA[LanguageCode]]>
			</b>
<![CDATA[ can be a smart parameter]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[		The possible values for the Language code are:]]>
<![CDATA[
]]>
<![CDATA[		]]>
			<ul>
<![CDATA[
]]>
<![CDATA[		]]>
				<li>
<![CDATA[ 'en' : English ]]>
				</li>
<![CDATA[
]]>
<![CDATA[		]]>
				<li>
<![CDATA[ 'ar' : Arabic ]]>
				</li>
<![CDATA[
]]>
<![CDATA[		]]>
				<li>
<![CDATA[ 'fr' : French ]]>
				</li>
<![CDATA[
]]>
<![CDATA[		]]>
				<li>
<![CDATA[ 'de' : German ]]>
				</li>
<![CDATA[
]]>
<![CDATA[		]]>
				<li>
<![CDATA[ 'it' : Italian ]]>
				</li>
<![CDATA[
]]>
<![CDATA[		]]>
				<li>
<![CDATA[ 'ja' : Japanese ]]>
				</li>
<![CDATA[
]]>
<![CDATA[		]]>
				<li>
<![CDATA[ 'ko' : Korean ]]>
				</li>
<![CDATA[
]]>
<![CDATA[		]]>
				<li>
<![CDATA[ 'pt' : Portuguese (Brazilian) ]]>
				</li>
<![CDATA[
]]>
<![CDATA[		]]>
				<li>
<![CDATA[ 'es' :Spanish ]]>
				</li>
<![CDATA[
]]>
<![CDATA[		]]>
			</ul>
<![CDATA[
]]>
<![CDATA[		]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before the Classify action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[NLCSetLanguage("en")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          NLCSetCredentials("@APPVAR(values/gen/NLCUserName)","@APPVAR(values/adv/NLCPassword)")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          NLCSetMinConfidence(0.9)]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          Recognize() ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          NLCClassify("@APPVAR(values/gen/NLCClassifierName)")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[All]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
	<method name="NLCSetMinConfidence" qi="Sets the minimum confidence score for classification matching.">
		<p name="MinScore" type="string" qi="Minimum score for classification matching. Valid values are fractional values between zero and one (for example: 0.0 and 1.0) ">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[        When Classify searches for a classification match, a score between zero (no match) and one (a]]>
<![CDATA[
]]>
<![CDATA[        positive match) is calculated. This action sets the minimum score that a match must have]]>
<![CDATA[
]]>
<![CDATA[        to be considered a match. Any matches with a score less than the value specified is rejected.]]>
<![CDATA[
]]>
<![CDATA[        With this action, you can control the tolerance for documents matching an existing example. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        When setting up the parameter in your application, use the decimal character from the system locale defined]]>
<![CDATA[
]]>
<![CDATA[        for the application in the Taskmaster Application Manager.  For example, when the decimal character is]]>
<![CDATA[
]]>
<![CDATA[        a period, use a value from 0.0 to 1.0.  When the decimal character is a comma, use a value from 0,0 to 1,0.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		The ]]>
			<b>
<![CDATA[MinScore]]>
			</b>
<![CDATA[ can be a Smart Parameter]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[        This action must be called before the Classify action.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          NLCSetLanguage("en")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          NLCSetCredentials("@APPVAR(values/gen/NLCUserName)","@APPVAR(values/adv/NLCPassword)")]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[NLCSetMinConfidence(0.9)]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          Recognize() ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          NLCClassify("@APPVAR(values/gen/NLCClassifierName)") ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[All.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[        ]]>
			<b>
<![CDATA[True ]]>
			</b>
<![CDATA[if the parameter value is between the valid range of zero to one (0.0 and 1.0) Otherwise, ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
		</ret>
	</method>
</com>
</rrx>
<rrx namespace="Documentum" src="c:\datacap\RRS\Documentum.dll">

<i ref="rrunner">
</i>
<f name="DM_Logon" access="public">
	<p name="sRepositoryDomain">
	</p>
	<p name="sRepositoryName">
	</p>
	<p name="sUserID">
	</p>
	<p name="sPassword">
	</p>
</f>
<af name="DM_UploadPage" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="DM_UploadDocument" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="DM_SetFolderName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="DM_SetObjectName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="DM_SetContentType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<help>
<![CDATA[

'************************************************************************
' Documentum.rrx - Documentum Content Server Upload Actions
' Based on the Documentum Foundation Classes 
' Requires DFC Version 6.x installed on a computer where these actions are running.  Earlier versions *may* work.

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************************
'
' Initial Help.xml created 5/24/2012 PHofle
'
]]>
  
  <ref id="DM_Logon" >
  <p name="sRepositoryDomain"/>
  <p name="sRepositoryName"/>
  <p name="sUserID"/>
  <p name="sPassword"/>
  <ap>
    sRepositoryDomain : The machine name for the repository.<br/>
    sRepositoryName : The name of the repository.<br/>
    sUserID : The userid for logon.<br/>
    sPassword : The password.<br/><br/>
    
    The parameters sRepositoryName, sUserID and sPassword cannot be blank.
    Smart parameters are supported.<br/>
    Note: Use a smart parameter to obtain an encrypted password from
    the appliation service instead of hard coding a clear text password in the rules.
  </ap>
  <lvl>
    This action can be called at any level but is recommended to be called at the batch level.
    It should be called only once per task.
  </lvl>
  <ret>
    <b>True,</b> if the logon is successful.  Otherwise, <b>False.</b>
  </ret>
    <h>
      Creates the connection to the repository where the pages will be uploaded.  This action must
      be called prior to DM_UploadPage or DM_UploadDocument.  The user ID must have
      write permission or files cannot be uploaded.<br/><br/>
      
      It is recommended that you create an advanced value in the custom values tab in the
      Applicaiton Manager to store your password.      
      <e>
        <b>DM_Logon("machinename", "repository", "userid", "password")</b><br/><br/>

        <b>DM_Logon("machinename", "repository", "userid", "@APPVAR(values/adv/MyPassword)")</b><br/>
        This example uses the smart paramter @APPVAR to obtain the password from the
        advanced value section of the applicaiton manager.  The custom value name is "MyPassword".<br/><br/>
        
        <b>DM_Logon("", "repository", "userid", "@APPVAR(values/adv/MyPassword)")</b><br/>
      </e>
    </h>
  <see>DM_UploadPage DM_UploadDocument</see>
</ref>


  <ref id="DM_UploadPage">
    <ap>
      None.
    </ap>
    <lvl>
      Page level.
    </lvl>
    <ret>
      <b>True,</b> if the page is uploaded to the repository.  Otherwise, <b>False.</b><br/><br/>

      If the file fails to upload or if the file is missing from the batch, the batch will be set to abort.
    </ret>
    <h>
      This action uploads the current page to the repository.
      An XML file called DM_Uploaded.xml is created in the batch directory.
      This file lists all of pages that have been uploaded.<br/><br/>

      DM_Logon must have been previously called.
      Additionally, the destination folder,
      final object name and content type must have been previously set.
      <e>
        DM_SetFolderName("/folder1/folder2")<br/>
        DM_SetContentType("tiff")<br/>
        DM_SetObjectName("@ID")<br/>
        <b>DM_UploadPage()</b><br/>
      </e>
    </h>
    <see>DM_SetFolderName DM_SetContentType DM_SetObjectName</see>
  </ref>

<ref id="DM_UploadDocument" >
  <ap>
    None.
  </ap>
  <lvl>
    Document level.
  </lvl>
  <ret>
    <b>True,</b> if all of the pages within the document are uploaded to the repository.  Otherwise, <b>False.</b><br/><br/>

    If any of the files for the document are missing from the batch, it is not considered an 
    error and the batch will not abort. If the upload to Documentum fails due to a different reason, 
    the document upload will stop and the batch will be set to abort.
  </ret>
  <h>
    This action will upload all of the pages that are attached to a document.
    An XML file called DM_Uploaded.xml is created in the batch directory.
    This file lists all of pages that have been uploaded.<br/><br/>

    DM_Logon must have been previously called.  Additionally, the destination folder,
    final object name and content type must have been previously set.  When uploading a document
    using this action, all pages must be of the same type.
    <e>
      DM_SetFolderName("/folder1/folder2")<br/>
      DM_SetContentType("tiff")<br/>
      DM_SetObjectName("@ID")<br/>
      <b>DM_UploadDocument()</b><br/>
    </e>
  </h>
  <see>DM_SetFolderName DM_SetContentType DM_SetObjectName</see>
</ref>

  <ref id="DM_SetFolderName">
  <ap>
    Repository folder where the file will be uploaded.
    Smart parameters are supported.
  </ap>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    The name of the cabinet / folder that will hold the uploaded file.  The path specification to the folder
    can be specified using a typical folder syntax separated by forward slashes, such as
    /folder/anotherfolder/finalfolder.  Alternatively, the target folder can be specified
    by the object ID of the folder as defined in the repository, without any slashes.<br/><br/>

    This action does not confirm that the folder actually exists in the repository.
    If the specified content type is incorrect, the upload action will report the error.
    This action must be called prior to DM_UploadPage or DM_UploadDocument.
    <e>
      <b>DM_SetFolderName("/folder1/folder2")</b><br/>
      DM_SetContentType("tiff")<br/>
      DM_SetObjectName("@ID")<br/>
      DM_UploadPage()<br/>
      This example shows the folder path as it exists in the repository.<br/><br/>

      <b>DM_SetFolderName("0c0022538000252d")</b><br/>
      DM_SetContentType("tiff")<br/>
      DM_SetObjectName("@ID")<br/>
      DM_UploadPage()<br/>
      This example uses the object ID of the destination folder in the repository.
    </e>
  </h>
  <see>DM_UploadPage DM_UploadDocument</see>
</ref>

  <ref id="DM_SetObjectName">
  <ap>
    The name for the uploaded file as it will appear in repository.
    Smart parameters are supported.
  </ap>
  <lvl>Any level.</lvl>
  <ret>Always <b>True.</b></ret>
  <h>
    This action is used to set the name of the uploaded file.  This is not the file name as it exists in the batch,
    but the final name that will be used when viewed in the repository.<br/><br/>

    This action must be called prior to DM_UploadPage or DM_UploadDocument.
    <e>
      DM_SetFolderName("/folder1/folder2")<br/>
      DM_SetContentType("tiff")<br/>
      <b>DM_SetObjectName("@ID")</b><br/>
      DM_UploadDocument()<br/>      
    </e>
  </h>
  <see>DM_UploadPage DM_UploadDocument</see>
</ref>

  <ref id="DM_SetContentType">
  <ap>
    The repository defined type for this page. 
    Smart parameters are supported.
  </ap>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    Sets the type for the page to be uploaded.  This type must be pre-defined in the repository.
    This action does not test that the specified type exists in the repository.
    If the specified content type is incorrect, the upload action will report the error.<br/><br/>

    This action must be called prior to DM_UploadPage or DM_UploadDocument.
    <e>
      DM_SetFolderName("/folder1/folder2")<br/>
      <b>DM_SetContentType("tiff")</b><br/>
      DM_SetObjectName("@ID")<br/>
      DM_UploadDocument()<br/>
    </e>
  </h>
  <see>DM_UploadPage DM_UploadDocument</see>
</ref>
</help>
</rrx>
<rrx namespace="Email" src="c:\datacap\RRS\Email.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="SetMailServer" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ 'Configures the mail server to use for sending mail."]]>
<![CDATA[
]]>
<![CDATA[ '  The IP or DNS address of the outgoing mail (SMTP) server.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   SetMailServer = true]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if (gOutlookInit) then]]>
<![CDATA[
]]>
<![CDATA[     ' When not set, these actions will always create an outlook email object.]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Warning, SetMailServer was called while the Outlook object is in use.")]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   gMailServer=trim(MetaWord(StrParam))]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Setting for IP or DNS address of SMTP server is:" & gMailServer)]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetRecipients" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Sets email recipients' address(es)."]]>
<![CDATA[
]]>
<![CDATA[  'Email address(es) of recipient(s).  You can either call this action multiple times to add multiple recipients,]]>
<![CDATA[
]]>
<![CDATA[  'or you can enter multiple email addresses separated by commas.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   SetRecipients = true]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[   if (Trim(CStr(StrParam)) = "") Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Error: SetRecipients was called with no recipients")]]>
<![CDATA[
]]>
<![CDATA[      SetRecipients = false  ]]>
<![CDATA[
]]>
<![CDATA[      Call ErrorHandler("Function SetRecipients")  ]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if ( Not CheckExistingMailItem() ) Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Error: SetRecipients could not create email object")]]>
<![CDATA[
]]>
<![CDATA[      SetRecipients = false]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(g_CDOSYS_NotPresent = TRUE) Then             ' Using Outlook]]>
<![CDATA[
]]>
<![CDATA[      g_MailItem.Recipients.Add StrParam]]>
<![CDATA[
]]>
<![CDATA[      writelog("Setting Recipient for Outlook: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[      if(ParseError("can not set Recipients for Outlook MailItem")) Then]]>
<![CDATA[
]]>
<![CDATA[         WriteLog("Error: SetRecipients could not set outlook recipient")]]>
<![CDATA[
]]>
<![CDATA[         SetRecipients = false]]>
<![CDATA[
]]>
<![CDATA[         ' and store that Initialization is fail]]>
<![CDATA[
]]>
<![CDATA[         gOutlookInit = FALSE]]>
<![CDATA[
]]>
<![CDATA[         gInitProcedurePassed = TRUE]]>
<![CDATA[
]]>
<![CDATA[         Set g_theOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[         exit Function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if Not g_MailItem.Recipients.ResolveAll Then ]]>
<![CDATA[
]]>
<![CDATA[         WriteLog("Unknown recipient: " + StrParam)]]>
<![CDATA[
]]>
<![CDATA[         SetRecipients = false]]>
<![CDATA[
]]>
<![CDATA[         Set g_theOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[         exit function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      writelog("Setting Recipient for CDOSYS: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[      Dim Ub]]>
<![CDATA[
]]>
<![CDATA[      Ub = Ubound(arRecipients,1) ]]>
<![CDATA[
]]>
<![CDATA[      Redim Preserve arRecipients(Ub + 1)]]>
<![CDATA[
]]>
<![CDATA[      arRecipients(Ub + 1) = StrParam]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Call ErrorHandler("Function SetRecipients")  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetCarbonCopyRcpts" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[ 'Set Carbon Copy recipients' email address(es)."]]>
<![CDATA[
]]>
<![CDATA[ ']]>
<![CDATA[
]]>
<![CDATA[ '  Email addresses to receive a copy of the email as a carbon copy.]]>
<![CDATA[
]]>
<![CDATA[ '  You can enter multiple email addresses separated by commas.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  SetCarbonCopyRcpts = true]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  writelog("CC Recipients: '" & StrParam & "'")]]>
<![CDATA[
]]>
<![CDATA[  if(Trim(CStr(StrParam)) = "") Then]]>
<![CDATA[
]]>
<![CDATA[    writelog("Error: SetCarbonCopyRcpts was called with no recipients")]]>
<![CDATA[
]]>
<![CDATA[    SetCarbonCopyRcpts = false]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if( Not CheckExistingMailItem() ) Then]]>
<![CDATA[
]]>
<![CDATA[    writelog("Error: SetCarbonCopyRcpts CheckExistingMailItem failed")]]>
<![CDATA[
]]>
<![CDATA[    SetCarbonCopyRcpts = false]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if(g_CDOSYS_NotPresent = TRUE) Then              ' Using Outlook Object]]>
<![CDATA[
]]>
<![CDATA[    g_MailItem.CC = StrParam]]>
<![CDATA[
]]>
<![CDATA[    if(ParseError("can not sets SenderName for Outlook MailItem")) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Error: SetCarbonCopyRcpts could not set Outlook CC")]]>
<![CDATA[
]]>
<![CDATA[      SetCarbonCopyRcpts = false]]>
<![CDATA[
]]>
<![CDATA[      ' and store that Initialization is fail]]>
<![CDATA[
]]>
<![CDATA[      gOutlookInit = FALSE]]>
<![CDATA[
]]>
<![CDATA[      gInitProcedurePassed = TRUE]]>
<![CDATA[
]]>
<![CDATA[      Set g_theOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[      exit Function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[  else                                            ' Using CDOSYS Object]]>
<![CDATA[
]]>
<![CDATA[    if(trim(MessageHeaders(cCarbonCopy)) <> "" ) Then]]>
<![CDATA[
]]>
<![CDATA[      MessageHeaders(cCarbonCopy) = MessageHeaders(cCarbonCopy) & "," & StrParam]]>
<![CDATA[
]]>
<![CDATA[    else]]>
<![CDATA[
]]>
<![CDATA[      MessageHeaders(cCarbonCopy) = StrParam]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function SetCarbonCopyRcpts")        ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetBlindCarbonCopyRcpts" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Sets Blind Carbon Copy recipients' email address(es)."]]>
<![CDATA[
]]>
<![CDATA[  ' The email addresses to receive a copy of the email as a blind carbon copy.]]>
<![CDATA[
]]>
<![CDATA[  '  You can enter multiple email addresses separated by commas.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   SetBlindCarbonCopyRcpts = true]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[   writelog("BCC Recipients: '" & StrParam & "'")]]>
<![CDATA[
]]>
<![CDATA[   if(Trim(CStr(StrParam)) = "") Then]]>
<![CDATA[
]]>
<![CDATA[      writelog "Error: SetBlindCarbonCopyRcpts was called with no recipients"]]>
<![CDATA[
]]>
<![CDATA[      SetBlindCarbonCopyRcpts = false]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if( Not CheckExistingMailItem() ) Then]]>
<![CDATA[
]]>
<![CDATA[      SetBlindCarbonCopyRcpts = false]]>
<![CDATA[
]]>
<![CDATA[      writelog("SetBlindCarbonCopyRcpts CheckExistingMailItem failed")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(g_CDOSYS_NotPresent = TRUE) Then                   ' Using Outlook object]]>
<![CDATA[
]]>
<![CDATA[      g_MailItem.BCC = StrParam]]>
<![CDATA[
]]>
<![CDATA[      if(ParseError("can not set BCC for Outlook MailItem")) Then]]>
<![CDATA[
]]>
<![CDATA[         writelog("SetBlindCarbonCopyRcpts Setting BCC value failed")]]>
<![CDATA[
]]>
<![CDATA[         SetBlindCarbonCopyRcpts = false]]>
<![CDATA[
]]>
<![CDATA[         ' and store that Initialization is fail]]>
<![CDATA[
]]>
<![CDATA[         gOutlookInit = FALSE]]>
<![CDATA[
]]>
<![CDATA[         gInitProcedurePassed = TRUE]]>
<![CDATA[
]]>
<![CDATA[         Set g_theOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[         exit Function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[   else                                                  ' Using CDOSYS Object]]>
<![CDATA[
]]>
<![CDATA[      if(trim(MessageHeaders(cBlindCarbonCopy)) <> "" ) Then]]>
<![CDATA[
]]>
<![CDATA[         MessageHeaders(cBlindCarbonCopy) = MessageHeaders(cBlindCarbonCopy) & "," & StrParam]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         MessageHeaders(cBlindCarbonCopy) = StrParam]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[   Call ErrorHandler("Function SetBlindCarbonCopyRcpts")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetAttachment" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Adds a file attachment to an email."]]>
<![CDATA[
]]>
<![CDATA[  '  The file’s path and name.  Smart Parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Dim g_ExportName_email]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   ' this function sets attachment from g_ExportName_email, which is set up by the same function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   g_ExportName_email = MetaWord(Trim(StrParamMW)) ' Smart Parameters are allowed.  Process them if any are present.	  ]]>
<![CDATA[
]]>
<![CDATA[   Dim StrPath ' actual path to file;  StrParam is file name]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   if(Trim(CStr(g_ExportName_email)) = "") Then]]>
<![CDATA[
]]>
<![CDATA[      writelog(space(2) & "SetAttachment get empty PathName")]]>
<![CDATA[
]]>
<![CDATA[      SetAttachment = false]]>
<![CDATA[
]]>
<![CDATA[      exit function  ]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   StrPath = Pilot.BatchDir & "\" & Trim(g_ExportName_email)]]>
<![CDATA[
]]>
<![CDATA[   StrPath = Trim(g_ExportName_email)]]>
<![CDATA[
]]>
<![CDATA[   if(FileMgr.FileExists(StrPath)) Then]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[      if( Not CheckExistingMailItem() ) Then]]>
<![CDATA[
]]>
<![CDATA[         writelog(space(2) & "SetAttachment CheckExistingMailItem failed")]]>
<![CDATA[
]]>
<![CDATA[         SetAttachment = false]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if(g_CDOSYS_NotPresent = TRUE) Then	              ' Using Outlook email object]]>
<![CDATA[
]]>
<![CDATA[         g_MailItem.Attachments.Add Trim(CStr(StrPath))]]>
<![CDATA[
]]>
<![CDATA[         if(ParseError("can not add Attachments for Outlook MailItem")) Then]]>
<![CDATA[
]]>
<![CDATA[            writelog(space(2) & "SetAttachment Cannot add outlook attachment")]]>
<![CDATA[
]]>
<![CDATA[            SetAttachment = false]]>
<![CDATA[
]]>
<![CDATA[            ' and store that Initialization is fail]]>
<![CDATA[
]]>
<![CDATA[            gOutlookInit = FALSE]]>
<![CDATA[
]]>
<![CDATA[            gInitProcedurePassed = TRUE]]>
<![CDATA[
]]>
<![CDATA[            Set g_theOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[            exit Function]]>
<![CDATA[
]]>
<![CDATA[         end if]]>
<![CDATA[
]]>
<![CDATA[      else                                              ' Using CDOSYS]]>
<![CDATA[
]]>
<![CDATA[         writelog(space(2) & "Setting CDOSYS attachment: " & strPath)]]>
<![CDATA[
]]>
<![CDATA[         'call g_MailItem.AttachFile(Trim(CStr(StrPath)),g_ExportName_email )]]>
<![CDATA[
]]>
<![CDATA[         call g_MailItem.AddAttachment(Trim(CStr(StrPath)),"","")]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      writelog(space(2) & "SetAttachment get unexisting file:" & StrPath)]]>
<![CDATA[
]]>
<![CDATA[      SetAttachment = false]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[   Call ErrorHandler("Function SetAttachment")]]>
<![CDATA[
]]>
<![CDATA[   SetAttachment = true]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetEmailBody" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Sets the text of the email’s body."]]>
<![CDATA[
]]>
<![CDATA[  '  The email message text.  Smart Parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Dim StrParam]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   StrParam = MetaWord(Trim(StrParamMW)) ' Smart Parameters are allowed.  Process them if any are present.	  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   if(Trim(CStr(StrParam)) = "") Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("SetEmailBody empty StrParam")]]>
<![CDATA[
]]>
<![CDATA[      SetEmailBody = true]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   if( Not CheckExistingMailItem() ) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("SetEmailBody could not create email item")]]>
<![CDATA[
]]>
<![CDATA[      SetEmailBody = false]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(g_CDOSYS_NotPresent = TRUE) Then]]>
<![CDATA[
]]>
<![CDATA[      g_MailItem.body = StrParam]]>
<![CDATA[
]]>
<![CDATA[      if(ParseError("can not set Body for Outlook MailItem")) Then]]>
<![CDATA[
]]>
<![CDATA[         SetEmailBody = false]]>
<![CDATA[
]]>
<![CDATA[         ' and store that Initialization is fail]]>
<![CDATA[
]]>
<![CDATA[         gOutlookInit = FALSE]]>
<![CDATA[
]]>
<![CDATA[         gInitProcedurePassed = TRUE]]>
<![CDATA[
]]>
<![CDATA[         Set g_theOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[         exit Function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      MessageHeaders(cBody) = StrParam]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[   Call ErrorHandler("Function SetEmailBody")]]>
<![CDATA[
]]>
<![CDATA[   SetEmailBody = true]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetSubject" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Sets the text for the email's Subject field."]]>
<![CDATA[
]]>
<![CDATA[  '  The subject line of the email.  Smart Parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Dim StrParam   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   StrParam = MetaWord(Trim(StrParamMW)) ' Smart Parameters are allowed.  Process them if any are present.	  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   if(Trim(CStr(StrParam)) = "") Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("SetSubject parameter is blank.")]]>
<![CDATA[
]]>
<![CDATA[      SetSubject = true]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[   if( Not CheckExistingMailItem() ) Then       ]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("SetSubject CheckExistingMailItem returned false.")]]>
<![CDATA[
]]>
<![CDATA[      SetSubject = false]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(g_CDOSYS_NotPresent = TRUE) Then              ' Using Outlook Object]]>
<![CDATA[
]]>
<![CDATA[      g_MailItem.Subject = StrParam]]>
<![CDATA[
]]>
<![CDATA[      if(ParseError("can not set Subject for Outlook MailItem")) Then]]>
<![CDATA[
]]>
<![CDATA[         SetSubject = false]]>
<![CDATA[
]]>
<![CDATA[         ' and store that Initialization is fail]]>
<![CDATA[
]]>
<![CDATA[         gOutlookInit = FALSE]]>
<![CDATA[
]]>
<![CDATA[         gInitProcedurePassed = TRUE]]>
<![CDATA[
]]>
<![CDATA[         Set g_theOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[         exit Function]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      MessageHeaders(cSubject) = StrParam]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function SetSubject")]]>
<![CDATA[
]]>
<![CDATA[  SetSubject = true]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetSender" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Sets the sending email address."]]>
<![CDATA[
]]>
<![CDATA[  '  The sender’s email address.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[   writelog("Sender: '" & StrParam & "'")]]>
<![CDATA[
]]>
<![CDATA[   if (Trim(CStr(StrParam)) = "") Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("SetSender Parameter is Blank")]]>
<![CDATA[
]]>
<![CDATA[      SetSender = true]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   if( Not CheckExistingMailItem() ) Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("SetSender could not create email object")]]>
<![CDATA[
]]>
<![CDATA[      SetSender = false]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(g_CDOSYS_NotPresent = TRUE) Then                     ' Using Outlook Object]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Outlook object will use current email account as Sender")]]>
<![CDATA[
]]>
<![CDATA[      SetSender = true]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      MessageHeaders(cFrom) = StrParam]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Call ErrorHandler("Function SetSender")]]>
<![CDATA[
]]>
<![CDATA[   SetSender = true]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SendEMail" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Sends an email."]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if (Not IsObject(g_MailItem)) Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Fatal Error: call SetRecipients() first")]]>
<![CDATA[
]]>
<![CDATA[      SendEMail = false]]>
<![CDATA[
]]>
<![CDATA[      gInitProcedurePassed = FALSE]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[   End If   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If(g_MailItem Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("SendEmail Error: email object is not created, first call actions to set email parameters")]]>
<![CDATA[
]]>
<![CDATA[      SendEMail = false]]>
<![CDATA[
]]>
<![CDATA[      gInitProcedurePassed = FALSE]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[   End If   ]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[   if( Not CheckExistingMailItem() ) Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("SendEmail Error: CheckExistingMailItem failed")]]>
<![CDATA[
]]>
<![CDATA[      SendEmail = false]]>
<![CDATA[
]]>
<![CDATA[      gInitProcedurePassed = FALSE]]>
<![CDATA[
]]>
<![CDATA[      Set g_MailItem = Nothing]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(g_CDOSYS_NotPresent = TRUE) then      ' Using Outlook Object]]>
<![CDATA[
]]>
<![CDATA[      call SendEMailThroughOutlook()]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Sent with Outlook")]]>
<![CDATA[
]]>
<![CDATA[   else                                     ' Using CDOSYS Object]]>
<![CDATA[
]]>
<![CDATA[      call SendEMailThroughCDOSYS()]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Sent with CDOSYS")]]>
<![CDATA[
]]>
<![CDATA[   end if   ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   ' After Sending, reset everything to inital state to create a new e-mail for next calls to the actions]]>
<![CDATA[
]]>
<![CDATA[   Set g_MailItem = Nothing]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   gCDOSYSinit = FALSE]]>
<![CDATA[
]]>
<![CDATA[   gOutlookInit = FALSE]]>
<![CDATA[
]]>
<![CDATA[   gInitProcedurePassed = FALSE]]>
<![CDATA[
]]>
<![CDATA[   g_CDOSYS_NotPresent = TRUE]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   MessageHeaders(cSubject) = ""]]>
<![CDATA[
]]>
<![CDATA[   MessageHeaders(cFrom) = ""]]>
<![CDATA[
]]>
<![CDATA[   MessageHeaders(cBody) = ""]]>
<![CDATA[
]]>
<![CDATA[   MessageHeaders(cImportance) = 1]]>
<![CDATA[
]]>
<![CDATA[   MessageHeaders(cCarbonCopy) = ""   ]]>
<![CDATA[
]]>
<![CDATA[   MessageHeaders(cBlindCarbonCopy) = ""]]>
<![CDATA[
]]>
<![CDATA[   Redim Preserve arRecipients(0)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If Err.Number <> 0 Then		]]>
<![CDATA[
]]>
<![CDATA[	  Call ErrorHandler("Function SendEMail")]]>
<![CDATA[
]]>
<![CDATA[	  SendEMail = FALSE]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[	  SendEMail = TRUE]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
	</g>
</af>
<help>
<![CDATA[
'************************************************************************
' EMail Actions
' 
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2015 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'Version = "8.1.0.14"
' Updated 07/13/2011 RFerin
' 31793 Added information regarding email subject lengths.
'
'Version = "8.1.0.15"
' Updated 08/04/2011 RFerin
' 31600 Added "extension" to help for SetAttachment.
'
'************************************************************************
]]>

  <ref id="SetMailServer" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Configures the mail server to use for sending mail.">
    <ap>
      The IP or DNS address of the outgoing mail (SMTP) server.<br/><br/>
      
      Smart parameters are supported.
    </ap>
    <h>
      Sets the address of the outgoing mail (SMTP) server.
      This may be the same mail server you configure in your mail program.
      The server must be accessible from the computer running the email actions.
      This action should be the first action in an email rule if the CDOSYS object is being used.<br/><br/>

      Use this action only if you are sending emails with CDOSYS.
      To use CDOSYS, this action must be called prior to any of the other email actions.
      If this action is not called prior to other email actions, these actions
      will use Outlook for sending emails.<br/><br/>

      You can use Email actions to direct a task to compose and send emails containing information and attachments.
      Email actions use the Windows CDOSYS library to send email via your preferred SMTP mail server.
      The CDOSYS object is included with Windows 2000 and above. Alternatively, Email actions can use the
      Outlook object but this is not recommended.<br/><br/>

      One of these two libraries (CDOSYS or Outlook) must be registered on the computer that runs rules employing email actions.<br/><br/>

      Outlook is primarily useful for demonstration purposes, as it is not suitable for unattended operation:
      it requires the Outlook user to be logged into the computer, and security prompts may be displayed for each message sent.
      <e>
        <b>SetMailServer("mail.YourISP.com")</b><br/>
        SetSender("paul@adomain.com")<br/>
        SetRecipients("lisa@adomain.com")<br/>
        SetSubject("Document Integrity")<br/>
        SetEMailBody("Document Page Types and counts are accurate. Thanks for your help.")<br/>
        SendEMail()
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>


  <ref id="SetRecipients" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets email recipients' address(es).">
    <ap>
      Email address(es) of recipient(s).  You can either call this action multiple times to add multiple recipients,
      or you can enter multiple email addresses separated by commas.<br/><br/>
      
      Smart parameters are supported.
    </ap>
    <h>
      The email address of the email’s primary recipients.
      <e>
        <b>SetRecipients("lisa@adomain.com,Joe@adomain.com")</b>
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if you do not enter an email addresses parameter,
      if the address is rejected by the mail system or if the email object cannot be initialized.
      Otherwise, <b>True.</b><br/><br/>

      Invalid email addresses may not be reported until SendEMail is called.
    </ret>
    <see>SetCarbonCopyRcpts, SetBlindCarbonCopyRcpts</see>
  </ref>


  <ref id="SetCarbonCopyRcpts" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Set Carbon Copy recipients' email address(es).">
    <ap>
      Email addresses to receive a copy of the email as a carbon copy.
      You can enter multiple email addresses separated by commas.<br/><br/>
      
      Smart parameters are supported.
    </ap>
    <h>
      Adds addresses to the Cc (Carbon Copy) portion of the email’s header.
      <e>
        SetRecipients("lisa@adomain.com")<br/>
        <b>SetCarbonCopyRcpts("cindy@anotherdomain.org")</b>
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if you do not enter an email addresses parameter,
      if the address is rejected by the mail system or if the email object cannot be initialized.
      Otherwise, <b>True.</b><br/><br/>

      Invalid email addresses may not be reported until SendEMail is called.
    </ret>
    <see>SetBlindCarbonCopyRcpts, SetRecipients</see>
</ref>


<ref id="SetBlindCarbonCopyRcpts" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets Blind Carbon Copy recipients' email address(es).">
  <ap>
    The email addresses to receive a copy of the email as a blind carbon copy.
    You can enter multiple email addresses separated by commas.<br/><br/>

    Smart parameters are supported.
  </ap>
    <h>
      Adds addresses to the Bcc (Blind Carbon Copy) portion of the email’s header.
      <e>
        SetRecipients("lisa@monarchy.com")<br/>
        <b>SetBlindCarbonCopyRcpts("james@regency.com")</b>
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if you do not enter an email addresses parameter,
      if the address is rejected by the mail system or if the email object cannot be initialized.
      Otherwise, <b>True.</b><br/><br/>

      Invalid email addresses may not be reported until SendEMail is called.
    </ret>
    <see>SetCarbonCopyRcpts, SetRecipients</see>
</ref>


  <ref id="SetAttachment" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Adds a file attachment to an email.">
    <ap>
      The file’s path, name and extension.  Smart Parameters are supported.
    </ap>
    <h>
      Attaches the specified file to the current email.
      <e>
        <b>SetAttachment("h:\MyDir\MQSW\export\+@BATCHID+.txt")</b><br/>
        This example attaches the Export file of the current batch to the email.
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if the file does not exist or cannot be attached. Otherwise, <b>True.</b>
    </ret>
</ref>


  <ref id="SetEmailBody" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Sets the text of the email’s body.">
    <ap>
      The email message text.  Smart Parameters are supported.
    </ap>
    <h>
      Sets the text of the email’s body.
      <e>
        SetSubject("Document Integrity")<br/>
        <b>SetEMailBody("Document Page Types and counts are accurate. Thanks for your help.")</b>
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if the mail object cannot be initialized.  Otherwise, <b>True.</b>
    </ret>
    <see>SetAttachment</see>
  </ref>


  <ref id="SetSubject" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Sets the text for the email's Subject field.">
    <ap>
      The subject line of the email.  Smart Parameters are supported.
    </ap>
    <h>
      Sets the text for the email Subject field.
      It is recommended that the subject line be no longer than 78 characters as this is a 
      common subject line length limitation.  Some systems may support even shorter lengths, 
      truncating the subject.  Our testing has been successful with lengths up to 255 characters.  
      It is recommended to test your settings and use lengths appropriate for your systems.<br/>
      <e>
        <b>SetSubject("Document Integrity")</b>
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if the mail object cannot be initialized.  Otherwise, <b>True.</b>
    </ret>
   
  </ref>


  <ref id="SetSender" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the sending email address.">
    <ap>
      The sender’s email address.<br/><br/>
      
      Smart parameters are supported.
    </ap>
    <h>
      Sets the email address of the sender for the current email.
      When using the CDOSYS object, use this action.
      When using the Outlook object, the current email account is used as the sender.
      <e>
        SetRecipients("lisa@adomain.com")<br/>
        <b>SetSender("paul@adomain.com")</b>
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if the mail object cannot be initialized.  Otherwise, <b>True.</b><br/><br/>

      Invalid email addresses may not be reported until SendEMail is called.
    </ret>
  
  </ref>


  <ref id="SendEMail" access="public" bInter="bInter" bDebug="bDebug" qi="Sends an email.">
    <ap>
      None.
    </ap>
    <h>
      Sends an email assembled by previous actions.
      Typically, this is the final action in an email ruleset.  At a minimum, the SetSender and SetRecipients
      actions must be called prior to sending an email.<br/><br/>

      After sending, this action will discard the contents of the email in memory.  Calls to the email actions
      after SendEMaill will cause the creation of a new email message.
      <e>
        SetSender("paul@adomain.com")<br/>
        SetRecipients("lisa@adomain.com,beth@adomain.com")<br/>
        SetSubject("Document Integrity")<br/>
        SetEMailBody("Document Page Types and counts are accurate. Thanks for your help.")<br/>
        SendEMail()
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>False</b> if the rule does not include a previous SetRecipients action, or if the email cannot be sent. Otherwise, <b>True.</b>
      If the email cannot be sent, the batch will be set to abort.
    </ret>
  </ref>
</help>

</rrx>
<rrx namespace="equalize" src="c:\datacap\RRS\equalize.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="EqualizeUnbalancedImage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ 'Resolves differences in the dpi (dots per inch) resolutions along the horizontal (X) and vertical (Y) planes of one ore more faxed images in a batch."]]>
<![CDATA[
]]>
<![CDATA[  'Integer value which determines the cut-off point for the resolution which should be equalized:<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  '  <scr>EqualizeUnbalancedImage(0)</scr>, for example, specifies that there is no cut-off point: ]]>
<![CDATA[
]]>
<![CDATA[  '  all images will be subject to equalization. <br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  '  <scr>EqualizeUnbalancedImage(20)</scr> establishes a cut-off point of 200(x)/180(y). This ]]>
<![CDATA[
]]>
<![CDATA[  '  means that the action will equalize all images with this resolution ratio and more (200/180, ]]>
<![CDATA[
]]>
<![CDATA[  '  200/160 etc.) - but will ignore all images with balance ratios less than 200/180 (in this example.)<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  '  <b>Alert!</b> Standard Mode fax resolution in Dots per Inch (DPI) is 204/98; Fine Mode fax ]]>
<![CDATA[
]]>
<![CDATA[  '  resolution is 204/196.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Dim percent]]>
<![CDATA[
]]>
<![CDATA[   Dim m_EmergCopy]]>
<![CDATA[
]]>
<![CDATA[   Dim result]]>
<![CDATA[
]]>
<![CDATA[   Dim retryCount]]>
<![CDATA[
]]>
<![CDATA[   EqualizeUnbalancedImage = false]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If(CurrentObj.ObjectType <> DCO_PAGE) Then]]>
<![CDATA[
]]>
<![CDATA[       writelog("This action needs to be called at the page level. Returning false.")]]>
<![CDATA[
]]>
<![CDATA[       exit function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if(Not IsNumeric(StrParam)) Then ]]>
<![CDATA[
]]>
<![CDATA[      writelog ("Invalid parameter passed. The action expects a parameter of numeric type. Valid values: 0-99. Returning false.")]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   percent = cInt(StrParam)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if(percent < 0 or percent > 99) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog ("Parameter should be numeric value of unbalancing in percentage 0..99. Returning false.")]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if (CurrentObj.ImageName="") Then]]>
<![CDATA[
]]>
<![CDATA[       writelog("Warning: Current object is not assosciated with an image.")]]>
<![CDATA[
]]>
<![CDATA[       exit function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if (not (FileMgr.FileExists(CurrentObj.ImageName))) then]]>
<![CDATA[
]]>
<![CDATA[       writelog("Warning: the file associated with the current object does not exist." & CurrentObj.ImageName)]]>
<![CDATA[
]]>
<![CDATA[       exit function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ' DCImage cannot resave over the same file that is open.  So we are creating a temporary file to work on.  ]]>
<![CDATA[
]]>
<![CDATA[   m_EmergCopy = Mid(CurrentObj.ImageName, 1, len(CurrentObj.ImageName)-3) & "TMP.TIF"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if (FileMgr.FileExists(m_EmergCopy)) then]]>
<![CDATA[
]]>
<![CDATA[       writelog("Warning: a backup file already exists. It will be overwritten (unless it is a read-only file): " & m_EmergCopy)       ]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Source file: '" + CurrentObj.ImageName + "' Creating temporary backup: " & m_EmergCopy)]]>
<![CDATA[
]]>
<![CDATA[   Call FileMgr.CopyFile(CurrentObj.ImageName, m_EmergCopy, True)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Backup created.")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Dim myTimer]]>
<![CDATA[
]]>
<![CDATA[   retryCount = 0]]>
<![CDATA[
]]>
<![CDATA[   Do ]]>
<![CDATA[
]]>
<![CDATA[      retryCount = retryCount + 1]]>
<![CDATA[
]]>
<![CDATA[      result = EqualizeIt(m_EmergCopy, CurrentObj.ImageName, percent)]]>
<![CDATA[
]]>
<![CDATA[      if ((retryCount < 6) and (2 = result)) Then]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Retrying equialize operation")         ]]>
<![CDATA[
]]>
<![CDATA[         myTimer = Timer]]>
<![CDATA[
]]>
<![CDATA[         Do           ]]>
<![CDATA[
]]>
<![CDATA[         Loop While (2 > (Timer - myTimer)) ' wait for about 2 seconds because WScript.Sleep does not work         ]]>
<![CDATA[
]]>
<![CDATA[      end if      ]]>
<![CDATA[
]]>
<![CDATA[   Loop While ((retryCount < 6) and (2 = result))]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if (0 = result) then]]>
<![CDATA[
]]>
<![CDATA[      EqualizeUnbalancedImage = true]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      EqualizeUnbalancedImage = false]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if (FileMgr.FileExists(m_EmergCopy)) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Deleting temporary backup: " & m_EmergCopy)]]>
<![CDATA[
]]>
<![CDATA[      Call FileMgr.DeleteFile(m_EmergCopy, True)]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Temporary backup does not exist. Skiping delete: " & m_EmergCopy)]]>
<![CDATA[
]]>
<![CDATA[   End if   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************************
' Equalize Actions help
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2015 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************************
]]>
     
<ref id="EqualizeUnbalancedImage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Resolves differences in the dpi (dots per inch) resolutions along the horizontal (X) and vertical (Y) planes of one ore more faxed images in a batch.">
  <ap>
    Integer value which determines the cut-off point for the resolution which should be equalized:<br/><br/>

    <scr>EqualizeUnbalancedImage(0)</scr>, for example, specifies that there is no cut-off point: 
    all images will be subject to equalization. <br/><br/>

    <scr>EqualizeUnbalancedImage(20)</scr> establishes a cut-off point of 200(x)/180(y). This 
    means that the action will equalize all images with this resolution ratio and more (200/180, 
    200/160 etc.) - but will ignore all images with balance ratios less than 200/180 (in this example.)<br/><br/>

    <b>Alert!</b> Standard Mode fax resolution in Dots per Inch (DPI) is 204/98; Fine Mode fax 
    resolution is 204/196.
  </ap>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the parameter is not numeric or if the rule containing the action is not bound 
    to a Page object of the Document Hierarchy. Otherwise, <b>True.</b>
  </ret>
  <h>
    Resolves differences in the dpi (dots per inch) resolutions along the horizontal (X) and 
    vertical (Y) planes of one ore more faxed images in a batch.<br/><br/>

    The action selects images from the batch in response to the parameter you enter, and 
    produces new images with 200 x 200 dpi.
    <e>
      <b>EqualizeUnbalanceImage(0)</b> 
    </e>
  </h>
</ref>
</help>

</rrx>
<rrx namespace="Export" src="c:\datacap\RRS\Export.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="BatchVariable_ExportValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim oBatch]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("EXPORT Batch Variable")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oBatch = currentobj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	While Not (oBatch.ObjectType <= 0)]]>
<![CDATA[
]]>
<![CDATA[		Set oBatch = oBatch.Parent()		]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(5) & "Variable Value is :'" & oBatch.Variable(StrParam) & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call WriteExport(bInter, bDebug, oBatch.Variable(StrParam))]]>
<![CDATA[
]]>
<![CDATA[	BatchVariable_ExportValue = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("BatchVariable_ExportValue")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "BatchVariable_ExportValue returns " & BatchVariable_ExportValue) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DocumentVariable_ExportValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("EXPORT Document Variable Input: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set odoc = currentobj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	While Not (oDoc.ObjectType <= 1)]]>
<![CDATA[
]]>
<![CDATA[		Set oDoc = oDoc.Parent()		]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(5) & "Variable Value is :'" & oDoc.Variable(StrParam) & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call WriteExport(bInter, bDebug, oDoc.Variable(StrParam))]]>
<![CDATA[
]]>
<![CDATA[	DocumentVariable_ExportValue = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("DocumentVariable_ExportValue")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "DocumentVariable_ExportValue returns " & DocumentVariable_ExportValue) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PageVariable_ExportValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim oPage]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("EXPORT Page Variable")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	While Not (oPage.ObjectType <= 2)]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oPage.Parent()		]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(5) & "Variable Value of " & StrParam & " is :'" & oPage.Variable(StrParam) & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call WriteExport(bInter, bDebug, oPage.Variable(StrParam))]]>
<![CDATA[
]]>
<![CDATA[	PageVariable_ExportValue = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("PageVariable_ExportValue")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "PageVariable_ExportValue returns " & PageVariable_ExportValue) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="BlankFields" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim Cntr]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	writelog("ADD Blank Field")]]>
<![CDATA[
]]>
<![CDATA[	BlankFields = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Trim(Strparam)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Not Isnumeric(StrParam) then Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = cint(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For Cntr = 1 to StrParam]]>
<![CDATA[
]]>
<![CDATA[		Call WriteExport(bInter, bDeBug, "")]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(5) & "Added " & cstr(StrParam) & " BlankFields to the Export.")]]>
<![CDATA[
]]>
<![CDATA[	BlankFields = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function BlankFields") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="BlankLines" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sFileContent]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    Strparam=replace(Strparam,Chrw(32),"")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(StrParam) or len(Trim(Strparam))=0 Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter must be numeric. Defaulting to 1") ]]>
<![CDATA[
]]>
<![CDATA[        StrParam = 1]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    StrParam = abs(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    If StrParam-cint(Strparam)>0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter must be an Integer. Parameter will be rounded to nearest integer.") ]]>
<![CDATA[
]]>
<![CDATA[        StrParam = cint(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If StrParam <= 0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter must be an Integer greater than Zero. Defaulting to 1") ]]>
<![CDATA[
]]>
<![CDATA[        StrParam = 1]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsObject(g_ExportFile) Then ]]>
<![CDATA[
]]>
<![CDATA[		Call OpenExportFile(bInter, bDebug)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsObject(g_ExportFile) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Unable to find open file.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Adding Blank LINE x " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(g_LastExportValue)>0 then]]>
<![CDATA[
]]>
<![CDATA[        If NOT(right(g_LastExportValue,1)=Chrw(10) or right(g_LastExportValue,1)=Chrw(13)) then]]>
<![CDATA[
]]>
<![CDATA[            StrParam=StrParam+1]]>
<![CDATA[
]]>
<![CDATA[        end if    ]]>
<![CDATA[
]]>
<![CDATA[    End if ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    g_LastExportValue=vbcrlf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call g_ExportFile.WriteBlankLines(Cint(StrParam))]]>
<![CDATA[
]]>
<![CDATA[	BlankLines = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function BlankLines") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="BPilot" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim Value]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Writelog("BPilot Input: " & strparam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Value = Eval("Pilot." & StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number<> 0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("'" & Strparam & "' is not a valid BPilot Property. Please use a valid BPilot property for this Action.")]]>
<![CDATA[
]]>
<![CDATA[    BPilot=False]]>
<![CDATA[
]]>
<![CDATA[    Err.Clear]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call WriteExport(bInter, bDebug, Value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  BPilot = True]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function BPilot") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CloseExportFile" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	g_bnewLine = FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ 	CloseExportFile = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsAlive(g_ExportFile) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Closing Export file...")]]>
<![CDATA[
]]>
<![CDATA[		g_ExportFile.Close]]>
<![CDATA[
]]>
<![CDATA[		g_ExportFile = Null]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "File Closed")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("Export File is not Open.")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function CloseExportFile") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DCOProperty" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim Value]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  Writelog("DCOProperty Input: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Value = Eval("CurrentObj." & StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number<>0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("'" & StrParam & "' is not a valid DCO Property. Please use a valid DCO property for the calling Object.")]]>
<![CDATA[
]]>
<![CDATA[    Err.clear]]>
<![CDATA[
]]>
<![CDATA[    DCOProperty=False]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call WriteExport(bInter, bDebug, Value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  DCOProperty = True]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function DCOProperty") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ExportAllFields" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ExportAllFields = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Calling ExportAllFields")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType <> 2 then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action must be called from a DCO Page. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call u_ExportChildren(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call NewLine(bInter, bDebug)		'add new line for next page]]>
<![CDATA[
]]>
<![CDATA[	ExportAllFields = True ]]>
	</g>
</af>
<af name="ExportFieldValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim setupObj]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld]]>
<![CDATA[
]]>
<![CDATA[	Dim nCount]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim VarId]]>
<![CDATA[
]]>
<![CDATA[	Dim aObjID	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    ExportFieldValue= False	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(trim(StrParam))=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("This action requires a parameter.")]]>
<![CDATA[
]]>
<![CDATA[        Exit function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    writelog("EXPORT FIELD " & Ucase(StrParam))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(CurrentObj) Then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If CurrentObj.Objecttype<>2 then]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Action must be called from a DCO Page.") ]]>
<![CDATA[
]]>
<![CDATA[            Exit Function]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "Finding DCO Value:'" & StrParam & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Set oFld = RReturnNamedComponent(StrParam)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If NOT(oFld is nothing) then]]>
<![CDATA[
]]>
<![CDATA[			'Check for variable in sFindObjID argument. Flag is the Decimal '.' character (period).]]>
<![CDATA[
]]>
<![CDATA[			aObjID = split(StrParam & ".",".")]]>
<![CDATA[
]]>
<![CDATA[			VarID = trim(aObjID(1))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			If Len(VarID)=0 then]]>
<![CDATA[
]]>
<![CDATA[				sValue = CheckDICT(oFld)]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[				sValue = oFld.Variable(VarID)]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "DCO Value is :'" & sValue & "' ")]]>
<![CDATA[
]]>
<![CDATA[            If u_CheckNoExportStatus(oFld)=TRUE then]]>
<![CDATA[
]]>
<![CDATA[  			    Call WriteExport(bInter, False, sValue)]]>
<![CDATA[
]]>
<![CDATA[	        End if]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[			ExportFieldValue= True]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Object '" & StrParam & "' Not Found.")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			ExportFieldValue = False]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(Space(5) & "There is No Current Object.")]]>
<![CDATA[
]]>
<![CDATA[		ExportFieldValue= False	]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("END Export Field. Returns: " & ExportFieldValue)]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function ExportFieldValue") ]]>
	</g>
</af>
<af name="ExportMYValue" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("EXPORT MY Value" & Ucase(StrParam))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(5) & "MY Value is :'" & CurrentObj.Text & "' ")]]>
<![CDATA[
]]>
<![CDATA[  If u_CheckNoExportStatus(CurrentObj)=TRUE then]]>
<![CDATA[
]]>
<![CDATA[  	Call WriteExport(bInter, bDebug, CheckDICT(CurrentObj))]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ExportMYValue= True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function ExportMYValue") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ExportSmartParameter" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  Dim oVal]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Writelog(Space(5) & "Finding Smart Parameter Value...")]]>
<![CDATA[
]]>
<![CDATA[  oVal = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not(oVal = "") Then	 ]]>
<![CDATA[
]]>
<![CDATA[    Writelog(Space(5) & "Found Value is :'" & oVal & "' ")]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog(Space(5) & "No results from smart parameter evaluation.")]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Call WriteExport(bInter, bDebug, oVal)]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  ExportSmartParameter=True]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function ExportSmartParameter") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ExportToBatchDir" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sBatchPath]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sBatchPath = Pilot.BatchDir]]>
<![CDATA[
]]>
<![CDATA[	ExportToBatchDir = SetExportPath(bInter, bDebug, sBatchPath) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GetDATE" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim dd,ddd,mm,yyyy,yy,y,m,d]]>
<![CDATA[
]]>
<![CDATA[	Dim DateText]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Updates field with current Date value]]>
<![CDATA[
]]>
<![CDATA[	'Strparam is the pattern to update the field with]]>
<![CDATA[
]]>
<![CDATA[	'Value: '*' sets to default value]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(trim(StrParam))=0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter is Empty. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[        GetDATE = False]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    GetDATE = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If InStr(StrParam,"*")>0 Then StrParam = "mm/dd/yyyy"]]>
<![CDATA[
]]>
<![CDATA[	StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"c","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam," "," & Chrw(32) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"/"," & Chrw(47) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"& &","&")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"day","dd")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"month","mm")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"year","yyyy")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"julian","y")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("DateStamp Strparam= '" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	d = Day(Now)]]>
<![CDATA[
]]>
<![CDATA[	dd = Right("0" & d,2)]]>
<![CDATA[
]]>
<![CDATA[	yyyy = Year(Now)]]>
<![CDATA[
]]>
<![CDATA[	yy = Right(yyyy,2)]]>
<![CDATA[
]]>
<![CDATA[	m = Month(Now)]]>
<![CDATA[
]]>
<![CDATA[	mm = Right("0" & m,2)]]>
<![CDATA[
]]>
<![CDATA[	ccyy = yyyy]]>
<![CDATA[
]]>
<![CDATA[	y = DatePart("y",Now)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  DateText = Eval(Strparam)]]>
<![CDATA[
]]>
<![CDATA[  Call WriteExport(bInter, bDeBug, DateText )]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("GetDATE returns true. Value: " & DateText)]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GetDATE") ]]>
	</g>
</af>
<af name="GetProfileString" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim aParams]]>
<![CDATA[
]]>
<![CDATA[  Dim sHeader]]>
<![CDATA[
]]>
<![CDATA[  Dim sSubSection]]>
<![CDATA[
]]>
<![CDATA[  Dim sFileNameINI]]>
<![CDATA[
]]>
<![CDATA[  Dim INIvalue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Writelog("GetProfileString Input: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If len(Trim(StrParam))=0 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Parameter is Empty. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[     GetProfileString = False]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  aParams = Split(StrParam & ",," , ",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sHeader = aParams(0)]]>
<![CDATA[
]]>
<![CDATA[  sSubSection = aParams(1)]]>
<![CDATA[
]]>
<![CDATA[  sFileNameINI = aParams(2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If FileMgr.FileExists(Pilot.BatchDir & "\" & sFileNameINI) Then ]]>
<![CDATA[
]]>
<![CDATA[    ' Writelog("Getting section: " & sSubSection & " from file: " & Pilot.BatchDir & "\" & sFileNameINI)]]>
<![CDATA[
]]>
<![CDATA[    INIvalue = Pilot.GetProfileString(sHeader, sSubSection,"",Pilot.BatchDir & "\" & sFileNameINI)]]>
<![CDATA[
]]>
<![CDATA[    Call WriteExport(bInter, bDebug, INIvalue)]]>
<![CDATA[
]]>
<![CDATA[    GetProfileString = True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Could not locate file: " & Pilot.BatchDir & "\" & sFileNameINI)]]>
<![CDATA[
]]>
<![CDATA[    GetProfileString = False]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function GetProfileString") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GetTime" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim mm,ss,hh,hhhh,m,s,h]]>
<![CDATA[
]]>
<![CDATA[	Dim TimeText]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    GetTime = False  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    If len(trim(StrParam))=0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter is Empty. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ' Remove all valid parameters from input string.]]>
<![CDATA[
]]>
<![CDATA[    ' If sTest is empty at the end, then only valid input strings were passed in.]]>
<![CDATA[
]]>
<![CDATA[    sTest = LCASE(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"minute","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"second","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"hour","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"min","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"sec","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"hr","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"h","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"m","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"s","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,":","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"/","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest," ","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"&","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"-","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"'","")]]>
<![CDATA[
]]>
<![CDATA[    sTest = Replace(sTest,"*","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(sTest)>0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Invalid Parameter Characters '" & sTest & "' found. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Updates field with current Time value]]>
<![CDATA[
]]>
<![CDATA[	'Strparam is the pattern to update the field with]]>
<![CDATA[
]]>
<![CDATA[	'Value: '*' sets to default value]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'WriteLog("Gettime Strparam= '" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[  If instr(StrParam,"*")>0 Then StrParam = "HH:MM:SS"]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam," "," & CHRW(32) &")   'NOTE CHRW is upper case so the 'hr' replace does not change chrw to chhw]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"/"," & CHRW(47) &")  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,":"," & CHRW(58) &")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"-"," & CHRW(45) &")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"'"," & CHRW(39) &")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"& &","&")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"minute","mm")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"min","mm")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"second","ss")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"sec","ss")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"hr","hh")]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"hour","hh")]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("TimeStamp Strparam= '" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	m = Minute(Now)]]>
<![CDATA[
]]>
<![CDATA[	s = Second(Now)]]>
<![CDATA[
]]>
<![CDATA[	h = Hour(Now)]]>
<![CDATA[
]]>
<![CDATA[	hhhh = hh]]>
<![CDATA[
]]>
<![CDATA[	mm = Right("0" & m,2)]]>
<![CDATA[
]]>
<![CDATA[	ss = Right("0" & s,2)]]>
<![CDATA[
]]>
<![CDATA[	hh = Right("0" & h,2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TimeText = Eval(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If err.number=0 then GetTime = True]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Call WriteExport(bInter, bDeBug, TimeText)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("GetTime returns " & GetTime & ". Value: " & TimeText)]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GetTime") ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="LineItem_AddElement" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim Lie, nLie]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LineItem_AddElement = True	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	strParam = trim(strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(2) & "Starting LineItem_AddElement")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For Lie = 0 to ubound(g_aLineItems)]]>
<![CDATA[
]]>
<![CDATA[		if g_aLineItems(Lie) = strParam then ]]>
<![CDATA[
]]>
<![CDATA[			writelog(space(7) & "Element already exists in Line Item Element Array.")	]]>
<![CDATA[
]]>
<![CDATA[			exit Function]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[	Next 'Lie]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(5) & "Adding Element '" & strparam & "' to Line Item Element Array.")	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nLie = ubound(g_aLineItems)]]>
<![CDATA[
]]>
<![CDATA[	Redim Preserve g_aLineItems(nLie + 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_aLineItems(nLie) = strParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function LineItem_AddElement")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "LineItem_AddElement Finished TRUE. Added element " & nLie & " '" & strparam & "'.") ]]>
	</g>
</af>
<af name="LineItem_BlankFields" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim Lie, nLie]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LineItem_BlankFields = False	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Trim(Strparam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(2) & "Starting LineItem_BlankFields")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	If Not Isnumeric(StrParam) then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Parameter must be NUMERIC")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	LineItem_BlankFields = TRUE]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = cint(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(5) & "Adding '" & StrParam & "' blank field Elements to Line Item Element Array.")	]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	For Cntr = 1 to StrParam]]>
<![CDATA[
]]>
<![CDATA[    nLie = ubound(g_aLineItems)]]>
<![CDATA[
]]>
<![CDATA[	  Redim Preserve g_aLineItems(nLie + 1)  ]]>
<![CDATA[
]]>
<![CDATA[    g_aLineItems(nLie) = ""  ]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function LineItem_BlankFields")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "LineItem_BlankFields Finished TRUE. Added element " & nLie & " '" & strparam & "'.") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="LineItem_SmartParameter" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim nLie]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LineItem_SmartParameter = True	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ 	WriteLog(Space(2) & "Starting LineItem_SmartParameter")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  For Lie = 0 to ubound(g_aLineItems)]]>
<![CDATA[
]]>
<![CDATA[		if g_aLineItems(Lie) = strParam then ]]>
<![CDATA[
]]>
<![CDATA[			writelog(space(7) & "Element already exists in Line Item Element Array.")	]]>
<![CDATA[
]]>
<![CDATA[			exit Function]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[  Next 'Lie]]>
<![CDATA[
]]>
<![CDATA[  	 ]]>
<![CDATA[
]]>
<![CDATA[  nLie = ubound(g_aLineItems)]]>
<![CDATA[
]]>
<![CDATA[  Redim Preserve g_aLineItems(nLie + 1)  ]]>
<![CDATA[
]]>
<![CDATA[  g_aLineItems(nLie) = StrParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  WriteLog(Space(5) & "Adding SmartParameter " & StrParam & " to Line Item Array at position " & nLie)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If not g_dictLISmartParam.Exists(nLie) then]]>
<![CDATA[
]]>
<![CDATA[    call g_dictLISmartParam.Add(nLie,StrParam)]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function LineItem_SmartParameter")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "LineItem_SmartParameter Finished TRUE. Added element " & nLie & " '" & strparam & "'.") ]]>
	</g>
</af>
<af name="LineItem_ClearElements" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Redim g_aLineItems(0)]]>
<![CDATA[
]]>
<![CDATA[  Call g_dictLISmartParam.RemoveAll() ]]>
<![CDATA[
]]>
<![CDATA[	LineItem_ClearElements = True	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function LineItem_ClearElements") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="LineItem_ExportElements" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	LineItem_ExportElements = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "Starting LineItem_ExportElements")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim n]]>
<![CDATA[
]]>
<![CDATA[  Dim LieObj]]>
<![CDATA[
]]>
<![CDATA[  Dim oVal]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	For n = 0 to ubound(g_aLineItems)-1]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(space(5) & "Exporting element " & n & ": '" & g_aLineItems(n) & "'.")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If g_aLineItems(n)<>"" then ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[      If g_dictLISmartParam.Exists(n) then]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      	Writelog(Space(5) & "Finding Smart Parameter Value")]]>
<![CDATA[
]]>
<![CDATA[		    oVal = MetaWord(g_aLineItems(n))]]>
<![CDATA[
]]>
<![CDATA[				               ]]>
<![CDATA[
]]>
<![CDATA[        Call WriteExport(bInter, bDebug, oVal)]]>
<![CDATA[
]]>
<![CDATA[        WriteLog(space(7) & "Value '" & oVal & "'.")   ]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    		Set LieObj = CurrentObj.FindChild(g_aLineItems(n))]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If not LieObj is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[		  	  Call WriteExport(bInter, bDebug, CheckDICT(LieObj))]]>
<![CDATA[
]]>
<![CDATA[			    WriteLog(space(7) & "Value '" & LieObj.text & "'.")]]>
<![CDATA[
]]>
<![CDATA[		    Else	]]>
<![CDATA[
]]>
<![CDATA[			    WriteLog(space(7) & "Element is NOTHING")]]>
<![CDATA[
]]>
<![CDATA[		    End if  ]]>
<![CDATA[
]]>
<![CDATA[      End if        ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      WriteLog(space(7) & "Exporting Blank field.")]]>
<![CDATA[
]]>
<![CDATA[      Call WriteExport(bInter, bDebug,"")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    		]]>
<![CDATA[
]]>
<![CDATA[	Next 'n]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function LineItem_ExportElements")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "LineItem_ExportElements Returns TRUE") ]]>
	</g>
</af>
<af name="NewLine" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_bNewLine = True]]>
<![CDATA[
]]>
<![CDATA[	newLine = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function NewLine") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SaveFilePathAsVariable" access="public" bInter="bInter" bDebug="bDebug" strParam="strparam">
	<g>
<![CDATA[
]]>
<![CDATA[	sPath = g_ExportPath & "\" & g_ExportName & g_ExportExtn]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Saveing Export File Path as Variable " & strparam & "  Path: " & g_ExportPath & "\" & g_ExportName & g_ExportExtn)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable(StrParam) = g_ExportPath & "\" & g_ExportName & g_ExportExtn]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SaveFilePathAsVariable = True ]]>
	</g>
</af>
<af name="SetCSV" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	  dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    strParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter parsing. Using original parameter '" & strparam & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Trim(Ucase(StrParam))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(Trim(StrParam))=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter is Empty. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[        SetCSV = False]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If StrParam = "TRUE" Or StrParam = "FALSE" or StrParam = "ON" or StrParam = "OFF" Then]]>
<![CDATA[
]]>
<![CDATA[		g_CSVformat = strParam]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		SetCSV = False]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	SetCSV = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Comma Separated file output is set to " & SetCSVformat)]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetCSV") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetElementSeparator" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    StrParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter parsing. Using original parameter '" & StrParam & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	if ucase(trim(StrParam)) = "OFF" or ucase(trim(StrParam)) = "FALSE" then ]]>
<![CDATA[
]]>
<![CDATA[		g_ElementSeparator = Space(1)]]>
<![CDATA[
]]>
<![CDATA[    g_CSVformat = "OFF"]]>
<![CDATA[
]]>
<![CDATA[	else]]>
<![CDATA[
]]>
<![CDATA[		if ucase(trim(StrParam)) = "ON" or ucase(trim(StrParam)) = "TRUE" then ]]>
<![CDATA[
]]>
<![CDATA[      StrParam = Space(1)]]>
<![CDATA[
]]>
<![CDATA[    end if  ]]>
<![CDATA[
]]>
<![CDATA[		g_ElementSeparator = StrParam]]>
<![CDATA[
]]>
<![CDATA[    g_CSVformat = "OTHER"]]>
<![CDATA[
]]>
<![CDATA[	end if		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetElementSeparator= True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Element Separator is '" & StrParam & "'.")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetElementSeparator") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetExportPath" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim sDriveName]]>
<![CDATA[
]]>
<![CDATA[	Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("SET EXPORT PATH")]]>
<![CDATA[
]]>
<![CDATA[	SetExportPath = False]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    strParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter parsing. Using original parameter '" & strparam & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	sDriveName = FileMgr.GetDriveName(strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not FileMgr.DriveExists(sDriveName) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "SET EXPORT PATH FAILED. NO SUCH DRIVE : " & strParam)]]>
<![CDATA[
]]>
<![CDATA[		SetExportPath = False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If FileMgr.FolderExists(strParam) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "Folder Exists. Setting Export path to: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[		g_ExportPath = strParam]]>
<![CDATA[
]]>
<![CDATA[		SetExportPath = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "Folder does Not Exist. Beginning MakePath Function.")]]>
<![CDATA[
]]>
<![CDATA[		If MakePath(strParam) Then]]>
<![CDATA[
]]>
<![CDATA[			SetExportPath = True]]>
<![CDATA[
]]>
<![CDATA[			g_ExportPath = strParam 	]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("END Set Export Path")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetExportPath") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetExtensionName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[		Dim i, nChar]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    On error resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    SetExtensionName=False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[    sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[    If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[     strParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("No result from Smart Parameter parsing. Using original parameter '" & strparam & "'") ]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    g_ExportExtn = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    If len(g_ExportExtn)>0 then]]>
<![CDATA[
]]>
<![CDATA[        While left(g_ExportExtn,1)="."  ]]>
<![CDATA[
]]>
<![CDATA[            g_ExportExtn = Right(g_ExportExtn,len(g_ExportExtn)-1)]]>
<![CDATA[
]]>
<![CDATA[        Wend]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Check for windows prohibited file name characters *<>[]"/|\:? and control characters '\p{C}']]>
<![CDATA[
]]>
<![CDATA[    sPattern = "\*\<\>\[\]\/\|\\:\?"""]]>
<![CDATA[
]]>
<![CDATA[    If DCGlobalStrings.RegExIsMatch(g_ExportExtn,"[" & sPattern & "\p{C}]") then]]>
<![CDATA[
]]>
<![CDATA[      Call writelog("Invalid Characters found in extension name '*<>[]""/|\:?' or control characters.  Exiting function with Status FAILED.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Setting Export File Extension Name to : " & g_ExportExtn)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    g_ExportExtn = "." & g_ExportExtn]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetExtensionName = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetExtensionName") ]]>
	</g>
</af>
<af name="SetFileName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	g_ExportName = ""]]>
<![CDATA[
]]>
<![CDATA[	on error resume next]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    g_ExportName=Trim(sSmartParam)  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter parsing. Using original parameter '" & strparam & "'") ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  If instr(strParam,",") > 0 or left(StrParam,1) = "@" or left(StrParam,1) = "#" then]]>
<![CDATA[
]]>
<![CDATA[		  Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[		  Dim n]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		  aStrParam = Split(StrParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[  		]]>
<![CDATA[
]]>
<![CDATA[		  For n = 0 to ubound(aStrParam) - 1]]>
<![CDATA[
]]>
<![CDATA[			  Dim sArg]]>
<![CDATA[
]]>
<![CDATA[			  sArg = ucase(trim(aStrParam(n)))	]]>
<![CDATA[
]]>
<![CDATA[			  WriteLog("Processing Arg# " & n & ". Argument: " & sArg)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			  if len(sArg) = 0 then exit For]]>
<![CDATA[
]]>
<![CDATA[			  if left(sArg,1) = "@" then ]]>
<![CDATA[
]]>
<![CDATA[				  Select Case sArg]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					  Case "@BATCHID"]]>
<![CDATA[
]]>
<![CDATA[						  g_ExportName = g_ExportName & replace(Pilot.BatchID,".","") ]]>
<![CDATA[
]]>
<![CDATA[						  WriteLog("Adding BatchID to Export File Name")]]>
<![CDATA[
]]>
<![CDATA[					  Case "@ID"]]>
<![CDATA[
]]>
<![CDATA[						  g_ExportName = g_ExportName & CurrentObj.ID]]>
<![CDATA[
]]>
<![CDATA[						  WriteLog("Adding Object ID to Export File Name")]]>
<![CDATA[
]]>
<![CDATA[					  Case "@STATUS"]]>
<![CDATA[
]]>
<![CDATA[						  g_ExportName = g_ExportName & CurrentObj.Status]]>
<![CDATA[
]]>
<![CDATA[						  WriteLog("Adding Object Status to Export File Name")]]>
<![CDATA[
]]>
<![CDATA[					  Case "@TYPE"]]>
<![CDATA[
]]>
<![CDATA[						  g_ExportName = g_ExportName & CurrentObj.Type]]>
<![CDATA[
]]>
<![CDATA[						  WriteLog("Adding Object Type to Export File Name")]]>
<![CDATA[
]]>
<![CDATA[					  Case "@DATE"]]>
<![CDATA[
]]>
<![CDATA[						  n = n + 1]]>
<![CDATA[
]]>
<![CDATA[						  sArg = Trim(aStrParam(n))]]>
<![CDATA[
]]>
<![CDATA[						  if len(sArg) = 0 then sArg= "mm/dd/yyyy"]]>
<![CDATA[
]]>
<![CDATA[						  If InStr(sArg,"*")>0 Then sArg= "mm/dd/yyyy"]]>
<![CDATA[
]]>
<![CDATA[							  sArg= LCase(sArg)]]>
<![CDATA[
]]>
<![CDATA[  	]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"c","y")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg," "," & Chrw(32) &")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"/"," & Chrw(47) &")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"& &","&")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"day","dd")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"month","mm")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"year","yyyy")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"julian","y")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"jjj","y")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							  WriteLog("Export filename DateStamp = '" & sArg & "' ")]]>
<![CDATA[
]]>
<![CDATA[  														]]>
<![CDATA[
]]>
<![CDATA[							  d = Day(Now)]]>
<![CDATA[
]]>
<![CDATA[							  dd = Right("0" & d,2)]]>
<![CDATA[
]]>
<![CDATA[							  yyyy = Year(Now)]]>
<![CDATA[
]]>
<![CDATA[							  yy = Right(yyyy,2)]]>
<![CDATA[
]]>
<![CDATA[							  m = Month(Now)]]>
<![CDATA[
]]>
<![CDATA[							  mm = Right("0" & m,2)]]>
<![CDATA[
]]>
<![CDATA[							  ccyy = yyyy]]>
<![CDATA[
]]>
<![CDATA[							  y = DatePart("y",Now)]]>
<![CDATA[
]]>
<![CDATA[  	]]>
<![CDATA[
]]>
<![CDATA[  						   	  DateVal = Eval(sArg)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							  DateVal = Replace(DateVal ," ","")]]>
<![CDATA[
]]>
<![CDATA[							  DateVal = Replace(DateVal ,"/","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						  g_ExportName = g_ExportName & DateVal]]>
<![CDATA[
]]>
<![CDATA[  					]]>
<![CDATA[
]]>
<![CDATA[					  Case "@TIME"]]>
<![CDATA[
]]>
<![CDATA[						  n = n + 1]]>
<![CDATA[
]]>
<![CDATA[						  sArg = Trim(aStrParam(n))]]>
<![CDATA[
]]>
<![CDATA[						  if len(sArg) = 0 then sArg= "HH:MM:SS"]]>
<![CDATA[
]]>
<![CDATA[						  If Trim(sArg) = "*" Then sArg= "HH:MM:SS"]]>
<![CDATA[
]]>
<![CDATA[							  sArg= LCase(sArg)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"/"," & Chrw(47) &")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg," "," & Chrw(32) &")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,":"," & Chrw(58) &")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"& &","&")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"min","mm")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"minute","mm")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"sec","ss")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"second","ss")]]>
<![CDATA[
]]>
<![CDATA[							  sArg= Replace(sArg,"hr","hh")]]>
<![CDATA[
]]>
<![CDATA[							  WriteLog("TimeStamp sArg= '" & sArg& "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							  m = Minute(Now)]]>
<![CDATA[
]]>
<![CDATA[							  s = Second(Now)]]>
<![CDATA[
]]>
<![CDATA[							  h = Hour(Now)]]>
<![CDATA[
]]>
<![CDATA[							  hhhh = hh]]>
<![CDATA[
]]>
<![CDATA[							  mm = Right("0" & m,2)]]>
<![CDATA[
]]>
<![CDATA[							  ss = Right("0" & s,2)]]>
<![CDATA[
]]>
<![CDATA[							  hh = Right("0" & h,2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							  TimeText = Eval(sArg)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							  TimeText = Replace(TimeText ,"/","")]]>
<![CDATA[
]]>
<![CDATA[							  TimeText = Replace(TimeText ," ","")]]>
<![CDATA[
]]>
<![CDATA[							  TimeText = Replace(TimeText ,":","")]]>
<![CDATA[
]]>
<![CDATA[  							]]>
<![CDATA[
]]>
<![CDATA[						  g_ExportName = g_ExportName & TimeText	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					  Case "@VALUE"]]>
<![CDATA[
]]>
<![CDATA[						  g_ExportName = g_ExportName & CheckDICT(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[						  WriteLog("Adding Object Text to Export File Name")		]]>
<![CDATA[
]]>
<![CDATA[				  End Select]]>
<![CDATA[
]]>
<![CDATA[			  elseif left(sArg,1) = "#" then ]]>
<![CDATA[
]]>
<![CDATA[				  Dim oObj]]>
<![CDATA[
]]>
<![CDATA[				  Set oObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[				  Set oObj = CurrentObj.FindChild(replace(sArg,"#",""))]]>
<![CDATA[
]]>
<![CDATA[				  if not oObj is Nothing then]]>
<![CDATA[
]]>
<![CDATA[					  g_ExportName = g_ExportName & CheckDICT(oObj)]]>
<![CDATA[
]]>
<![CDATA[					  WriteLog("Adding Field Value '" & oObj.Text & "' to Export File Name")]]>
<![CDATA[
]]>
<![CDATA[				  end if]]>
<![CDATA[
]]>
<![CDATA[			  else]]>
<![CDATA[
]]>
<![CDATA[				  g_ExportName = g_ExportName & sArg	]]>
<![CDATA[
]]>
<![CDATA[			  end if]]>
<![CDATA[
]]>
<![CDATA[		  Next 'n 		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	  else]]>
<![CDATA[
]]>
<![CDATA[		  g_ExportName = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	  end if]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	if len(trim(g_ExportName))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Export Name has no value. Setting to Default 'Export'")]]>
<![CDATA[
]]>
<![CDATA[		g_ExportName = "Export"]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Setting Export File Name to : " & g_ExportName)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetFileName = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetFileName") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetOMR_Separator" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	g_OMRSepChar = StrParam]]>
<![CDATA[
]]>
<![CDATA[  DCO.Variable("g_OMRSepChar")=StrParam]]>
<![CDATA[
]]>
<![CDATA[	Writelog("OMR Separation Character is set to '" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[	SetOMR_Separator = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Text" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim nLength]]>
<![CDATA[
]]>
<![CDATA[  Dim tLength]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  tLength = g_FixedLen]]>
<![CDATA[
]]>
<![CDATA[  g_FixedLen = len(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	writelog("ADD TEXT")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call WriteExport(bInter, bDeBug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(5) & "Added Text: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[	Text = True ]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function Text")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  g_FixedLen = tLength]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="Variable_ExportValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    Dim sValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Variable_ExportValue = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(strParam)=0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter is Empty. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("EXPORT Variable: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    sValue = ""]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.FindVariable(Strparam)>0 then]]>
<![CDATA[
]]>
<![CDATA[        sValue = CurrentObj.Variable(Strparam)]]>
<![CDATA[
]]>
<![CDATA[        WriteLog(Space(5) & "Value is :'" & sValue & "' ")]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Variable Not Found.")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call WriteExport(bInter, bDebug, sValue)]]>
<![CDATA[
]]>
<![CDATA[	Variable_ExportValue = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Variable_ExportValue")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "Variable_ExportValue returns " & Variable_ExportValue) ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Variable_IsValue" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sVarName]]>
<![CDATA[
]]>
<![CDATA[	Dim sMatchVal]]>
<![CDATA[
]]>
<![CDATA[	Dim sCMD]]>
<![CDATA[
]]>
<![CDATA[	Dim sFoundVal]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Variable_IsValue = False]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "Starting Function Variable_IsValue")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If len(strParam)=0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter is Empty. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & "," ,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sVarName = trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	sMatchVal = trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(4) & "Find Variable: " & sVarName)]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(4) & "  Match Value: " & sMatchVal) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(sVarName)=0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Variable name is Empty. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(sMatchVal)=0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Match value is Empty. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.FindVariable(sVarName)<=0 then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Variable does not Exist. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sFoundVal = cstr(CurrentObj.Variable(sVarName))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(4) & "Variable Value: " & sFoundVal)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	if sFoundVal = sMatchVal then Variable_IsValue = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function Variable_IsValue")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(space(2) & "Variable_IsValue returns " & Variable_IsValue)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<g>
</g>
<af name="SetFixedLength" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  SetFixedLength = False]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(Trim(strParam)) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Invalid Parameter '" & StrParam & "'. Numeric value expected. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		g_FixedLen = ""]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	g_FixedLen = CLng(Trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Fixed Length set to :" & g_FixedLen)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetFixedLength = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetFixedLength") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetJustified" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetJustified = False]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Ucase(Trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Select Case Left(StrParam & space(1),1)  ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Case "R"]]>
<![CDATA[
]]>
<![CDATA[			g_Justified = "Right"]]>
<![CDATA[
]]>
<![CDATA[		Case "L"]]>
<![CDATA[
]]>
<![CDATA[			g_Justified = "Left"]]>
<![CDATA[
]]>
<![CDATA[		Case Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Invalid Parameter '" & StrParamm & "'. Value of 'Left'(L) or 'Right'(R) Expected. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End Select]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Justification set to :" & g_Justified & ".  Returning True.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetJustified = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetJustified") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetZeroFill" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_SetFill = "0"]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Set to Zero Fill")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetZeroFill = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetZeroFill") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFill" access="public" bInter="bInter" bDebug="bDebug" strParam="Strparam">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetFill = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(StrParam)<> 1 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Invalid Fill Character Parameter '" & sChar & "'. Single charcter expected. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_SetFill = StrParam]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Set to " & Strparam & " Fill")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetFill = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetFill") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetSpaceFill" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_SetFill = " "]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Set to Space Fill")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetSpaceFill = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetSpaceFill") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetIgnoreFieldStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="Strparam">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  SetIgnoreFieldStatus = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  strparam = Trim(strparam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not(IsNumeric(Strparam)) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Parameter Must be a numeric value.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	g_IgnoreFieldStatus = Strparam]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("SetIgnoreFieldStatus is set to: " & Strparam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetIgnoreFieldStatus = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetIgnoreFieldStatus") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ResetFieldVariables" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	g_FixedLen 	= ""]]>
<![CDATA[
]]>
<![CDATA[	g_Justified = "Left"]]>
<![CDATA[
]]>
<![CDATA[	g_SetFill	= Space(1)]]>
<![CDATA[
]]>
<![CDATA[  g_IgnoreFieldStatus=""]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Field Variables have been Reset." & vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ResetFieldVariables = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function ResetFieldVariables") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FixedLenLJ" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim aParams]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FixedLenLJ = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aParams = Split(StrParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If SetJustified(bInter, bDeBug, "L") = False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	If SetFixedLength(bInter, bDeBug, aParams(1)) = False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	If ExportFieldValue(bInter, bDebug, aParams(0)) = False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FixedLenLJ = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function FixedLenLJ") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FixedLenRJ" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim aParams]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FixedLenRJ = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aParams = Split(StrParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If SetJustified(bInter, bDeBug, "R")= False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	If SetFixedLength(bInter, bDeBug, trim(aParams(1)))= False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	If ExportFieldValue(bInter, bDebug, aParams(0))= False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FixedLenRJ = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function FixedLenRJ") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Filler" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  'StrParams is a 2 part CSV of the length and optional character for export ]]>
<![CDATA[
]]>
<![CDATA[  'If no character is specified the last global Fill character setting is used.		]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim sFiller]]>
<![CDATA[
]]>
<![CDATA[	Dim sChar]]>
<![CDATA[
]]>
<![CDATA[	Dim aParams]]>
<![CDATA[
]]>
<![CDATA[	Dim nLength]]>
<![CDATA[
]]>
<![CDATA[	Dim tLength]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Filler Input: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Filler=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aParams = Split(StrParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nLength = Trim(aParams(0))]]>
<![CDATA[
]]>
<![CDATA[	sChar = Trim(aParams(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(nLength) Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Invalid Parameter '" & nLength & "'. Numeric value expected. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit function]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    tLength = g_FixedLen]]>
<![CDATA[
]]>
<![CDATA[    g_FixedLen = nLength]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Select Case len(sChar)]]>
<![CDATA[
]]>
<![CDATA[		Case 0]]>
<![CDATA[
]]>
<![CDATA[			sChar = g_SetFill]]>
<![CDATA[
]]>
<![CDATA[		Case 1]]>
<![CDATA[
]]>
<![CDATA[			'Value is ok. Continue Action.]]>
<![CDATA[
]]>
<![CDATA[		Case Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Invalid Fill Character Parameter '" & sChar & "'. Single charcter expected. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[			Exit function]]>
<![CDATA[
]]>
<![CDATA[	End Select]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sFiller = String(nLength,sChar)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Text(bInter, bDebug, sFiller) = False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function Filler")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  g_FixedLen = tLength]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Filler = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<f name="SetExportFileEncodingAsASCII" access="public">
	<p name="ASCIIEncoding">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ SetExportFileEncodingAsASCII=TRUE]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ Dim mStrParam]]>
<![CDATA[
]]>
<![CDATA[ 'Determines if a file uses ANSI or Unicode encoding.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  mStrParam = MetaWord(ASCIIEncoding)]]>
<![CDATA[
]]>
<![CDATA[  If mStrParam<>"" then ASCIIEncoding = mStrParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	if UCase(ASCIIEncoding) = "TRUE" Then]]>
<![CDATA[
]]>
<![CDATA[     g_ExportFileEncoding = g_exportASCII]]>
<![CDATA[
]]>
<![CDATA[     writelog("Param: '" & StrParam & "'  Setting to Export file encoding to ASCII")]]>
<![CDATA[
]]>
<![CDATA[  else]]>
<![CDATA[
]]>
<![CDATA[     g_ExportFileEncoding = g_exportUNICODE]]>
<![CDATA[
]]>
<![CDATA[     writelog("Param: '" & StrParam & "'  Setting to Export file encoding to UNICODE")]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetExportFileEncodingAsASCII = True	]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function SetExportFileEncodingAsASCII")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<help>
  <![CDATA[
'************************************************************
' help.xml for Export 

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************

]]>

<ref id="BatchVariable_ExportValue" qi="Exports the value contained in the specified batch-level variable.">
  <ap>The name of the Batch variable.</ap>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    Exports the value contained in the specified batch-level variable.
    <e>
      <b>BatchVariable_ExportValue("ED")</b><br/><br/>

      This action will export the value located in the ED Batch variable to your Export file.
   </e>
  </h>
</ref>

<ref id="DocumentVariable_ExportValue" qi="Exports the value contained in the specified Document-level variable.">
  <ap>Document Variable Name.</ap>
  <h>
    Exports the value contained in the specified Document-level variable.
    <e>
      <b>DocumentVariable_ExportValue("PageCount")</b><br/><br/>

      A number of techniques can add variables to a Document object of the Document Hierarchy. These 
      variables are listed as properties of the object in the Document Hierarchy Setup window.<br/><br/>

      The example above reads the value assigned to the PageCount Document variable and places it in 
      the Export file.
    </e>
  </h>
  <lvl>Document, Page or Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="PageVariable_ExportValue" qi="Exports runtime values assigned to a variable of the bound Page object of the Document Hierarchy.">
  <ap>String value of the variable's name.</ap>
  <h>
    Exports runtime values assigned to a variable of the bound Page object of the Document Hierarchy.
    <e>
      <b>PageVariable_ExportValue("TemplateID")</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="BlankFields" qi="Inserts n blank fields into the Export file, adjacent to the current field."> 
  <ap>
    A number indicating how many blank fields to add to the Export file.
  </ap>	
  <h>
    The <b>BlankFields</b> action adds the number of fields you specify. The fields are blank;
    other actions direct the Export task to fill the fields.<br/><br/>

    Note: Make sure you call SetCSV, and optionally SetElementSeparator, to set the separator values as 
    desired for your export file.  if neither of these actions are called before 
    the BlankFields action, no empty fields will be exported because
    the default separator is set to no separator.
    <e>
      SetCSV("TRUE")<br/>
		  <b>BlankFields("12")</b>
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    SetSCV, SetElementSeparator
  </see>
</ref>

<ref id="BlankLines" qi="Inserts n blank lines into the Export file.">
  <ap>
    A number <b>n</b> indicating how many blank lines to add below the current line.
  </ap>
  <h>
    Inserts <b>n</b> blank lines into the Export file.
    <e>
      <b>BlankLines("4")</b><br/><br/>

      This action inserts four empty lines, leaving the insertion point for the next output on 
      the following line. Additional output will begin on the fifth line.
    </e>
  </h>
  <lvl>All level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
	  NewLine
  </see>
</ref>

<ref id="BPilot" qi="Exports the value assigned to the Batch Pilot property designated as the parameter.">
  <ap>
    The name of the Batch Pilot <b><i>'Property'</i></b> whose value is to be included in the Export file.<br/><br/>
    <b>BatchDir</b> The name and location of the application’s Batches directory.<br/>
    <b>BatchID</b> The Batch Number of the current batch (20020072.003, for example.)<br/>
    <b>JobName</b> The name of the current User Application job (Main, for example.)<br/>
    <b>Operator</b> The User ID of the operator currently processing the batch.<br/>
    <b>PagesInBatch</b> A count of all pages in the batch.<br/>
    <b>DocsInBatch</b> A count of all documents in the batch. Remember: in most configurations, 
    a Recognition task reorganizes a batch into a series of documents and their pages.<br/>
    <b>Priority</b> 
      The processing priority assigned to the current batch (“10” = Low, “1 = High, “5” = Default). A task selects batches from its queue first according to Priority.
      Station	The Station ID of the workstation currently processing the batch.
    <br/>
    <b>TaskName</b> The name of the task with the batch in its queue.<br/>
    <b>XtraBatchFieldValue</b> The value in a custom field you’ve added to the Job Monitor’s Batch Information Table.<br/>
  </ap>  
  <h>
    Exports the value assigned to the Batch Pilot property that designated as the parameter.<br/><br/>
    <e>
      NewLine()<br/>
      Text("BatchID:")<br/>
      <b>BPilot("BatchID")</b><br/><br/>

      This sequence adds "BatchID: " followed by the current Batch ID into the Export file. For example:<br/><br/>
      BatchID: 20050019.001
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    <b>False</b> if the parameter is not a Batch Pilot property.  Otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="CloseExportFile" qi="Closes the currently opened Export file.">
  <ap>None.</ap>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    Closes the currently opened Export file.<br/><br/>

    This action usually belongs to its own RuleSet (ExportClose, for example), and applies to 
    the Batch object of the Document Hierarchy.  However, it can be used at any level.
    <e>
      <b>CloseExportFile()</b>
    </e>
  </h>
  <see>
    SetFileName
  </see>
</ref>

<ref id="DCOProperty" qi="Exports the value assigned to the DCO property that you designate as the parameter.">
  <ap>
    The name of the DCO <b><i>'Property'</i></b> whose value is to be included in the Export file.<br/><br/>
    <b>ID</b> The value of an object’s ID property. For a Batch object, 
    this might be 20020072.003. You can apply this action at any level(s).<br/><br/>
    
    <b>ImageName</b> The name and location of a Page object’s Image file: 
    c:\ParentDirectory\Invoices\batches\20030145.001\TM000001.tif, for example.<br/><br/>
    
    <b>Status</b> The value assigned to an object’s Status property. You can apply this action at any level(s).<br/><br/>
    
    <b>Type</b> The value assigned to an object’s Status property. You can apply this action at any level(s).<br/>
  </ap>
  <h>
    Exports the value assigned to the DCO Property that you designate as the parameter.<br/><br/>
    <e>
      NewLine()<br/>
      Text("Document: ")<br/>
      <b>DCOProperty("ID")</b><br/><br/>

      If this sequence is applied to a Document object, the Export file for document 01 in batch 20050219.057 will look like:<br/><br/>
      Document: 20050219.057.01
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    <b>False</b> if the parameter is not a valid DCO Property.  Otherwise, <b>True.</b>
  </ret>
  <see>
    BPilot
  </see>
</ref>

  
<ref id="ExportAllFields" qi="Exports all field values on the current page, including values of Line Item Detail sub-fields - with exceptions.">
  <ap>None.</ap>  
  <h>
    This action exports all field values of the current page. However, the action does <b><i>not</i></b>
    export those values of <b>Field</b> objects of the Document Hierarchy with:<br/><br/>
    1. a setup <b>NOEXPORT</b> variable of "1", or <br/><br/>
    2. a value of a runtime <b>SetIgnoreStatus</b> a field status equal to the <i>Numeric</i> field 
    status defined by a previously-run <b>SetIgnoreFieldStatus</b> action. 
    (For details, see the description of that action.)
    <e>      
      <b>ExportAllFields()</b>      
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if the action is not used at the Page level. Otherwise, <b>True.</b>
  </ret>
</ref>

  
<ref id="ExportFieldValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Exports the specified Field object's value to the Export file.">
  <ap>The name of the Field object whose value you want to export.</ap>  
  <h>
    Exports the specified Field object's value to the Export file. Will only export the 
    last Field if multiple fields of the same field type are found.
    <e>
      <b>ExportFieldValue("Date")</b><br/>
      <b>ExportFieldValue("Number")</b><br/>
      <b>ExportFieldValue("Total")</b><br/><br/>

      This sequence exports the current values stored in the Date, Number and Total fields.
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if the parameter is not a Field object's name. Otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="ExportMYValue" qi="Exports the current field value to the Export file.">
  <ap>None.</ap>  
  <h>
    Exports the current field value to the Export file.
    <e>
      <b>ExportMYValue()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="ExportSmartParameter" qi="Exports an evaluated smart parameter value to the Export file.">
  <ap>The value to export expressed with smart parameter syntax.</ap>  
  <h>
    Exports an evaluated smart parameter value to the Export file.  
    If the input parameter is not a smart parameter, it will export an empty field.
    <e>
      The example will export the value of a variable named
      <b><i>Expired</i></b> on field <b><i>DueDate</i></b> which is a child field on the parent page 
      <b><i>(@P)</i></b> of the calling node.<br/><br/>
      <b>ExportSmartParameter("@P\DueDate.Expired")</b>
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    SetSCV, SetElementSeparator
  </see>
</ref>
  
<ref id="ExportToBatchDir" qi="Specifies that the path for the current Export file(txt) is the Batch directory.">
  <ap>None.</ap>
  <h>
    This action sets the path for the Export file to the current Batch directory.<br/>
    <b>Note:</b> Usually, an Export file is placed in the application's Export folder instead 
    of in a Batch folder of the Batch directory.
    <e>
      <b>ExportToBatchDir()</b>
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    <b>False</b>, if the Batch Directory is not accessible. Otherwise, <b>True.</b>
  </ret>
  <see>
    SetExportPath
  </see>
</ref>

<ref id="GetDATE" qi="Exports today's Date in the format specified as the parameter.">
  <ap>
    The Date's format. <br/><br/>

    "*" stipulates the default mm/dd/yyyy construction. However, you can combine any of the following String values to define a different format:<br/>
    d = day of the month, 1-31<br/>
    dd = two-digit day, 01-31<br/>
    yyyy = four-digit year<br/>
    yy = two-digit year<br/>
    m = month, 1-12<br/>
    mm = two-digit month, 01-12<br/>
    ccyy = four-digit year<br/>
    y = Julian day of the year<br/><br/>

    "." and "/" are valid separators.
  </ap>
  <h>
    Exports today's Date in the format specified as the parameter.
    <e>
      <b>GetDate("*")</b> inserts today's date into the Export file with this format:<br/>
      11/16/2005
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    GetTime
  </see>
</ref>

<ref id="GetProfileString" qi="Accesses a Settings file (.ini) and adds a value in that file to your Export file.">
  <ap>
    <b>1.</b> The [Section] within the Settings file.<br/>
    <b>2.</b> The Key entry within the section, with the value you want to retrieve.<br/>
    <b>3.</b> The name of the Settings file.
  </ap>
  <h>
    Accesses a Settings file (.ini), locates the specified key and adds the value of the key to your Export file.  If the key 
    cannot be read from the settings file, an empty string will be written to the export.  If the settings file
    cannot be found, nothing will be written to the export.<br/><br/>

    <b>Important:</b> The action assumes that the Settings file resides in the <i>current</i> batch directory.
    If you want the INI file to reside in the "Batches" directory, specify your file name with a relative path 
    like this: "..\myfile.ini".
    <e>
      <b>GetProfileString("General,MyValue,Batch.ini")</b>
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    <b>False</b> if the settings file cannot be found.  Otherwise, <b>True.</b>  If the settings file
    can be found but the key entry cannot be found within the file, this action will return <b>True.</b>
  </ret>
</ref>

<ref id="GetTime" qi="Exports the current Time in the format specified as the parameter.">
  <ap>
    The parameter specifies the display format for the current time. <br/><br/>

    * = A single asterisk will use the HH:MM:SS time format. However, you can combine any of the following String values to define a different format:<br/>
    m = minute 1-59<br/>
    s = second 1-59<br/>
    h = 1-23<br/>
    mm, min, minute = two-digit minute, 01-59<br/>
    ss, sec, second = two-digit second, 01-59<br/>
    hh, hr, hour = two-digit hour, 01-23<br/><br/>

    ":/'-" are the valid separators.
  </ap>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    Exports the current Time in the format specified by the input parameter.
    <e>
      <b>GetTime("*")</b><br/>
      inserts the current time into the Export file with this format: 07:08:16<br/><br/>
      <b>GetTime("hh-mm-ss")</b><br/>
      inserts the current time into the Export file with this format: 07-08-16<br/><br/>
      <b>GetTime("ss:mm:hh")</b><br/>
      inserts the current time into the Export file with this format: 16:08:07
    </e>
  </h>
  <see>
    GetDate
  </see>
</ref>

<ref id="LineItem_AddElement" qi="Includes the specified Line Item Field object as an element of a Line Item Array. ">
  <ap>
    The name of the child <b>Field</b> object of the Document Hierarchy.
  </ap>
  <h>
    This action includes the specified Line Item field object as an element of a Line Item Array.<br/><br/>

    A Line Item Array accumulates and organizes captured line item values retrieved from the Data 
    file of a particular page.<br/><br/>

    <b>Note:</b> A rule using this action should be applied to the <i>LINEITEM</i> fields 
    of the Document Hierarchy.<br/><br/>

    This action is used for exporting Line Item values.
    <e>
      <b>LineItem_AddElement("Price")</b><br/>
      LineItem_ExportElements()<br/><br/>

      The action above expands the Line Item Array by one field: Price. <br/><br/>

      LineItem_ExportElements will populate this element and other elements 
      of the array with the captured values it finds in a page's Data file before exporting them.
    </e>
  </h>
  <lvl>
    The <b><i>parent</i></b> field that contains the child Line Item field.
  </lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    LineItem_ExportElements,  LineItem_ClearElements, LineItem_BlankFields
  </see>
</ref>

<ref id="LineItem_BlankFields" qi="Includes the specified number of blank fields as elements of a Line Item Array. ">
  <ap>
    The number of Blank fields to export as part of the Line Item Array.
  </ap>
  <h>
    This action includes the specified number of Blank Line Item fields as elements 
    of a Line Item Array.<br/><br/>

    A Line Item Array accumulates and organizes captured line item values retrieved 
    from the Data file of a particular page.<br/><br/>

    <b>Note:</b> A rule using this action should be applied to the <i>LINEITEM</i> fields of the Document Hierarchy.<br/><br/>

    This action is used for exporting Blank Line Item values.
    <e>
      <b>LineItem_BlankFields("6")</b><br/><br/>

      The action above expands the Line Item Array by six blank fields<br/><br/>

      <scr>LineItem_ExportElements</scr> will populate this element and other elements 
      of the array with the captured values it finds in a page's Data file before exporting them.
    </e>
  </h>
  <lvl>
    The <b><i>parent</i></b> field that contains the child Line Item field.  
  </lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    LineItem_ExportElements, LineItem_ClearElements,LineItem_AddElements, LineItem_SmartParameter
  </see>
</ref>
  
<ref id="LineItem_SmartParameter" qi="Add a smart parameter algorithm as an element of a Line Item Array. ">
  <ap>Smart Parameter to be evaluated during processing of the Lineitem array.</ap>
  <h>
    This action permits adding a smart parameter as an element of a Line Item Array to be evaluated 
    during the Array processing.<br/><br/>

    A Line Item Array accumulates and organizes captured line item values retrieved 
    from the Data file of a particular page.<br/><br/>

    <b>Important!</b> A rule using this action should be applied to the <i>LINEITEM</i> fields of the Document Hierarchy.<br/><br/>

    This action is used for exporting Blank Line Item values.
    <e>
      <b>LineItem_SmartParameter("@F\Price+@TIME(HH:MM:SS)")</b><br/>
      LineItem_ExportElements()<br/><br/>

      The action above places a child field <b><i>Price</i></b> of the calling field node <b><i>(@F)</i></b> 
      appended with the current time in format HH:MM:SS to the export file. <br/><br/>

      LineItem_ExportElements will populate this element and other elements 
      of the array with the captured values it finds in a page's Data file before exporting them.
    </e>
  </h>
  <lvl>
    The <b><i>parent</i></b> field that contains the child Line Item field.  
  </lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    LineItem_ExportElements, LineItem_ClearElements, LineItem_AddElements, LineItem_BlankFields
  </see>
</ref>


<ref id="LineItem_ClearElements" qi="Clears values in the Line Item Array.">
	<ap>None</ap>
	<h>
		This is mainly a housekeeping function you can use to be sure the array does not contain leftover values.
		<e>
      <b>LineItem_ClearElements()</b>
    </e>	
	</h>
  <lvl>
    The <b><i>parent</i></b> Field object of the Document Hierarchy that contains a <b><i>child</i></b>
    Line Item field, such as you may typically find in an invoice application.
  </lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    LineItem_AddElement, LineItem_ExportElements, LineItem_BlankFields, LineItem_SmartParameter
  </see>
</ref>

<ref id="LineItem_ExportElements" qi="Exports the captured values in a page's Line Item Array that have been populated with LineItem_AddElement actions.">
  <ap>None.</ap>
  <lvl>
    The parent field that contains the child Line Item sub-fields.
  </lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    Exports the captured values in a page's Line Item Array that have been populated 
    with LineItem_AddElement actions.
    <e>
      LineItem_AddElement("Price")<br/>
      LineItem_AddElement("LineTotal")<br/>
      <b>LineItem_ExportElements()</b><br/>
      NewLine()<br/><br/>

      This example exports the values included in the Line Item Array to your Export file.
    </e>
  </h>
  <see>
    LineItem_ClearElements, LineItem_AddElement, LineItem_BlankFields, LineItem_SmartParameter
  </see>
</ref>

	<ref id="NewLine" qi="Starts a new line in your Export file.">
		<ap>None.</ap>
		<lvl>Any level.</lvl>
		<ret>
			Always <b>True.</b>
		</ret>
		<h>
			Starts a new line in your Export file.
			<e>
				<b>NewLine()</b><br/>
				Text("Export Output")<br/><br/>

				This sequence starts a new line and adds "Export Output" to the beginning of the line.
			</e>
		</h>
		<see>
			BlankLines
		</see>
</ref>

<ref id="SaveFilePathAsVariable" qi="Saves the path and name of your Export file to the variable specified by the parameter. ">
  <ap>Variable name specifying where the Export file name and path will be stored.</ap>
  <h>
    Saves the path and name of your Export file to the variable specified by the parameter.  If the 
    variable does not exist, it will be created.
    <e>
      <b>SaveFilePathAsVariable("Export_File")</b>
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="SetCSV" qi="Ensures that all exported values are delimited by a comma separator.">
  <ap>
    <b>TRUE or ON:</b> Enables CSV formatted output using a comma separator.<br/>
    <b>FALSE:</b> Uses a custom separator, as set by SetElementSeparator(), between output fields.<br/>
    <b>OFF:</b> Causes no separator to be placed between output fields.<br/><br/>
    Smart parameters are supported.
  </ap>
  <h>
    Ensures that all exported values are delimited by a comma separator.
    <e>
      <b>SetCSV("TRUE")</b><br/>      
      ExportFieldValue("Date")<br/>
      ExportFieldValue("Number")<br/>
      ExportFieldValue("Total")<br/>
      <b>SetCSV("FALSE")</b><br/><br/>

      This sequence will export the captured values of the Date, Number, and Total Field 
      objects into your Export file.  A comma will be added after each value to separate the fields.
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    SetElementSeparator
  </see>
</ref>

<ref id="SetElementSeparator" qi="Ensures that all exported values are delimited by a separator designated as the parameter.">
	<ap>
    The input parameter can be one of the following:<br/><br/>
    
    A field separator character: Uses the provided custom character as the separator between fields.
    Smart parameters are supported.<br/><br/>
    ON or TRUE: Sets the field element separator to a single space.  This is the default value.<br/>
    OFF or FALSE: No separator will be placed between fields.<br/><br/>
    Smart parameters are supported.
  </ap>	
	<h>
		Ensures that all exported values are delimited by a separator designated as the parameter.<br/><br/>
    Note: If you wish to set your own custom separator, SetCSV(FALSE) must be called prior to exporting fields.
    If SetCSV(FALSE) is not called, then your custom element separator will not be used for export.
		<e>
      SetCSV("FALSE")<br/> 
			<b>SetElementSeparator("|")</b><br/>
			This action uses "|" to delimit the Export file's values.<br/><br/>

			<b>SetElementSeparator("Off")</b> turns off the action.
		</e>
	</h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
	<see>
		SetCSV
	</see>
</ref>

<ref id="SetExportPath" qi="Specifies the path to the Export file's location. Alternatively, you can use a Smart Parameter to identify a Paths.ini file that has a set of path parameters for your application - see the Parameters and Details sections below.">
<ap>
  The complete path to the application's Export folder. Smart parameters are supported.
</ap>
<lvl>All</lvl>
<ret>
	<b>True</b> if the path specified by the parameter exists. Otherwise, <b>False.</b>
</ret>
<h>
	The action's parameter specifies the path to the Export file's location, or uses a Smart Parameter to retrieve a path's value from the application's Paths.ini file.
	<e>
		<b>SetExportPath("c:\ParentDirectory\Invoice\Export")</b>
		<br/>
		<br/>
    <b>SetExportPath("@APPPATH(export)")</b><br/>
    In the second example, a smart parameter is used to obtain the location of the Export Directory from the
    value configured in the Application Manager.
	</e>
</h>
</ref>

<ref id="SetExtensionName" qi="Assigns an extension to the current Export file.">
  <ap>
    The file extension you want to use, including the leading period.  If you do not want a file
    extension, do not pass any parameter to this action.
    Disallowed characters are *&gt;&lt;[]&quot;/|\:? and control characters.<br/><br/>
    
    Smart parameters are supported.
  </ap>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    Assigns an extension to the current Export file. If this action is not called, the default value 
    of .TXT will be used.
    <e>
      SetFileName("Export_+@BATCHID")<br/>
      <b>SetExtensionName(".dat")</b><br/><br/>

      In this example, the Export file will have a .dat extension.
    </e>
  </h>
  <see>
    SetFileName
  </see>
</ref>

<ref id="SetFileName" qi="Assigns a name to the current Export file.">
	<ap>
		The file's name (without an extension). <br/><br/>
    Smart parameters are supported.
	</ap>
	<h>
    Assigns a name to the current Export file.  If SetExtensionName is not called, the file
    extension defaults to .TXT.  If you require a different file extension, use SetExtensionName.
    <e>
			<b>SetFileName("Export_+@BATCHID")</b><br/>
			SetExtensionName(".txt")<br/><br/>

			This sequence establishes a series of Export files with names such as<br/>
			Export_20021231.001.txt<br/>
			Export_20021231.002.txt<br/><br/>

			In contrast,<br/>
			<b>SetFileName("@BATCHID")</b><br/>
			SetExtensionName(".txt")<br/>
			will establish a series of Export files with Batch IDs only:<br/>
      20021231.001.txt<br/>
      20021231.002.txt
		</e>
	</h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
		SetExtensionName
	</see>
</ref>

<ref id="SetOMR_Separator" qi="For multi-punch OMR fields, uses the parameter's value as the separator character.">
  <ap>The separator character you want to use.</ap>
  <h>
    For multi-punch OMR fields, uses the parameter's value as the separator character.  When
    multi-punch fields are exported, you typically do not want to use the same separator
    that you are using for fields as these values are typically all within a single field.  This
    action allows you to specify a custom separator to be used when exporting.  If this
    action is not called, the default value is a space.
    <e>
      <b>SetOMR_Separator(";")</b>
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="Text" qi="Places a string into the Export file.">
	<ap>The string to write to the export file.</ap>	
	<h>
		This action unconditionally adds a string to the export file.  No character padding will be performed on this value.
		<e>
      SetFileName("Export_+@BatchID")<br/>
      SetExtensionName(".txt")<br/>
      <b>Text("This line will appear in the export file.")</b>
    </e>
	</h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="Variable_ExportValue" qi="Exports the value assigned to a variable of the current object of the Document Hierarchy.">
	<ap>The name of the variable with the value you want to export.</ap>
	<h>
		Exports the value assigned to a variable of the current object of the Document Hierarchy.
		<e>
			<b>Variable_ExportValue("ID")</b><br/><br/>

			This action exports the value assigned to the ID property of the current object of the Document Hierarchy.
		</e>
	</h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="Variable_IsValue" qi="Checks to see if the parameter value matches the value assigned to a variable of the current object of the Document Hierarchy.">
	<ap>
		<b>1.</b> The name of the variable with the value you want to compare.<br/>
		<b>2.</b> The value you want to match with the variable's value.
	</ap>
	<h>
		Checks to see if the parameter value matches the value assigned to a variable of the current object of the Document Hierarchy.
		<e>
			<b>Variable_IsValue("Invoice,Yes")</b><br/><br/>

			This action returns <b>True</b> if the value of the current Page object's Invoice variable is "Yes".
		</e>
	</h>
  <lvl>Any level.</lvl>
  <ret>
    <b>True</b> if the variable's value matches the parameter's value. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="SetFixedLength" qi="Uses the Numeric value you enter as a parameter to establish a fixed length of a value exported from the current field.">
<ap>
	<i>Numeric</i> value indicating the field's length.
</ap>
<lvl>Any level.</lvl>
<ret>
  <b>False</b> if the parameter is not <i>Numeric</i>; Otherwise, <b>True.</b>
</ret>
<h>
  Uses the Numeric value you enter as a parameter to establish a fixed length of a value exported from the current field.<br/><br/>
  Use ResetFieldVariables to clear this setting.
  <e>
    <b>SetFixedLength("12")</b>
  </e>
</h>
  <see>ResetFieldVariables</see>
</ref>

<ref id="SetJustified" qi="Right-justifies or left-justifies a field's exported values.">
<ap>An upper case R(right-justified) or L(left-justified).</ap>
<h>
  Right-justifies or left-justifies a field's exported values according to the parameter you enter.<br/><br/>
  Use ResetFieldVariables to clear this setting.
  SetFixedLength must also be used to set the maximum length of the field.
  <e>
    SetFixedLength("10")<br/>
    <b>SetJustified("R")</b>
  </e>
</h>
<lvl>Any level.</lvl>
<ret>
  <b>False</b> if the parameter is not an "R" or "L". Otherwise, <b>True.</b>
</ret>
</ref>

<ref id="SetZeroFill" qi="Sets the ASCII 48 zero as the global filler value to be used to expand the current value of a field in a flat file, if the field's allowable length is greater than the length of its current export value.">
 <ap>None.</ap>
 <lvl>Any level.</lvl>
 <ret>Always <b>True.</b></ret>
 <h>
   Sets the ASCII 48 zero as the global filler value to be used to expand the current
   value of a field in a flat file, if the field's allowable length is greater than the length of its current export value.<br/><br/>
   SetFixedLength, FixedLenRJ or FixedLenLJ must also be used to set the maximum length of the field.
   Use ResetFieldVariables to clear this setting.
   <e>
     SetFixedLength("10")<br/>
     <b>SetZeroFill()</b>
     <br/>
     <br/>
     <b>Note</b> that the action specifies the use of the ASCII 48 "zero" filler.
   </e>
 </h>  
</ref>

<ref id="SetFill" qi="Sets the filler character to be used to expand the current value of a field in a flat file, if the field's allowable length is greater than the length of its current export value.">
  <ap>
    Single <i>String</i> character to be used as the filler value.
  </ap>
  <lvl>Any level.</lvl>
  <ret>
    <b>False</b> if more than one character is entered as a parameter. Otherwise, <b>True.</b>
  </ret>
  <h>
    Sets the filler character to be used to expand the current value of a field in a flat file, 
    if the field's allowable length is greater than the length of its current export value.<br/><br/>
    Note: When using SetFill, the action SetFixedLength, FixedLenRJ or FixedLenLJ must also
    be used to set the maximum length of the field.  You can use SetSpaceFill if you wish
    to make the filler character a space.
    Use ResetFieldVariables to clear this setting.
    <e>
      SetFixedLength("10")<br/>
      <b>SetFill("$")</b>
      <br/>
      This example sets the fill character to a $.
    </e>
  </h>
</ref>

<ref id="SetSpaceFill" qi="Specifies the use of the ASCII 32 space as the global filler value to be used to expand the current value of a field in a flat file, if the field's allowable length is greater than the length of its current export value.">
  <ap>None.</ap>
  <h>
    Specifies the use of the ASCII 32 space as the global filler value to be used to 
    expand the current value of a field in a flat file, if the field's allowable length is 
    greater than the length of its current export value.<br/><br/>
    If you use SetSpaceFill, the action SetFixedLength, FixedLenRJ or FixedLenLJ must also be
    used to set the maximum length of the field.
    Use ResetFieldVariables to clear this setting.
    <e>
      <b>SetSpaceFill()</b>
      <br/><br/>
      <b>Note</b> that the action specifies the use of the ASCII 32 "space" as the filler character.
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="SetIgnoreFieldStatus" qi="Assigns a Numeric value to the application's SetIgnoreStatus variable. Any field with this status cannot export data to an Export file or database."> 
  <ap>
    A <i>Numeric</i> value that represents the status of fields to be "ignored" by Export tasks.
  </ap>
  <h>
    This action establishes the status that determines if an Export task will
    export a field's value.  If the status of the field being exported matches this set value,
    the field will not be exported.<br/><br/>
    Use ResetFieldVariables to clear this setting.
    <e>
      <b>SetIgnoreFieldStatus("1")</b><br/><br/>
      This example ensures that runtime values for fields with a "1" status will not
      be added to an Export file or update an Export database. (Typically, "1" denotes a problem field.)
   </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    <b>False</b> if the parameter is not Numeric. Otherwise, <b>True.</b>
  </ret>
</ref>
  
 
<ref id="ResetFieldVariables" qi="Resets the variables of the bound Field object of the Document Hierarchy.">
	<ap>None.</ap>
	<h>
     This action resets some of the export settings that can be independently set by other actions.<br/><br/>
     The default field fill character is reset to a space.<br/>
     Field justification is reset to left.<br/>
     The ignore field status is reset to not ignore any fields based on the status.<br/>
     Fields are no longer set to a specific length.         
     <e>
       <b>ResetFieldVariables()</b>
     </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    SetFixedLength, SetJustified, SetZeroFill, SetFill, SetSpaceFill and SetIgnoreFieldStatus
  </see>
</ref>

<ref id="FixedLenLJ" qi="Exports a specified number of characters from a field's left end (left-justified.)"> 
  <ap>
    Two comma-separated values.<br/><br/>
    <b>1.</b> The field's name: this is the name of the corresponding <b>Field</b> object of the Document Hierarchy.<br/><br/>
    <b>2.</b> The number of characters that are to be exported, counting from the field's left end.
  </ap>  
  <h>
    This action is similar to the FixedLenRJ.  It exports a specified
    number of characters from a field's left end (left-justified.)    
    <e>
      <b>FixedLenLJ("Volume,8")</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if either parameter is invalid or if the action is called at the wrong level.
    Otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="FixedLenRJ" qi="Exports a specified number of characters from a field's right end (right-justified.)">
<ap>
	Two comma-separated values.<br/><br/>
  <b>1.</b> The field's name: this is the name of the corresponding <b>Field</b> object of the Document Hierarchy.<br/><br/>
  <b>2.</b> The number of characters that are to be exported, counting from the field's right end.
</ap>
<lvl>Page level.</lvl>
<ret>
  <b>False</b> if either parameter is invalid or if the action is called at the wrong level.  
  Otherwise, <b>True.</b>
</ret>
<h>
  Similar to the FixedLenLJ action, this action exports a specified number of characters from a field's right end (right-justified.)
  <e>
		<b>FixedLenRJ("InvoiceDate,12")</b><br/><br/>
    This exports 12 characters from the right end of the <i>InvoiceDate</i> field.
	</e>
</h>
</ref>

<ref id="Filler" qi="Adds a string of identical filler characters to the Export.">
  <ap>
    Two comma-separated values. The first is a number indicating the total length in characters of the filler.
    The second parameter is the filler's character.<br/><br/>
    The second parameter is optional: if you do not enter a value, the action will use the most 
    recent Global character setting.
  </ap>
  <h>
    Adds a single filler character to the Export, repeated by the number of times indicated in the
    first input parameter.  The second parameter cannot be a space.  The filler string is written
    regardless of the data in the current field.  If you wish to
    use a space as a filler character, use SetSpaceFill
    and then call Filler without the optional second parameter.
    <e>
      <b>Filler("12,n")</b><br/><br/>
      The action in the example fills the current field with 12 instances of the character "n".
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    <b>False</b> if the first parameter is not numeric or if the second parameter is more than 1 character.
    Otherwise, <b>True.</b>
  </ret>
	</ref>

  <ref id="SetExportFileEncodingAsASCII">
    <ap>
      If set to "True", then Export files will be created with ASCII encoding.
      "False" creates files with UNICODE encoding and is the default.<br/>
      Smart parameters are supported.
    </ap>
    <h>
      Determines if the Export file is created with ASCII or UNICODE encoding.
      A parameter value of "True" will create files with ASCII format.
      "False" will create files with UNICODE format.<br/><br/>

      <b>
      NOTE:
      This action must be called before any actions that physically write to and create the Export file.  If not called,
      then the file will be created with UNICODE encoding.
      </b>
      <br/><br/>
      <e>
        <b>SetExportFileEncodingAsASCII("True")</b><br/>
        ExportAllFields()<br/><br/>

        This example will create files in ASCII format.<br/><br/>

        <b>SetExportFileEncodingAsASCII("False")</b><br/>
        ExportAllFields()<br/><br/>
        
        This example will create the file in UNICODE format. 
      </e>
    </h>
    <lvl>Any.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>
</help>
</rrx>
<rrx namespace="ExportDB" src="c:\datacap\RRS\ExportDB.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="AddRecord" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim sSQL]]>
<![CDATA[
]]>
<![CDATA[	Dim sClm]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	AddRecord = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Add Record...")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("oConn.State = " & oConn.State)	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If oConn.State = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Connection is Closed. Trying to open...")]]>
<![CDATA[
]]>
<![CDATA[		If Not ExportOpenConnection(bInteractive, bDebug, g_sDSN) Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Failed to open connection. Setting status to abort.")]]>
<![CDATA[
]]>
<![CDATA[			bAbort = True]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If			]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sClm = GetColumnNames]]>
<![CDATA[
]]>
<![CDATA[	If Len(sClm) <> 0 Then 	]]>
<![CDATA[
]]>
<![CDATA[		sSQL = "INSERT INTO " & g_sTableName & " (" & GetColumnNames() & ") VALUES (" & GetColumnValues() & ");"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Modify sSQL if DB type is Oracle - rrunner.rrx 7.6.42 function]]>
<![CDATA[
]]>
<![CDATA[    sSQL = ModifySQLByDBType(oConn,sSQL)]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sSQL)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Call oConn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Post Execute")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If DBErrTrap(oConn,"ADD Record")= False then ]]>
<![CDATA[
]]>
<![CDATA[			AddRecord = True]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Err.Clear]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		dictFldColumn.RemoveAll()]]>
<![CDATA[
]]>
<![CDATA[	Else ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No values were found when building the SQL. INSERT was bypassed.")]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
	</g>
</af>
<af name="ExportCloseConnection" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[' CloseConnection removed.  Replaced by ExportCloseConnection]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim i, sError]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ExportCloseConnection = True	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Close Connection...")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("oConn.State = " & oConn.State)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CloseDB()]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	If cstr(oConn.State) <> "0" Then ]]>
<![CDATA[
]]>
<![CDATA[    ' If the connection is already closed, just log the condition but still return true.]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(sError)]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("CloseConnection returns " & ExportCloseConnection )]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[	Call ConnErrHandler("Function ExportCloseConnection")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function ExportCloseConnection") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ExportFieldToColumn" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim sColumnName]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sField]]>
<![CDATA[
]]>
<![CDATA[	Dim sStyle]]>
<![CDATA[
]]>
<![CDATA[  Dim sQuotChar]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ExportFieldToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & ",,",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sField = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[	sColumnName = Trim(astrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	sStyle = Trim(aStrParam(2))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sValue = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sStyle = "1" Then]]>
<![CDATA[
]]>
<![CDATA[		If CheckColumnName(sColumnName) = False Then ]]>
<![CDATA[
]]>
<![CDATA[			ExportFieldToColumn= False]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If sStyle = "2" Then ]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = ""   'no quotes]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = "'"]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	If IsAlive(CurrentObj) Then ]]>
<![CDATA[
]]>
<![CDATA[		  Writelog(Space(5) & "Finding Value of Field:" & sField)]]>
<![CDATA[
]]>
<![CDATA[		  Set oFld = CurrentObj.FindChild(sField)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  		If Not(oFld Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[        sValue=CheckDict(oFld)]]>
<![CDATA[
]]>
<![CDATA[	  		Writelog(Space(5) & "Field Value is :'" & sValue & "' ")]]>
<![CDATA[
]]>
<![CDATA[		  	ExportFieldToColumn= True       ]]>
<![CDATA[
]]>
<![CDATA[		  Else]]>
<![CDATA[
]]>
<![CDATA[			  Writelog(Space(5) & "Field Object Not Found.")]]>
<![CDATA[
]]>
<![CDATA[			  Writelog(Space(5) & "Current Obj is " & CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			  ExportFieldToColumn = False]]>
<![CDATA[
]]>
<![CDATA[		  End If]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "There is No Current Object.")]]>
<![CDATA[
]]>
<![CDATA[		ExportFieldToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	If (sStyle="2") AND sValue = "" then]]>
<![CDATA[
]]>
<![CDATA[    Call dictFldColumn.Add(sColumnName, "NULL") ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sValue = replace(sValue,"'","''")]]>
<![CDATA[
]]>
<![CDATA[	  Call dictFldColumn.Add(sColumnName, sQuotChar & sValue & sQuotChar) ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="ExportPropertyToColumn" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim sColumnName]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sProperty]]>
<![CDATA[
]]>
<![CDATA[	Dim sStyle]]>
<![CDATA[
]]>
<![CDATA[  Dim sQuotChar]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ExportPropertyToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & ",,",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sProperty = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[	sColumnName = Trim(astrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	sStyle = Trim(aStrParam(2))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sStyle = "1" Then]]>
<![CDATA[
]]>
<![CDATA[		If CheckColumnName(sColumnName) = False Then ]]>
<![CDATA[
]]>
<![CDATA[			ExportPropertyToColumn = False]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sStyle = "2" Then ]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = ""   'no quotes]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = "'"]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'If sStyle = "3" Then ]]>
<![CDATA[
]]>
<![CDATA[    'Do Nothing --> Null value flag ]]>
<![CDATA[
]]>
<![CDATA[  'End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(CurrentObj) Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "Finding Property Value")]]>
<![CDATA[
]]>
<![CDATA[		oVal = CurrentObj.Variable(sProperty)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Not(oVal = "") Then	 ]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Field Value is :'" & oVal & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			ExportPropertyToColumn= True]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Property Value Not Found.")]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Current Obj is " & CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			ExportPropertyToColumn= False]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "There is No Current Object.")]]>
<![CDATA[
]]>
<![CDATA[		ExportPropertyToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (sStyle="2" OR sStyle="3") AND oVal = "" then]]>
<![CDATA[
]]>
<![CDATA[    Call dictFldColumn.Add(sColumnName, "NULL") ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sValue = replace(oVal,"'","''")]]>
<![CDATA[
]]>
<![CDATA[	  Call dictFldColumn.Add(sColumnName, sQuotChar & sValue & sQuotChar) ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="ExportToColumn" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim sColumnName]]>
<![CDATA[
]]>
<![CDATA[	Dim sCheckColumn]]>
<![CDATA[
]]>
<![CDATA[  Dim sStyle]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ExportToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sColumnName = Trim(astrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	sStyle = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	sValue = ""]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sStyle = "1" Then]]>
<![CDATA[
]]>
<![CDATA[		If CheckColumnName(sColumnName) = False Then ]]>
<![CDATA[
]]>
<![CDATA[			ExportToColumn = False]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[  If sStyle = "2" Then ]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = ""   'no quotes]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = "'"]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'If sStyle = "3" Then ]]>
<![CDATA[
]]>
<![CDATA[    'Do Nothing --> Null value flag ]]>
<![CDATA[
]]>
<![CDATA[  'End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If IsAlive(CurrentObj) Then ]]>
<![CDATA[
]]>
<![CDATA[		sValue = replace(CheckDict(CurrentObj),"'","''")]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "Field Value is :'" & sValue & "' ")		]]>
<![CDATA[
]]>
<![CDATA[    If len(sValue)>0 then ExportToColumn = True]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (sStyle="2" OR sStyle="3") AND sValue = "" then]]>
<![CDATA[
]]>
<![CDATA[    sValue="NULL" ]]>
<![CDATA[
]]>
<![CDATA[    ExportToColumn = True]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call dictFldColumn.Add(sColumnName, sQuotChar & sValue & sQuotChar) ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="ExportOpenConnection" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ' OpenConnection was replaced by ExportOpenConnection.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On error resume next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim i]]>
<![CDATA[
]]>
<![CDATA[  Dim sError]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	oConn.Errors.Clear]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ExportOpenConnection = True	]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" and strParam<>sSmartParam Then ]]>
<![CDATA[
]]>
<![CDATA[    'attempt to decrypt value]]>
<![CDATA[
]]>
<![CDATA[    bRes = [securecall]sSmartParam,strParam[/securecall]   ]]>
<![CDATA[
]]>
<![CDATA[    If bRes=False Then Writelog("Value not Decrypted.")]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter parsing. Using the original parameter string.") ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	strParam = FormatADOConn(strParam)	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If oConn.State = 1 Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Connection is already Open, Function returns TRUE")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oConn.Open(strParam)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("oConn.State = " & oConn.State)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If oConn.State = 1 Then ExportOpenConnection = True Else ExportOpenConnection = False : WriteLog(sError)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ExportOpenConnection returns " & ExportOpenConnection )]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[	Call ConnErrHandler("Function ExportOpenConnection")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function ExportOpenConnection")  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetTableName" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	SetTableName = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_sTableName = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Trim(aStrParam(1))="1" Then]]>
<![CDATA[
]]>
<![CDATA[		SetTableName = CheckTableName(g_sTableName)   ]]>
<![CDATA[
]]>
<![CDATA[		If SetTableName = True then Writelog("Table Name '" & g_sTableName & "' is valid.")]]>
<![CDATA[
]]>
<![CDATA[		If SetTableName = False then Writelog("Table Name '" & g_sTableName & "' is invalid.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		SetTableName = True]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
	</g>
</af>
<af name="ExportBatchIDToColumn" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sColumnName]]>
<![CDATA[
]]>
<![CDATA[	Dim sCheckColumn]]>
<![CDATA[
]]>
<![CDATA[	Dim sStyle]]>
<![CDATA[
]]>
<![CDATA[  Dim sQuotChar]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue	]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	ExportBatchIDToColumn = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sColumnName = Trim(strParam)]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sColumnName = Trim(astrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	sStyle = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sStyle = "1" Then]]>
<![CDATA[
]]>
<![CDATA[		If CheckColumnName(sColumnName) = False Then ]]>
<![CDATA[
]]>
<![CDATA[			ExportBatchIDToColumn = False]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  If sStyle = "2" Then ]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = ""   'no quotes]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = "'"]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'If sStyle = "3" Then ]]>
<![CDATA[
]]>
<![CDATA[    'Do Nothing --> Null value flag ]]>
<![CDATA[
]]>
<![CDATA[  'End if  ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  If (sStyle="2" OR sStyle="3") AND oVal = "" then]]>
<![CDATA[
]]>
<![CDATA[    Call dictFldColumn.Add(sColumnName, "NULL") ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sValue = replace(DCO.ID,"'","''")]]>
<![CDATA[
]]>
<![CDATA[	  Call dictFldColumn.Add(sColumnName, sQuotChar & sValue & sQuotChar) ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ExportBatchIDToColumn = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ExportSmartParamToColumn" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim sColumnName]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sProperty]]>
<![CDATA[
]]>
<![CDATA[	Dim sStyle]]>
<![CDATA[
]]>
<![CDATA[    Dim sQuotChar]]>
<![CDATA[
]]>
<![CDATA[    Dim sValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ExportSmartParamToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & ",,",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sProperty = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[	sColumnName = Trim(astrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	sStyle = Trim(aStrParam(2))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sStyle = "1" Then]]>
<![CDATA[
]]>
<![CDATA[		If CheckColumnName(sColumnName) = False Then ]]>
<![CDATA[
]]>
<![CDATA[			ExportSmartParamToColumn = False]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sStyle = "2" OR sStyle = "4" Then ]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = ""   'no quotes]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = "'"]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ExportSmartParamToColumn= True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'If sStyle = "3" Then ]]>
<![CDATA[
]]>
<![CDATA[    'Do Nothing --> Null value flag ]]>
<![CDATA[
]]>
<![CDATA[  'End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(CurrentObj) Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "Finding Property Value")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If sStyle = "4" Then  ' Current DATE/Time]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Current Date/Time")]]>
<![CDATA[
]]>
<![CDATA[      dtNow = Now()]]>
<![CDATA[
]]>
<![CDATA[      If (IsDBOracleEx(""))  then]]>
<![CDATA[
]]>
<![CDATA[          FormattedDateStamp = Right("00" & Month(dtNow),2) & "-" & Right("00" & Day(dtNow),2) & "-" & Year(dtNow) ' mm-dd-yyyy]]>
<![CDATA[
]]>
<![CDATA[          FormattedDateStamp = FormattedDateStamp & " " & Right("00" & Hour(dtNow),2) & ":" & Right("00" & Minute(dtNow),2) & ":" & Right("00" & Second(dtNow),2) ' hh:mm:ss]]>
<![CDATA[
]]>
<![CDATA[          oVal = "to_date('" & FormattedDateStamp & "','mm-dd-yyyy HH24:MI:SS')" ]]>
<![CDATA[
]]>
<![CDATA[          ' should include hhmmss YYYY/MM/DD HH24:MI:SS]]>
<![CDATA[
]]>
<![CDATA[		  Else]]>
<![CDATA[
]]>
<![CDATA[          'NON-ORACLE VERSION:	]]>
<![CDATA[
]]>
<![CDATA[          if IsDBSQLEx("") or IsDBDB2Ex("") then]]>
<![CDATA[
]]>
<![CDATA[            'SQL Server or DB2 date/time:	]]>
<![CDATA[
]]>
<![CDATA[            oVal = "'" & Year(Now) & "-" & Right("00" & Month(Now),2) & "-" & Right("00" & Day(Now),2) ' yyyy-MM-dd]]>
<![CDATA[
]]>
<![CDATA[            oVal = oVal & " " & Right("00" & Hour(dtNow),2) & ":" & Right("00" & Minute(dtNow),2) & ":" & Right("00" & Second(dtNow),2) & "'" '  HH:mm:ss]]>
<![CDATA[
]]>
<![CDATA[          else]]>
<![CDATA[
]]>
<![CDATA[            'Access date/tome:	]]>
<![CDATA[
]]>
<![CDATA[            oVal = "'" & CStr(dtNow) & "'"]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[      End If ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    Else ' not date/time (style <> 4), regular Smart Param parsing]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		  oVal = MetaWord(sProperty)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Not(oVal = "") Then	 ]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Found Value is :'" & oVal & "' ")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Smart Parameter Value Not Found.")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "There is No Current Object.")]]>
<![CDATA[
]]>
<![CDATA[		ExportSmartParamToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (sStyle="2" OR sStyle="3" OR sStyle="4") AND oVal = "" then]]>
<![CDATA[
]]>
<![CDATA[    Call dictFldColumn.Add(sColumnName, "NULL") ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    if (sStyle = "4") then]]>
<![CDATA[
]]>
<![CDATA[      sValue = oVal]]>
<![CDATA[
]]>
<![CDATA[    else]]>
<![CDATA[
]]>
<![CDATA[      sValue = replace(oVal,"'","''")]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  Call dictFldColumn.Add(sColumnName, sQuotChar & sValue & sQuotChar) ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="ExportNodeXMLToColumn" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim sColumnName]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sProperty]]>
<![CDATA[
]]>
<![CDATA[	Dim sStyle]]>
<![CDATA[
]]>
<![CDATA[  Dim sQuotChar]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ExportNodeXMLToColumn= False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    aStrParam = Split(strParam & ",,",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    sProperty = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[    sColumnName = Trim(astrParam(1))]]>
<![CDATA[
]]>
<![CDATA[    sStyle = Trim(aStrParam(2))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	  If sStyle = "1" Then]]>
<![CDATA[
]]>
<![CDATA[		  If CheckColumnName(sColumnName) = False Then ]]>
<![CDATA[
]]>
<![CDATA[			  ExportNodeXMLToColumn = False]]>
<![CDATA[
]]>
<![CDATA[			  Exit Function]]>
<![CDATA[
]]>
<![CDATA[		  End if ]]>
<![CDATA[
]]>
<![CDATA[	  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    sQuotChar = "'"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ExportNodeXMLToColumn= True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    oval=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "Finding Node Value")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    Set oNode = DCONav(sProperty)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    If Not oNode is Nothing then]]>
<![CDATA[
]]>
<![CDATA[        oVal = oNode.xml]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[		If Not(oVal = "") Then	 ]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Found Value is :'" & oVal & "' ")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(5) & "Smart Parameter Value Not Found.")		]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    If (sStyle="2" OR sStyle="3") AND oVal = "" then]]>
<![CDATA[
]]>
<![CDATA[      Call dictFldColumn.Add(sColumnName, "NULL") ]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      sValue = replace(oVal,"'","''")]]>
<![CDATA[
]]>
<![CDATA[	    Call dictFldColumn.Add(sColumnName, sQuotChar & sValue & sQuotChar) ]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************
' help.xml for Export 

' Licensed Materials - Property of IBM
' â€œRestricted Materials of IBMâ€
' 5725-C15 5725-C69
'
' Â© Copyright IBM Corp. 1994, 2014 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************
]]>
  
	
<ref id="AddRecord" qi="Inserts assembled data into the database table specified by a previous SetTableName action.">
  <ap>None.</ap>
  <h>
    Inserts assembled data into the database table specified by a previous <b>SetTableName</b> action.<br/><br/>

    <b>Important.</b> This action must be placed after earlier actions that gather data, open the database, and access the correct table.
    <e>
      SetTableName("Invoice")<br/>
      ExportFieldToColumn("VendorID,db_Vendor")<br/>
      ExportFieldToColumn("Number,db_Number")<br/>
      ExportFieldToColumn("Total,db_Total")<br/>
      <b>AddRecord()</b><br/><br/>

      This ExportDB rule applies to a Page object of the Document Hierarchy.<br/><br/>

      The actions open the database and direct the rule's attention to the Invoice table. 
      The rule then sets up a record with three values - Vendor ID, Invoice Number and Total. 
      Afterwards, the AddRecord action updates the table with new information. <br/><br/>
      
      Note: A return of False means the record may not have been successfully exported, 
      and needs to be followed by a "failure check" rule that typically would call 
      SetTaskStatus(0) (or the rrunner action rr_AbortBatch) to ensure that the batch aborts.
    </e>
  </h>
  <lvl>All, but generally used at the Page or Field level.</lvl>
  <ret>
    <b>False</b> if there is no connection to the database; if an error occurs when the action
    attempts to add the record to the database; or if a SetTableName action was not previously used.<br/><br/>
    Otherwise, <b>True</b>.
  </ret>
	<see>SetTableName, ExportFieldToColumn</see>
</ref>
	
<ref id="ExportCloseConnection" qi="Closes an open connection to your Export database.">
  <ap>None.</ap>
  <h>
    Closes an open connection to the previously opened Export database.<br/><br/>

    Usually, this action is placed in a RuleSet that is separate from the RuleSet that opens 
    the connection and stores the data.<br/><br/>

    For example this action could be placed into a RuleSet called ExportDBClose, 
    and attached to a batch level close event which executes after all data has been 
    exported from the batch to the specified database.
    <e>
      <b>ExportCloseConnection()</b><br/><br/>

      This action closes the previously opened connection to the Export database.<br/><br/>

      This action is usually part of a separate RuleSet that prevents the need to repeatedly
      open the connection to the Export database. (You can open the connection once in the first
      RuleSet, export data from all documents and pages in the batch, then close the connection once
      in the second RuleSet.)
    </e>
  </h>
  <lvl>All, but generally used as part of a separate RuleSet at the Batch level.</lvl>
  <ret>
    <b>True,</b> even if the connection is already closed.
  </ret>
  <see>ExportOpenConnection</see>
</ref>
 
	
<ref id="ExportFieldToColumn" qi="A page-level action that extracts the captured value of a Field object from the Data file of the current page, and specifies its target location within a table of the Export database.">
<ap>
  Three comma-separated values:<br/><br/>
  <b>1.</b> The name of the field whose value will be stored in the column.<br/><br/>

  <b>2.</b> The name of the database column that will hold the value.<br/><br/>

  <b>3.</b> Optional: Can be set to  the numerical value of 1, 2, or 3.  If this parameter is not specified, 
  quotes will be placed around the value in the SQL query to update the table.<br/><br/>
  
  Setting the value to 1 causes this action to return False if the Table name is invalid; 
  otherwise the error will not be discovered until the action that performs the DB insert call, 
  such as an AddRecord action, is called.  This value would typically only be 
  used in a development environment as it will increase processing time.<br/><br/>
  
  Setting this value to 2 allows NULL column values and inserts no quotes around values 
  (for numeric) in the SQL query to update the database.<br/><br/>
  
  Setting the value to 3 allows NULL and if the column value is not NULL, 
  the column value will be surrounded in quotes in the SQL query to update the database.
</ap>
  <h>
    This is a page-level action that extracts the captured value of a Field object from the
    Data file of the current page, and specifies its target location within a table of the Export database.<br/><br/>

    Within a rule, this action should run before an AddRecord action, which commits the data
    to the database.
    <e>
      SetTableName("Export_Results")<br/>
      <b>
      ExportFieldToColumn("VendorID,db_Number,2")<br/>
      ExportFieldToColumn("Date,db_Date")<br/>
      ExportFieldToColumn("Total,db_Total")
      </b><br/>
      AddRecord()<br/><br/>

      This action exports the captured value of three Field objects from the Data file of the current page,
      to corresponding columns of the Export_Results table, within the open Export database. It also
      provides the action with an optional <i>Style</i> value.<br/><br/>

      <b>Important.</b> Make sure you use the ExportOpenConnection action to establish a connection
      to your Export database.  This is usually accomplished by a rule at the Batch level.
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if:<br/>
    <b>1.</b> There is no connection to the database.<br/>
    <b>2.</b> The database column specified as a parameter does not exist.<br/>
    <b>3.</b> The Field object identified by the parameter does not exist.<br/>
    <b>4.</b> A SetTableName action was not used previously.<br/><br/>

    Otherwise, <b>True.</b>
  </ret>
  <see>SetTableName, ExportToColumn</see>
</ref>

<ref id="ExportPropertyToColumn" qi="Adds the value of a property (variable) of the selected object to a column of the Export database">
  <ap>
    Three comma-separated values:<br/><br/>

    <b>1.</b> The property name whose value will be stored in the column.<br/><br/>

    <b>2.</b> The name of the database column that will hold the value.<br/><br/>

    <b>3.</b> Optional: Can be set to  the numerical value of 1, 2, or 3.  <br/><br/>
    
    If this parameter is not specified, quotes will be placed around the value in the SQL query to update the table.<br/><br/>
    Setting the value to 1 causes this action to return False if the Table name is invalid; 
    otherwise the error will not be discovered until the action that performs the DB 
    insert call, such as an AddRecord action, is called.  This value would 
    typically only be used in a development environment as it will increase processing time.<br/><br/>
    
    Setting this value to 2 allows NULL column values and inserts no quotes around values 
    (for numeric) in the SQL query to update the database.<br/><br/>
    
    Setting the value to 3 allows NULL and if the column value is not NULL, 
    the column value will be surrounded in quotes in the SQL query to update the database.
    
  </ap>
  <h>
    Adds the value of a property (variable) of the selected object to a column of the Export database.
    <e>
      SetTableName("Export_Results")<br/>
      ExportFieldToColumn("VendorID,db_Number")<br/>
      <b>ExportPropertyToColumn("Status,db_PageStatus,2")</b><br/>
      ExportFieldToColumn("Total,db_Total")<br/>
      AddRecord()<br/><br/>

      This sequence updates the db_PageStatus column of the Export_Results table with the value of
      the selected object's Status property. It also uses the optional third parameter to define
      a <i>Style</i> for the action.
    </e>
  </h>
  <lvl>All, but generally used at the Page or Field level.</lvl>
  <ret>
    <b>False</b> if:<br/><br/>
    <b>1.</b> There is no connection to the Export database.<br/>
    <b>2.</b> The column of the database does not exist.<br/>
    <b>3.</b> The property (variable) identified by the parameter does not exist.<br/>
    <b>4.</b> A SetTableName action was not used previously.<br/><br/>

    Otherwise, <b>True.</b>
  </ret>
  <see>ExportToColumn, ExportFieldToColumn, ExportBatchIDToColumn</see>
</ref>
	
<ref id="ExportToColumn" qi="A field-level action that exports the captured value of the current Field object from the page's Data file to a target column within a previously designated table of an open Export database.">
<ap>
  Two comma-separated values:<br/><br/>

  <b>1.</b> The name of the database column that will hold the value of the current field.<br/><br/>

  <b>2.</b> Optional: Can be set to  the numerical value of 1, 2, or 3.  <br/>
  
  If this parameter is not specified, quotes will be placed around the value in the SQL query to update the table.<br/><br/>
  Setting the value to 1 causes this action to return False if the Table name is invalid; 
  otherwise the error will not be discovered until the action that performs the DB insert call, 
  such as an AddRecord action, is called.  This value would typically only be used 
  in a development environment as it will increase processing time.<br/><br/>
  
  Setting this value to 2 allows NULL column values and inserts no quotes around values (for numeric) in the SQL query to update the database.<br/><br/>
  
  Setting the value to 3 allows NULL and if the column value is not NULL, the column value will be 
  surrounded in quotes in the SQL query to update the database.

</ap>
	<h>
    This field-level action exports the captured value of the current Field object from the page's 
    Data file to a target column within a previously designated table of an open Export database. 
    Optionally, it can assign a <i>Style</i> to the action.
		<e>
      Batch Level:<br/>
      ExportOpenConnection("@APPVAR(values/dsn/exportdb:cs")<br/>
      SetTableName("Export_Results")<br/><br/>

      Current field:<br/>
      <b>ExportToColumn("db_Date,3")</b><br/><br/>

      Last Field:<br/>
      AddRecord()<br/><br/>

      This example exports the captured value of the Field object to which the rule applies, 
      from the Data file of the current page to the db_Date column of the Export_Results table, 
      within the Export database. 
      It also uses the second, optional parameter value to assign a <i>Style</i> to the action.
		</e>	
	</h>
  <lvl>Field level only.</lvl>
  <ret>
    <b>False</b> if:<br/>
    <b>1.</b> There is no connection to the database.<br/>
    <b>2.</b> The column identified by the parameters does not exist.<br/>
    <b>3.</b> A SetTableName action was not previously used.<br/><br/>

    Otherwise, <b>True.</b>
  </ret>
  <see>ExportFieldToColumn, ExportPropertyToColumn</see>
</ref>
	
<ref id="ExportOpenConnection" qi="Opens a connection to the database specified as the parameter.">
  <ap>
    The Connection String of the target Export database.
    Use smart parameters to avoid clear text passwords in your application.
  </ap>
  <h>
    Opens a connection to the database specified as the parameter.<br/><br/>

    A rule containing this action can apply to any object of the Document Hierarchy, but it is most often used at the batch level.<br/><br/>
    <e>
      <b>ExportOpenConnection("@APPVAR(values/dsn/exportdb:cs)")</b><br/><br/>

      <b>Note:</b> This action must come before any other ExportDB actions.  This example
      uses smart parameters to obtain the connection string from the application service
      where the custom connection string key "exportdb" has been created in the "Custom Values" tab.
      It provides a single location for the connection string and security for passwords.<br/><br/>

      <b>Note:</b> If the action is establishing a connection with an Oracle database,
      or a SQL Server database using SQL Server Authentication, be sure to expand the DSN parameter
      by adding the correct Provider, user ID and Password.  For example:<br/><br/>

      <b>Oracle</b><br/>
      ExportOpenConnection("PROVIDER=ODBCORACLE;DSN=1040Look;CATALOG=;DBNTA=;UID=Admin;PWD=Admin;")<br/><br/>

      <b>SQL Server Authentication</b><br/>
      ExportOpenConnection("PROVIDER=ODBCMSSQL;DSN=1040Look;CATALOG=;DBNTA=;UID=Admin;PWD=Admin;")<br/><br/>

      <b>Note:</b> Although the Oracle and SQL examples show the connection string, it is recommended that a smart 
      parameter is used to obtain the connection string from the application service, as shown in the first example,
      to provide password security and application portability.

    </e>
  </h>
  <lvl>All, but generally used at the Batch level.</lvl>
  <ret>
    <b>True</b> if the connection opens. Otherwise, <b>False.</b>
  </ret>
  <see>
    ExportCloseConnection
  </see>
</ref>


<ref id="SetTableName" qi="Sets the name of the table in your database to which the data is to be exported.">
  <ap>
    Two comma separated parameters:<br/><br/>

    <b>1.</b> The name of the database table where the exported data will be inserted.<br/><br/>

    <b>2.</b> Optional: If the numeric value of 1 is specified, the action will immediately check the database to
    confirm that the supplied table name is valid.  If the table name is not valid, SetTableName will return False.
    Note that this value causes an extra database call so it is typically specified only during development,
    not in a production system as it will increase the number of database calls and running time.<br/><br/>

    If the second parameter is not specified, this action will always return true.
    If the specified table name is in valid, an error will be returned when the current row is inserted to the database on the next AddRecord call.
  </ap>
  <h>Sets the name of the table in your database to which the data is to be exported.  This action needs to be used before the AddRecord action.
		<e><b>SetTableName(Export_Results,1)</b><br/>
		<scr>ExportFieldToColumn(MyDate, db_Date)</scr><br/>
		<scr>AddRecord()</scr> 
		</e>
	</h>
  <lvl>All.</lvl>
  <ret>
    Returns <b>False</b> only if the first parameter contains an invalid table name and a value of 1 is specified as a second parameter.  
    Otherwise this action always returns <b>True.</b>
  </ret>
  <see>AddRecord</see>
</ref>
	
<ref id="ExportBatchIDToColumn" qi="Exports the current Batch ID to the database column specified by the parameter.">
<ap>
  Three comma-separated values:<br/><br/>

  <b>1.</b> The name of the database column that will hold the value.<br/><br/>
  
  <b>2.</b> Optional: Can be set to  the numerical value of 1, 2, or 3.<br/><br/>
  
  If this parameter is not specified, quotes will be placed around the value in the SQL query to update the table.<br/><br/>
  
  Setting the value to 1 causes this action to return False if the Table name is invalid;
  otherwise the error will not be discovered until the action that performs the DB insert call,
  such as an AddRecord action, is called.  This value would typically
  only be used in a development environment as it will increase processing time.<br/><br/>
  
  Setting this value to 2 allows NULL column values and inserts no quotes around values (for numeric) in the SQL query to update the database.<br/><br/>
  
  Setting the value to 3 allows NULL and if the column value is not NULL, 
  the column value will be surrounded in quotes in the SQL query to update the database.
  <br/><br/>
</ap>

  <h>
    Exports the current Batch ID to the database column specified by the parameter. The action also has an optional <i>Style</i> parameter with two values.
    <e>
      SetTableName("Export_Results")<br/>
      <b>ExportBatchIDToColumn("db_BatchID,1")</b><br/>
      ExportFieldToColumn("Date,db_Date")<br/>
      ExportFieldToColumn("Total,db_Total")<br/>
      AddRecord()
    </e>
  </h>
  <lvl>All, but generally at the Page or Field level.</lvl>
  <ret>
    <b>False</b> if the second parameter is set to "1" and the parameters do not identify a
    valid database column. Otherwise, <b>True.</b>
  </ret>
  <see>AddRecord, ExportFieldToColumn, ExportPropertyToColumn</see>
</ref>

<ref id="ExportSmartParamToColumn" qi="Adds the evaluated value of a smart parameter to a column of the Export database">
  <ap>
    Three comma-separated values:<br/><br/>

    <b>1.</b> A smart parameter that specifies the value to be stored into the column.<br/><br/>

    <b>2.</b> The name of the database column that will hold the value.<br/><br/>

    <b>3.</b> Optional: Can be set to  the numerical value of 1, 2, or 3.<br/><br/>
    
    If this parameter is not specified, quotes will be placed around the value in the SQL query to update the table.<br/><br/>

    Setting the value to 1 causes this action to return False if the Table name is invalid; 
    otherwise the error will not be discovered until the action that performs the DB insert call, 
    such as an AddRecord action, is called.  This value would typically only be used 
    in a development environment as it will increase processing time.<br/><br/>
    
    Setting this value to 2 allows NULL column values and inserts no quotes 
    around values (for numeric) in the SQL query to update the database.<br/><br/>
    
    Setting the value to 3 allows NULL and if the column value is not NULL, 
    the column value will be surrounded in quotes in the SQL query to update the database.<br/><br/>
</ap>
  <h>
    Using the database opened by an earlier ExportDB action, this action will 
    store a value into the specified column for the current row.  
    The action allows the input value to be specified with a smart parameter.<br/><br/>
    <e>
      <b>ExportSmartParamToColumn("@P\MyField.TYPE,EXPDBCOLUM")</b>
    </e>
  </h>
  <lvl>All, but generally at the Page or Field level.</lvl>
  <ret>
    <b>False</b> if:<br/><br/>
    <b>1.</b> There is no connection to the database.<br/>
    <b>2.</b> The column identified by the parameter does not exist.<br/>
    <b>3.</b> A <b>SetTableName</b> action was not previously used.<br/><br/>
    Otherwise, <b>True.</b>
  </ret>  
</ref>
  
<ref id="ExportNodeXMLToColumn" qi="Exports the value of the XML property of the bound object (node) of the Document Hierarchy to a column of the Export database.">
  <ap>
    Three comma-separated values:<br/><br/>

    1. The smart parameter path to the bound object of the Document Hierarchy. 
    This object's XML property will be added to a designated column of the Export database.<br/><br/>

    2. The String value of the name of the target column in the Export database. 
    The action will add the value of the calling object's XML property to this column.<br/><br/>

    3. Optional: Can be set to the numerical value of 1 or 3.  <br/><br/>
    
    If this parameter is not specified, quotes will be placed around the value in the SQL query to update the table.<br/><br/>
    
    Setting the value to 1 causes this action to return False if the Table name is invalid; 
    otherwise the error will not be discovered until the action that performs the 
    DB insert call, such as an AddRecord action, is called.  This value would typically 
    only be used in a development environment as it will increase processing time.<br/><br/>
          
    Setting the value to 3 allows NULL and if the column value is not NULL, the column value
    will be surrounded in quotes in the SQL query to update the database.
  </ap>
  <h>
    This action exports the value of the <b>XML</b> property of the bound object (node)
    of the Document Hierarchy to a column of the Export database.<br/>
    <br/>
    <e>
      <b>ExportNodeXMLToColumn("@P\MyField,MYDBCOLUM")</b>
    </e>
  </h>
  <lvl>All, but generally at the Page or Field level.</lvl>
  <ret>
    <b>False</b> if:<br/>
    <br/>
    <b>1.</b> There is no connection to the database.<br/>
    <b>2.</b> The column identified by the parameter does not exist.<br/>
    <b>3.</b> A <b>SetTableName</b> action was not previously used.<br/>
    <b>4.</b> The smart parameter path does not point to a valid object of the Document Hierarchy.<br/><br/>
    Otherwise, <b>True.</b>
  </ret>
</ref>
</help>
</rrx>
<rrx namespace="ExportXML" src="c:\datacap\RRS\ExportXML.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<af name="xml_SaveFile" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call XMLExport.CommitNodes()]]>
<![CDATA[
]]>
<![CDATA[	xml_SaveFile = XMLExport.SaveXMLFile()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Action xml_SaveFile")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="xml_SetExportPath" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	xml_SetExportPath = XMLExport.SetExportPath(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Action xml_SetExportPath")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="xml_SetFileName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	xml_SetFileName = XMLExport.SetFileName(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Action xml_SetFileName")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="xml_NewNode" access="public" bInter="bInter" bDebug="bDebug" strParam="Strparam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim NewNodeID]]>
<![CDATA[
]]>
<![CDATA[	Dim ParentNodeID]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & ",",",")        ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	NewNodeID = metaword(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	ParentNodeID = metaword(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	xml_NewNode = XMLExport.AddNode(NewNodeID,ParentNodeID)	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Action xml_NewNode")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="xml_SetNodeValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sNodeID]]>
<![CDATA[
]]>
<![CDATA[	Dim sFindValue]]>
<![CDATA[
]]>
<![CDATA[	Dim sNodeValue]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = split(strparam & "," & CurrentObj.Type ,",")]]>
<![CDATA[
]]>
<![CDATA[	sNodeID = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	sFindValue = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sNodeValue = MetaWord(sFindValue)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	xml_SetNodeValue=XMLExport.SetNodeValue(metaword(sNodeID), sNodeValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Action xml_SetNodeValue")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="xml_SetAttributeValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim NodeID]]>
<![CDATA[
]]>
<![CDATA[	Dim sAttID]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrparam]]>
<![CDATA[
]]>
<![CDATA[	Dim sFindValue]]>
<![CDATA[
]]>
<![CDATA[	Dim sNodeValue]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	xml_SetAttribute=True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & ",," & CurrentObj.Type,",")        ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	NodeID = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	sAttID = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	sFindValue = Trim(aStrParam(2))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sNodeValue = MetaWord(sFindValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	xml_SetAttributeValue=XMLExport.SetAttributeValue(NodeID,sAttID,sNodeValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Action xml_SetAttributeValue")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="xml_CommitNode" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	xml_CommitNode=XMLExport.CommitChildren(metaword(Trim(StrParam)))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Action xml_CommitNode")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<f name="xml_SetFileEncodingAsASCII" access="public">
	<p name="ASCIIEncoding">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ xml_SetFileEncodingAsASCII=TRUE]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ Dim mStrParam]]>
<![CDATA[
]]>
<![CDATA[ 'Determines if a file uses ANSI or Unicode encoding.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  mStrParam = MetaWord(ASCIIEncoding)]]>
<![CDATA[
]]>
<![CDATA[  If mStrParam<>"" then ASCIIEncoding = mStrParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	if UCase(ASCIIEncoding) = "TRUE" Then]]>
<![CDATA[
]]>
<![CDATA[     XMLExport.ExportFileEncoding = False]]>
<![CDATA[
]]>
<![CDATA[     writelog("Param: '" & StrParam & "'  Setting to Export file encoding to ASCII")]]>
<![CDATA[
]]>
<![CDATA[  else]]>
<![CDATA[
]]>
<![CDATA[     XMLExport.ExportFileEncoding = True]]>
<![CDATA[
]]>
<![CDATA[     writelog("Param: '" & StrParam & "'  Setting to Export file encoding to UNICODE")]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  xml_SetFileEncodingAsASCII = True	]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function xml_SetFileEncodingAsASCII")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<help>
  <![CDATA[
'************************************************************
' help.xml for Export 

' Licensed Materials - Property of IBM
' â€œRestricted Materials of IBMâ€
' 5725-C15 5725-C69
'
' Â© Copyright IBM Corp. 1994, 2015 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************
]]>

<ref id="xml_SaveFile">
  <ap>None.</ap>
  <h>
    This action commits all unsaved nodes and saves XML file to disk. You must use this action
    to complete the creation of the export XML file. <br/><br/>
    Nodes that were not committed using the <b>xml_CommitNode</b> action will be committed
    to the parent node when <b>xml_SaveFile</b> is called, and will appear subsequent to nodes previously committed using action <b>xml_CommitNode</b>.
    <e>
      <b>xml_SaveFile()</b>
    </e>
  </h>
  <lvl>Batch, Document or Page level.</lvl>
  <ret>
    <b>True</b> if the file is created successfully. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="xml_SetExportPath" >
  <ap>
    Specifies the full path to the directory that will store the export XML file.  
    If this action is not called, the XML file will be saved in the batch directory.  
    Smart parameters are supported.
  </ap>
  <h>
    This action will only set the path.  You will still need to use <b>xml_SetFileName</b> to set the
    name of the export file.
    <e>
      <b>xml_SetExportPath("C:\Invoice\ExportXML")</b><br/>
      xml_SetFileName("@BatchID")
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="xml_SetFileName">
  <ap>
    The name of the XML export file.  Smart Parameters are supported.
  </ap>
  <h>
    Use of this action is required to set the name of the XML Export file.  
    While this action can be called at any level, it is typically called at the batch level.  
    If the action xml_SetExportPath is not called, the file will be saved in the batch folder.
    <e>
      xml_SetExportPath("C:\Invoice\ExportXML")<br/>
      <b>xml_SetFileName("@BatchID")</b>
    </e>
  </h>	
  <lvl>All.</lvl>
  <ret>Always <b>True.</b></ret>
  <see>xml_SaveFile</see>
</ref>
  
<ref id="xml_NewNode" >
  <ap>Comma-separated String values of:<br/><br/>  
    <b>1.</b> The NodeID (tag name) of a new child node.<br/>
    <b>2.</b> The NodeID (tag name) of the parent node, if there is a parent.<br/><br/>
    Smart parameters are supported.
  </ap>
  <h>
    The new NodeID followed by the parent NodeID creates a new Node in the Export XML file.  
    <br/><br/>
    The first <b>xml_NewNode</b> action in a ruleset will create the root node of the XML file using the
    new child NodeID, the parent NodeID must be blank.
    <br/><br/>
    <e>
      xml_SetExportPath("C:\ParentDir\APT")<br/>
      xml_SetFileName("@BATCHID")<br/>
      <b>xml_NewNode("B")</b><br/>
      xml_SetAttributeValue("B,id,@BATCHID")<br/><br/>
      The example above starts an export XML file that is named the same as the current batch ID.
      It has a root node "B" whose "id" is assigned the batch ID.  It is expected that additional rules
      will continue to build the XML structure.  The last invoked action must call xml_SaveFile to save
      the export file to disk.
      <br/><br/>
      <b>xml_NewNode("ClaimsData,HCFA")</b><br/>
      Duplicated Node ID's will cause the prior node of the same ID to commit to its specific parent
      node and will no longer be available for modification.<br/><br/>
      Note: Adding a second child NodeID with the same Tag name of the root node will cause the action
      to return false.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True</b> if parent node exists. <br/><b>False</b> if duplicate root node
    is declared, or parent NodeID does not exist.
  </ret>
  <see>xml_SaveFile</see>
</ref>
  
<ref id="xml_SetNodeValue" >
  <ap>
    Two comma-separated values:<br/><br/>
    1. The NodeID.<br/>
    2. The value to assign to the node.<br/><br/>
    The action defaults the current object's value.<br/>
    Smart parameters are supported.
  </ap>
  <h>
    Assigns a value to a specific node.  
    <e>
      The example below shows how creation of an XML for invoice line items might look.<br/>
      xml_NewNode("LineItem,Invoice")<br/>
      xml_SetAttributeValue("LineItem,id,@ID")<br/>
      xml_NewNode("ItemID,LineItem")<br/>
      <b>xml_SetNodeValue("IdemID,@F\ItemID")</b><br/>
      xml_NewNode("ItemDesc,LineItem")<br/>
      <b>xml_SetNodeValue("ItemDesc,@F\ItemDesc")</b><br/>
      xml_NewNode("Qty,LineItem")<br/>
      <b>xml_SetNodeValue("Qty,@F\Qty")</b><br/>
      xml_CommitNode("LineItem")<br/>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>Always <b>True.</b></ret>
  <see>xml_NewNode</see>
</ref>
  
<ref id="xml_SetAttributeValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Assigns attributes to a specific node.">
  <ap>
    Three comma-separated values:<br/><br/>
    <b>1.</b>The NodeID.<br/>
    <b>2.</b>The attribute's name.<br/>  
    <b>3.</b>The value to be assigned to the attribute.  Smart parameters are supported.
  </ap>
  <h>
    Sets an attribute value within a specific node in the XML hierarchy.
    <e>
      The example below assigns the current Page's <b>Number</b> field value to the
      <b>Xpage</b> node's <b>Number</b> attribute.<br/>
      <b>xml_SetAttributeValue("Xpage,Number,@P\Number")</b><br/><br/>
  
      The example below shows how creation of an XML for invoice line items might look.<br/>
      xml_NewNode("LineItem,Invoice")<br/>
      <b>xml_SetAttributeValue("LineItem,id,@ID")</b><br/>
      xml_NewNode("ItemID,LineItem")<br/>
      xml_SetNodeValue("IdemID,@F\ItemID")<br/>
      xml_NewNode("ItemDesc,LineItem")<br/>
      xml_SetNodeValue("ItemDesc,@F\ItemDesc")<br/>
      xml_NewNode("Qty,LineItem")<br/>
      xml_SetNodeValue("Qty,@F\Qty")<br/>
      xml_CommitNode("LineItem")<br/>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the node does not exist.  Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="xml_CommitNode" >
  <ap>
    String value of the xml Tag.  Smart parameters are supported.
  </ap>
  <h>
    Commits (closes) current xml node to it's parent node with the xml tag value of the parameter. Allowing a new node with the same
    tag to be created at the same hierarchical level in the output xml.  
    <e>xml_CommitNode("LineTotal")</e><br/>
    Example commits (closes) the current xml node with a Tag <i>LineTotal</i>.<br/><br/>
    Remember: Use of this action can change the expected order of xml nodes as they appear in the final xml, since this action commits the current xml
    to the parent xml node when it is called. Sibling xml nodes that were not committed using this action are later committed
    to the parent node when the <b>xml_SaveFile</b> is called, so those xml nodes will appear after nodes previously committed using the <b>xml_CommitNode</b> action. 
    
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>

</ref>
  <ref id="xml_SetFileEncodingAsASCII">
    <ap>
      If set to "True", then Export files will be created with ASCII encoding.
      "False" creates files with UNICODE encoding and is the default.<br/>
      Smart parameters are supported.
    </ap>
    <h>
      Determines if the Export file is created with ASCII or UNICODE encoding.
      A parameter value of "True" will create files with ASCII format.
      "False" will create files with UNICODE format.<br/><br/>

      <b>
        NOTE:
        This action must be called before any actions that physically write to and create the Export file.  If not called,
        then the file will be created with UNICODE encoding.
      </b>
      <br/><br/>
      <e>
        <b>xml_SetFileEncodingAsASCII("True")</b><br/>
        xml_CommitNode("LineTotal")<br/><br/>

        This example will create files in ASCII format.<br/><br/>

        <b>xml_SetFileEncodingAsASCII("False")</b><br/>
        xml_CommitNode("LineTotal")<br/><br/>
        
        This example will create the file in UNICODE format. 
      </e>
    </h>
    <lvl>Any.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

</help>
</rrx>
<rrx namespace="FileNetIDM" src="c:\datacap\RRS\FileNetIDM.dll">

<i ref="rrunner">
</i>
<af name="Library_IS_Initialize" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Initializes a previously defined, active Image Services Library.">
</af>
<af name="Library_DS_Initialize" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Initializes a previously defined, active Document Services Library.">
</af>
<af name="Library_DMA_Initialize" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Initializes a previously-defined, active DMA Library.">
</af>
<af name="Library_LogIn" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Logs into the initialized FileNet library using the User ID and Password parameter values.">
</af>
<f name="Library_LogOff" access="public">
</f>
<af name="SaveDocToFolder" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Places the committed FileNet document in an existing folder of the open FileNet library.">
</af>
<f name="UseIndexes_ON" access="public">
</f>
<f name="UseIndexes_OFF" access="public">
</f>
<f name="NewDocument" access="public">
	<p name="StrParam">
	</p>
</f>
<af name="AddTIFImageToDocument" access="public" bInter="bInter" bDebug="bDebug" qi="Adds an Image file to the new FileNet document.">
</af>
<af name="AddPDFImageToDocument" access="public" bInter="bInter" bDebug="bDebug" qi="Adds a PDF Image file to the new FileNet document.">
</af>
<af name="AddFileToDocument" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Adds a file to the current FileNet document.">
</af>
<af name="AddAllImagesToDocument" access="public" bInter="bInter" bDebug="bDebug" qi="Adds All Document Page object Images to IS Document object.">
</af>
<af name="IndexProperty_ID_DateComponent" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Sets up a Date element of the FileNet task’s processing index.">
</af>
<f name="IndexProperty_SmartParameter" access="public">
	<p name="PropertyName">
	</p>
	<p name="Value">
	</p>
	<p name="Length">
	</p>
</f>
<af name="IndexProperty_LeftJUSTIFY" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Left-justifies a value that is being assigned to a target property of the FileNet document.">
</af>
<af name="IndexProperty_RightJUSTIFY" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Right-justifies a value that is being assigned to a target property of the FileNet document.">
</af>
<af name="Upload" access="public" bInter="bInter" bDebug="bDebug" qi="Commits the Active FileNet Document to the FileNet Library.">
</af>
<af name="FileNETDocID_SetValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Assigns the FileNet Document’s ID.">
</af>
<f name="FileNETDocID_SaveAsSmartParameter" access="public">
</f>
<af name="GetDocuments" access="public" bInter="bInter" bDebug="bDebug" qi="Logs the names of the documents in the FileNet collection.">
</af>
<af name="GetTopFolders" access="public" bInter="bInter" bDebug="bDebug" qi="Lists existing top-level FileNet folders in the current task’s Log file.">
</af>
<af name="CreateFolder" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Creates a top-level FileNet folder.">
</af>
<af name="FileNetDB_ADOConnect" access="public" bInter="bInter" bDebug="bDebug" qi="Establishes an ActiveX Data Connection object (ADO connection) with FileNet.">
</af>
<af name="Upload_SetDelay" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Controls the delay between upload retries.">
</af>
<af name="Upload_SetNumAttempts" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamMW" qi="Control the number of retries for the FileNet upload.">
</af>
<help>
  <![CDATA[
  
'************************************************************************
' FileNetIDM.rrx - FileNet P8 Upload Actions

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'************************************************************************
' 
' FileNetIDM.rrx - Help.xml 
' 6/18/2012
'

]]>

  <ref id="Library_IS_Initialize">
    <ap>
      String value containing the Library name. The Library name will commonly consist of three, colon-separated elements of the Library Name. In some cases, the short
      name can be used.
      Smart Parameters are supported.
    </ap>
    <h>
      Initializes a previously defined, active Image Services Library.<br/><br/>
      In some cases, the formal three-part Library Name should be used to properly configure initialization. However, there may be some cases where
      configuring the library through the IDM Configuration tool first and then passing the short name could be used.
      Please check your FileNet documentation for guidelines on designating a formal Library Name.
      <e>
        <b>Library_IS_Initialize("LibraryName")</b><br/>
        This action initializes but does not open the library – see Library_Login.
      </e>
    </h>
    <lvl>
      Any level, but the Batch level is recommended.
    </lvl>
    <ret>
      <b>False</b> if there is a problem connecting to the FileNet Image Services Library. Otherwise, <b>True.</b>
      Note: If the action returns False, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>

  <ref id="Library_DS_Initialize">
    <ap>
      String value consisting of the three colon-separated elements of the Library Name.
      Smart Parameters are supported.
    </ap>
    <h>
      Initializes a previously defined, active Document Services Library.<br/><br/>
      Do not confuse the Library Name with the local FileNet Neighborhood label.
      In some cases, the formal three-part Library Name must be used to properly configure initialization.
      Please check your FileNet documentation for guidelines on designating a formal Library Name.
      <e>
        <b>Library_DS_Initialize("DSLibrary:Datacap:FileNet")</b><br/>
        Alert! This action initializes but does not open the library – see Library_Login.
      </e>
    </h>
    <lvl>
      Any level, but the Batch level is recommended.
    </lvl>
    <ret>
      <b>False</b> if there is a problem connecting to the FileNet Document Services Library. Otherwise, <b>True.</b>
      Note: If the action returns False, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>
  <ref id="Library_DMA_Initialize">
    <ap>
      String value consisting of three colon-separated elements of the Library Name.
      Smart Parameters are supported.
    </ap>
    <h>
      Do not confuse the Library Name with the local FileNet Neighborhood label.
      In some cases, the formal three-part Library Name must be used to properly configure initialization.
      Please check your FileNet documentation on how to discern your formal library name.
      <e>
        <b>Library_DMA_Initialize("DMALibrary:Datacap:FileNet")</b><br/>
        This action initializes but does not open the library – see Library_Login.
      </e>
    </h>
    <lvl>
      Any level, but the Batch level is recommended.
    </lvl>
    <ret>
      <b>False</b> if there is a problem connecting to the FileNet DMA Library. Otherwise, <b>True.</b>
      Note: If the action returns False, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>

  <ref id="Library_LogIn">
    <ap>
      String values of the User ID and Password, with a comma separator. Smart Parameters are supported.
    </ap>
    <h>
      Logs into the initialized FileNet library using the User ID and Password parameter values.
      You must include this action to access a library. Be sure the Library_Login action follows
      one of the Library_Initialize actions.
      <e>
        Library_DS_Initialize("DefaultLib:Datacap:FileNet")<br/>
        <b>Library_LogIn("FileNet2,FN2")</b><br/><br/>
        Library_IS_Initialize("LibraryName")<br/>
        <b>Library_LogIn("@APPVAR(values/gen/ISUser),@APPVAR(values/adv/ISPassword)")</b><br/><br/>
        Library_IS_Initialize("LibraryName")<br/>
        <b>Library_LogIn("@STRING(@APPVAR(values/gen/ISUser),@APPVAR(values/adv/ISPassword))")</b>
      </e>
    </h>
    <lvl>
      Any level, but the Batch level is recommended.
    </lvl>
    <ret>
      <b>False</b> if an active library is not found, the parameter values are incorrect, or an error
      occurs while logging into the library. Otherwise, <b>True.</b>
      Note: If the action returns False, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>

  <ref id="Library_LogOff">
    <ap>
      None.
    </ap>
    <h>
      Closes the FileNet connection.
      <e>
        <b>Library_LogOff()</b>
      </e>
    </h>
    <lvl>
      Any level, but the Batch level is recommended.
    </lvl>
    <ret>
      <b>True,</b> if the logoff was successful.  Otherwise, <b>False.</b>
    </ret>
  </ref>
  <ref id="SaveDocToFolder">
    <ap>
      String value of the Folder ID, beginning with a forward slash (/) - see the example.  Smart Parameters are supported.
    </ap>
    <h>
      Places the committed FileNet document in an existing folder of the open FileNet library.
      Although the forward slash (/) character is a standard element of this action’s parameter,
      the setup of your FileNet library may mean that the forward slash is not used.
      Under exceptional circumstances, this action will have this syntax – note that a
      forward slash does not precede the Folder ID:
      SaveDocToFolder("1074a")
      <e>
        Library_DS_Initialize("1040Docs")<br/>
        Library_Login("FileNet2,FN2")<br/>
        NewDocument("1040EZtwo")<br/>
        AddAllImagesToDocument()<br/>
        Upload()<br/>
        <b>SaveDocToFolder("/1074a")</b><br/><br/>

        As the example shows, you can insert this action after adding images and successfully committing
        (uploading) the document to the FileNet library.
      </e>
    </h>
    <lvl>
      All Levels.
    </lvl>
    <ret>
      <b>False</b> if there is no active FileNet document, no active FileNet library,
      invalid parameter, or if the active FileNet document has not been committed. Otherwise, <b>True.</b>
      Note: If the action cannot access the specified folder, the action directs the Rulerunner
      task to finish with a status of “Aborted”.
    </ret>
  </ref>

  <ref id="UseIndexes_ON">
    <ap>
      None.
    </ap>
    <h>
      This status allows the task to access the properties of the FileNet document,
      and to provide these properties with values of objects of the Document Hierarchy.
      True is the default value for using indexes
      <e>
        <b>UserIndexes_ON()</b><br/>
        IndexProperty_ID_Component("FNDoc,1040EZTwo,12")<br/><br/>

        A task cannot define or populate indices until a rule with this action activates the
        Indexing feature. However, the On status is a default status, and is in effect unless
        a UseIndexes_OFF action turns it Off.
      </e>
    </h>
    <lvl>
      All levels.
    </lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

  <ref id="UseIndexes_OFF">
    <ap>
      None.
    </ap>
    <h>
      Turns Off a Rulerunner task’s Indexing feature.
      Because the feature is On by default, the task will continue to generate and assign
      index values until a rule with this action turns it Off.<br/><br/>
      A rule with action must be applied before a new FileNet document is created.
      <e>
        <b>UserIndexes_OFF()</b>
      </e>
    </h>
    <lvl>
      All levels.
    </lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>
  <ref id="NewDocument">
    <ap>
      String value of a previously defined FileNet Document Class.  Smart Parameters are supported.
    </ap>
    <h>
      Sets up a new FileNet document, and assigns the FileNet Document Class you specify as
      an argument to the new FileNet document.<br/><br/>

      After an Upload action commits the document to a FileNet library,
      FileNet immediately links a unique ID to the document.
      <e>
        Library_DS_Initialize("DefaultIMS:Datacap:FileNet")<br/>
        Library_Login("FileNet2,FN2")<br/>
        <b>NewDocument("1040EZtwo")</b><br/><br/>

        In this example, the NewDocument action instantiates a new FileNet document of Class:‘1040EZtwo’.
        (To populate the document, you’ll probably follow this action with one of the AddImage actions.)

      </e>
    </h>
    <lvl>
      All Levels.
    </lvl>
    <ret>
      <b>False</b> if a new document cannot be created. Otherwise, <b>True.</b>
      Note: If the action returns False, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>

  <ref id="AddTIFImageToDocument">
    <ap>
      None.
    </ap>
    <h>
      Adds the Image file associated with a Page object of the Document Hierarchy to the new FileNet document.<br/><br/>
      If a rule containing this action is bound to a Field object, it adds the Image
      file associated with the field’s parent Page object.<br/>
      An Upload action should stay at any level lower than this action.
      <e>
        NewDocument("1040EZtwo")<br/>
        <b>AddTIFImageToDocument()</b><br/><br/>

        This sequence associates the calling component’s bound Image file with a new FileNet ‘1040EZtwo’ document.
      </e>
    </h>
    <lvl>
      Field or Page level.<br/>
    </lvl>
    <ret>
      <b>False</b> if no Page component of the calling object is found, batch images
      cannot be accessed, or if the active FileNet document has already been committed to the library. Otherwise, <br>True.</br>
      Note: If the action cannot access the batch’s image files, the action directs
      the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>

  <ref id="AddPDFImageToDocument">
    <ap>
      None.
    </ap>
    <h>
      Adds a PDF Image file associated with a Page object of the Document Hierarchy to the new FileNet document.
      This action works only if the PDF file is in the appropriate folder of the application’s Batches directory –
      and has the same name as an associated page’s corresponding Tiff Image file.
      <e>
        NewDocument("1040EZtwo")<br/>
        AddPDFImageToDocument()<br/><br/>

        This sequence associates calling components bound to the PDF file with a new FileNet ‘1040EZtwo’ document.
      </e>
    </h>
    <lvl>
      Field or Page level.
    </lvl>
    <ret>
      <b>False</b> if no Page component of the calling object is found, batch images
      cannot be accessed, or if the active FileNet document has already been committed to the library. Otherwise, <b>True.</b>
      Note: If the action cannot access the batch’s image files, the action directs the
      Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>
  <ref id="AddFileToDocument">
    <ap>
      String value of the File name to add to the document – and its path.  Smart Parameters are supported.
    </ap>
    <h>
      Adds any file you designate as a parameter to the current FileNet document.<br/><br/>
      If the parameter does not include a path to a folder, the action will use the path to
      the current Batches directory as the default. You can also designate a variable of the
      bound object of the Document Hierarchy as the source of path’s value by using the
      # character followed by the variable’s name. For example: #FilePath
      <e>
        NewDocument("1040EZtwo")<br/>
        AddTIFImageToDocument()<br/>
        <b>AddFileToDocument("C:\Datacap\MQSW\Process\FNLog.log")</b><br/><br/>

        This sequence assumes that Taskmaster logs its FileNet activities – and that a resulting Log
        file is available for the document.
      </e>
    </h>
    <lvl>
      All levels.
    </lvl>
    <ret>
      <b>False</b> if the specified file is not found, or if the active FileNet document
      has already been committed to the library. Otherwise, <b>True.</b>
      Note: If the action cannot access the batch’s image files, the action directs the
      Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>

  <ref id="AddAllImagesToDocument">
    <ap>
      None.
    </ap>
    <h>
      Assigns all images associated within a Document object (or parent Document object) of the Document Hierarchy to the new FileNet document.
      This action is valid for IS libraries only. DS libraries only permit a single associated file.<br/><br/>
      This action solicits information from the Rulerunner task’s Page file
      (upload.xml, for example) as it assigns Image files representing pages linked to a Document object
      (or child Page objects) of the Document Hierarchy to the FileNet document.<br/><br/>
      The images are not yet committed to the library.
      <e>
        NewDocument("1040EZtwo")<br/>
        AddAllImagesToDocument()
      </e>
    </h>
    <lvl>
      Document, Page or Field levels.
    </lvl>
    <ret>
      False if action is placed at the Batch level, if the current active FileNet
      document has already been committed to the Library, or if no documents exist in the batch. Otherwise, True.
      Note: If the action cannot access the batch’s image files, the action directs the
      Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>


  <ref id="IndexProperty_ID_Component">
    <ap>
      Comma-separated values of:<br/>
      1. the name of a FileNet document’s property;<br/>
      2. the name(s) of one or more Document Hierarchy objects with values for the variable that will be transferred to the FileNet document’s property;<br/>
      3. the value of the maximum length of the subscript value.<br/><br/>

      Smart Parameters are supported.
    </ap>
    <h>
      This action links the property of the FileNet document to an object of the Document Hierarchy.
      <e>
        IndexProperty_ID_Component("FNBatch,1040EZ,18")<br/>
        IndexProperty_ID_Component("FNDoc,1040EZTwo,22")<br/>
        IndexProperty_ID_Component("FNPageF,Front,12")<br/>
        IndexProperty_ID_Component("FNPageB,Back,12")<br/>
        IndexProperty_ID_Component("FNFldLast,Last,18")<br/>
        IndexProperty_ID_Component("NFldFirst,First,18")<br/>
        IndexProperty_ID_Component("NFldMI,MI,2")<br/><br/>

        This sequence defines seven elements of a processing index for a FileNet task. In each case,
        the first parameter is the name of a property of a FileNet document that has been previously assembled.
        The second parameter assigns the Name of a Document Hierarchy object to the FileNet document’s property.
        The third parameter is the property’s maximum length.
        During task operations, runtime values for each object will become the FileNet document’s Index values.
      </e>
    </h>
    <lvl>
      Page or Field level with child Fields.
    </lvl>
    <ret>
      <b>False</b> if the FileNet property specified is invalid, or the
      FileNet Property Collection does not exist. Otherwise, <b>True.</b>
      Note: If the action returns False, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>
  <ref id="IndexProperty_ID_DateComponent">
    <ap>
      String consisting of four comma-separated values:<br/>
      1. the name of the FileNet document’s Date property;<br/>
      2. the name of a Document Hierarchy object with a Date property;<br/>
      3. the format of the Date when supplied to the FileNet document; and<br/>
      4. the format of the Date value being added to the task’s processing index.<br/><br/>
      See the example for acceptable Date values.  Smart Parameters are supported.
    </ap>
    <h>
      This element can then supply Date information to a Date property of the FileNet document.<br/><br/>
      The parameters can use the Date formats on the left:<br/>
      cc Century 20 yy Year 03 yyyy Year 2003 dd Day 29 mm Month 06 Julian Year/Day 03-145
      <e>
        <b>IndexProperty_ID_Date_Component("FNStart,1040EZ,mm/dd/yy,yyyy/mm/dd")</b><br/><br/>

        This example re-formats the value of the Batch object’s Start Date and assigns it
        to the FNStart property of the FileNet document.
      </e>
    </h>
    <lvl>
      Page, or Field level with child Fields.
    </lvl>
    <ret>
      <b>False</b> if the FileNet property specified is invalid, or the FileNet Property Collection does not exist. Otherwise, <b>True.</b>
      Note: If the action returns False, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref> 
  
  <ref id="IndexProperty_LeftJUSTIFY">
    <ap>
      String with two comma-separated values:<br/>
      1. The name of the property of the FileNet document; and<br/>
      2. The maximum size of a value.<br/><br/>

      Smart Parameters are supported.
    </ap>
    <h>
      Left-justifies a value that is being assigned to a target property of the FileNet document.
      <e>
        IndexProperty_ID_Variable("FNFldData,Year+SSN+ Income+Deductions+Net,256")<br/>
        <b>IndexProperty_LeftJUSTIFY("FNFldData,256")</b><br/><br/>

        This sequence provides the FNFldData property with a value, then formats the value
        before it is actually assigned to the active FileNet document.
      </e>
    </h>
    <lvl>
      All levels.
    </lvl>
    <ret>
      <b>False</b> if the FileNet property cannot be set.
      Otherwise, <b>True.</b>
    </ret>
  </ref>
  <ref id="IndexProperty_RightJUSTIFY">
    <ap>
      String with two comma-separated values:<br/>
      1. The name of the property of the FileNet document; and<br/>
      2. The maximum size of a value.<br/><br/>

      Smart Parameters are supported.
    </ap>
    <h>
      Right-justifies a value that is being assigned to a target property of the FileNet document.
      <e>
        IndexProperty_ID_Variable("FNFldData,Year+SSN+ Income+Deductions+Net,256")<br/>
        <b>IndexProperty_RightJUSTIFY("FNFldData,256")</b><br/><br/>

        This sequence provides the FNFldData property with a value, then formats the value
        before it is actually assigned to the active FileNet document.
      </e>
    </h>
    <lvl>
      All levels.
    </lvl>
    <ret>
      <b>False</b> if the FileNet property cannot be set.
      Otherwise, <b>True.</b>
    </ret>
  </ref>
  <ref id="IndexProperty_SmartParameter">
    <ap>
      1. The name of the FileNet document’s target property.<br/>
      2. The value to assign to the property.<br/>  
      3. The length of the property value (space filled).<br/><br/>

      Smart Parameters are supported for all arguments.
    </ap>
    <h>
      Assigns a constant value to a particular property of a FileNet document.
      <e>
        IndexProperty_SmartParameter(FNTaxQtr,@P/Taxes,"")<br/>
        The action above will assign the value of field “Taxes” to the FNTaxQtr property of the FileNet document.<br/>

        IndexProperty_SmartParameter(FNNameLast,@P.LastName,10)<br/>
        The action above will assign the space filled value of page variable “LastName” to the FNNameLast property
        of the FileNet document, if the variable value exceeds 10 characters the value saved will be right truncated.
      </e>
    </h>
    <lvl>
      All levels.
    </lvl>
    <ret>
      <b>False</b> if the FileNet property specified cannot be set.
      Otherwise, <b>True.</b>
    </ret>
  </ref>
  <ref id="IndexProperty_ID_Value">
    <ap>
      String with two comma-separated values:<br/>
      1. The name of the FileNet document’s target property;<br/>
      2. The constant’s value.<br/><br/>

      Smart Parameters are supported.
    </ap>
    <h>
      Assigns a constant value to a particular property of a FileNet document.
      <e>
        IndexProperty_ID_Value(FNTaxQtr,3)
        The action above will assign “3” to the FNTaxQtr property of the FileNet document whenever the FileNet task processes the bound object of the Document Hierarchy…the object to which the action’s rule applies.
      </e>
    </h>
    <lvl>
      All levels.
    </lvl>
    <ret>
      False if the FileNet property specified cannot be set. Otherwise, True.
    </ret>
  </ref>  
  <ref id="Upload">
    <ap>
      None.
    </ap>
    <h>
      Commits the active FileNet document to the open FileNet library.
      <e>
        <b>Upload()</b>
      </e>
    </h>
    <lvl>
      All levels.
    </lvl>
    <ret>
      <b>False</b> if the Document object does not exist; if the library object is missing;
      if all pages were previously committed; if the active FileNet document has already been committed
      to the library; or the upload is unsuccessful. Otherwise, <b>True.</b>
      Note: If the active FileNet document has already been committed, or
      the action encounters an error, the action directs the Rulerunner task to finish with a status of “Aborted”.
    </ret>
  </ref>
    <ref id="FileNETDocID_SetValue">
      <ap>
        The name of the Field object.  Smart Parameters are supported.
      </ap>
      <h>
        Assigns the FileNet Document’s ID to a child Field object of the bound Document,
        Page or parent Field object of the Document Hierarchy.
        <e>
          NewDocument("1040EZtwo")<br/>
          AddAllImagesToDocument()<br/>
          Upload()<br/>
          FileNETDocID_SetValue("DocID")<br/><br/>

          This sequence will set up a new FileNet document, commit it to the FileNet library,
          and assign its ID as the Text value of the specified child field value of the bound object.
        </e>
      </h>
      <lvl>
        Document level, Page level or Field with child fields.
      </lvl>
      <ret>
        <b>False</b> if an active FileNet document is not found;
        if the active FileNet document has not been committed; or if the child Field object was not found.
        Otherwise, <b>True.</b>
      </ret>
    </ref>

  <ref id="FileNETDocID_SaveAsSmartParameter">
    <ap>
      None.
    </ap>
    <h>
      Assigns the FileNet document’s ID to the TEXT variable of the bound object of the Document Hierarchy.
      <e>
        NewDocument("1040EZtwo")<br/>
        AddAllImagesToDocument()<br/>
        Upload()<br/>
        FileNETDocID_SaveAsSmartParameter()<br/><br/>
      </e>
    </h>
    <lvl>
      All levels.
    </lvl>
    <ret>
      <b>False</b> if no active FileNet document is found; or if the active FileNet
      document has not been committed. Otherwise, <b>True.</b>
    </ret>
  </ref>

    <ref id="GetDocuments">
      <ap>
        None.
      </ap>
      <h>
        A utility action used to aid debugging, it logs the names of the documents in the collection.
        This action is used to help verify the FileNet connection and that documents have been created.
        It is recommended that this is used for debugging and not in a normal production environment.
        <e>
          <b>GetDocuments()</b>
        </e>
      </h>
      <lvl>
        All levels.
      </lvl>
      <ret>
        Always <b>True.</b>
      </ret>
    </ref>
    <ref id="GetTopFolders">
      <ap>
        None.
      </ap>
      <h>
        Lists existing top-level FileNet folders in the current task’s Log file.
        <e>
          <b>GetTopFolders()</b>
        </e>
      </h>
      <lvl>
        All levels.
      </lvl>
      <ret>
        <b>False</b> if the top-level folder collection cannot be located. Otherwise, <b>True.</b>
      </ret>
    </ref>
    <ref id="CreateFolder">
      <ap>
        The name of the folder to create.  Smart Parameters are supported.
      </ap>
      <h>
        Creates a top-level FileNet folder
        <e>
          <b>CreateFolder("MQSW_Q601")</b>
        </e>
      </h>
      <lvl>
        Document, Page or Field levels.
      </lvl>
      <ret>
        <b>False</b> if the folder cannot be created. Otherwise, <b>True.</b>
      </ret>
    </ref>
    <ref id="FileNetDB_ADOConnect">
      <ap>
        None.
      </ap>
      <h>
        Establishes an ActiveX Data Connection object (ADO connection) with the specified FileNet database.<br/><br/>
        <e>
          Library_IS_Initialize("DefaultIMS:Domain:FileNet")<br/>
          LibraryLogin("Admin,AdOK")<br/>
          <b>FileNetDB_ADOConnect()</b>
        </e>
      </h>
      <lvl>
        All levels.
      </lvl>
      <ret>
        <b>False</b> if the FileNet library is not initialized. Otherwise, <b>True.</b>
        Note: If the action encounters an error connecting to the specified database, the action directs the Rulerunner task to finish with a status of “Aborted”.
      </ret>
    </ref>
    <ref id="Upload_SetDelay">
      <ap>
        The number of seconds to wait between each retry of the FileNet upload.  Smart Parameters are supported.
      </ap>
      <h>
        If an upload fails, it will be automatically retried.  Between each retry, the application will pause.  The
        length of the pause can be set with this action.
        If this action is not called, the default value of 5 seconds is used.
        <e>
          Upload_SetDelay("15")
        </e>
      </h>
      <lvl>
        All levels.
      </lvl>
      <ret>
        Always <b>True.</b>
      </ret>
    </ref>

    <ref id="Upload_SetNumAttempts">
      <ap>
        The number of times to retry the FileNet upload upon failure.  Smart Parameters are supported.
      </ap>
      <h>
        If the upload action fails, it will be automatically retried.  The number of retries can be controlled with this action.
        If this action is not called, the default value of 3 will be used.
        <e>
          <b>Upload_SetNumAttempts("5")</b>
        </e>
      </h>
      <lvl>
        All levels.
      </lvl>
      <ret>
        Always <b>True.</b>
      </ret>    
    </ref>  
  </help>
</rrx>
<rrx namespace="FileNetP8" src="c:\datacap\RRS\FileNetP8.dll">

<i ref="rrunner">
</i>
<af name="FNP8_SetURL" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the URL for the FileNet P8 Web Service.">
</af>
<af name="FNP8_Login" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the UserID and Password for login to the IBM FileNet P8 system.">
</af>
<af name="FNP8_SetLocale" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Identifies the locale on the target P8 system.">
</af>
<af name="FNP8_SetTargetClassID" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the F8 Document Class for uploaded documents.">
</af>
<af name="FNP8_SetTargetObjectID" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the name of the Object Store in which documents will be stored.">
</af>
<af name="FNP8_SetDestinationFolder" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the destination folder for the documents being uploaded.">
</af>
<af name="FNP8_CreateFolder" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Creates a subfolder on a specified target class and object.">
</af>
<af name="FNP8_SetDocClassId" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the P8 Document Class for the uploaded files.">
</af>
<af name="FNP8_SetDefineSecurityParentage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the security parentage for the uploaded files.">
</af>
<af name="FNP8_SetDocTitle" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the Document Title for documents being uploaded.">
</af>
<af name="FNP8_SetFileMimeType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Specifies a custom MIME type to be used by a file extension.">
</af>
<af name="FNP8_SetProperty" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the designated FileNet property to a specified value.">
</af>
<af name="FNP8_SetPropertyEx" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the designated FileNet property to a specified value.">
</af>
<af name="FNP8_SetMultiValueProperty" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the values in a multi-value property.">
</af>
<af name="FNP8_SetTimeout" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the timeout for the FileNet P8 Web Service in milliseconds.">
</af>
<af name="FNP8_Upload" access="public" bInter="bInter" bDebug="bDebug" qi="Uploads the Batch images to the FileNet P8 repository.">
</af>
<af name="FNP8_UploadDir" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Uploads all images from a specific source folder.">
</af>
<af name="FNP8_SetFileType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Assigns the file type for the files that are uploaded.">
</af>
<af name="FNP8_SetUploadMode" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Set the upload mode.">
</af>
<af name="FNP8_MultiPageDocs" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Set the upload mode.">
</af>
<af name="FNP8_SetRetry" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the number of automatic upload retries.">
</af>
<af name="FNP8_SetKeyProperty" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the update properties key to a FileNet document property and its corresponding property value.">
</af>
<af name="FNP8_UpdateProperties" access="public" bInter="bInter" bDebug="bDebug" qi="Updates an existing FileNet P8 document's properties values using the data passed into the SetProperty action.">
</af>
<af name="FNP8_SetSearchClass" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the document class to use for search.">
</af>
<af name="FNP8_SetSearchDownloadDir" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the full directory path for where the contents of the documents returned by search should be downloaded to.">
</af>
<af name="FNP8_SetSearchWhereClause" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the search criteria (WHERE clause). ">
</af>
<af name="FNP8_SetSearchAndDownloadStatusProperty" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the name of an integer             property which the FNP8_SearchAndDownload action will update for the documents which it downloads to flag that the document has been downloaded.">
</af>
<af name="FNP8_SetSearchMaxItems" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the maximum number of search results.">
</af>
<af name="FNP8_SetSearchFolderRestriction" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets a folder path to restrict the search results.">
</af>
<af name="FNP8_SetSearchOrderBy" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the orderby clause for the search results.">
</af>
<af name="FNP8_SetSearchIncludeDocsWithoutContent" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Set to true to include documents without content in search results, false otherwise. Default is false.">
</af>
<af name="FNP8_SetSearchIncludeSubClasses" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Set to true to include the subclasses of the search class in search results, false otherwise. Default is true.">
</af>
<af name="FNP8_SetSearchCurrentVersionOnly" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Set to true to include only the current version of documents in the search results, false otherwise. Default is true.">
</af>
<af name="FNP8_SearchAndDownload" access="public" bInter="bInter" bDebug="bDebug" qi="Executes a search for documents in Filenet P8 and downloads the content of the documents.">
</af>
<af name="FNP8_AddRedactionsToP8Document" access="public" bInter="bInter" bDebug="bDebug" qi="Updates an existing P8 document to add redactions, if any fields have been redacted">
</af>
  <help>
  <![CDATA[

'************************************************************************
' FileNetP8.rrx - FileNet P8 Upload Actions

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2014 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'************************************************************************
' 
' FileNetP8.rrx - Help.xml 
' 6/18/2012
'
]]>
<ref id="FNP8_SetURL">
<ap>
A single parameter identifying the URL for the IBM FileNet P8 Server .
The IP port is typically :9080 (IBM WebSphere) and the URL typically ends in /WSDL.
Smart parameters are supported.
</ap>
<h>
This action sets the URL for the FileNet P8 Content Manager Server.
This action should be called before any other P8 upload actions.
<e>
  <b>FNP8_SetURL("http://myp8server:9080/wsi/FNCEWS40MTOM/")</b><br /><br />
  
  IMPORTANT: The address may be case sensitive and the trailing forward-slash “/” must be present. To confirm that
  the address reaches a working IBM FileNet P8 Server, browse to the address after adding “wsdl” to
  the end, e.g. http://myp8server:9080/wsi/FNCEWS40MTOM/wsdl
</e>
</h>
<lvl>All, but generally at the Batch level.</lvl>
<ret>
<b>False,</b> if DC_P8_Server.dll was not successfully installed on this computer,
or if the parameter is not formatted as a valid URL. Otherwise, <b>True.</b><br /><br />
Note: This action returns True whether or not the URL is actually an operating IBM FileNet P8 Server
or not.  If not, an error will be reported when the Upload or UploadDir action runs.
You can check that the URL is correct and operating by displaying it in any web browser.
</ret>
</ref>
    
<ref id="FNP8_Login">
<ap>
Two comma-separated smart parameter supported string values:<br /><br />
1. Login Name.<br />
2. Password.<br /><br />    
</ap><h>
This action provides the User ID and Password to use when logging in to IBM FileNet P8.
<e><b>FNP8_Login("User1,Password1")</b></e></h><lvl>All, but generally at the Batch level.</lvl><ret><b>False,</b> if DC_P8_Server.dll was not successfully installed on this computer,
or either parameter value is missing or not a string.  Otherwise, <b>True.</b></ret>
</ref>
    
<ref id="FNP8_SetLocale">
<ap>
Locale value accepted by the FileNet P8 Web Service. The default value is “en_US”.<br /><br />
Locales are represented by 2-letter ISO 639 Language Codes and 2-letter ISO 3166 Country Codes 
separated by a _ character. For example: en_US or de_DE<br /><br />
Please consult these ISO documents to determine your locale value.
</ap><h>
Sets the Locale (the language and language conventions such as date format) used on the P8 server.  
This action is only required if the P8 repository uses a locale other than US English.
<e><b>FNP8_SetLocale("en_US")</b></e></h><lvl>All, but generally at the Batch level.</lvl><ret><b>False,</b> if DC_P8_Server.dll was not successfully installed on this computer,
or either parameter value is missing or not a string.  Otherwise, <b>True.</b></ret>
</ref>
    
<ref id="FNP8_SetTargetClassID">
<ap>
Specifies the repository type.  The valid values are "ObjectStore" and 
"FileStore".    
</ap><h>
Sets the top level repository type.
If this action is not called, the default value of "ObjectStore"will be used.
FileStore is an alternative repository type.
<e><b>FNP8_SetTargetClassID("ObjectStore")</b></e></h><lvl>All levels.</lvl><ret><b>False</b> if DC_P8_Server.dll was not successfully installed on this computer,
or either parameter value is missing or not a string.  Otherwise, <b>True.</b></ret>
</ref>
    
<ref id="FNP8_SetTargetObjectID">
<ap>
  String value of the Object Store name. Smart parameters are supported.
</ap><h>
Provides the name of the Object Store that you wish to store your documents in.
<e><b>FNP8_SetTargetObjectID("AP_ObjectStore")</b></e></h>
  <lvl>All, but generally at the Batch level.</lvl>
  <ret><b>False,</b> if DC_P8_Server.dll was not successfully installed on this computer,
or either parameter value is missing or not a string.  Otherwise, <b>True.</b>
  </ret>
</ref>
    
<ref id="FNP8_SetDestinationFolder" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the destination folder for the documents being uploaded.">
  <ap>
    The path to the destination FileNet P8 folder in the selected Object Store where documents should be uploaded.  For example: \1040EZ\
    The default value is the root folder of the specified target object.  Smart parameters are supported.<br /><br />
    Note: The trailing '\' is optional, folders that are children of the root folder do not have 
    to have a '\' after the name. In some cases a main folder of the object store will require a trailing '\', if the 'object store' configured for it.
  </ap><h>
Sets the destination folder for the documents being uploaded.  See also FNP8_CreateFolder.<br /><br />
Note: This setting can be changed by a subsequent FNP8_CreateFolder action.
Note: If you call it with the foldername "Unfiled Documents" (case insensitive) it will upload to FileNet's special "Unfiled Documents" folder.
<e><b>FNP8_SetDestinationFolder("\1040EZ\")</b></e></h><lvl>All levels.</lvl><ret><b>False</b> if DC_P8_Server.dll was not successfully installed on this computer,
or either parameter value is missing or not a string.  Otherwise, <b>True.</b>
</ret>
</ref>
    
<ref id="FNP8_CreateFolder">
<ap>
A string value or a predefined Smart Parameter variable which specifies the name of the folder to 
create.<br /><br />
Smart parameters are supported such as: @BATCHID, @ID, @STATUS, @TYPE, @VALUE, 
@JOBID, @JOBNAME, @OPERATOR, @STATION, @TASKID and @TASKNAME.  Please refer to
the smart parameter documentation for more information.
</ap><h>
This action creates a subfolder on a specified target class and object.  Like the 
Upload actions, this action must be preceded by SetURL, Login and SetTargetClassID actions.
<e>
FNP8_SetDestinationFolder("\1040EZ\Export\")<br /><b>FNP8_CreateFolder("@BATCHID")</b><br /><br />
This example will create a subfolder under the \1040EZ\Export\ folder and change 
the destination folder to the newly created folder.
If the folder is created successfully, the action adds a variable “Folder_ID” 
to the current DCO with the folder ID returned from FileNet Web Service.
</e></h><lvl>All levels.</lvl><ret><b>False</b> if the parameter cannot be parsed, the set up information is invalid,
or the folder cannot be created.  Otherwise, <b>True.</b><br /><br />
Note: If the action returns False, the action directs the Rulerunner task to finish
with a status of “Aborted”.
</ret>
</ref>
    
<ref id="FNP8_SetDocClassId">
<ap>
String value of the Document Class ID.    
</ap><h>
Sets the Document Class to be used in FileNet P8 for the documents being uploaded.
If this action is not called, the default value of "Document" will be used.
<e><b>FNP8_SetDocClassId("Document")</b></e></h><lvl>All levels.</lvl><ret><b>False</b> if DC_P8_Server.dll was not successfully installed on this computer,
or if parameter is not a string.  Otherwise, <b>True.</b></ret>
</ref>

<ref id="FNP8_SetDefineSecurityParentage">
		  <ap>
			  A string or smart parameter value "True" or "False" whether the file security is to be inherited from the parent folder. Smart parameters are supported.
		  </ap>
		  <h>
			  If "True", specifies that security is to be inherited from the parent folder,
			  equivalent to setting the filenet.api.constant.DefineSecurityParentage to DEFINE_SECURITY_PARENTAGE.
			  If "False", specifies that security is not inherited from the parent folder,
			  equivalent to setting the filenet.api.constant.DefineSecurityParentage to DO_NOT_DEFINE_SECURITY_PARENTAGE.			  
			  <p>
			  If this action is not called or the parameter is not "True" or "False", the default value of "False" will be used,
			  and the security will not inherit from the parent folder.
			  </p>
			  <e>
				  FNP8_SetDestinationFolder("@APPVAR(values/gen/P8Folder)")<br/>
				  <b>FNP8_SetDefineSecurityParentage("True")</b><br/>
				  FNP8_Upload()
			  </e>
		  </h>
		  <lvl>All levels.</lvl>
		  <ret>
			  <b>True</b>
		  </ret>
	  </ref>
	  
<ref id="FNP8_SetDocTitle">
<ap>
String value of a Document Title or a predefined Smart Parameter variable.  “Title”, without the quotation 
marks, is an acceptable default parameter.<br /><br />
Smart parameters are supported.
</ap><h>
Sets the Document Title for documents being uploaded.
<e><b>FNP8_SetDocTitle("1040ez")</b><br />
or<br /><b>FNP8_SetDocTitle("@ID")</b></e></h><lvl>All levels.</lvl><ret><b>False</b> if DC_P8_Server.dll was not successfully installed on this computer,
or if parameter is not a string.  Otherwise, <b>True.</b></ret>
</ref>
    
<ref id="FNP8_SetMimeType">
<ap>A string indicating the MIME type of the uploaded documents.</ap>
  <h>
    FNP8_SetMimeType has been replaced by FNP8_SetFileType.<br/>
    This action sets the MIME (Multipurpose Internet Mail Extensions) type, or content type,
    for the uploaded documents.  
  <e>
    <b>FNP8_SetMimeType("jpg")</b>
  </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
     <b>False</b> if DC_P8_Server.dll was not successfully installed on this computer,
     or if parameter is not a string.  Otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="FNP8_SetFileMimeType">
  <ap>
    Two comma-separated values.  
    The first value specifies the file extension and the second specifies the new MIME type for the file extension.
  </ap>
  <h>
    This action sets the MIME (Multipurpose Internet Mail Extensions) type, or content type,
    for uploaded documents with matching file extensions.
    This action overrides the library’s default mapping of the file extension to a MIME type.
    To override and use the custom MIME type,
    provide the file extension and the new MIME type to associate with the file extension.<br/><br/>

    The following file type extensions have default MIME type mappings:<br/>
    ai : application/illustrator<br/>
    avi : video/x-msvideo<br/>
    bmp : image/bmp<br/>
    doc : application/msword<br/>
    docx : application/vnd.openxmlformats-officedocument.wordprocessingml.document<br/>
    dwg : image/vnd.dwg<br/>
    dxf : image/vnd.dxf<br/>
    gif : image/gif<br/>
    htm : text/html<br/>
    html : text/html<br/>
    ico : image/x-icon<br/>
    jpe : image/jpeg<br/>
    jpeg : image/jpeg<br/>
    jpg : image/jpeg<br/>
    jpgv : video/jpeg<br/>
    m4v : video/x-m4v<br/>
    mov : video/quicktime<br/>
    mp4 : video/mp4<br/>
    mpeg : video/mpeg<br/>
    mpg : video/mpeg<br/>
    mpp : application/vnd.ms-project<br/>
    mpv : video/mpv<br/>
    msg : application/msoutlook<br/>
    ogg : application/ogg<br/>
    pcx : image/x-pcx<br/>
    pdf : application/pdf<br/>
    pic : image/x-pict<br/>
    png : image/png<br/>
    ppt : application/vnd.ms-powerpoint<br/>
    pptx : application/vnd.openxmlformats-officedocument.presentationml.presentation<br/>
    qt : video/quicktime<br/>
    rgb : image/x-rgb<br/>
    rtf : text/richtext<br/>
    tif : image/tiff<br/>
    tiff : image/tiff<br/>
    txt : text/plain<br/>
    vsd : application/vnd.visio<br/>
    wmd : application/x-ms-wmd<br/>
    wmv : video/x-ms-wmv<br/>
    wmx : video/x-ms-wmx<br/>
    xls : application/vnd.ms-excel<br/>
    xlsx : application/vnd.openxmlformats-officedocument.spreadsheetml.sheet<br/>
    xml : text/xml<br/><br/>
    
    Other file types are mapped to the generic
    'application/octet-stream' MIME type.<br/><br/>
 <br/>
  <e>
    <b>FNP8_SetFileMimeType(".rar,application/x-rar-compressed")</b>
  </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>Always returns <b>True.</b></ret>
</ref>

<ref id="FNP8_SetProperty">
<ap>
The following comma-separated string values:<br />
  <b>1.</b> Property ID:  the name of an existing document property in the FileNet
  library (equivalent to a document index field).<br /><br />
  <b>2.</b> Property Value: the value to assign to the associated Property ID. A value enclosed within single quotes are treated as string literal.<br /><br />
  <b>3.</b> Optional property type.  If this parameter is not specified, the
  property type will default to a 'string'.  Supported types are: Binary, Boolean, DateTime, Float, ID, Integer, Object and String. <br /><br />
  Smart Parameters are supported for values.
</ap><h>
  Sets the designated FileNet property to a specified value.
  This is equivalent to setting an index value for a document in other document management systems.
  If the property value contains an comma then the entire property value should be contained by single quotes.<br/>
  <e><b>FNP8_SetProperty("DocumentTitle, @ID")</b><br />
FNP8_Upload()
</e></h>
  <lvl>All levels.</lvl>
  <ret>
    <b>False</b> if either parameter is blank or if the value parameter is invalid.  Otherwise <b>True.</b><br /><br />
    Note: If the action returns False, the action directs the Rulerunner task to finish
    with a status of “Abort”. The task will also abort if more than one value is assigned
    to the Smart Parameter variable.  If a ruleset calls the FNP8_SetProperty action more than once,
    using the same Property ID as the opening parameter, FileNet P8 assumes that the second
    parameter is multi-value and assigns that value to the property.    
  </ret>
</ref>

<ref id="FNP8_SetPropertyEx">
  <ap>
    The following comma-separated string values:<br />
    <b>1.</b> Property ID:  the name of an existing document property in the FileNet
    library (equivalent to a document index field).<br /><br />
    <b>2.</b> Property Value: the value to assign to the associated Property ID. A value enclosed within single quotes are treated as string literal.<br /><br />
    <b>3.</b> Optional property type.  If this parameter is not specified, the
    property type will default to a 'string'.  Supported types are: Binary, Boolean, DateTime, Float, ID, Integer, Object and String. <br /><br />
    Smart Parameters are supported for values.<br /><br />
    Important Note: Any ruleset that calls the FNP8_SetPropertyEx action more than once, using the same Property ID as the opening parameter the
    property value will not create a multivalue property. Unlike the FNP8_SetProperty behavior, it will replace the existing property value that was set by any previous ruleset.<br/>    
  </ap>
  <h>
    Sets the designated FileNet property to a specified value.
    This is equivalent to setting an index value for a document in other document management systems.
    If the property value contains an comma then the entire property value should be contained by single quotes.<br/>
    <e>
      <b>FNP8_SetPropertyEx("DocumentTitle, @ID")</b><br />
      FNP8_Upload()
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    <b>False</b> if either parameter is blank or if the value parameter is invalid.  Otherwise <b>True.</b><br /><br />
    Note: If the action returns False, the action directs the Rulerunner task to finish
    with a status of “Abort”. The task will also abort if more than one value is assigned
    to the Smart Parameter variable.  <br/>        
  </ret>
</ref>
<ref id="FNP8_SetMultiValueProperty">
<ap>
A comma separated string consisting of these three values:<br />
  <b>1.</b> Property ID.<br />
  <b>2.</b> Property Value. Smart parameters are supported for this parameter only. A value enclosed within single quotes are treated as string literal.<br />
  <b>3.</b> An optional Property Type.  The default is a "String".  Refer to the FileNet documentation
  for a list of Property Types.
</ap>
  <h>
    This action sets the property of a FileNet P8 multi-value property.  It can be called multiple times.<br/><br/>
    The property delimiter is obtained from the application service location: "values/gen/p8delimiter" and a
    smart parameter value is supported.  If not configured, a comma will be used as the default delimiter.
    If the property value contains an comma then the entire property value should be contained by single quotes.<br/>
    <e>
FNP8_SetDocClassId("MyFilenetClass")<br />
FNP8_SetDocTitle("MyFilenetClass Documents")<br />
FNP8_SetProperty("CustomerName,@D.CustomerName")<br /><b>FNP8_SetMultiValueProperty("InvoiceList,@D.InvoiceList")</b><br />
FNP8_SetProperty("ScanStation,@STATION")<br />
FNP8_SetProperty("ScanOperator,@OPERATOR")<br />
FNP8_SetFileType("pdf")<br />
FNP8_Upload()
</e></h><lvl>All levels.</lvl><ret><b>False</b> if the ID or Value parameters are missing or if the specified property
is not a multi-value property.  Otherwise <b>True.</b></ret>
</ref>
    
<ref id="FNP8_SetTimeout">
<ap>
A single parameter identifying the timeout in milliseconds for the FileNet P8 Web Service.  
The default timeout is 600000 milliseconds (600 seconds).
</ap><h>
This action sets the timeout in milliseconds for the FileNet P8 Web Service.  
This action should be called before the FNP8_Upload action.
<e><b>FNP8_SetTimeout(90000)</b><br /><br /></e></h><lvl>All, but generally at the Batch level.</lvl><ret><b>False,</b> if DC_P8_Server.dll was not successfully installed on this computer,
or if the parameter is not formatted as a valid integer value. Otherwise, <b>True.</b><br /><br /></ret>
</ref>
    
<ref id="FNP8_Upload">
<ap>None.
</ap>
<h>
Creates new FileNet P8 documents in the specified destination folder with the image files from the Taskmaster batch.
When called at the Batch or Document level, attempts to upload a 
multipage TIF image file named ObjID.tif, where ObjID is the DCO Object ID of the 
Batch or Document.  If such a file does not exist, tries to upload all page images in 
the Batch or Document.  When called at the Page level, uploads the image file for that page.
It is important that any required properties are set before calling FNP8_Upload such as FNP8_SetDocTitle otherwise an upload error could occur.
<e> 
FNP8_SetURL("http://server:port//wsi/FNCEWS40MTOM/")<br />
FNP8_Login("user,password")<br />
FNP8_SetLocale("en-us")<br />
FNP8_SetTargetObjectID("MyObjectStore")<br />
FNP8_SetDestinationFolder("/MyTargetFolder")<br />
FNP8_SetDocClassId("MyFilenetDocClass")<br />
FNP8_SetDocTitle("@D.ID")<br />
FNP8_SetProperty("CustomerName,@D.CustomerName")<br />
FNP8_SetMultiValueProperty("InvoiceList,@D.InvoiceList")<br />
FNP8_SetProperty("ScanStation,@STATION")<br />
FNP8_SetProperty("ScanOperator,@OPERATOR")<br />
FNP8_SetFileType("pdf")<br />
<b>FNP8_Upload()</b>
</e>
</h><lvl>Batch, Document or Page level.</lvl>
<ret><b>False</b> if the upload is not successful, or the action was applied to the
Field level.  Otherwise, <b>True.</b>  If successful, each page uploaded will have a
variable “Doc_ID” set to the FileNet document identifier.<br /><br />
Note: The action directs the Rulerunner task to finish with a status of “Aborted”.
</ret>
</ref>
    
<ref id="FNP8_UploadDir">
<ap>
Two comma-separated String values:<br /><b>1.</b>	The full path of the source folder that contains the images to be uploaded. 
For example: C:\images<br /><b>2.</b>	A Boolean value to indicate if images should be deleted from the source folder.<br />
False: images will not be deleted from the source folder after they are uploaded.<br />
True: images will be deleted from the source folder after they are uploaded.
</ap><h>
Uploads all images in the folder you enter as the first parameter to the specified 
destination folder.  This action is an alternative to FNP8_Upload if you wish to 
upload images that are not within a Taskmaster batch.
<e><b>FNP8_UploadDir("C:\images,False")</b><br />
This example leaves the images in the source folder after they are uploaded.<br /><br /><b>FNP8_UploadDir("C:\images,True")</b><br />
This example deletes the images in the source folder after they are uploaded.
</e></h><lvl>Batch or Document level.</lvl><ret><b>False</b> if the upload is not successful.  Otherwise, <b>True.</b><br /><br />
Note: If the action returns False, the action directs the Rulerunner task to finish
with a status of “Aborted”.
</ret>
</ref>
    
<ref id="FNP8_SetFileType">
<ap>
A string identifying the file type.  If not provided, the value defaults to TIF.<br />
Valid types are "tif", "jpeg", "jpg", "jpe", "gif", "pdf", "xls", "doc", "msg", "docx", "xlsx","zip","mpp","vsd","ppt".
</ap><h>
Use this action to identify the file type of the files that will be uploaded to FileNet P8.
<e><b>FNP8_SetFileType("jpg")</b><br />
FNP8_Upload()
</e></h><lvl>Batch or Document level.</lvl><ret>
Always returns <b>True.</b></ret>
</ref>
    
<ref id="FNP8_SetUploadMode">
<ap>
A string or Smart Parameter identifying the page level variable where file name stored.  
If this action is not called, the value defaults to blank and regular upload logic applied.  Smart parameters are supported.<br /><br />
  
For example FNP8_SetUploadMode("ParentImage") will cause uploading file with the name stored in  'ParentImage' variable on the page level.
</ap><h>
Use this action to identify the files that will be uploaded to FileNet P8.
<e><b>FNP8_SetUploadMode("ParentImage")</b><br />
FNP8_Upload()
</e></h><lvl>Batch, Document or Page level.</lvl><ret>
Always <b>True.</b></ret>
</ref>
    
<ref id="FNP8_SetRetry" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the number of automatic upload retries.">
  <ap>
    A integer value identifies the amount of retries performed if the upload failed.  Smart parameters are supported.
</ap>
  <lvl>Batch, Document or Page level.</lvl><ret><b>False</b> if non-numeric parameter specified. Otherwise <b>True.</b></ret><h>
Use this action to set the amount of retries for the FileNet P8 upload actions.  If the upload to FileNet fails, the
upload action will immediately be retried the number of times specified by the FNP8_SetRetry action.<br /><br />
If this action is not called prior to a FileNet upload action, the default amount of retries is 0.
<e><b>FNP8_SetRetry("3")</b><br />
FNP8_Upload()<br /><br />
FNP8_SetRetry("3") will cause the FNP8_Upload to initiate 3 upload attempts if the upload to FileNet fails.
</e></h><lvl>Batch, Document or Page level.</lvl><ret><b>False,</b> if a non-numeric parameter specified.  Otherwise <b>True.</b></ret>
</ref>
    
<ref id="FNP8_SetKeyProperty">
<ap>
  Two comma-separated string values (Smart Parameters supported):
  1.  property name (symbolic name) of a document in FileNet P8 repository
  2.  corresponding value of the property
  
  There should be 1 document in the destination P8 Object Store which has matching property with the corresponding value.
  <b>IMPORTANT: The FNP8_UpdateProperties action will only update the first document returned which matches the criteria 
  specified by the parameters of this action.</b>
</ap>
  <lvl>
    Batch, Document or Page level.
  </lvl>
  <ret>
    <b>False</b> if either parameter is blank or if the value parameter is invalid. Otherwise True. 
<b>True.</b>
  </ret>
  <h>
This action sets the key that is used by the FNP8_UpdateProperties action. The key is a FileNet document property name and 
its corresponding value. The FNP8_UpdateProperties action will use the key to search for an existing FileNet P8 document. 
If the document is found, the properties on the document will be updated with the values specified in the FNP8_SetProperty 
actions.<br /><br />
    <e>
      <br /><b>FNP8_SetKeyProperty("DCKey,@DCKey")</b><br />
      FNP8_SetProperty("FNProperty,@SomeValue")<br> </br>
      FNP8_UpdateProperties()<br /><br />

      This example uses the parameters of FNP8_SetKeyProperty("DCKey,@DCKey") to search for a
      FileNet P8 document in an object store, if the FileNet document is found it will be assigned the
      values specified in the SetProperty action when the UpdateProperties action is called.
      The UpdateProperties action will only perform actions on the first document that is returned.
      If more than one document matches the criteria specified in the FNP8_SetKeyProperty action, 
      only the first document will be updated.
      <br /></e><br /></h>
</ref>


<ref id="FNP8_MultiPageDocs">
  <ap>
   Instructs the FNP8_Upload actions create a single or multiple page P8 document.
  </ap>
  <h>
    Use this action to indicate whether the upload actions should create one P8 document per page or not. <br />
    <e>
      <b></b><br></br>      
      FNP8_MultiPageDocs("True")<br />
      FNP8_Upload()<br /><br />
      FNP8_MultiPageDocs("True")<br />
      FNP8_UploadDir()<br /><br />
      Setting FNP8_MultiPageDocs("True") will instruct the FNP8_Upload or FNP8_UploadDir actions to create one P8 document that contains multiple pages. If FNP8_MultiPageDocs
      is set to "True" then the FNP8_Upload or FNP8_UploadDir actions will place all the pages listed the dco into one singe P8 document.
      The default bevhavior is for the FNP8_Upload and FNP8_UploadDir actions to create a P8 document for each individual page list in the document dco object.
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    <b>False</b> if either parameter is blank or if the value parameter is invalid.
    <b>True</b> if the multi page mode has been set successfully.
  </ret>
</ref>
    
<ref id="FNP8_UpdateProperties">
<ap>
Uses the key specified in the FNP8_SetKeyProperty action to search for an existing document 
within a FileNet P8 Content Manager Object Store and updates the P8 document’s properties as specified by the FNP8_SetProperty action.
</ap>
  <lvl>
    Batch, Document or Page level.
  </lvl>
  <ret>Action returns <b>True </b>if the update is successfully; False if the action is unable to update the document.</ret>
  <h>
Use this action to update an existing FileNet P8 document's properties. 
The UpdateProperties action should only be used to update properties for an existing document. 
If a new document is created use the Upload action. <br />
    <e>
      FNP8_SetKeyProperty ("DCKey,@DCKey)<br />
      FNP8_SetProperty("AGIncome, @AGIncome")<br />
      FNP8_SetProperty("TaxYear,@TaxYear)<br />
      <b>FNP8_UpdateProperties()</b><br /><br />
      This example will first set the key document property name and value to search
      for a document, the next two actions indicate which properties and values that
      the Filenet P8 document should be updated with. The FNP8_UpdateProperties will invoke the actual update.
      If more than one document matches the criteria specified in the SetKeyProperty action, only the first document will be updated.
    </e>
  </h>       
</ref>


<ref id="FNP8_SetSearchClass">
   <ap>
     A string value of the name (symbolic name) of the class of document to search for in Filenet P8.
     The name must be the symbolic name of a Filenet P8 class.  Smart parameters are supported.   
     The name of the class is not validated until the FNP8_SearchAndDownload action is executed.
   </ap>
   <h>
      This action is <b>required</b> prior to calling action <b>FNP8_SearchAndDownload</b>.
      <p>
         Set the name (symbolic name in P8) of the class of document to search for in Filenet P8.
      </p>
      <p> 
         By default, subclasses of the specified class will be included in the search results. 
         See action <b>FNP8_SetSearchIncludeSubClasses</b> for how to control whether or not subclasses are included. 
      </p>
      <e>
         <b>FNP8_SetSearchClass("Invoice")</b><br/>
         FNP8_SetSearchDownloadDir("C:/mylocaldir")<br />
         FNP8_SearchAndDownload()<br />
         Scan()<br/>
      </e>
   </h>
   <lvl>All levels.</lvl>
   <ret>
      <b>False</b> if parameter is not a string.  Otherwise, <b>True.</b>
   </ret>
</ref>

    <ref id="FNP8_SetSearchDownloadDir">
      <ap>
        A string value of the full directory path for where the contents of the documents returned in 
        search results should be downloaded to.  Smart parameters are supported.
      </ap>
      <h>
        This action is <b>required</b> prior to calling action <b>FNP8_SearchAndDownload</b>.
        <p>
          Set the full directory path for where the contents of the documents returned in search results should be downloaded to.       
        </p>
        <p>
          The user or process running the FNP8_SearchAndDownload action must have write permission to the directory specified by this action.  
          The existence of the directory is not validated by this action.
        </p>
        <e>
          FNP8_SetSearchClass("Invoice")<br />
          <b>FNP8_SetSearchDownloadDir("@APPPATH(vscanimagedir)")</b><br />
          FNP8_SearchAndDownload()<br />
          Scan()<br/> <br/>
          
          This example downloads the content of the search documents to the directory specified by the Smart Parameter for the VScan image directory.
        </e>
        
        <br /><br />
        <e>
            FNP8_SetSearchClass("Invoice")<br />
            <b>FNP8_SetSearchDownloadDir("C:/mylocaldir")</b><br />
            FNP8_SearchAndDownload()<br />
            Scan()<br/>
           <br/>
            This example downloads the content of the search documents to the directory "C:/mylocaldir".
        </e>       
        <br />
      </h>
      <lvl>All levels.</lvl>
      <ret>
        <b>False</b> if parameter is not a string.  Otherwise, <b>True.</b>
      </ret>
    </ref>

    <ref id="FNP8_SetSearchWhereClause">
      <ap>
        A string value of the SQL search criteria (i.e. the WHERE clause).  The criteria should follow the standard used
        by Filenet P8 query, which generally conforms to the SQL-92 standard.  Please reference the Filenet P8
        Knowledge Center for a complete description. Smart parameters are supported.
        The clause is not validated until the FNP8_SearchAndDownload action is executed.
      </ap>
      <h>
        This action is <b>optional</b> prior to calling action <b>FNP8_SearchAndDownload</b>.        
        <p>
          Set the SQL search criteria (i.e. the WHERE clause).   Set to empty string "" to unset a previously set WHERE clause.
          Note that only parametric search is supported, not content-based (full-text) search. 
        </p>
        <p>
          The syntax of the WHERE clause is not validated until the FNP8_SearchAndDownload action is executed.
          The SQL search criteria must follow the IBM FileNet standard, which generally conforms to SQL-92, 
          with extensions for IBM FileNet specific constructs. For a complete description, see the 
          IBM Knowledge Center for IBM FileNet P8 Platform.
        </p>
        <e>
          FNP8_SetSearchClass("Invoice")<br />
          FNP8_SetSearchDownloadDir("C:/mylocaldir")<br />
          <b>FNP8_SetSearchWhereClause("DocumentTitle LIKE '2017-Invoices%'")</b><br />
          FNP8_SearchAndDownload()<br />
          <br/>
        </e>
      </h>
      <lvl>All levels.</lvl>
      <ret>
        <b>False</b> if parameter is not a string.  Otherwise, <b>True.</b>
      </ret>
    </ref>

    <ref id="FNP8_SetSearchMaxItems">
      <ap>
        A string representing an integer value for the maximum number of items to return in search results. Smart parameters are supported.
      </ap>
      <h>
        This action is <b>optional</b> prior to calling action <b>FNP8_SearchAndDownload</b>.
        <p>
          Optionally, set the maximum number of search results.  Set to "0" or any value less than "0" for no maximum.  <b>If not set, the default maximum is 1000.</b>
        </p>
        <e>
            FNP8_SetSearchClass("Invoice")<br />
            FNP8_SetSearchDownloadDir("C:/mylocaldir")<br />
            <b>FNP8_SetSearchMaxItems(“100”)</b><br />
            FNP8_SearchAndDownload()<br />                  
          <br/>
        </e>
      </h>
      <lvl>All levels.</lvl>
      <ret>
        <b>False</b> if parameter is not an string numerical value.  Otherwise, <b>True.</b>
      </ret>
    </ref>

    <ref id="FNP8_SetSearchFolderRestriction">
      <ap>
        A string of the folder path in FileNet P8 repository to restrict search results to. Smart parameters are supported.
        The folder path is not validated until the FNP8_SearchAndDownload action is executed.
      </ap>
      <h>
        This action is <b>optional</b> prior to calling action <b>FNP8_SearchAndDownload</b>.
        <p>
          Set a FileNet P8 folder path to restrict the search results. The search results will <b>not</b> include subfolders of the folder.  Set to empty string "" 
          to unset a previously set value.
        </p>
        <p>
          If this action is used to set a folder path, the action "FNP8_SearchAndDownload" will set the folder restriction using the FileNet P8 API method "SQLSearch.SetFolderRestriction".
        </p>
        <p>
          NOTE: Setting the folder restriction may result in only document versions with version state value of "Released" being included in search result.  Refer to FileNet P8 
          documentation to confirm expected behavior.
        </p>
        <e>
          FNP8_SetSearchClass("Invoice")<br />
          FNP8_SetSearchDownloadDir("C:/mylocaldir")<br />
          <b>FNP8_SetSearchFolderRestriction("/MyFolder/MySubfolderA“)</b><br />
          FNP8_SearchAndDownload()<br />
        </e>
      </h>
      <lvl>All levels.</lvl>
      <ret>
        <b>False</b> if parameter is not a string.  Otherwise, <b>True.</b>
      </ret>
    </ref>

    <ref id="FNP8_SetSearchOrderBy">
      <ap>
        A string value of the ORDERBY clause for sorting search results. Smart parameters are supported.
        The clause is not validated until the FNP8_SearchAndDownload action is executed.  
        The expected format of the parameter is: PROPERTY_NAME ASC|DESC
      </ap>
      <h>
        This action is <b>optional</b> prior to calling action <b>FNP8_SearchAndDownload</b>.
        <p>
          Set the ORDERBY clause for the search results.  Set to empty string "" to unset a previously set value.
        </p>
        The parameter is not validated until the SearchAndDownload is run.<br/><br/>
        <e>
          FNP8_SetSearchClass("Invoice")<br />
          FNP8_SetSearchDownloadDir("C:/mylocaldir")<br />
          <b>FNP8_SetSearchOrderBy("DocumentTitle ASC“)</b> <br/>
          FNP8_SearchAndDownload()<br />
        </e>  <br/>
        In this example, the results are sorted by DocumentTitle in ascending order.
        <br/>
        <e>
          FNP8_SetSearchClass("Invoice")<br />
          FNP8_SetSearchDownloadDir("C:/mylocaldir")<br />
          <b>FNP8_SetSearchOrderBy("DocumentTitle DESC“)</b><br/>
          FNP8_SearchAndDownload()<br />
        </e><br/>
        In this example, the results are sorted by DocumentTitle in descending order. <br/>
      </h>
      <lvl>All levels.</lvl>
      <ret>
        <b>False</b>  if parameter is not a string.  Otherwise, <b>True.</b>
      </ret>
    </ref>

    <ref id="FNP8_SetSearchIncludeDocsWithoutContent">
      <ap>
        A string representing a boolean value ("True" or "False") for whether or not to include documents without content in the search results.
        Smart parameters are supported.
      </ap>
      <h>
        This action is <b>optional</b> prior to calling action <b>FNP8_SearchAndDownload</b>.
        <p>
          Set to "True" to <b>include</b> documents without content in search results.<br/><br/>
          Set to "False" to <b>filter out</b> documents without content from search results.<br/><br/>
          If not set, <b>the default is False</b>. <br/> <br/>
          If an invalid value is given for the parameter (i.e. not "True" or "False"), then the action has no effect on the setting and the setting stays the
          same value as it was prior to the action. <br/> <br/>
          In general, it should <b>not</b> be necessary to change the default setting which filters out content-less documents from the search results since there 
          should be no content to download for those documents.  This action is only provided in case there is any unexpected behavior with the search clause used to 
          filter out content-less documents, and there is a need to turn off the filtering.          
        </p>
        <p>
          When this setting is "False", the search criteria used by "FNP8_SearchAndDownload" will include the condition "ContentSize > 0".
        </p>
        <e>
          FNP8_SetSearchClass("Invoice")<br />
          FNP8_SetSearchDownloadDir("C:/mylocaldir")<br />
          <b>FNP8_SetSearchIncludeDocsWithoutContent("True")</b><br />
          FNP8_SearchAndDownload()<br />
        </e>
      </h>
      <lvl>All levels.</lvl>
      <ret>
        <b>True</b>
      </ret>
    </ref>

    <ref id="FNP8_SetSearchIncludeSubClasses">
      <ap>
        A string representing a boolean value ("True" or "False") for whether or not to include documents of the subclasses of the search class
        in the search results. Smart parameters are supported.
      </ap>
      <h>
        This action is <b>optional</b> prior to calling action <b>FNP8_SearchAndDownload</b>.
        <p>
          Set to “True” to include documents of the class specified by the action FNP8_SetSearchClass <b>and</b> all the subclasses of the 
          search class in search results.<br/><br/>

          Set to “False” to include documents of <b>only</b> of the class specified by the action FNP8_SetSearchClass in search results.<br/><br/>
          
          If not set, the default is <b>True</b>.<br/><br/>

          If an invalid value is given for the parameter (i.e. not "True" or "False"), then the action has no effect on the setting and the setting stays the
          same value as it was prior to the action.
        </p>
        <p>
          The value of this setting is used by the action "FNP8_SearchAndDownload" to set the search behavior using the FileNet P8 API method "SQLSearch.SetFromClauseInitialValue".
        </p>
        <e>
          FNP8_SetSearchClass("Invoice")<br />
          FNP8_SetSearchDownloadDir("C:/mylocaldir")<br />
          <b>FNP8_SetSearchIncludeSubClasses("False")</b><br />
          FNP8_SearchAndDownload()<br />
        </e>
      </h>
      <lvl>All levels.</lvl>
      <ret>
        <b>True</b>
      </ret>
    </ref>

    <ref id="FNP8_SetSearchCurrentVersionOnly">
      <ap>
        A string representing a boolean value ("True" or "False") for whether or not to limit the search results to only the current version of documents.
        Smart parameters are supported.
      </ap>
      <h>
        This action is <b>optional</b> prior to calling action <b>FNP8_SearchAndDownload</b>.
        <p>
          Set to “True” to limit the search results to only the current version of documents.<br/><br/>
          
          Set to “False” to allow search results to include any version of documents. <br/><br/>
          
          If not set, the <b>default value is "True"</b>.<br/><br/>
          
          If an invalid value is given for the parameter (i.e. not "True" or "False"), then the action has no effect on the setting and the setting stays the 
          same value as it was prior to the action.
          <br/>
        </p>
        <p>
          When set to "True", the search criteria used by the action "FNP8_SearchAndDownload" will include the condition "IsCurrentVersion=True".
        </p>
        <e>
          FNP8_SetSearchClass("Invoice")<br />
          FNP8_SetSearchDownloadDir("C:/mylocaldir")<br />
          <b>FNP8_SetSearchCurrentVersionOnly("False")</b><br />
          FNP8_SearchAndDownload()<br />
        </e>
      </h>
      <lvl>All levels.</lvl>
      <ret>
        <b>True</b>
      </ret>
    </ref>

    <ref id="FNP8_SetSearchAndDownloadStatusProperty">
      <ap>
        A name (symbolic name) of an existing integer property of the Filenet P8 document class specified by the action "FNP8_SetSearchClass".
        Smart parameters are supported.  The name of the property is not validated until the FNP8_SearchAndDownload action is executed.  
        <b>IMPORTANT: The "FNP8_SearchAndDownload" action will update the value of this specified property.</b>
      </ap>
      <h>
        This action is <b>optional</b> prior to calling action <b>FNP8_SearchAndDownload</b>.
        <p>
          Set the name of an integer property of the FileNet P8 document that the "FNP8_SearchAndDownload" action will flag 
          (set to value of 1) to indicate that the document has already been downloaded by Datacap.  On subsequent executions of 
          "FNP8_SearchAndDownload()", the P8 documents that have been downloaded (i.e. have status property value set to 1) will not 
          be downloaded again.
        </p>
        <p>
          The default behavior if no status property is set is that no properties on the P8 document will be updated by the "FNP8_SearchAndDownload" action
          when a P8 document is downloaded, and no status property will be checked when searching for documents.
        </p>
        <p>
          Set to empty string "" to unset a previously set status property.  
        </p>
        <e>
          FNP8_SetSearchClass("Invoice")<br />
          FNP8_SetSearchDownloadDir("C:/mylocaldir")<br />
          <b>FNP8_SetSearchAndDownloadStatusProperty("myStatusProp")</b><br />
          FNP8_SearchAndDownload()<br /><br />

          In this example, "FNP8_SearchAndDownload()" will download P8 documents of class "Invoice" and set the property "myStatusProp"
          to value of 1 for each document that is downloaded.  When "FNP8_SearchAndDownload()" action performs its search, any documents 
          with "myStatusProp=1" will be excluded from the search and will not be downloaded.
          <br/>
        </e>
        <br/>
        <e>
          FNP8_SetSearchClass("Invoice")<br />
          FNP8_SetSearchDownloadDir("C:/mylocaldir")<br />
          <b>FNP8_SetSearchAndDownloadStatusProperty("")</b><br />
          FNP8_SearchAndDownload()<br /><br />

          In this example, FNP8_SetSearchAndDownloadStatusProperty("") unsets any previously set value for the download status
          property name.  "FNP8_SearchAndDownload()" will download P8 documents of class "Invoice", but will <b>not</b> set a status
          property on documents that have been downloaded.  When "FNP8_SearchAndDownload()" actions performs its search, there is no
          check of a status property, so P8 documents that may have been previously been downloaded will be included.
          <br/>
        </e>
        
      </h>
      <lvl>All levels.</lvl>
      <ret>
        <b>False</b>  if parameter is not a string.  Otherwise, <b>True.</b>  The existence of the property on the document class is not verified until
        FNP8_SearchAndDownload is run.
      </ret>
    </ref>
    <ref id="FNP8_SearchAndDownload">
      <ap>
        Uses the parameters set in the FNP8_SetSearch* methods for executing the search against FileNet P8 repository.
      </ap>
      <h>
        Executes a search for documents in FileNet P8 and downloads the content of the documents returned by the search. <br /><br />

        By default, the maximum number of search results is limited to <b>1000</b> documents.  Use the action <b>FNP8_SetSearchMaxItems</b> to set a different maximum.
        <br /><br />
        
        The user or process executing the action must have write permissions for the directory.  If a file already exists in the directory
        with the same name as the content being downloaded, the existing file will be overwritten.
        <br /><br />
      <p>
        The following actions are <b>REQUIRED</b> to be called prior to calling <b>FNP8_SearchAndDownload</b>.  See the help for these actions for more details.
        <b>
        <ul>
          <li>FNP8_SetURL</li>
          <li>FNP8_Login</li>
          <li>FNP8_SetTargetObjectID</li>
          <li>FNP8_SetSearchClass</li>
          <li>FNP8_SetSearchDownloadDir</li>
        </ul>
        </b>
      </p>
      <p>
        The following actions can <b>OPTIONALLY</b> be called prior to calling <b>FNP8_SearchAndDownload</b>.  See the help for these actions for more details. <br /><br />
        <b>
          Important: Use the actions below, as needed, to filter which documents are downloaded by the FNP8_SearchAndDownload action.</b><br/><br/>
       <b>
       <ul>
        <li>FNP8_SetSearchWhereClause</li>
        <li>FNP8_SetSearchFolderRestriction</li>
        <li>FNP8_SetSearchOrderBy</li>
        <li>FNP8_SetSearchMaxItems</li>
        <li>FNP8_SetSearchCurrentVersionOnly</li>
        <li>FNP8_SetSearchIncludeDocsWithoutContent</li>
        <li>FNP8_SetSearchIncludeSubclasses</li>
        <li>FNP8_SetSearchAndDownloadStatusProperty</li>
       </ul>
       </b>
     </p>
        <e>
          FNP8_SetURL("http://myp8server:9080/wsi/FNCEWS40MTOM/")<br />
          FNP8_Login("User1,Password1")<br />
          FNP8_SetTargetObjectID("AP_ObjectStore")<br />
          FNP8_SetSearchClass("Invoice")<br />
          FNP8_SetSearchDownloadDir("@APPPATH(vscanimagedir)")<br />
          FNP8_SetSearchWhereClause("DocumentTitle LIKE '2017-Invoices%'")<br />
          FNP8_SetSearchMaxItems(“100”)<br />
          FNP8_SetSearchOrderBy("InvoiceDate ASC“)<br />
          <b>FNP8_SearchAndDownload()</b><br />
          Scan()<br/>

        <br /><br />
        This example will search for documents of "Invoice" class which have property "DocumentTitle" matching the
        wildcard string '2017-Invoice%', sort the results in ascending order based on the InvoiceDate property,
        take the top 100 results and download the contents of those documents to the directory specified in the Smart Parameter
        for the VScan image directory.
        <br /><br />
        
        The output file name will be a concatenation of the FileNet P8 item ID and the original upload file name of 
        the content (if it exists).  If the original upload file name does not exist, then the default file extension 
        would be ".tif" if the mime type of the content is "image/tiff". <br /><br />
        
        <b>Example:  {3054025F-0000-CE12-B41A-7B2661D28802}.Flight1.tif.</b><br /><br />
        
        When the Scan() action runs, it will see the populated image directory and process as usual.<br /><br />
          
        </e><br /><br />
        <e>
          FNP8_SetURL("http://myp8server:9080/wsi/FNCEWS40MTOM/")<br />
          FNP8_Login("User1,Password1")<br />
          FNP8_SetTargetObjectID("AP_ObjectStore")<br />
          FNP8_SetSearchClass("Invoice")<br />
          FNP8_SetSearchDownloadDir("@APPPATH(vscanimagedir)")<br />
          FNP8_SetSearchWhereClause("DocumentTitle LIKE '2017-Invoices%'")<br />
          FNP8_SetSearchMaxItems(“100”)<br />
          FNP8_SetSearchAndDownloadStatusProperty("myStatusProp")<br />
          <b>FNP8_SearchAndDownload()</b><br />
          Scan()<br/><br />

          This example is similar to earlier one.  The main differences:<br />
            1. For each document downloaded, the property "myStatusProp" of the document will be set to value of 1.<br />
            2. When searching for documents, any documents which have "myStatusProp=1" will excluded from the search.
          <br /><br />
        </e><br />

      </h>
      <lvl>All levels.</lvl>
      <ret>
        <b>False</b> if any errors occur.  Otherwise, <b>True.</b>
      </ret>
    </ref>

    <ref id="FNP8_AddRedactionsToP8Document">
      <ap>
        None.  The page property "PageName" is used.
      </ap>
      <h>
        This action updates an existing FileNet P8 document by adding redactions (if any fields have been redacted). <br /><br />
        <b>IMPORTANT: </b>This action can only be used for documents that were downloaded by <b>FNP8_SearchAndDownload</b> action, or that have
        filenames beginning with the P8 document ID.  Example: "{3054025F-0000-CE12-B41A-7B2661D28802}.APT008.tif" <br /> <br />
        <e>
          FNP8_SetSearchClass("Invoice")<br />
          FNP8_SetSearchDownloadDir("C:/mylocaldir")<br />
          FNP8_SetSearchWhereClause("DocumentTitle LIKE '2017-Invoices%'")<br />
          FNP8_SearchAndDownload()<br />
          Scan()<br/>
          RedactFields("CCPattern1", "Redact_CreditCard", "4,4,4,4", True)<br/>
          <b>FNP8_AddRedactionsToP8Document()</b>
        </e>
      </h>
      <lvl>Page level.</lvl>
      <ret>
        <b>False</b> if any errors occur or if the action is run on any level that is not page level.  Otherwise, <b>True.</b>
      </ret>
    </ref>
    
  </help>

</rrx>
<rrx namespace="Flex" src="c:\datacap\RRS\Flex.dll">

<i ref="rrunner">
</i>
<i ref="validations">
</i>
<i ref="barcode_p">
</i>
<i ref="zones">
</i>
<i ref="picture">
</i>
<i ref="locate">
</i>
<i ref="invoice">
</i>
<i ref="redaction">
</i>
<af name="SetSELECTonField" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="IntellocateHeaderFields" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="ValidateVendor" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="ReadConfigurationDB" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="CreateFlexFields" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="SetFieldValidationVariables" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="ClearFlexFieldType" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="ValidateFlexField" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="WriteFlexXMLHeader" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="WriteFlexXMLFooter" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="WriteFlexXML" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="SetFieldLocateVariables" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="LocateFlexField" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="PerformAdditionalFlexActions" access="public" bInter="bInteractive" bDebug="bDebug">
</af>
<af name="DeleteChildByType" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="FlexRegExFind" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="FlexKeywordListFind" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<af name="FlexLastKeywordListFind" access="public" bInter="bInteractive" bDebug="bDebug" strParam="StrParam">
</af>
<f name="CheckP8Config" access="public">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Your VBScript code goes here.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    CheckP8Config = TRUE       'Actions must always return a TRUE or FALSE.]]>
<![CDATA[
]]>
<![CDATA[    LogMessage = "You must go into file " & P8ConfigFile & " and fill out this entry to export to P8."]]>
<![CDATA[
]]>
<![CDATA[     Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[     Dim oPage]]>
<![CDATA[
]]>
<![CDATA[     Dim oField]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     For i = 0 to DCO.NumOfChildren-1   'loop through docs]]>
<![CDATA[
]]>
<![CDATA[          Set oDoc = DCO.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Checking document: " & oDoc.ID)]]>
<![CDATA[
]]>
<![CDATA[          Set oPage = oDoc.GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Main_Page ID: " & oPage.ID)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          for j = 0 to oPage.NumOfChildren - 1   'loop through fields]]>
<![CDATA[
]]>
<![CDATA[                Set oField = oPage.GetChild(j)]]>
<![CDATA[
]]>
<![CDATA[                Writelog("Checking field: " & oField.ID)]]>
<![CDATA[
]]>
<![CDATA[                 If oField.Type = "DocType" then]]>
<![CDATA[
]]>
<![CDATA[                     CurrentDocType = oField.Text]]>
<![CDATA[
]]>
<![CDATA[                      Writelog("CurrentDocType: " & CurrentDocType)]]>
<![CDATA[
]]>
<![CDATA[                       retn = Pilot.GetProfileString(CurrentDocType,"P8DocClass","*",P8ConfigFile)]]>
<![CDATA[
]]>
<![CDATA[                       if retn = "*" then]]>
<![CDATA[
]]>
<![CDATA[                            Call Pilot.SetProfileString(CurrentDocType,"P8DocClass","",P8ConfigFIle)]]>
<![CDATA[
]]>
<![CDATA[                            Writelog("P8Config Error:  Missing P8DocClass entry for  [" & CurrentDocType & "]")]]>
<![CDATA[
]]>
<![CDATA[                            Writelog(LogMessage)]]>
<![CDATA[
]]>
<![CDATA[                       end if]]>
<![CDATA[
]]>
<![CDATA[                 end if]]>
<![CDATA[
]]>
<![CDATA[                 if oField.Type = "FlexField" then]]>
<![CDATA[
]]>
<![CDATA[                       retn = Pilot.GetProfileString(CurrentDocType,oField.ID,"*",P8ConfigFile)]]>
<![CDATA[
]]>
<![CDATA[                       if retn = "*" then]]>
<![CDATA[
]]>
<![CDATA[                            CheckP8Config = FALSE]]>
<![CDATA[
]]>
<![CDATA[                            Writelog("P8Config Error:  Missing entry for document [" & CurrentDocType & "] property: " & oField.ID)]]>
<![CDATA[
]]>
<![CDATA[                            Writelog(LogMessage)]]>
<![CDATA[
]]>
<![CDATA[                             Call Pilot.SetProfileString(CurrentDocType,oField.ID,"",P8ConfigFile)]]>
<![CDATA[
]]>
<![CDATA[                       end if]]>
<![CDATA[
]]>
<![CDATA[                       if TRIM(retn) = "" then]]>
<![CDATA[
]]>
<![CDATA[                             Writelog("P8Config Error: Blank entry for document [" & CurrentDocType & "] property: " & oField.ID)]]>
<![CDATA[
]]>
<![CDATA[                             Writelog(LogMessage)]]>
<![CDATA[
]]>
<![CDATA[                        end if]]>
<![CDATA[
]]>
<![CDATA[                 end if]]>
<![CDATA[
]]>
<![CDATA[         Next 'j]]>
<![CDATA[
]]>
<![CDATA[     Next 'i]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<f name="SetP8FlexProperties" access="public">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Your VBScript code goes here.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    SetP8FlexProperties = TRUE       'Actions must always return a TRUE or FALSE.]]>
<![CDATA[
]]>
<![CDATA[    Dim oField]]>
<![CDATA[
]]>
<![CDATA[    Dim PropAr]]>
<![CDATA[
]]>
<![CDATA[    for i = 0 to CurrentObj.NumOfChildren - 1   'loop through fields]]>
<![CDATA[
]]>
<![CDATA[           Set oField = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[           Writelog("Checking field: " & oField.ID)]]>
<![CDATA[
]]>
<![CDATA[           If oField.Type = "DocType" then]]>
<![CDATA[
]]>
<![CDATA[              CurrentDocType = oField.Text]]>
<![CDATA[
]]>
<![CDATA[              Writelog("CurrentDocType: " & CurrentDocType)]]>
<![CDATA[
]]>
<![CDATA[              retn = Pilot.GetProfileString(CurrentDocType,"P8DocClass","*",P8ConfigFile)]]>
<![CDATA[
]]>
<![CDATA[               if retn = "*" then ]]>
<![CDATA[
]]>
<![CDATA[                     Writelog("P8Config Error:  Unable to find document class.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[                     Exit Function]]>
<![CDATA[
]]>
<![CDATA[                end if    ]]>
<![CDATA[
]]>
<![CDATA[                Writelog("Setting P8 Document Class to: " & retn)]]>
<![CDATA[
]]>
<![CDATA[                 Call  FNP8_SetDocClassID(false,false,retn)          ]]>
<![CDATA[
]]>
<![CDATA[            end if]]>
<![CDATA[
]]>
<![CDATA[            if oField.Type = "FlexField" then]]>
<![CDATA[
]]>
<![CDATA[               retn = Pilot.GetProfileString(CurrentDocType,oField.ID,"*",P8ConfigFile)]]>
<![CDATA[
]]>
<![CDATA[                if ((retn = "*") OR (Trim(retn) ="")) then]]>
<![CDATA[
]]>
<![CDATA[                    Writelog("P8Config Error: Missing or blank entry for document [" & CurrentDocType & "] property: " & oField.ID)]]>
<![CDATA[
]]>
<![CDATA[                    Exit Function]]>
<![CDATA[
]]>
<![CDATA[                 end if]]>
<![CDATA[
]]>
<![CDATA[                 PropAr = SPLIT(retn,",")]]>
<![CDATA[
]]>
<![CDATA[                 PropName = PropAr(0)]]>
<![CDATA[
]]>
<![CDATA[                 Writelog("Setting P8 property type to: " & PropName)]]>
<![CDATA[
]]>
<![CDATA[                 if uBound(PropAr) > 0 then]]>
<![CDATA[
]]>
<![CDATA[                      DataType = PropAr(1)]]>
<![CDATA[
]]>
<![CDATA[                     Writelog("Setting P8 DataType to: " & DataType)]]>
<![CDATA[
]]>
<![CDATA[                 end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[                Writelog("Setting P8 property type to: " & PropName)]]>
<![CDATA[
]]>
<![CDATA[                if DataType = "" then]]>
<![CDATA[
]]>
<![CDATA[                    Writelog("Using: " & PropName & "," & oField.Text)]]>
<![CDATA[
]]>
<![CDATA[                    Call FNP8_SetProperty(false,false,PropName & "," & oField.Text)]]>
<![CDATA[
]]>
<![CDATA[                 else]]>
<![CDATA[
]]>
<![CDATA[                    Writelog("Using: " & PropName & "," & oField.Text & "," & DataType)]]>
<![CDATA[
]]>
<![CDATA[                    Call FNP8_SetProperty(false,false,PropName & "," & oField.Text & "," & DataType)]]>
<![CDATA[
]]>
<![CDATA[                 End if]]>
<![CDATA[
]]>
<![CDATA[                 'Call FNP8_SetProperty(false,false,PropName & "," & DataType)]]>
<![CDATA[
]]>
<![CDATA[           end if]]>
<![CDATA[
]]>
<![CDATA[   Next 'i  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<f name="GetPageBarcode" access="public">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Your VBScript code goes here.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    GetPageBarcode = TRUE       'Actions must always return a TRUE or FALSE.]]>
<![CDATA[
]]>
<![CDATA[    Call ZoneLeft_ImageLeft(false,false)]]>
<![CDATA[
]]>
<![CDATA[    Call ZoneRight_ImageRight(false,false)]]>
<![CDATA[
]]>
<![CDATA[    Call ZoneTop_ImageTop(false,false)]]>
<![CDATA[
]]>
<![CDATA[    Call ZoneBottom_ImageBottom(false,false)]]>
<![CDATA[
]]>
<![CDATA[    Call GetBarcodeBP(false,false)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<help>
  <![CDATA[
'*****************************************************************************
' help.xml for Flex
'-----------------------------------------------------------------------------
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2016 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'*****************************************************************************
'
]]>

<ref id="ActionName">
  <ap>None.</ap>
  <h>
    This action changes the <i>something</i> condition of a <b>Page</b> object - and
    its <b>Field</b> objects - from <i>Off</i> to <i> On</i>.<br/><br/>

    The <i>On</i> condition prevents a rule and its actions from assigning a "problem" status to a
    field - even if the field's value fails validation.<br/>
    <e>
      <b>ActionName()</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    AnotherAction
  </see>
</ref>
   
  <ref id="SetDynamicDetailZones">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the SetDynamicDetailZones action in the Invoice action library.
      <br/><br/>
      <b>*** Original Description ***</b><br/>
      StrParam is Zone Bottom field. If more than one field is listed, Zone Bottom must be first field, and additional fields are ignored.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="LoadCCOFromField">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the LoadCCOFromField action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ScanLineItemDynamic">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the ScanLineItemDynamic action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="AllowOnlyChars">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the AllowOnlyChars action in the Validations action library.      
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="PopulateZNLineItemFieldDynamic">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the PopulateZNLineItemFieldDynamic action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
</ref >
  
  <ref id="CalculateNotesZone">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the CalculateNotesZone action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ParseImageName">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.  Instead, use the FileIO action library.
      Use SplitFileName with smart parameters.  For example: <br/><br/>

      SplitFileName("@P.ScanSrcPath","","","@P\Fieldname.Text","")<br/>
      See the action help for details.<br/><br/><br/>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsFingerPrintClass">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the IsFingerPrintClass action in the Invoice action library.
      <br/><br/>
      <b>*** Original Description ***</b><br/>
      Two comma separated parameters:
      1. The database connection string.  Smart parameters are supported.
      2. Fingerprint class.

      This action connects to the fingerprint database and verifies that the specified fingerprint
      class contains the fingerprint ID of the current page.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >

  <ref id="MovePDF">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.  Instead, use the FileIO action library.
      Use RenameFile to move the file using smart parameters.  For example: <br/><br/>

      RenameFile("@DCO(BATCHDIR)+\+MyFile.pdf","@APPPATH(export)+\+MyFile.pdf",true)<br/>
      See the action help for details.<br/><br/><br/>

      <b>*** Deprecated Help Description ***</b><br/>
      This action moves the PDF associated with the current document to the specified directory.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see> 
  </ref >
  
  <ref id="iloc_SetDetailSimple">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the iloc_SetDetailSimple action in the Invoice action library.
      <br/><br/>
      <b>*** Original Description ***</b><br/>
      Action fills Setup DCO from Runtime Data file Parameter is the DETAIL DCO TYPE
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="Is_InCharSet">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.  Instead, use the Picture action library.
      First call the action PIC_SetPictureCharacter to set the list of valid
      characters with a custom picture string.  Multiple lists can be defined as necessary.
      Then call PIC_ApplyPictureString to validate the field with the custom picture string.
      See the action help for details.<br/><br/><br/>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsBatchVariable">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the rrCompare action in the Rrunner action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsMultipageDocument">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the IsMultipageDocument action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsSinglePageDocument">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the IsSinglePageDocument action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="DoMsgbox">
    <ap>
      The message to display.
    </ap>
    <h>
      This Action is Deprecated, its functionality is no longer supported.

      The message is displayed to the user and they must press "OK" to continue.<br/><br/>

      <b>Note:</b> This action must not be used within a ruleset that is run
      unattended or processing will stop.
      <e>
        CheckDCOStatus("75")<br/>
        <b>DoMsgbox("The page was deleted.")</b>
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref >
  
  <ref id="IsChildFieldValue">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.  Instead, use the rrunner action library.
      Use rrCompare with smart parameters.  For example, <br/><br/>

      rrCompare("Expected Value", "@F\MyFieldToTest")<br/>
      See the action help for details.<br/><br/><br/>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="CreateFingerprint">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the CreateFingerprint action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="SetPicChar">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the PIC_SetPictureCharacter action in the Picture action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ApplyPictureString">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.  Instead, use the Picture action library.
      First call the action PIC_SetPictureCharacter to set the list of valid
      characters with a custom picture string.  Multiple lists can be defined as necessary.
      Then call PIC_ApplyPictureString to validate the field with the custom picture string.
      See the action help for details.<br/><br/><br/>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="WriteErrorMessage">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the WriteErrorMessage action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsInList">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the IsInList action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsInINI">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the IsInINI action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsTaskName">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.  Instead, use the rrunner action library.
      Use rrCompare to test using smart parameters.  For example: <br/><br/>

      rrCompare("MyExpectedName", "@TASKNAME")<br/>
      See the action help for details.<br/><br/><br/>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="DetailFix">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the DetailFix action in the Invoice action library.
      <br/><br/>
      <b>*** Original Description ***</b><br/>
      Action is meant to be placed on the LineItem field.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="CheckForSticky">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the CheckForSticky action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsCurrentObjVariable">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the rrCompare action in the Rrunner action library.      
      <e>
        <b>rrCompare("@F.Sticky","No")</b><br/>
        SkipChildren()
      </e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IsChildFieldBlank">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.  Instead, use the rrunner action library.
      Use rrCompare with smart parameters.  For example, <br/><br/>

      rrCompare("@EMPTY", "@F\MyFieldToTest")<br/>
      See the action help for details.<br/><br/><br/>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="SetStickyNo">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the SetStickyNo action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ClearErrorMsg">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the ClearErrorMsg action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="AddToErrorMsg">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the AddToErrorMsg action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret>always return False</ret>
    <see></see>
  </ref >
  
  <ref id="IsStationIDSuffix">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the IsStationIDSuffix action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="OpenConnection">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the OpenConnection action in the Lookup action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ExecuteSQLBind">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the SmartSQL action in the Lookup action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="Is_JobName">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.  Instead, use the rrunner action library.
      Use rrCompare to test the job name using smart parameters.  For example, <br/><br/>

      rrCompare("MyExpectedName", "@JOBNAME")<br/>
      See the action help for details.<br/><br/><br/>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="SetSELECTonField">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="SaveObjectVariable">
      <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the rrSet action in the Rrunner action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="IntellocateHeaderFields">
    <ap></ap>
    <h>
      Action write fingerprint.xml from runtime page file Parameter is FingerprintDir,HostName,HostID
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ReadFPXMLZones">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the ReadFPXMLZones action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="FPXMLUsed">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the FPXMLUsed action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="SwitchMMDD">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the SwitchMMDD action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ValidateVendor">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the ValidateVendor action in the Invoice action library.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="FindExportImage">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.
      Instead, use the FindExportImage action in the Invoice action library.
      <br/><br/>
      <b>*** Original  Description ***</b><br/>
      1 - Document Level TIFF<br/>
      2 - Document Level PDF<br/>
      3 - Page Level TIO<br/>
      4 - Page Level TIF<br/>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ReadConfigurationDB">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="CreateFlexFields">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="SetFieldValidationVariables">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ClearFlexFieldType">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="ValidateFlexField">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="WriteFlexXMLHeader">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="WriteFlexXMLFooter">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="WriteFlexXML">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="SetFieldLocateVariables">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="LocateFlexField">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="PerformAdditionalFlexActions">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="DeleteChildByType">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="FlexRegExFind">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="FlexKeywordListFind">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >
  
  <ref id="FlexLastKeywordListFind">
    <ap></ap>
    <h>
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see>
  </ref >

  <ref id="SetToDocIDMPTIFF">
    <ap></ap>
    <h>
      <b>*** This Action Is Deprecated ***</b><br/>
      This action has been deprecated and is scheduled to be removed in a future release.
      It is recommended that you no longer use this action.  Instead, use the rruner action library.
      Use rrSet with smart parameters.  For example: <br/><br/>

      rrSet("@APPPATH(export)+\+@ID+.tif","@F\FieldName.text")<br/>
      See the action help for details.<br/><br/><br/>


      <b>*** Deprecated Help Description ***</b><br/>
        The path to the exported tiff files.
    
        This action builds a full path to the a tiff file and sets the field text to this value.
        The path consists of the export path + DOCID + .TIF.
        The value is put into the field
        so it can be access later in the application, if necessary.  It only builds the path.
        The action does not output the TIF file.
      <e></e>
    </h>
    <lvl></lvl>
    <ret></ret>
    <see></see> 
  </ref >

  <ref id="CheckP8Config">
    <ap>
      None<br/>
    </ap>
    <h>
      Flex only.  Checks for completeness of the P8Config.ini file.  If an entry is blank, this action fails.  If an entry is missing in the file, it adds it (leaving it blank) and fails.<br/>
      <e>
        Function1:
        CheckP8Config()<br/>
        Function2:
        SkipChildren()<br/>
      </e>
    </h>
    <lvl>
      Designed to run at the batch level
    </lvl>
    <ret>
      If the P8Config.ini has missing or blank entries, it adds the entry (if missing) and returns <b>FALSE.</b>  Otherwise, <b>TRUE.</b>
    </ret>
    <see>
      Reference other related actions here <br/>
      <scr>RelatedFunctionName</scr>
    </see>
  </ref>

  <ref id="SetP8FlexProperties">
    <ap>
      None<br/>
    </ap>
    <h>
      For Flex only.  Sets the P8 Document Class and Properties defined in the P8Config.ini<br/>
      <e>
        SetP8FlexProperties()<br/>
      </e>
    </h>
    <lvl>
      Field level only
    </lvl>
    <ret>
      Always <b>TRUE.</b>
    </ret>
    <see>
      Reference other related actions here <br/>
      <scr>RelatedFunctionName</scr>
    </see>
  </ref>

  <ref id="GetPageBarcode">
    <ap>
      None<br/>
    </ap>
    <h>
      Sets the field dimensions to the entire page before recognizing the barcode to the field.  Note, if
      a combined CCO is used, then the entire document is searched.<br/>
      <e>
        GetPageBarcode<br/>
      </e>
    </h>
    <lvl>
      Field level only
    </lvl>
    <ret>
      Always <b>TRUE.</b>
    </ret>
  </ref>

</help>
</rrx>
<rrx namespace="FNP8forFlex" src="c:\datacap\RRS\FNP8forFlex.dll">

<i ref="rrunner">
</i>
<i ref="FileNetP8">
</i>
<af name="DD_SetSettingsFileName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="DD_PollDirectories" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="MoveFilesToBatchDir" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="MoveFilesToFailureDir" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="MoveFilesToSuccessDir" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="ReadINPFile" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="SetFNParameters" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="ExportDocumentToFN" access="public" bInter="bInter" bDebug="bDebug">
</af>
<help>
  <![CDATA[
'*****************************************************************************
' help.xml for FNP8forFlex
'-----------------------------------------------------------------------------
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'*****************************************************************************

'(Declarations)
]]>

<ref id="DD_SetSettingsFileName">
  <ap>Description of Parameter value(s)</ap>
  <lvl>Action works at the ?Batch/Doc/Page/All? level</lvl>
  <ret>Action returns TRUE/FALSE when...?</ret>
  <h>
    <![CDATA[Detailed Help]]><e>example of use</e>
  </h>
</ref>
  
  <ref id="DD_PollDirectories" >
    <ap>Description of Parameter value(s)</ap>
    <lvl>Action works at the ?Batch/Doc/Page/All? level</lvl>
    <ret>Action returns TRUE/FALSE when...?</ret>
    <h>
      <![CDATA[Detailed Help]]><e>example of use</e>
    </h>
  </ref>
  
  <ref id="MoveFilesToBatchDir">
    <ap>Description of Parameter value(s)</ap>
    <lvl>Action works at the ?Batch/Doc/Page/All? level</lvl>
    <ret>Action returns TRUE/FALSE when...?</ret>
    <h>
      <![CDATA[Detailed Help]]><e>example of use</e>
    </h>
  </ref>
  
  <ref id="MoveFilesToFailureDir">
    <ap>Description of Parameter value(s)</ap>
    <lvl>Action works at the ?Batch/Doc/Page/All? level</lvl>
    <ret>Action returns TRUE/FALSE when...?</ret>
    <h>
      <![CDATA[Detailed Help]]><e>example of use</e>
    </h>
  </ref>
  
  <ref id="MoveFilesToSuccessDir">
    <ap>Description of Parameter value(s)</ap>
    <lvl>Action works at the ?Batch/Doc/Page/All? level</lvl>
    <ret>Action returns TRUE/FALSE when...?</ret>
    <h>
      <![CDATA[Detailed Help]]><e>example of use</e>
    </h>
  </ref>
  
  <ref id="ReadINPFile">
    <ap>Description of Parameter value(s)</ap>
    <lvl>Action works at the ?Batch/Doc/Page/All? level</lvl>
    <ret>Action returns TRUE/FALSE when...?</ret>
    <h>
      <![CDATA[Detailed Help]]><e>example of use</e>
    </h>
  </ref>
  
  <ref id="SetFNParameters">
    <ap>Description of Parameter value(s)</ap>
    <lvl>Action works at the ?Batch/Doc/Page/All? level</lvl>
    <ret>Action returns TRUE/FALSE when...?</ret>
    <h>
      <![CDATA[Detailed Help]]><e>example of use</e>
    </h>
  </ref>
  
  <ref id="ExportDocumentToFN">
    <ap>Description of Parameter value(s)</ap>
    <lvl>Action works at the ?Batch/Doc/Page/All? level</lvl>
    <ret>Action returns TRUE/FALSE when...?</ret>
    <h>
      <![CDATA[Detailed Help]]>
      <e>example of use</e>
    </h>
  </ref>
    
</help>
</rrx>
<rrx namespace="FPXML" src="c:\datacap\RRS\FPXML.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="ReadZonesFPX" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim sName	]]>
<![CDATA[
]]>
<![CDATA[	Dim PosName]]>
<![CDATA[
]]>
<![CDATA[	Dim sOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim aOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim nXoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim nYoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim oCurPage]]>
<![CDATA[
]]>
<![CDATA[	Dim bPos]]>
<![CDATA[
]]>
<![CDATA[	Dim bPM]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ReadZonesFPX = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sFingerprintDir = m_sFingerprintDir]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If Trim(sFingerprintDir) = "" Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "The fingerprint directory has not been set. Exiting."]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Right(FingerprintDir,1) <> "\" Then]]>
<![CDATA[
]]>
<![CDATA[    FingerprintDir = FingerprintDir & "\"]]>
<![CDATA[
]]>
<![CDATA[  End If ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	sOffSet = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCurPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sOffSet=oCurPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	While oCurPage.ObjectType<>2 AND oCurPage.ObjectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oCurPage = oCurPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[		If len(sOffSet)=0 then sOffSet=oCurPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sName=oCurPage.Variable("TemplateID")	]]>
<![CDATA[
]]>
<![CDATA[	PosName = "Pos" & sName]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ReadZones for " & PosName)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not FPXMLWrapper.OpenFingerprint(sFingerprintDir, sName, False) Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Could not open the fingerprint information: " & FPXMLWrapper.LastError]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aOffSet = Split(sOffSet & ",0" , ",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sOffSet <> "" Then]]>
<![CDATA[
]]>
<![CDATA[	  nXoffset = (-1*aOffSet(0))]]>
<![CDATA[
]]>
<![CDATA[	  nYoffset = (-1*aOffSet(1))]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nXoffSet)) or len(trim(nXoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nXoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("X offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nYoffSet)) or len(trim(nYoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nYoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("Y offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Offsets : " & nXoffset & "," & nYoffset)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oSet = 0]]>
<![CDATA[
]]>
<![CDATA[	xAdj = clng(nXoffSet)]]>
<![CDATA[
]]>
<![CDATA[	Yadj = clng(nYoffSet)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType < 4 then ]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		sZonePos = FPXMLWrapper.GetFieldInfo(CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[		writelog("DCO pos:" & sZonePos)]]>
<![CDATA[
]]>
<![CDATA[		bPM = Not(CurrentObj.Variable("PatternMatch")="1")]]>
<![CDATA[
]]>
<![CDATA[		bPos = CurrentObj.Variable("Position")="0,0,0,0" or CurrentObj.Variable("Position")="" ]]>
<![CDATA[
]]>
<![CDATA[		If sZonePos <> "" and sZonePos <> "0,0,0,0" and bPM and bPos then]]>
<![CDATA[
]]>
<![CDATA[			arZonePos=split(sZonePos,",")]]>
<![CDATA[
]]>
<![CDATA[			If UBound(arZonePos)=3 Then]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(0)=arZonePos(0)+Xadj]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(1)=arZonePos(1)+Yadj]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(2)=arZonePos(2)+Xadj]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(3)=arZonePos(3)+Yadj]]>
<![CDATA[
]]>
<![CDATA[				CurrentObj.Variable("Position")=CStr(arZonePos(0)) & "," & CStr(arZonePos(1)) & "," & CStr(arZonePos(2)) & "," & CStr(arZonePos(3))]]>
<![CDATA[
]]>
<![CDATA[				writelog("new pos:" & CurrentObj.Variable("Position"))		]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		Set oSetupNode = CurrentObj.SetupNode()]]>
<![CDATA[
]]>
<![CDATA[		If Not(oSetupNode is Nothing) then ]]>
<![CDATA[
]]>
<![CDATA[			If oSetupNode.variable("RecogType")="4" then]]>
<![CDATA[
]]>
<![CDATA[				writelog(space(oSet+2) & "OMR recogtype found.") ]]>
<![CDATA[
]]>
<![CDATA[				For nChar = 1 to oSetupNode.NumOfRules]]>
<![CDATA[
]]>
<![CDATA[					Set oSubRule = oSetupNode.GetRule(nChar-1)]]>
<![CDATA[
]]>
<![CDATA[					Set oSubChar = CurrentObj.GetChild(nChar-1)]]>
<![CDATA[
]]>
<![CDATA[					If Not(oSubRule is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[						If oSubChar is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[							Set oSubChar = CurrentObj.AddChild(4, "", -1)]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						sZonePos = FPXMLWrapper.GetFieldInfo(oSubRule.Name)]]>
<![CDATA[
]]>
<![CDATA[						writelog(space(oSet+2) & "Found ZonePos: " & sZonePos)]]>
<![CDATA[
]]>
<![CDATA[						if sZonePos <> "" and sZonePos <> "0,0,0,0" then]]>
<![CDATA[
]]>
<![CDATA[							arZonePos=split(sZonePos,",")]]>
<![CDATA[
]]>
<![CDATA[							If UBound(arZonePos)=3 Then]]>
<![CDATA[
]]>
<![CDATA[										]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(0)=arZonePos(0)+Xadj]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(1)=arZonePos(1)+Yadj]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(2)=arZonePos(2)+Xadj]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(3)=arZonePos(3)+Yadj]]>
<![CDATA[
]]>
<![CDATA[										]]>
<![CDATA[
]]>
<![CDATA[								bRes = oSubChar.SetPosition(clng(arZonePos(0)) ,clng(arZonePos(1)),clng(arZonePos(2)),clng(arZonePos(3)))]]>
<![CDATA[
]]>
<![CDATA[								bRes = oSubChar.GetPosition(clng(arZonePos(0)) ,clng(arZonePos(1)),clng(arZonePos(2)),clng(arZonePos(3)))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[								'writelog("Saved X Y (" & CStr(arZonePos(2)- arZonePos(0)) & "," & CStr(arZonePos(3)-arZonePos(1)) & ") " & vbcrlf)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							end if]]>
<![CDATA[
]]>
<![CDATA[						end if]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[				Next 'nChar]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oSetupNode = Nothing]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		Call ZoneChildrenFPX(CurrentObj, PosName, oSet, Xadj, Yadj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ReadZonesFPX = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="SetDetailsAndLineitemPairFPX" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  SetDetailsAndLineitemPairFPX = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If UBound(ParamAr) < 1 Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Invalid parameter count: this action expects two parameters. Exiting."]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    m_sDetailType = MetaWord(ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[    m_sLineItemType = MetaWord(ParamAr(1))]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Detail field type set to " & m_sDetailType]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Lineitem field type set to " & m_sLineItemType]]>
<![CDATA[
]]>
<![CDATA[    SetDetailsAndLineitemPairFPX = True]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="SetDirectoryFPX" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  SetDirectoryFPX = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Len(Trim(StrParam)) = 0 Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Invalid parameter: this action expects the fingeprint directory. Exiting."]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    m_sFingerprintDir = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Right(m_sFingerprintDir,1) <> "\" then]]>
<![CDATA[
]]>
<![CDATA[      m_sFingerprintDir = m_sFingerprintDir & "\"]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Fingerprint directory set to " & m_sFingerprintDir]]>
<![CDATA[
]]>
<![CDATA[    SetDirectoryFPX = True]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="WriteZonesFPX" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[  Dim oPage]]>
<![CDATA[
]]>
<![CDATA[  Dim sFingerprint]]>
<![CDATA[
]]>
<![CDATA[  Dim sFingerprintDir]]>
<![CDATA[
]]>
<![CDATA[  Dim sHostName]]>
<![CDATA[
]]>
<![CDATA[  Dim sHostID]]>
<![CDATA[
]]>
<![CDATA[  Dim oFS]]>
<![CDATA[
]]>
<![CDATA[  Dim FPXMLFile]]>
<![CDATA[
]]>
<![CDATA[  Dim i]]>
<![CDATA[
]]>
<![CDATA[  Dim oField]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sHostName = ""]]>
<![CDATA[
]]>
<![CDATA[  sHostID = ""]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   WriteZonesFPX = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action belongs on a page level only.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   sFingerprintDir = m_sFingerprintDir]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if Right(sFingerprintDir,1) <> "\" then]]>
<![CDATA[
]]>
<![CDATA[      sFingerprintDir = sFingerprintDir & "\"]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If Trim(sFingerprintDir) = "" Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "The fingerprint directory has not been set. Exiting."]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   If uBound(ParamAr) >= 0 Then sHostName = MetaWord(ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   If uBound(ParamAr) >= 1 then sHostID = MetaWord(ParamAr(1))]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   sFingerprint = oPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If uBound(ParamAr) >= 2 then]]>
<![CDATA[
]]>
<![CDATA[      sPageType = MetaWord(ParamAr(2))]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      sPageType = oPage.Type]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   writelog("Fingerprint ID " & sFingerprint)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If Not oFS.FolderExists(sFingerprintDir) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Could not find: " & sFingerprintDir)]]>
<![CDATA[
]]>
<![CDATA[      oFS.CreateFolder(sFingerprintDir)]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Created: " & sFingerprintDir)]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If sHostID = "" Then]]>
<![CDATA[
]]>
<![CDATA[      sHostID = ""]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If sHostName = "" then]]>
<![CDATA[
]]>
<![CDATA[      sHostName = ""]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Writelog "Fingerprint directory : " & sFingerprintDir]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If Not FPXMLWrapper.OpenFingerprint(sFingerprintDir, sFingerprint, true) Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "Could not open the fingerprint information: " & FPXMLWrapper.LastError]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Writelog "Fingerprint page type set to " & sPageType]]>
<![CDATA[
]]>
<![CDATA[   Writelog "Fingerprint host name set to " & sHostName]]>
<![CDATA[
]]>
<![CDATA[   Writelog "Fingerprint host id   set to " & sHostID]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   FPXMLWrapper.UpdateFPrint sPageType,sHostName ,sHostID]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog "Saving zones..." ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   For i = 0 to oPage.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[      Set oField = oPage.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If Not oField Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[        If oField.ObjectType = 3 Then]]>
<![CDATA[
]]>
<![CDATA[           If oField.Type = m_sDetailType Then]]>
<![CDATA[
]]>
<![CDATA[              Call WriteDetailFieldFPX(oField)]]>
<![CDATA[
]]>
<![CDATA[           Else]]>
<![CDATA[
]]>
<![CDATA[              If Trim(oField.Variable("Position")) <> "" AND Trim(oField.Variable("Position")) <> "0,0,0,0" Then ]]>
<![CDATA[
]]>
<![CDATA[                  FPXMLWrapper.AddFieldInfo oField.ID,oField.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[                  Writelog "Writing zones for field " & oField.ID ]]>
<![CDATA[
]]>
<![CDATA[              End If ]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[              If oField.NumOfChildren <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[                Call WriteChildrenZonesFPX(oField) ]]>
<![CDATA[
]]>
<![CDATA[              End If]]>
<![CDATA[
]]>
<![CDATA[           End If]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[   Next 'i]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If FPXMLWrapper.Save Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "Finished saving zones."]]>
<![CDATA[
]]>
<![CDATA[      WriteZonesFPX = True]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog "The page zones could not be written to the fingerprint XML file :" & FPXMLWrapper.LastError]]>
<![CDATA[
]]>
<![CDATA[      WriteZonesFPX = False]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<help>
  <![CDATA[
'****************************************************
' fpxml.rrx - a description of the library

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2016 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.

'****************************************************

]]>

  <ref id="ReadZonesFPX" qi="Loads position information for current fingerprint">
    <ap>None.</ap>
    <h>
      This action reads the field zone information from the fingerprint XML file associated with the fingerprint for
      the current page object.  This action is similar to the ReadZones action in the Zones library.
      The primary difference is that ReadZones reads the zone information stored in the setup DCO and ReadZonesFPX
      reads the zone information from the associated fingerprint XML file.
      Typically this action will be called after the CreateFields action but before field recognition.<br/><br/>

      ReadZonesFPX loads position information for each node in the calling object and it's children. Pre-adjusts
      these values based on offset information stored in the 'Image_Offset' variable at any node level.
      The offset value is applied to all child objects of a node where an 'Image_Offset' variable is found;
      unless overwritten by a child node also having an Image_Offset value to apply.<br/><br/>

      Position information is based on the Fingerprint XML position for the parent page's fingerprint ID.<br/><br/>

      If 'Enable FPXML' setting is checked in the application settings 'Main' tab within the Taskmaster Application Manager,
      Datacap Studio will place field zone information into a fingerprint XML file instead of placing the zone
      information into the applications setup DCO.  One FPXML file is created per fingerprint.
      Depending on application needs, using fingerprint XML files may have
      advantages.  Refer to Taskmaster documentation for more information about using fingerprint XML files.
      If the application is using FPXML files, then use this action to load the zones.
      <br/><br/>
      <e>
        SetDirectoryFPX("@APPPATH(*/fingerprint)") <br/>
        <b>ReadZonesFPX()</b>
      </e>
    </h>
    <lvl>Page or Field level.</lvl>
    <ret>
      <b>False,</b> if the fingeprint xml cannot be loaded or if SetDirectoryFPX has not
      been called to set the location of the fingerprint XML files. Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="SetDetailsAndLineitemPairFPX" qi="Sets the type of the special Details and Lineitem fields.">
    <ap>
      Two comma separated parameters:<br/><br/>

      <b>Detail field type:</b> type of the field that is the parent to the line item field, often called "Details". <br/><br/>
      <b>LineItem field type:</b> type of the line item field which is the parent of the fields to be captured, often called "Lineitem".<br/><br/>

      Smart parameters are supported.
    </ap>
    <h>
      Use this action if your page contains Details and Lineitems fields, as is common with an invoice page.
      The action sets the type of the special Details and Lineitem fields. These fields, unlike other field types,
      are handled by the ReadZonesFPX and WriteZonesFPX actions in a special way that is compatible
      with the Locate actions framework.<br/><br/>

      If your page has Details and Lineitems, then this action is required to identify the types
      so the position information will be properly saved.
      Using SetDetailsAndLineitemPairFPX prior to calling WriteZonesFPX will cause WriteZonesFPX to save line
      item field positions to the fingerprint file. The second parameter is the type of the line item
      field which is the parent of the fields to be captured and is often called "Lineitem".<br/><br/>

      If your page contains Detail and Lineitem fields, this action also needs to be used prior
      to calling ReadZonesFPX.<br/><br/>

      Details are the parent object of the line item fields.  Details are a collection of lineitems
      and each line item has a collection of fields.  For example, in a typical invoice
      application a single lineitem can contain the fields: quantity, item number, description, unit price, and total.<br/><br/>
      <e>
        <b>SetDetailsAndLineitemPairFPX("Details,Lineitem")</b><br/>
        ReadZonesFPX()<br/><br/>

        In this example, the details field is called "Details" and the line items are called "Lineitem".<br/><br/><br/>

        An example DCO hierarchy may look something like this:<br/>
        - Details<br/>
        --- Lineitem<br/>
        ------- Qty<br/>
        ------- ItemID<br/>
        ------- ItemDesc<br/>
        ------- Price<br/>
        ------- LineTotal<br/>
      </e>
    </h>
    <lvl>Any level.</lvl>
    <ret>
      <b>False</b> if one parameter is missing. Otherwise <b>True</b>
    </ret>
  </ref>

  <ref id="SetDirectoryFPX" qi="Sets the directory in which fingerprint xml files should be read and written to.">
    <ap>
      A string identifying the Fingerprint directory.  This is the directory that contains the FPXML files.
      Smart parameters are supported.
    </ap>
    <h>
      This action sets the directory from which fingerprint XML files will be written or read.
      This action must be called to identify the FPXML directory before calling ReadZonesFPX or WriteZonesFPX.
      <e>
        <b>SetDirectoryFPX("@APPPATH(*/fingerprint)")</b><br/>
        ReadZonesFPX()<br/>
        This example uses the @APPPATH smart parameter to obtain the directory from the application service.<br/><br/>


        <b>SetDirectoryFPX("C:\Datacap\APT\fingerprint")</b><br/>
        ReadZonesFPX()<br/>
        This example hard codes the directory, which is fine but could make the application less portable.
      </e>
    </h>
    <lvl>Any level.</lvl>
    <ret>
      <b>False</b> if the parameter is missing. Otherwise <b>True</b>
    </ret>
  </ref>

  <ref id="WriteZonesFPX"  qi="Writes position information for all fields of the page">
    <ap>
      Three comma separated parameters:<br/><br/>

      <b>Fingerprint host name:</b> This is the fingerprint class name and can be seen in the zones tab of Datacap Studio.
      It is used to group or classify fingerprints.
      If this value is not provided, then a blank class name will be used.<br/><br/>

      <b>Fingerprint host id:</b> This is an internal numeric value that is associated with the fingerprint class name.
      If a value is not provided, a blank value will be used.<br/><br/>

      <b>Fingerprint page type:</b> This is the page type that corresponds to the fingerprint for the page.
      If this value is not provided, it uses the page type of the current page.<br/><br/>

      Smart parameters are supported.  All parameters are optional.  If you provide only the second or third parameter,
      you must supply an empty value for the previous parameters.
    </ap>
    <h>
      This action will write out all of the field positions for the current page to the fingerprint XML file.
      Typically this action is used for applications that are using fingerprint XML files and new pages
      are dynamically zoned at runtime.  After the zoning of the page has been completed, then this action
      is used to write out the zone information to the FPXML file, allowing subsequent pages of this
      type to be processed using the saved zone information.<br/><br/>

      If the fingerprint directory that had been previously specified using SetDirectoryFPX does not exist, it will be created,
      providing that the parent directory already exists.<br/><br/>

      Fields with empty positions are not written to the fingerprint XML file.<br/><br/>
      <e>
        SetDirectoryFPX("@APPPATH(*/fingerprint)")<br/>
        <b>WriteZonesFPX("MyFPClass,,MyPageType")</b><br/><br/>

        This example writes out the zones for the current page and sets the fingerprint class to "MyFPClass" and
        the page type to "MyPageType".<br/><br/>

        SetDirectoryFPX("@APPPATH(*/fingerprint)")<br/>
        <b>WriteZonesFPX("MyFPClass,,@P.MyType")</b><br/><br/>

        This example writes out the zones for the current page and sets the fingerprint class to "MyFPClass" and
        the page type to the value contained by the page variable "MyType".<br/><br/>
      </e>
    </h>
    <lvl>Page level only.</lvl>
    <ret>
      <b>False,</b> if there is a problem saving to fingerprint XML file or if not called at the page level,
      if the page does not have a fingerprint assigned, or a fingerprint directory has not been set. Otherwise <b>True.</b>
    </ret>
  </ref>
</help>

</rrx>
<rrx namespace="Grayscale" src="c:\datacap\RRS\Grayscale.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="ConvertGraytoBW" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Converts Grayscale TIFF files to Black and White TIFF files."]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  <b>Note:</b>The action renames the original Grayscale image using the same base filename,]]>
<![CDATA[
]]>
<![CDATA[  '  but replaces the .tif filename extension with ".tis".]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ConvertGraytoBW = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType > 2) Then WriteLog("Error: This action must be placed at the Batch, Document, or Page Level.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[	ConvertGraytoBW = Process(CurrentObj)]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************************
' Grayscale Conversion Actions
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2013 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************************

]]>

<ref id="ConvertGraytoBW" access="public" bInter="bInter" bDebug="bDebug" qi="Converts Grayscale TIFF files to Black and White TIFF files.">
  <ap>None.</ap>
  <h>
    This action converts grayscale TIFF files into Black and White TIFF files.<br/><br/>

    The ConvertGraytoBW action is especially good at converting color dropout forms, 
    including medical claims, scanned in grayscale to black and white. 
    The action categorizes each pixel in the image as either foreground (black), dropout (red / light gray), 
    or background (white), to produce a final black and white image without the dropout color.
    <br/><br/>    
    
    <b>Note:</b> The action renames the original grayscale image using the same base file name,
    but replaces the .tif filename extension with ".tis".<br/><br/>
    <e>
      <b>ConvertGraytoBW()</b>
    </e>
  </h>
  <lvl>Batch, Document or Page level.  If called at the batch level, all images will be converted.  
     If called at the document level all of the pages within the document will be converted.
     If called at the page level, the single page will be converted.
  </lvl>
  <ret>
    <b>False</b> if a ruleset with this action is bound to a <b>Field</b> object of the 
    Document Hierarchy. Otherwise, <b>True.</b><br/><br/>
    
    If the input image is not grayscale, the image will not be converted but the action will still return <b>True.</b>
  </ret>
</ref></help>
</rrx>
<rrx namespace="icr_c" src="c:\datacap\RRS\icr_c.dll">

<i ref="rrunner">
</i>
<i ref="recog_shared">
</i>
<af name="RecognizePageICR_C" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="RecognizePageToPDFICR_C" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="RecognizePageFieldsICR_C" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="EnableLoggingICR_C" bInter="bInter" bDebug="bDebug" strParam="strParam">
</af>
<af name="RecognizeFieldICR_C" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="RecognizeFieldVoteICR_C" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="RecognizePageFields2CCO_ICR_C" access="public" bInter="bInter" bDebug="bDebug">
</af>
<help>
  <![CDATA[
'****************************************************
' icr_c.rrx - a description of the library

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2016 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.

'****************************************************

]]>

  <ref id="RecognizePageICR_C" access="public"  qi="Performs full page recognition using the ICR/C Engine.">
    <ap>None.</ap>
    <h>
      Performs full page character recognition on the current page based on the settings
      in the ICR/C tab in Datacap Studio.
      The action will recognize all characters on the page, and populate the page's
      CCO file with the recognition results.
      If a CCO file does not exist at the time this action is called, the action will create one.<br/><br/>

      If recognition fails, the action is automatically retried.<br/><br/>

      <b>ICR/C Library Information</b><br/>
      The ICR/C action library provides actions that perform recognition with an engine that supports handwriting recognition.
      Page and field level recognition can be performed using the actions in this library which can then be processed by actions in other
      libraries and ultimately displayed to the user for verification.<br/><br/>

      The ICR/C actions support automatic retries when a recognition takes longer than expected.
      In rare situations recognition can fail to complete, such as when processing a damaged or atypical
      image.  Sometimes a retry will be successful and allow processing to continue normally.
      When recognition fails to complete, once the configured timeout is reached, the recognition engine will
      be stopped and restarted, then recognition attempted again until the retry count is reached.
      By default, when a failure occurs because of the timeout being reached, the action will
      be retried 1 time.  The default timeout is 180 seconds. These default values can be
      changed using the SetupAutomaticRetry action in the RecogShared library.
      No other actions are required to setup the automatic retry feature.<br/><br/>

      After a recognition operation is complete, the variable <b>RecogStatus</b> is set to indicate the
      success or failure of recognition. If page-level recognition is being performed, RecogStatus values of 0, 1, or 2 are considered successful.
      The list of successful values includes:<br/><br/>

      0 - Success<br/>
      1 - Recognition was successful but there are no results...the page was empty.<br/>
      2 - Recognition was successful and additional processing such as "RotateImage" was performed.<br/><br/>

      Other values are considered failures.<br/><br/>

      <b>Supported Languages</b><br/><br/>

      The following countries and languages are supported by ICR_C:<br/>
      Afrikaans, Albanian, Australia, Austria, Belgium, Bosnian_Latin, Brazil, Canada, Catalan, Central_America, Central_Europe, Croatia, Croatian,
      Czech, Czech_Language, Danish, Denmark, Dutch, English, Estonia, Estonian, Faroese, Finland, Finnish, France, French, German, Germany,
      Great_Britain, Hungarian, Hungary, Icelandic, Ireland, Irish, Italian, Italy, Latvian, Liechtenstein, Lithuania, Lithuanian, Netherlands,
      New_Zealand, Norway, Norwegian, Poland, Polish, Portugal, Portuguese, Rhaeto_Romanic, Romanian, Russian, Scandinavia, Serbian_Latin, Slovak,
      Slovakia, Slovenia, Slovenian, South_Africa, South_America, South_America_Spanish, Spain, Spanish, Swahili, Sweden, Swedish, Switzerland, Turkey,
      Turkish, USA, Western_Europe<br/><br/>

      The language or country can be bound to the DCO object by selecting it in the ICR_C tab in the zones tab of Datacap Studio.
      When selected in the ICR_C tab the variable <b>c_cr</b> is set to the country or language.
      The country or language also can be set within rules using the <b>rrSet</b> action to set
      the <b>c_cr</b> variable to the desired country or language.<br/><br/>

      For example: <b>rrSet("Italian", "@X.c_cr")</b> will set the language to Italian.<br/><br/>

      If the <b>c_cr</b> variable is not set for the current DCO object, the recognized
      language is determined by the current locale set with the <b>hr_locale</b> variable.
      For example, if the locale is set for Germany, then the text will be recognized as German.<br/><br/>

      The value in <b>c_cr</b> takes precedence over the locale setting.
      If <b>c_cr</b> is set but the engine should use the value set for <b>hr_locale</b> instead,
      setting the variable <b>dco_uselocale</b> to "1" will give precedence to <b>hr_locale.</b><br/><br/>


      <e>
        AnalyzeImage()<br/>
        RotateImage()<br/>
        <b>RecognizePageICR_C()</b><br/><br/>

        This sequence creates a CCO file and checks to see if rotation of the image is needed.
        Full-page recognition then takes place based on the settings in the ICR/C
        tab in Datacap Studio. The recognition results are stored in the page's CCO file.
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>False,</b> if called at the wrong level or if there is a failure in the
      recognition process.  Otherwise, <b>True.</b>
    </ret> 
  </ref>


  <ref id="RecognizePageToPDFICR_C" access="public" qi="Performs recognition on the current page and places the results in a PDF file.">
    <ap>None.</ap>
    <h>
      Performs full page character recognition on the current page based on the
      settings in the ICR/C tab in Datacap Studio. The action will creates a PDF that
      contains the original page image and the recognized text.<br/><br/>

      If recognition fails, the action is automatically retried.  See RecognizePageICR_C for more information.<br/>
      <e>
        AnalyzeImage()<br/>
        RotateImage()<br/>
        <b>RecognizePageToPDFICR_C()</b>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>False,</b> if called at the wrong level or if there is a failure in the
      recognition process.  Otherwise, <b>True.</b>
    </ret> 
  </ref>

  ' This action is private and not called so it has not been setup for automatic retry.
  <ref id="RecognizePageFieldsICR_CEx" access="private" qi="Recognizes all fields on the page that have been configured for ICR/C recognition.">
    <ap>
      None.
    </ap>
    <h>
      This page-level action recognizes all fields on the page that have been configured for ICR/C recognition.
      Individual field-level recognition actions will overwrite the results from this page-level action.
      This action will not recognize a zoned field If the Skip Recognition checkbox is selected in
      the ICR/C tab in Datacap Studio. <br/><br/>

      <b>Important:</b> The recognition settings must be set individually for each field being recognized. <br/>
      When recognizing an area that contains hand printed characters only, a country, not language, should be selected from the "Country" dropdown in the ICR/C tab of Dstudio for optimal recognition results. If the zoned area
      contains both hand printed and machine printed characters, then a language, and not a country, should be selected from the "Country" dropdown in the ICR/C tab of Dstudio for optimal recognition resuls.<br/><br/>

      If recognition fails, the action is automatically retried.  See RecognizePageICR_C for more information.<br/>
      <br/>
      <e>
        <b>RecognizePageFieldsICR_CEx()</b>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>False,</b> if called at the wrong level or if there is a failure in the
      recognition process.  Otherwise, <b>True.</b>
    </ret> 
  </ref>

  <ref id="RecognizePageFieldsICR_C" access="public"   qi="Performs recognition on all fields that have been configured for ICR/C in Datacap Studio.">
    <ap>None.</ap>
    <h>
      This page-level action recognizes all fields on the page that have been configured
      for ICR/C recognition in Datacap Studio. Individual field-level recognition actions
      will overwrite the results from this page-level action. This action will not recognize
      a zoned field if the “Skip Recognition” checkbox is selected in the ICR/C tab
      in Datacap Studio.<br/><br/>

      <b>Important:</b> The recognition settings must be set individually for each field being recognized. <br/>
      When recognizing an area that contains hand printed characters only, a country, not language, should be selected from the "Country" dropdown in the ICR/C tab of Dstudio for optimal recognition results. If the zoned area
      contains both hand printed and machine printed characters, then a language, and not a country, should be selected from the "Country" dropdown in the ICR/C tab of Dstudio for optimal recognition results.<br/><br/>

      If recognition fails, the action is automatically retried.  See RecognizePageICR_C for more information.<br/>
      <br/>

      <e>
        AnalyzeImage()<br/>
        RotateImage()<br/>
        <b>RecognizePageFieldsICR_C()</b>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret> 
  </ref>


  <ref id="EnableLoggingICR_C" access="public"   strParam="strParam" qi="Enables or disables event logging for the ICR/C engine.">
    <ap>
      A boolean value. <b>True</b> enables ICRC logging and <b>False</b> disables ICRC logging.
      If no parameter is passed in, it will use the default value of <b>true.</b>
    </ap>
    <h>
      This action enables or disables event logging for the ICR/C engine.  Logs are written to the
      System event log under the entry "Datacap.Recognition.Recostar".  This action is intended
      for debugging ICRC recognition problems.  If this action is never called, no logging will occur.<br/><br/>
      <e>
        <b>EnableLoggingICR_C("true")</b>
      </e>
    </h>
    <lvl>All levels.</lvl>
    <ret>
      <b>True</b> if the logging state is successfully changed.  Otherwise, <b>False.</b>
    </ret> 
  </ref>

  <ref id="RecognizeFieldICR_C" access="public"   qi="Performs character recognition for a specific field.">
    <ap>None.</ap>
    <h>
      Recognition is performed on the current field.  The field must have the proper
      settings in the ICR/C tab in Datacap Studio.  This field-level action recognizes
      characters based on the settings in the ICR/C tab in Datacap Studio and the value is
      stored in the current field object. <br/><br/>

      <b>Important:</b> When recognizing an area that contains hand printed characters only, a country, not language, should be selected from the "Country" dropdown in the ICR/C tab of Dstudio for optimal recognition results. If the zoned area
      contains both hand printed and machine printed characters, then a language, and not a country, should be selected from the "Country" dropdown in the ICR/C tab of Dstudio for optimal recognition resuls.<br/><br/>

      If recognition fails, the action is automatically retried.  See RecognizePageICR_C for more information.<br/>
      <br/>
      <e>
        <b>RecognizeFieldICR_C()</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False,</b> if called at the wrong level or if there is a failure in the
      recognition process.  Otherwise, <b>True.</b>
    </ret> 
  </ref>

  <ref id="RecognizeFieldVoteICR_C" access="public"   qi="Recognizes characters based on results from two recognition engines.">
    <ap>None.</ap>
    <h>
      Voting adjusts the assigned confidence of recognized characters based on the results from two different
      recognition engines.  This action is expected to be called after field level recognition is
      performed on the same field by a different engine.<br/><br/>

      When this action stores the results of recognition, it first determines if the
      corresponding <b>Field</b> object of the Document Hierarchy already contains a value.
      If a value is present, indicating recognition had previously been performed on the field,
      the action compares the existing value with the field's new recognition results -
      character by character. If a character's values match the existing value,
      the Confidence Rating for the character is raised to the maximum level.<br/><br/>

      Note that when using voting actions, the recognition results are never assigned to the field.
      Instead, the action changes the Confidence Ratings on the basis of results provided
      by the first Recognition engine.  However, if there are no previous recognition results in the field
      when this action is called, it will perform like the <b>RecognizeFieldICR_C</b> action.<br/><br/>

      If recognition fails, the action is automatically retried.  See RecognizePageICR_C for more information.<br/>
      <e>
        RecognizeFieldOCR_S()<br/>
        <b>RecognizeFieldVoteICR_C()</b><br/><br/>
        This example first uses the OCR/S engine to recognize the text and store it in the field object.
        Then it votes on the
        confidence of the character by comparing it to the ICR/C engine result.
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False,</b> if called at the wrong level or if there is a failure in the
      recognition process.  Otherwise, <b>True.</b>
    </ret> 
  </ref>

  <ref id="RecognizePageFields2CCO_ICR_C" access="public"   qi="Performs recognition for all of the zoned fields on a page.">
    <ap>None.</ap>
    <h>
      This action recognizes all of the zoned fields on a page and puts
      the recognition results for each field in both the Datacap Object Hierarchy and in an already existing CCO.
      To create a CCO, call either a Full Page OCR action or the AnalyzeImage action before this action.<br/><br/>

      If recognition fails, the action is automatically retried.  See RecognizePageICR_C for more information.<br/>
      <e>
        AnalyzeImage()<br/>
        <b>RecognizePageFields2CCO_ICR_C()</b>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>False</b> if called at the wrong level or if the CCO does not already exist. Otherwise, <b>True.</b>
    </ret>
    <see>CCO2CCO (CCO2CCO), AnalyzeImage (Recog_Shared)</see>
  </ref>
   
</help>

</rrx>
<rrx namespace="ImageConvert" src="c:\datacap\RRS\ImageConvert.dll">

<i ref="rrunner">
</i>
<af name="AppendImage_StartAsNew" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="AppendImage" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="AppendAllImages" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="AppendAllImages_ByType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<f name="RescaleImage" access="public">
	<p name="ImageHeight">
	</p>
	<p name="ImageWidth">
	</p>
	<p name="ImageDPI">
	</p>
</f>
<af name="SetDeleteOriginal" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SetTIFFCompression" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<f name="SetImageDPIByWidth" access="public">
	<p name="PageWidth">
	</p>
	<p name="ImageDPI">
	</p>
	<p name="Rescale">
	</p>
</f>
<f name="SaveImageInformation" access="public">
	<p name="ImageWidth">
	</p>
	<p name="ImageHeight">
	</p>
	<p name="ImageDPIX">
	</p>
	<p name="ImageDPIY">
	</p>
	<p name="PhysicaImageWidth">
	</p>
	<p name="PhysicalImageHeight">
	</p>
	<p name="BitDepth">
	</p>
</f>
<af name="SetLuminanceFactor" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SetGrayScale" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SetChrominanceFactor" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="ConvertToJPEG" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="ConvertToTIFF" access="public" bInter="bInter" bDebug="bDebug">
</af>
<help>
  <![CDATA[
'******************************************************************************************
' Image Conversion Actions help
'******************************************************************************************
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'******************************************************************************************
]]>
    
<ref id="AppendImage_StartAsNew" access="public" bInter="bInter" bDebug="bDebug" qi="Sets the current page as the first page for a concatenated file.">
  <ap>None.</ap>
  <lvl>Page level.</lvl>
  <ret>
    <b>True,</b> if the image file exists for the current page and if it is a TIFF file.  Otherwise, <b>False.</b>
  </ret>
  <h>
    Sets the current page as the start of a new concatenated document.  This action is used
    in conjunction with AppendImage to create a single image created by concatenating images to
    the bottom of the first image.      AppendImage_StartAsNew identifies the first page
    and AppendImage identifies all subsequent pages.
    The result of the action will modify the first image in the document to become a single continuous image like this:<br/>
    Page 1<br/>
    Page 2<br/>
    Page 3<br/><br/>

    If images are appended prior to recognition, the entire page area will be recognized and
    click-n-key enabled.<br/><br/>
    
    It is highly recommended that this action be used only documents that have a small number of pages, such as
    two or three pages per document.  The size of the
    final composite image can quickly become larger than can be handled by some image viewers and possibly subsequent
    actions.  To keep memory usage to a minimum, it is also recommended that 1-bit Black and White images are used.<br/><br/>

    <b>Note:</b> This action only operates on TIFF images.<br/>
    <e>
      <b>AppendImage_StartAsNew()</b>
    </e>
  </h>
  <see>AppendImage</see>
</ref>
  
<ref id="AppendImage" access="public" bInter="bInter" bDebug="bDebug" qi="Concatinates the current image to the bottom of an existing image.">
  <ap>None.</ap>
  <lvl>Page level.</lvl>
  <ret>
    <b>True,</b> if the current page is successfully concatenated with the previous page.  Otherwise, <b>False.</b>
  </ret>
  <h>
    This action will concatenate the image for the current page to the bottom of the previous 
    image processed by a call to AppendImage_StartAsNew or AppendImage.  If AppendImage_StartAsNew
    has not been called, then the first image encountered will be treated as the starting image.<br/><br/>

    If images are appended prior to recognition, the entire page area will be recognized and
    click-n-key enabled.<br/><br/>
    
    The image must be a TIFF.
    See AppendImage_StartAsNew for details.<br/>
    <e>
      AppendImage()
    </e>
  </h>
  <see>AppendImage_StartAsNew</see>
</ref>
  
<ref id="AppendAllImages" access="public" bInter="bInter" bDebug="bDebug" qi="Appends all of the images in the document to the first page.">
  <ap>None.</ap>
  <lvl>Document level.</lvl>
  <ret>
    <b>True,</b> if all of the TIFF images within the document have been appended to the end of the first TIFF image.
    Otherwise, <b>False.</b>
  </ret>
  <h>
    This action will append (concatenate) all of the images within the document to the first image of the document, creating one long image.
    The result of the action will modify the first image in the document to become a single continuous image like this:<br/>
    Page 1<br/>
    Page 2<br/>
    Page 3<br/><br/>

    If images are appended prior to recognition, the entire page area will be recognized and
    click-n-key enabled.<br/><br/>      
    
    It is highly recommended that this action be used only documents that have a small number of pages, such as
    two or three pages per document.  The size of the
    final composite image can quickly become larger than can be handled by some image viewers and possibly subsequent
    actions.  To keep memory usage to a minimum, it is also recommended that 1-bit Black and White images are used.<br/><br/>
    
    <b>Note:</b> This action only operates on TIFF images.<br/>
    <e>
      <b>AppendAllImages()</b>
    </e>
  </h>
</ref>
  
<ref id="AppendAllImages_ByType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Appends all of the images of a specific type within a document.">
  <ap>
    A string that matches the pages' 'Type' variable.
  </ap>
  <lvl>
    Document level.
  </lvl>
  <ret>
    <b>True,</b> if all of the TIFF images that match the specified type within the document have 
    been appended to the end of the first matching TIFF image.
    Otherwise, <b>False.</b>
  </ret>
  <h>
    This action will append (concatenate) all of the images, that are of the type
    specified by the input parameter, that are all within the same document to the first image of that type, creating one long image.
    Images are not appended across documents.
    Assuming you have a document where the first three pages are all the same matching type, 
    the result of the action will modify the first image in the document to become a single continuous image like this:<br/>
    Page 1<br/>
    Page 2<br/>
    Page 3<br/><br/>

    If images are appended prior to recognition, the entire page area will be recognized and
    click-n-key enabled.<br/><br/>
    
    It is highly recommended that this action be used only documents that have a small number of pages, such as
    two or three pages per document.  The size of the
    final composite image can quickly become larger than can be handled by some image viewers and possibly by subsequent
    actions.  To keep memory usage to a minimum, it is also recommended that 1-bit Black and White images are used.<br/><br/>

    <b>Note:</b> This action only operates on TIFF images.
    <e>
      <b>AppendAllImages_ByType("PO")</b><br/><br/>
      This example will append all of the images within a document that have a page type of 'PO'.
    </e>
  </h>
</ref>


<ref id="RescaleImage" qi="Adjusts image for the current page to the specified size.">
  <ap>
    <b>ImageHeight:</b> Output Height of the page in pixels. If blank, defaults to 3300 pixels.<br/><br/>
    <b>ImageWidth:</b> Output Width of the page in pixels. If blank, defaults to 2550 pixels.<br/><br/>
    <b>ImageDPI:</b> The new DPI of the image.  If blank, defaults to 300 dpi.<br/><br/>
    Smart parameters are supported.<br/><br/>
  </ap>
  <h>
    Scales the image and sets the DPI to the specified values.<br/><br/>

    <e>
      <b>RescaleImage(3300, 2550, 300)</b>
    </e>
  </h>
  <lvl>Page level only, and the page must refer to a valid single page image file</lvl>
  <ret>
    <b>True</b> if the operation is successful, else <b>False</b> if any error occurred.
  </ret>
</ref>


<ref id="SetDeleteOriginal" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Controls deletion of file after conversion.">
  <ap>
    <b>true:</b> After the new image is created, the original will be deleted.
    <b>false:</b> After the new image is created, the original will remain.<br/><br/>
    
    Smart Parameters are supported.
  </ap>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    Use this action to control the deletion of the source image file when using the actions ConvertToJPEG and ConvertToTIFF.
    If this action is not called, the default value of <b>false</b> will be used, the source image
    will not be deleted after conversion.
    <e>
      <b>SetDeleteOriginal("True")</b><br/>
      ConvertToJPEG()
    </e>
  </h>
  <see>ConvertToJPEG ConvertToTIFF</see>
</ref>


<ref id="SetImageDPIByWidth" qi="Adjusts the dpi of the image and optionally resizes based on the expected physical size.">
    <ap>
      <b>PageWidth:</b> Physical width of the page in inches. If not specified, the value will default to 8.5 inches.<br/><br/>

      <b>ImageDPI:</b> The target DPI for the updated image.  If not specified, the value will default to 300 dpi.<br/><br/>

      <b>Rescale:</b> Indicates if the image should be rescaled.
      True - rescale image width and height to match the specified dpi and physical size, 
      False - do not rescale the page, just set the DPI.<br/><br/>

      Smart parameters are supported.
    </ap>
    <h>
      This action will adjust the dpi and with of the image to the specified dpi.  
      The image can also be resized to the correct logical size based on the expected physical width in inches.
      This action is useful for images that 
      do not have a correctly specified DPI or need to be resized based on the expected width.<br/><br/>

      When the rescale parameter is true, the image size is adjusted.  
      The image is scaled proportionally in the horizontal and vertical directions based on the
      width that has been specified for the image.  The final image will have the specified dpi and the pixel width and height
      will be scaled to the specified logical size.<br/><br/>      
      
      <e>
        <b>SetImageDPIByWidth("6", "", "True")</b><br/>
        <br/>
        This example is on a page level rule and sets the image width to 6 inches while rescaling the image as necessary.<br/><br/>

        <b>SetImageDPIByWidth("6", "300", "False")</b><br/>
        <br/>
        This example is on a page level rule and sets the image width to 6 inches while rescaling the image as necessary.<br/><br/>
      </e>
    </h>
    <lvl>Page level only, and the page must refer to a valid single page image file</lvl>
    <ret>
      <b>True</b> if the operation is successful, otherwise <b>False</b> if any error occurred.
    </ret>
</ref>



<ref id="SetTIFFCompression" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Controls the compression format when saving a TIFF.">
  <ap>
    One of the following values:<br/>
    <b>0</b> : No compression.<br/>
    <b>1</b> : Run length encoding (RLE).<br/>
    <b>2</b> : CCITT Group 3 fax compression.<br/>
    <b>3</b> : CCITT Group 4 fax compression.<br/>
    <b>4</b> : LZW compression.<br/>
    <b>5</b> : Apple Macintosh PackBits compression.<br/>
    <b>6</b> : JPEG compression format.<br/>
    <b>7</b> : Lossless compression standard derived from LZ77.<br/>
    <b>8</b> : CCITT Group 3 two-dimensional standard fax compression.<br/><br/>
    
    Smart Parameters are supported.
  </ap>
  <lvl>
    All levels.
  </lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    This action sets the compression type of the TIFF that is output from the action ConvertToTIFF.
    Typically Group 4 compression is used for performing recognition on images.<br/><br/>
    <b>Note:</b> all of these possible output formats may not be supported by other image processing actions.
    If this action is not called, Group 4 compression will be used.
    <e>
      <b>SetTiffCompression("3")</b><br/>
      ConvertToTIFF()
    </e>
  </h>
  <see>ConvertToTIFF</see>
</ref>

  
<ref id="SetLuminanceFactor" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the image luminance or grayscale quality.">
  <ap>
    A value of 0 to 255, with a value of 0 meaning minimum compression (best quality) and 255 meaning maximum image compression.
    Smart Parameters are supported.
  </ap>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>  
  </ret>
  <h>
    JPEG images are stored in a compressed format.  This action controls the amount of compression used when converting an image to
    a JPEG image using the ConvertToJPEG action.<br/><br/>

    Data loss is the result of JPEGs ability to achieve high compression ratios. Higher quality settings result in less compression,
    while lower quality settings result in higher compression. Quality versus compression is a tradeoff.
    Adjust image compression ratio by setting the SetLuminanceFactor and SetChrominanceFactor actions.
    The SetLuminanceFactor action adjusts the luminance or gray scale quality,
    while the SetChrominanceFactor action adjusts the chrominance or color quality.
    Lower settings for these properties result in higher quality images with less compression.
    Higher settings for these properties result in lower quality images with more compression.<br/><br/>

    If this action is not called, a default value of 24 will be used.
    <e>
      <b>SetLuminanceFactor("24")</b><br/>
      SetChrominanceFactor("10")<br/>
      SetGrayScale("True")<br/>
      ConvertToJPEG()
    </e>
  </h>
  <see>ConvertToJPEG</see>
</ref>

<ref id="SetGrayScale" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Controls the grayscale output for JPEG images.">
  <ap>
    <b>True:</b> Saves the image as a grayscale image.<br/>
    <b>False:</b> Saves the image as color.<br/>
    Smart Parameters are supported.
  </ap>
  <lvl>
    All Levels.
  </lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    This action will determine if a JPEG image will be output as grayscale or color.  
    If SetGrayScale is True, all images will be saved as 8 bit grayscale.  If SetGrayScale is False, color images will
    be saved as 24 bit color and if the original image is 1 bit black and white, the new image will be 8 bit grayscale.
    If this action is not called, the value will default to False (color).
    <e>
      SetLuminanceFactor("24")<br/>
      SetChrominanceFactor("10")<br/>
      <b>SetGrayScale("True")</b><br/>
      ConvertToJPEG()
    </e>
  </h>
  <see>ConvertToJPEG</see>
</ref>

<ref id="SetChrominanceFactor" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Set Compression for JPEG Output Files.">
  <ap>
    A value of 0 to 255, with a value of 0 meaning minimum compression (best quality) and 255 meaning maximum image compression.  
    Smart Parameters are supported.
  </ap>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <h>
    JPEG images are stored in a compressed format.  This action controls the amount of compression used when converting an image to
    a JPEG image using the ConvertToJPEG action.<br/><br/>
    
    Data loss is the result of JPEGs ability to achieve high compression ratios. Higher quality settings result in less compression,
    while lower quality settings result in higher compression. Quality versus compression is a tradeoff.
    Adjust image compression ratio by setting the SetLuminanceFactor and SetChrominanceFactor actions.
    The SetLuminanceFactor action adjusts the luminance or gray scale quality,
    while the SetChrominanceFactor action adjusts the chrominance or color quality.
    Lower settings for these properties result in higher quality images with less compression.
    Higher settings for these properties result in lower quality images with more compression.<br/><br/>
    
    If this action is not called, a default value of 10 will be used.
    <e>
      SetLuminanceFactor("24")<br/>
      <b>SetChrominanceFactor("10")</b><br/>
      SetGrayScale("True")<br/>
      ConvertToJPEG()
    </e>
  </h>
  <see>ConvertToJPEG</see>
</ref>


<ref id="ConvertToJPEG" access="public" bInter="bInter" bDebug="bDebug" qi="Converts the current image to a JPEG.">
  <ap>None.</ap>
  <lvl>Page level.</lvl>
  <ret>
    <b>True,</b> if the image is converted to a JPEG.<br/>
    <b>False,</b> if the input image is a JPEG or if a failure occurs during the conversion.
  </ret>
  <h>
    Converts the current image to a JPEG.  The output file name will have a JPG extension.<br/><br/>
    
    Supported input file formats: BMP (1, 4, 8, or 24-bit), GIF (1, 4 or 8-bit), PNG (1, 4, 8 and 24-bit), and
    TIFF (1, 4, 8 and 24-bit) with compression (RLE, Group 3 fax, and Group 4 fax, Pack Bits, LZW, JPEG).<br/><br/>

    <b>Note:</b> Not all actions that manipulate images support the same input file formats as this action.    
    <e>
      SetLuminanceFactor("24")<br/>
      SetChrominanceFactor("10")<br/>
      SetGrayScale("True")<br/>
      <b>ConvertToJPEG()</b>
    </e>
  </h>
</ref>

<ref id="ConvertToTIFF" access="public" bInter="bInter" bDebug="bDebug" qi="Converts the current image to a TIFF.">
  <ap>
    None.
  </ap>
  <lvl>
    Page Level.
  </lvl>
  <ret>
    <b>True,</b> if the image is converted to a TIFF.<br/>
    <b>False,</b> if the input image is a TIFF or if a failure occurs during the conversion.
  </ret>
  <h>
    Converts the current image to a TIFF.  The output file name will have a TIF extension.<br/><br/>

    Supported input file formats: BMP (1, 4, 8, or 24-bit), GIF (1, 4 or 8-bit),
    JPG or JPEG (8 and 12-bit grayscale and 24-bit color), and PNG (1, 4, 8 and 24-bit).<br/><br/>

    <b>Note:</b> Not all actions that manipulate images support the same input file formats as this action.
    <e>
      SetTiffCompression("3")<br/>
      <b>ConvertToTIFF()</b>
    </e>
  </h>
</ref>

<ref id="SaveImageInformation" qi="Gets the image information and stores it into the DCO.">
    <ap>
      <b>ImageWidth:</b> The input parameter is the name to be specified by user to store the image width in pixels. If not specified, the DCO variable is not created for width.<br/><br/>
      <b>ImageHeight:</b> The input parameter is the name to be specified by user to store the image height in pixels. If not specified, the DCO variable is not created for height.<br/><br/>
      <b>ImageDPIX:</b> The input parameter is the name to be specified by user to store the DPIX in dots per inch. If not specified, the DCO variable is not created for DPIX.<br/><br/>
      <b>ImageDPIY:</b> The input parameter is the name to be specified by user to store the DPIY in dots per inch. If not specified, the DCO variable is not created for DPIY.<br/><br/>
      <b>PhysicaImageWidth:</b> The input parameter is the name to be specified by user to store the physical width in pixels. If not specified, the DCO variable is not created for physical width.<br/><br/>
      <b>PhysicalImageHeight:</b> The input parameter is the name to be specified by user to store the physical height in pixels. If not specified, the DCO variable is not created for physical height.<br/><br/>
      <b>BitDepth:</b> The input parameter is the name to be specified by user to store the Depth in bit. If not specified, the DCO object is not created for Bit Depth.<br/><br/>
      Smart parameters are supported for all parameters.<br/><br/>
    </ap>
    <h>
      This action will get the image information Height, Width, DPIX, DPIY, Physical Height, Physical Width,Bit Depth
      into respective parameters specified by user and store it into the Document heirarchy/><br/>

      <e>
        <b>SaveImageInformation("@P.Width","@P.Height","@P.DPIx","@P.DPIy","@P.PhysicalWidth","@P.PhysicalHeight","@P.BitDepth")</b>
        <br/>

        This example stores image information into variables specified by user at the page level.<br/><br/>
        Width = "2479"<br/>
        Height = "3508"<br/>
        DPIx = "300"<br/>
        DPIy = "300"<br/>
        PhysicalWidth = "743700"<br/>
        PhysicalHeight = "1052400"<br/>
        BitDepth = "1"<br/><br/>

        <b>SaveImageInformation(" "," ","@P.DPIx","@P.DPIy","@P.PhysicalWidth","@P.PhysicalHeight","@P.BitDepth")</b>
        <br/>

        This example stores image information DPIx, DPIy, PhysicalWidth, PhysicalHeight,BitDepth into respective variables
        specified at the page level.<br/><br/>
        DPIx = "300"<br/>
        DPIy = "300"<br/>
        PhysicalWidth = "743700"<br/>
        PhysicalHeight = "1052400"<br/>
        BitDepth = "1"<br/><br/>

        <b>SaveImageInformation("@P\Field1.Width","@P\Field1.Height","@P\Field1.DPIx","@P\Field1.DPIy","@P\Field1.PhysicalWidth","@P\Field1.PhysicalHeight","@P\Field1.BitDepth")</b>
        <br/>

        This example stores image information into respective parameters specified by user at the field level.<br/><br/>
        Width = "2479"<br/>
        Height = "3508"<br/>
        DPIx = "300"<br/>
        DPIy = "300"<br/>
        PhysicalWidth = "743700"<br/>
        PhysicalHeight = "1052400"<br/>
        BitDepth = "1"<br/><br/>
      </e>
    </h>
    <lvl>Page level only, and the page must refer to a valid single page image file.</lvl>
    <ret>
      <b>True</b> if the operation is successful, else <b>False</b> if any error occurred.
    </ret>
  </ref>

</help>
</rrx>
<rrx namespace="ImageFix" src="c:\datacap\RRS\ImageFix.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="ImageEnhance" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ImageEnhance = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not g_ScanFix Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[    Set g_ScanFix.CurrentDCO = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[    ImageEnhance = g_ScanFix.ImageEnhance(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog "ScanFix object is not initialized."]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="LoadSettings" access="public" bInter="bInter" bDebug="bDebug" strParam="sFilePath">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  LoadSettings = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not g_ScanFix Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[    g_ScanFix.CurrentDCO = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[    LoadSettings = g_ScanFix.LoadSettings(sFilePath)]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog "ScanFix object is not initialized."]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="LoadSettings_FingerprintID" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[    LoadSettings_FingerprintID = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Dim sFingerPrintFolderPath]]>
<![CDATA[
]]>
<![CDATA[	  Dim sProjectFolderPath]]>
<![CDATA[
]]>
<![CDATA[	  Dim aLookup	]]>
<![CDATA[
]]>
<![CDATA[	  Dim sFprintpath]]>
<![CDATA[
]]>
<![CDATA[	  Dim sSQL]]>
<![CDATA[
]]>
<![CDATA[  			]]>
<![CDATA[
]]>
<![CDATA[	  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.Variable("FingerprintDir") <> "" Then]]>
<![CDATA[
]]>
<![CDATA[      sFingerPrintFolderPath = CurrentObj.Variable("FingerprintDir")]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      If CurrentObj.Variable("TemplateID")<>"" then	]]>
<![CDATA[
]]>
<![CDATA[		    aLookup = GetDataArray("SELECT TP_CCOPATH FROM TEMPLATE WHERE TP_TEMPLATEID=" & CurrentObj.Variable("TemplateID") & "; ")]]>
<![CDATA[
]]>
<![CDATA[  				]]>
<![CDATA[
]]>
<![CDATA[		    sFingerPrintFolderPath = ""]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[		    If isarray(aLookup) and not(isEmpty(aLookup)) then]]>
<![CDATA[
]]>
<![CDATA[			      sFingerPrintFolderPath = trim(aLookup(0,0))]]>
<![CDATA[
]]>
<![CDATA[			    If isnull(sFingerPrintFolderPath)=true then ]]>
<![CDATA[
]]>
<![CDATA[				    sFingerPrintFolderPath=""]]>
<![CDATA[
]]>
<![CDATA[			    Else]]>
<![CDATA[
]]>
<![CDATA[				    sFingerPrintFolderPath = trim(FileMgr.GetParentFolderName(sFingerPrintFolderPath))]]>
<![CDATA[
]]>
<![CDATA[			    End if]]>
<![CDATA[
]]>
<![CDATA[		    End if]]>
<![CDATA[
]]>
<![CDATA[  		]]>
<![CDATA[
]]>
<![CDATA[		    If sFingerPrintFolderPath="" then]]>
<![CDATA[
]]>
<![CDATA[			    Writelog("No FingerPrint INI found.")]]>
<![CDATA[
]]>
<![CDATA[          Exit Function]]>
<![CDATA[
]]>
<![CDATA[		    Else]]>
<![CDATA[
]]>
<![CDATA[			    Writelog("FingerPrint Path: '" & cstr(sFingerPrintFolderPath) & "' ")]]>
<![CDATA[
]]>
<![CDATA[		    End if]]>
<![CDATA[
]]>
<![CDATA[	    End if]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Not g_ScanFix Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[      Set g_ScanFix.CurrentDCO = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	    LoadSettings_FingerprintID = g_ScanFix.LoadSettings_FingerprintID (sFingerPrintFolderPath)]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog "ScanFix object is not initialized."]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<help>
  <![CDATA[
'****************************************************
' ImageFix.rrx - a description of the library

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2016 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.

'****************************************************

]]>

  <ref id="ImageEnhance" qi="Initiates image processing.">
    <ap>
      The file extension that the action is to assign to the backup of the original Image file.
      For example: tio<br/><br/>
      The extension must be at least 1 character.  If the leading period is provided,
      it must have at least one character following it.  Long name file extensions are allowed.
    </ap>
    <h>
      Initiates image processing to perform a preconfigured set of image enhancements.<br/><br/>

      Include this action after a <scr>LoadSettings</scr> or <scr>LoadSettings_FingerprintID</scr> action.
      <e>
        LoadSettings("C:\ParentDir\Invoice\Process\ImageFix.ini")<br/>
        <b>ImageEnhance("tio")</b>
        <br/><br/>

        Keep in mind in this example that the ImageFix settings specified in ImageFix.ini will be
        applied to every page in the batch.  An example of the copied file name: "TM000001.tio".<br/><br/>

        LoadSettings("C:\ParentDir\Invoice\Process\ImageFix.ini")<br/>
        <b>ImageEnhance("tio.tif")</b>
        <br/><br/>

        This example uses a longer file extension, which preserves the original file type,
        making it easier to view the original file without renaming.
        An example of the copied file name: "TM000001.tio.tif".
      </e>
    </h>
    <lvl>Page or Field Level.</lvl>
    <ret>
      <b>False</b> if the parameter is too short.  Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="LoadSettings" qi="Loads the settings that an ImageFix action will use to process all images in the current batch. Note: The action can use a smart parameter to designate the path value for the Settings file (.ini).">
    <ap>
      <i>String</i>value of the name of the ImageFix Settings file (.ini). The action will search
      for a file of this name in the application's <b>Process</b>directory.<br/><br/>

      If this file is not located in the <b>Process</b> directory, you  must provide the file's
      full path as well as its name.<br/><br/>
      Note, however, that the action can use Smart Parameter syntax, such as the '@PATH(string)'
      method to specify the path.
    </ap>
    <h>
      This action loads the settings that the <b>ImageFix</b>action will use to process all images
      in the current batch. The action's parameter includes the file's name and complete path to
      its location in the application's <b>Process</b>directory. As an alternative, the parameter
      can use a <i>smart</i> parameter such as @Path to designate the value of the path to the
      same <b>Process</b>directory.<br/>
      <e>
        <scr>
          <b>LoadSettings(C:\ParentDir\Invoice\Process\ImageFix.ini)</b>
        </scr>
        <br/>
        <scr>ImageEnhance(tio)</scr>
        <br/>
        <br/>
      </e>
      <e>
        Loads the settings file using the path denoted by the "ScanFixSettings" key that is listed
        in the Paths.ini file.  If the key pointed to a relative path, it would be converted to the
        appropriate full path and then use that path to find the settings:<br/><br/>
        <scr>
          <b>LoadSettings(@PATH(ScanFixSettings))</b>
        </scr>
        <br/>
        <scr>ImageEnhance(tio)</scr>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if the ImageFix Settings file that you specify as a parameter is not found. Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="LoadSettings_FingerprintID" qi="Loads the specific ImageFix Settings file (.ini) that corresponds to the Fingerprint ID of the current page.">
    <ap>None.</ap>
    <h>
      Loads the specific ImageFix Settings file (.ini) that corresponds to the Fingerprint ID of the current page.<br/><br/>

      The action will search the application's fingerprint folder for a fingerprint-specific
      ImageFix Settings file. Settings for these files are assigned during the Image Enhancement phase
      of Fingerprint Definition, using tools of Rule Manager's Image Processing Setup dialog.
      (Chapter 3 of the Rule Manager Reference shows you how to define a fingerprint-specific
      ImageFix Settings file.)<br/><br/>

      <b>Important!</b> The name of a fingerprint-specific ImageFix Settings file is limited to
      the Fingerprint ID with the ".ini" extension: 1044.ini, for example.
      <e>
        <scr>
          <b>LoadSettings_FingerprintID()</b>
        </scr>
        <br/>
        <scr>ImageEnhance(tio)</scr>
      </e>
    </h>
    <lvl>Page level only.</lvl>
    <ret>
      <b>False</b> if a fingerprint-specific Settings file does not exist. Otherwise, <b>True.</b>
    </ret>
  </ref>
</help>

</rrx>
<rrx namespace="Imprint" src="c:\datacap\RRS\Imprint.dll">

<i ref="rrunner">
</i>
<i ref="locate">
</i>
<g>
</g>
<af name="SetFontName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Specifies the font style that will be used.]]>
<![CDATA[
]]>
<![CDATA[  'String value of the font's name.</ap>]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If(Not oImPrint is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[		call oImPrint.SetFontName(StrParam)]]>
<![CDATA[
]]>
<![CDATA[		SetFontName = true]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		SetFontName = false]]>
<![CDATA[
]]>
<![CDATA[		writelog("ImPrint object is not properly initialized")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFontSize" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Specifies the font size that will be used. ]]>
<![CDATA[
]]>
<![CDATA[  'Numeric value of the font's size.</ap>  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	if(Not oImPrint is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[		if(isNumeric(StrParam)) Then]]>
<![CDATA[
]]>
<![CDATA[			call oImPrint.SetFontSize(StrParam)]]>
<![CDATA[
]]>
<![CDATA[			SetFontSize = true]]>
<![CDATA[
]]>
<![CDATA[		else]]>
<![CDATA[
]]>
<![CDATA[			SetFontSize = false]]>
<![CDATA[
]]>
<![CDATA[			writelog("Parameter is not numeric")]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[	else]]>
<![CDATA[
]]>
<![CDATA[		SetFontSize = false]]>
<![CDATA[
]]>
<![CDATA[		writelog("ImPrint object is not properly initialized")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetAdjustedWidth" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Numeric value of the maximum character length of the string to be imprinted.]]>
<![CDATA[
]]>
<![CDATA[	' Adjust the width of the imprinted text.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'This action is optional.  If the action is not used, the adjusted width will default to 30.  ]]>
<![CDATA[
]]>
<![CDATA[  ' If your text is being cut off, increase the parameter value.]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	If(Not oImPrint is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[		if(isNumeric(StrParam)) Then]]>
<![CDATA[
]]>
<![CDATA[			call oImPrint.SetAdjustWidth(StrParam)]]>
<![CDATA[
]]>
<![CDATA[			SetAdjustedWidth = true]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[			SetAdjustedWidth = false]]>
<![CDATA[
]]>
<![CDATA[			writelog("Parameter is not numeric")]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		SetAdjustedWidth = false]]>
<![CDATA[
]]>
<![CDATA[		writelog("ImPrint object is not properly initialized")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetOpaque" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Sets the opacity/transparency of rectangles that cover text, or images beneath the text, resulting from Imprint actions."]]>
<![CDATA[
]]>
<![CDATA[  '  Integer value: 1 or 0.]]>
<![CDATA[
]]>
<![CDATA[  '  SetOpaque(1) indicates full opacity and is typical.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[  '  SetOpaque(0) results in subsequent rectangles that are translucent (transparent.)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  Call oImPrint.SetOpaque(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  SetOpaque = True ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<f name="AnnotateImage" access="public">
	<p name="displayText">
	</p>
	<p name="xCoordinate">
	</p>
	<p name="yCoordinate">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   'Imprints the text you specify onto the current page's image file"]]>
<![CDATA[
]]>
<![CDATA[   'Three parameters:<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'displayText Comma-delimited string to be placed onto the image:<br/>]]>
<![CDATA[
]]>
<![CDATA[    'The 'text' parameter can combine plain text along with any number of tags]]>
<![CDATA[
]]>
<![CDATA[    'that will be evaluated at runtime.  Use commas to separate each part of the string.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    '<b>A)</b> Text to place on the image.  The text cannot contain commas.<br/>]]>
<![CDATA[
]]>
<![CDATA[    '<b>B)</b> Variables:<br/>]]>
<![CDATA[
]]>
<![CDATA[    '<b>1.</b> @BATCHID - The current Batch ID.<br/>]]>
<![CDATA[
]]>
<![CDATA[    '<b>2.</b> @ID - The ID of the current object.<br/>]]>
<![CDATA[
]]>
<![CDATA[    '<b>3.</b> @STATUS - Status of the current object.<br/>]]>
<![CDATA[
]]>
<![CDATA[    '<b>4.</b> @TYPE - Type of the current object.<br/>]]>
<![CDATA[
]]>
<![CDATA[    '<b>5.</b> @DATE - Today's date.]]>
<![CDATA[
]]>
<![CDATA[    '<b>6.</b> @TIME - Current time.]]>
<![CDATA[
]]>
<![CDATA[    '<b>7.</b> @VARIABLE - ObjectType/VariableName<br/>]]>
<![CDATA[
]]>
<![CDATA[    'For ObjectType in Option #7 above:<br/> ]]>
<![CDATA[
]]>
<![CDATA[    '0 = Batch<br/>]]>
<![CDATA[
]]>
<![CDATA[    '1 = Document<br/>]]>
<![CDATA[
]]>
<![CDATA[    '2 = Page<br/>]]>
<![CDATA[
]]>
<![CDATA[    '3 = Field<br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    '<b>xCoordinate</b> The X coordinate for the starting position of the text on the image.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[    '<b>yCoordinate</b> The Y coordinate for the starting position of the text on the image.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim nParam]]>
<![CDATA[
]]>
<![CDATA[  Dim tmpX]]>
<![CDATA[
]]>
<![CDATA[  Dim tmpY]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	nParam = -1]]>
<![CDATA[
]]>
<![CDATA[  AnnotateImage = False	 ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  displayText = Trim(displayText)]]>
<![CDATA[
]]>
<![CDATA[  if (Len(displayText) = 0) Then]]>
<![CDATA[
]]>
<![CDATA[    writelog("AnnotateImage: displayText value must not be blank.")]]>
<![CDATA[
]]>
<![CDATA[		exit function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  tmpX = Trim(MetaWord(xCoordinate))]]>
<![CDATA[
]]>
<![CDATA[  If len(tmpX)>0 then xCoordinate=tmpX]]>
<![CDATA[
]]>
<![CDATA[	X = Trim(xCoordinate)]]>
<![CDATA[
]]>
<![CDATA[	if(Not IsNumeric(X)) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("AnnotateImage: X coordinate is not numeric: '" & X & "'.")]]>
<![CDATA[
]]>
<![CDATA[		exit function]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  tmpY = Trim(MetaWord(yCoordinate))]]>
<![CDATA[
]]>
<![CDATA[  If len(tmpY)>0 then yCoordinate=tmpY]]>
<![CDATA[
]]>
<![CDATA[	Y = Trim(yCoordinate)]]>
<![CDATA[
]]>
<![CDATA[	if(Not IsNumeric(Y)) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("AnnotateImage: Y coordinate is not numeric: '" & Y & "'.")]]>
<![CDATA[
]]>
<![CDATA[		exit function]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	writelog("Text string to annotate on image is: " & displayText)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oImPrint.InitPageVariables()]]>
<![CDATA[
]]>
<![CDATA[	call oImPrint.EndorseString(displayText,X,Y)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	AnnotateImage = true]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<f name="RedactParameters" access="public" qi="Redacts a specified area of the page.">
	<p name="FillColor">
	</p>
	<p name="NewText">
	</p>
	<p name="TopLeftX">
	</p>
	<p name="TopLeftY">
	</p>
	<p name="BottomRightX">
	</p>
	<p name="BottomRightY">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   RedactParameters = false]]>
<![CDATA[
]]>
<![CDATA[   Dim sParams]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   FillColor    = MetaWord(FillColor)]]>
<![CDATA[
]]>
<![CDATA[   NewText      = MetaWord(NewText)]]>
<![CDATA[
]]>
<![CDATA[   TopLeftX     = MetaWord(TopLeftX)]]>
<![CDATA[
]]>
<![CDATA[   TopLeftY     = MetaWord(TopLeftY)]]>
<![CDATA[
]]>
<![CDATA[   BottomRightX = MetaWord(BottomRightX)]]>
<![CDATA[
]]>
<![CDATA[   BottomRightY = MetaWord(BottomRightY)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   sParams = FillColor & "," & NewText & "," & TopLeftX & "," & TopLeftY & "," & BottomRightX & "," & BottomRightY]]>
<![CDATA[
]]>
<![CDATA[   WriteLog("Parameters are: " & sParams )]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   writelog "Starting Redaction"]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Dim aParam, l,t,r,b, cBack, cFore, redactImage, fileName, sText, fName, nType]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   writelog "CurrentObj.ObjecType: " & CurrentObj.ObjectType]]>
<![CDATA[
]]>
<![CDATA[   nType=1]]>
<![CDATA[
]]>
<![CDATA[   If NewText <> "" Then nType=9]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If (CurrentObj.ObjectType = 2) Then   ]]>
<![CDATA[
]]>
<![CDATA[      If Not IsNumeric(TopLeftX) Then]]>
<![CDATA[
]]>
<![CDATA[         Writelog "At page level, TopLeftX parameter must be numeric.  Exiting action."]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If Not IsNumeric(TopLeftY) Then]]>
<![CDATA[
]]>
<![CDATA[         Writelog "At page level, TopLeftX parameter must be numeric.  Exiting action."]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[      If Not IsNumeric(BottomRightX) Then]]>
<![CDATA[
]]>
<![CDATA[         Writelog "At page level, TopLeftX parameter must be numeric.  Exiting action."]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If Not IsNumeric(BottomRightX) Then]]>
<![CDATA[
]]>
<![CDATA[         Writelog "At page level, TopLeftX parameter must be numeric.  Exiting action."]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End If    ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      l=cint(TopLeftX)]]>
<![CDATA[
]]>
<![CDATA[      t=cint(TopLeftY)]]>
<![CDATA[
]]>
<![CDATA[      r=cint(BottomRightX)]]>
<![CDATA[
]]>
<![CDATA[      b=cint(BottomRightY)]]>
<![CDATA[
]]>
<![CDATA[      WriteLog "Setting position to specified position " & l & "," & t  & "," & r & "," & b]]>
<![CDATA[
]]>
<![CDATA[      fName = CurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[   ElseIf (CurrentObj.ObjectType=3) Then	]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.GetPosition l,t,r,b]]>
<![CDATA[
]]>
<![CDATA[      WriteLog "Field level, Ignoring XY parameters, Setting position to current field position " & l & "," & t  & "," & r & "," & b]]>
<![CDATA[
]]>
<![CDATA[      Dim oPage]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[      Do While oPage.ObjectType>2]]>
<![CDATA[
]]>
<![CDATA[            Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[      Loop			]]>
<![CDATA[
]]>
<![CDATA[      fName = oPage.ImageName]]>
<![CDATA[
]]>
<![CDATA[      writelog "oPage Type " & oPage.ObjectType]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = nothing]]>
<![CDATA[
]]>
<![CDATA[   Else ]]>
<![CDATA[
]]>
<![CDATA[      WriteLog "Action has been called at the wrong level.  Exiting Action."]]>
<![CDATA[
]]>
<![CDATA[      babort=true]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Dim area]]>
<![CDATA[
]]>
<![CDATA[   area = (r - l) * (b - t)]]>
<![CDATA[
]]>
<![CDATA[   If (area <= 0) Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Invalid field bounds.  Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[      babort=true]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   writelog "file name is: " & fname]]>
<![CDATA[
]]>
<![CDATA[   If UCase(FillColor) = "WHITE" Then]]>
<![CDATA[
]]>
<![CDATA[      If nType=1 Then]]>
<![CDATA[
]]>
<![CDATA[         cBack=16777215]]>
<![CDATA[
]]>
<![CDATA[         cFore=0]]>
<![CDATA[
]]>
<![CDATA[      ElseIf nType=9 Then]]>
<![CDATA[
]]>
<![CDATA[         cBack=0]]>
<![CDATA[
]]>
<![CDATA[         cFore=16777215]]>
<![CDATA[
]]>
<![CDATA[      End If	]]>
<![CDATA[
]]>
<![CDATA[      WriteLog "WHITE Background"]]>
<![CDATA[
]]>
<![CDATA[   ElseIf UCase(FillColor) = "BLACK" Then]]>
<![CDATA[
]]>
<![CDATA[      If nType=1 Then]]>
<![CDATA[
]]>
<![CDATA[         cBack=0]]>
<![CDATA[
]]>
<![CDATA[         cFore=16777215]]>
<![CDATA[
]]>
<![CDATA[      ElseIf nType=9 Then]]>
<![CDATA[
]]>
<![CDATA[         cBack=16777215]]>
<![CDATA[
]]>
<![CDATA[         cFore=0]]>
<![CDATA[
]]>
<![CDATA[      End If	]]>
<![CDATA[
]]>
<![CDATA[      WriteLog "BLACK"		]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      WriteLog "First paramter must be white or black.  Exiting Action."]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If NewText <> "" Then]]>
<![CDATA[
]]>
<![CDATA[      sText = NewText]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[       sText = ""]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   WriteLog "Text: " & sText]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ImageCtrl.FileName=fName]]>
<![CDATA[
]]>
<![CDATA[   writelog "loaded image"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ImageCtrl.GetImageInfo iW, iH, iR]]>
<![CDATA[
]]>
<![CDATA[   dim xDPI]]>
<![CDATA[
]]>
<![CDATA[   dim yDPI]]>
<![CDATA[
]]>
<![CDATA[   ImageCtrl.GetRes xDPI, yDPI]]>
<![CDATA[
]]>
<![CDATA[   writelog "image width, height, bitDepth " & iW & " " & iH & " " & iR]]>
<![CDATA[
]]>
<![CDATA[   writelog "image xDPI, yDPI " & xDPI & " " & yDPI]]>
<![CDATA[
]]>
<![CDATA[   If iW<r Then r=iW]]>
<![CDATA[
]]>
<![CDATA[   If iH<b Then b=iH]]>
<![CDATA[
]]>
<![CDATA[   if l<0 then l=0]]>
<![CDATA[
]]>
<![CDATA[   if t<0 then t=0]]>
<![CDATA[
]]>
<![CDATA[   writelog "checked boundaries"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ImageCtrl.EnableAnnot=true]]>
<![CDATA[
]]>
<![CDATA[   WriteLog "Drawing rectangle " & l & " " & t & " " & r & " " & b & " " & nType & " " & cBack & " " & cFore & " " & sText]]>
<![CDATA[
]]>
<![CDATA[   Call ImageCtrl.DrawRect(l,t,r,b,nType,cBack,cFore,sText)]]>
<![CDATA[
]]>
<![CDATA[   WriteLog "Rectangle drawn"]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Dim bColor]]>
<![CDATA[
]]>
<![CDATA[   bColor=False]]>
<![CDATA[
]]>
<![CDATA[   If cint(iR) > 1 then bColor = true   ' preseve color if a color image]]>
<![CDATA[
]]>
<![CDATA[	 ImageCtrl.MergeAnnotations(bColor)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Call ImageCtrl.SetRes(xDPI,yDPI)]]>
<![CDATA[
]]>
<![CDATA[   WriteLog "Saving Image"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set fso = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[   if Not fso.FileExists(fName) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("ERROR - Source file does not exist: " & fName)]]>
<![CDATA[
]]>
<![CDATA[      babort=true]]>
<![CDATA[
]]>
<![CDATA[      set fso = nothing]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   dim sDest]]>
<![CDATA[
]]>
<![CDATA[   sDest = fName & ".redact"]]>
<![CDATA[
]]>
<![CDATA[   Call fso.CopyFile(fName, sDest)]]>
<![CDATA[
]]>
<![CDATA[   if err.number <>0 then]]>
<![CDATA[
]]>
<![CDATA[      writelog "Error backing up image"]]>
<![CDATA[
]]>
<![CDATA[      writelog "Error Number " & cstr(err.number)]]>
<![CDATA[
]]>
<![CDATA[      writelog "Error Description " & err.description]]>
<![CDATA[
]]>
<![CDATA[      err.clear]]>
<![CDATA[
]]>
<![CDATA[      Set fso = Nothing]]>
<![CDATA[
]]>
<![CDATA[      babort=true]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Call fso.DeleteFile(fName, True)]]>
<![CDATA[
]]>
<![CDATA[   ImageCtrl.Save(fName)]]>
<![CDATA[
]]>
<![CDATA[   if err.number <>0 then]]>
<![CDATA[
]]>
<![CDATA[      writelog "Error saving redacted image"]]>
<![CDATA[
]]>
<![CDATA[      writelog "Error Number " & cstr(err.number)]]>
<![CDATA[
]]>
<![CDATA[      writelog "Error Description " & err.description]]>
<![CDATA[
]]>
<![CDATA[      err.clear]]>
<![CDATA[
]]>
<![CDATA[      Set fso = Nothing]]>
<![CDATA[
]]>
<![CDATA[      babort=true]]>
<![CDATA[
]]>
<![CDATA[      exit function]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Call fso.DeleteFile(sDest, True)	]]>
<![CDATA[
]]>
<![CDATA[   end if	]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set fso = Nothing]]>
<![CDATA[
]]>
<![CDATA[   WriteLog "Saved Image"]]>
<![CDATA[
]]>
<![CDATA[   if err.number <>0 then]]>
<![CDATA[
]]>
<![CDATA[      writelog "Error Deleting temp file"]]>
<![CDATA[
]]>
<![CDATA[      writelog "Error Number " & cstr(err.number)]]>
<![CDATA[
]]>
<![CDATA[      writelog "Error Description " & err.description]]>
<![CDATA[
]]>
<![CDATA[      err.clear]]>
<![CDATA[
]]>
<![CDATA[   end if   ]]>
<![CDATA[
]]>
<![CDATA[   RedactParameters = true]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<f name="RedactByRegEx" access="public" qi="Redacts all occurrences of the specified regular expression.">
	<p name="RegEx">
	</p>
	<p name="VariableBase">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   RedactByRegEx = TRUE       'Actions must always return a TRUE or FALSE.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("This action must be on the Field level.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   RegEx = MetaWord(RegEx)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   count = 1]]>
<![CDATA[
]]>
<![CDATA[   if RegExFind(false, false, RegEx) then]]>
<![CDATA[
]]>
<![CDATA[      Call UpdateField(false, false)      ]]>
<![CDATA[
]]>
<![CDATA[      FoundFieldPosition = CurrentObj.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Found field position: " & FoundFieldPosition)]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.Parent.Parent.Variable(VariableBase & cStr(count)) = CurrentObj.Parent.ID & "," & CurrentObj.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[      count = 2]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[      ' call Redact(false,false,"Black,,,,,") 'Fill color, text, lx, ly, rx, ry - Coords ignored for field level]]>
<![CDATA[
]]>
<![CDATA[      call RedactParameters("Black","","","","","")  'Fill color, text, lx, ly, rx, ry - Coords ignored for field level]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Phrase found and redacted")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      While RegExFindNext( false, false, RegEx)]]>
<![CDATA[
]]>
<![CDATA[         Call UpdateField(false, false)]]>
<![CDATA[
]]>
<![CDATA[         If CurrentObj.Variable("Position") = FoundFieldPosition then]]>
<![CDATA[
]]>
<![CDATA[            Exit Function]]>
<![CDATA[
]]>
<![CDATA[         else]]>
<![CDATA[
]]>
<![CDATA[            CurrentObj.Parent.Parent.Variable(VariableBase & cStr(count)) = CurrentObj.Parent.ID & "," & CurrentObj.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[            count = Count + 1]]>
<![CDATA[
]]>
<![CDATA[            ' call Redact(false,false,"Black,,,,,") 'Fill color, text, lx, ly, rx, ry - Coords ignored for field level]]>
<![CDATA[
]]>
<![CDATA[            call RedactParameters("Black","","","","","")  'Fill color, text, lx, ly, rx, ry - Coords ignored for field level]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Phrase found and redacted")]]>
<![CDATA[
]]>
<![CDATA[         end if]]>
<![CDATA[
]]>
<![CDATA[      Wend]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<help>
  <![CDATA[
'************************************************************************
' ImPrint Actions help
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2016 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************************
]]>
  
<ref id="SetFontName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
  <ap>
    String value of the font's name.  Smart parameters are supported.
  </ap>
  <h>
    Specifies the font style that will be used.<br/><br/>

    This action is optional. If not used, the font style will default to Times New Roman.
    If you use this action, it must be called prior to the AnnotateImage action.<br/><br/>
    <e>
      <b>SetFontName("Arial")</b>
      <br/>
      <scr>SetFontSize("10")</scr>
      <br/>
      <scr>SetAdjustedWidth("100")</scr>
      <br/>
      AnnotateImage("@BATCHID+ Page:+@ID","0","0")
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the parameter is missing.  Otherwise <b>True.</b>
  </ret>
</ref>
	
<ref id="SetFontSize" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
  <ap>
    Numeric value of the font's size. Smart parameters are supported.
  </ap>  
  <h>
    Specifies the font size that will be used.<br/><br/>

    This action is optional. If you do not use the action, the font size will default to 12.
    If you use this action, it must be called prior to the AnnotateImage action.<br/><br/>
    <e>
      <scr>SetFontName("Arial")</scr>
      <br/>
      <scr>SetFontSize("10")</scr>
      <br/>
      <scr>SetAdjustedWidth("100")</scr>
      <br/>
      AnnotateImage("@BATCHID+ Page:+@ID","0","0")
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the parameter is not Numeric.  Otherwise <b>True.</b>
  </ret>
</ref>

  
<ref id="SetAdjustedWidth" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<ap>
    Numeric value for a length adjustment of the string to be imprinted.  Smart parameters are supported.
  </ap>	
	<h>
    This actions adjusts the maximum width of the imprinted text.  It is possible that the 
    calculation of the string length may not allow for the entire string in the specified font and point size.
    This is an adjustment factor which will lengthen the area for the string to imprint on the image.<br/><br/>
    
	  This action is optional.  If the action is not used, the adjusted width will default to 30.  
    If your text is being cut off, increase the parameter value.  If you use this action
    it must be called prior to the AnnotateImage action.<br/><br/>
		<e>
      SetFontName("Arial")<br/>
		  SetFontSize("10")<br/>
  		<b>SetAdjustedWidth("100")</b><br/>
      AnnotateImage("@BATCHID+ Page:+@ID","0","0")
    </e>
	</h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the parameter is not numeric.  Otherwise, <b>True.</b>
  </ret>
</ref>

  
<ref id="SetOpaque" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
  <ap>
    Integer value: 1 or 0.<br/><br/>
    SetOpaque(1) indicates full opacity / black.<br/>
    SetOpaque(0) results in subsequent rectangles that are white.<br/>
    Smart parameters are supported.
  </ap>
  <h>
    Sets the transparency of the background of the imprint text.  This is the background that is
    added behind the imprinted text.  If you use this action it must be called
    prior to the AnnotateImage action.<br/><br/>
    
    If this action is not called, then the default value of 0, white, will be used for the background of the annotation text.
    <e>
      <b>SetOpaque("1")</b><br/>
      AnnotateImage("@BATCHID+ Page:+@ID","0","0")
    </e>
  </h>
  <lvl>All, but generally used at the Page level.</lvl>
  <ret>
    <b>False</b> if the parameter is not an <i>Integer.</i> Otherwise, <b>True.</b>
  </ret>
</ref>


<ref id="AnnotateImage" access="public">
  <p name="displayText"/>
  <p name="xCoordinate"/>
  <p name="yCoordinate"/>
  <ap>
    Three parameters:<br/><br/>

    <b>displayText</b> smart parameter supported string to be placed onto the image.<br/>
    The 'displaytext' can combine plain text along with smart parameters.<br/><br/>

    <b>xCoordinate</b> The X coordinate for the starting position of the text on the image. Smart parameter supported.<br/><br/>

    <b>yCoordinate</b> The Y coordinate for the starting position of the text on the image. Smart parameter supported.
  </ap>
  <h>
    Imprints the text you specify onto the current page's image file.<br/><br/>

    By default, the text's font size is 12, and font's style "Times New Roman", with an adjusted width of 30.<br/><br/>
    <e>
      SetFontName("Arial")<br/>
      SetFontSize("10")<br/>
      SetAdjustedWidth("100")<br/>
      <b>AnnotateImage("@BATCHID+ Page:+@ID","0","0")</b><br/><br/>

      This example will place the Batch ID followed by ' Page:' and the calling object ID at the top of the image using the 'Arial' font
      with a point size of 10 and a width of 100.
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if parameter(s) are missing, or the X or Y parameters are not Numeric.  Otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="ImPrint" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
  <ap>
    Three parts, separated by semicolons(;).  See AnnotateImage for descriptions of the parameters.<br/><br/>
  </ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.
    Instead, use the AnnotateImage action.
    <br/><br/>
    See the action help for details.<br/><br/><br/>    
  </h>
  <see>AnnotateImage</see>
</ref>

<ref id="RedactParameters" access="public">
  <p name="FillColor"/>
  <p name="NewText" />
  <p name="TopLeftX" />
  <p name="TopLeftY" />
  <p name="BottomRightX" />
  <p name="BottomRightY" />
  <ap>    
    <b>FillColor:</b> The fill color to use.  Must be either White, or Black.<br/>
    <b>NewText:</b> Optional - The text to include in the overlay.<br/>
    <b>TopLeftX</b> The top left X coordinate in pixels.<br/>
    <b>TopLeftY</b> The top left Y coordinate in pixels.<br/>
    <b>BottomRightX</b> The bottom right X coordinate in pixels.<br/>
    <b>BottomRightY</b> The bottom right Y coordinate in pixels.<br/><br/>
    
    Smart parameters are supported for all parameters.
  </ap>
  <h>
    This action overlays a black, or white rectangle on the image.  A default text value may optionally be applied to the overlay.<br/><br/>
    
    If run on the field level, the entire field will be redacted and the last four X/Y parameters will be ignored.
    If run on the page level the last four parameters to specify the location must be provided.<br/><br/>       
    <e>
      <b>RedactParameters("black","","0","0","100","100")</b><br/>
      Called at the page level, this will apply a black square overlay on the top left of the image.<br/><br/>

      <b>RedactParameters("White","Hello","","","","")</b><br/>
      Called at the field level, this will apply a white square overlay on the coordinates for the current field,
      and imprint the word "Hello".<br/>
    </e>
  </h>
  <lvl>Page and Field level.</lvl>
  <ret>
    <b>True</b> if the area is redacted.  Otherwise, <b>False.</b>
  </ret>
</ref>  
  
<ref id="Redact" access="private" bInter="bInter" bDebug="bDebug" strParam="StrParam">
  <ap>
    Six comma separated parameters:<br/>
    <b>1.</b> The fill color to use.  Must be either White, or Black.<br/>
    <b>2.</b> Optional - The text to include in the overlay.<br/>
    <b>3.</b> The top left X coordinate in pixels.<br/>
    <b>4.</b> The top left Y coordinate in pixels.<br/>
    <b>5.</b> The bottom right X coordinate in pixels.<br/>
    <b>6.</b> The bottom right Y coordinate in pixels.<br/>
  </ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.
    Instead, use the RedactParameters action.
    <br/><br/>
    See the action help for details.<br/><br/><br/>

    <b>*** Deprecated Description ***</b><br/>
    This action overlays a black, or white rectangle on the image.  A default text value may optionally be applied to the overlay.
    If run on the field level, the entire field will be redacted and the last four parameters will be ignored.
    If run on the page level the last four parameters to specify the location must be included.<br/><br/>
    <e>
      <b>Redact("white,")</b> - will apply a white overlay using the current field position<br/>
      <b>Redact("black,,0,0,100,100")</b> - will apply a black square overlay on the top left of the image
    </e>
  </h>
  <lvl>Page and Field</lvl>
  <ret>
    <b>True</b> if the area is redacted.  Otherwise, <b>False.</b>
  </ret>
  </ref>

<ref id="RedactByRegEx" access="public">
    <p name="RegEx"/>
    <p name="VariableBase" />
    <ap>
      <b>RegEx:</b> The expression to search for on the page.  Smart parameters are supported.<br/>
      <b>VariableBase:</b> A variable to create in the runtime DCO to track each redaction.<br/><br/>      
    </ap>
    <h>
      Although this action is called on a field, it ignores the field zone and searches the entire page
      redacting all occurrences of the phrase that matches the RegEx expression.
      This action must be called at a field level, however the coordinates of the field will change
      during the operation and will remain on the last found occurrence of the found text, so it
      may be necessary to use a zoned but unused field for this action.<br/><br/>

      The VariableBase parameter specifies a variable name to use as a history of redacted words.  For each redaction,
      a variable of the form "VariableBasen", where n is an incrementing number, 
      is created in the runtime DCO with the coordinates of the redacted
      word.  For example, if the parameter was "Hello", the variables created would be named: "Hello1", "Hello2",
      "Hello3", etc. for each redaction.  An example value of the variable: "TM000001,159,1085,242,1115".<br/><br/>
      <e>
        RedactByRegEx("[Hh]istory", "Location")<br/>
        This example will redact all areas on the page where the word "History" or "history" exists.
        The redactions will be tracked in the runtime DCO in a variable called Location0, Location1, etc.<br/><br/>

        An example of the DCO XML:<br/>
        ᗉV n="Location1"ᗌTM000005,771,1523,874,1559ᗉ/Vᗌ<br/>
        ᗉV n="Location2"ᗌTM000005,779,1602,882,1638ᗉ/Vᗌ<br/>
        ᗉV n="Location3"ᗌTM000005,778,1840,881,1875ᗉ/Vᗌ<br/>
      </e>
    </h>
    <lvl>
      Field Level.
    </lvl>
    <ret>
      Always <b>TRUE.</b>
    </ret>
    <see>      
      <b>RedactParameters</b>
    </see>
  </ref>

</help>
</rrx>
<rrx namespace="Intellocate" src="c:\datacap\RRS\Intellocate.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<af name="iloc_SetZones" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   Dim arXY]]>
<![CDATA[
]]>
<![CDATA[   arXY = Split("0,0,0,0",",")]]>
<![CDATA[
]]>
<![CDATA[   arXY(0) = 0]]>
<![CDATA[
]]>
<![CDATA[   arXY(1) = 0]]>
<![CDATA[
]]>
<![CDATA[   arXY(2) = 0]]>
<![CDATA[
]]>
<![CDATA[   arXY(3) = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oSetup = CurrentObj.SetupObject]]>
<![CDATA[
]]>
<![CDATA[   sSetupPath=oSetup.path]]>
<![CDATA[
]]>
<![CDATA[on error resume next]]>
<![CDATA[
]]>
<![CDATA[If oSetup.readlock(sSetupPath) Then]]>
<![CDATA[
]]>
<![CDATA[   If(oSetup Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Can not get SetupObject from currentObj.  Does the DCO exist?")]]>
<![CDATA[
]]>
<![CDATA[      iloc_SetZones = False]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      writelog("Setup Object is received. SetupObj has path" & vbCrLf & oSetup.Path)]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[   If(oPage Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Can not get currentObj.")]]>
<![CDATA[
]]>
<![CDATA[      iloc_SetZones = False]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ' find assigned template]]>
<![CDATA[
]]>
<![CDATA[   sTempl = ""]]>
<![CDATA[
]]>
<![CDATA[   sTempl = oPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[   writelog("Template ID " & sTempl)]]>
<![CDATA[
]]>
<![CDATA[   If(CStr(sTempl) = "" ) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog "unable find out template ID"]]>
<![CDATA[
]]>
<![CDATA[      iloc_SetZones = False]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Call processRunTimeSubFields(oSetup, oPage, sTempl, arXY)]]>
<![CDATA[
]]>
<![CDATA['  call processRunTimeDetailFields(oSetup, oPage, sTempl, arXY)]]>
<![CDATA[
]]>
<![CDATA['  call GetDetailBottomEdge(oSetup, oPage, sTempl)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   writelog("save DCO Setup from " & oSetup.path)	 ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	   If oSetup.WriteSetup(sSetupPath)  Then]]>
<![CDATA[
]]>
<![CDATA[	      writelog("save DCO into local copy")]]>
<![CDATA[
]]>
<![CDATA[	      writelog(oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[	      iloc_SetZones = True ]]>
<![CDATA[
]]>
<![CDATA[	   Else]]>
<![CDATA[
]]>
<![CDATA[	      writelog("unable to save DCO into local copy")]]>
<![CDATA[
]]>
<![CDATA[	      writelog(oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[	      iloc_SetZones = False  ]]>
<![CDATA[
]]>
<![CDATA[	   End If]]>
<![CDATA[
]]>
<![CDATA[	   oSetup.UnlockIt()]]>
<![CDATA[
]]>
<![CDATA[Else]]>
<![CDATA[
]]>
<![CDATA[  writelog("unable to save DCO because it was locked")]]>
<![CDATA[
]]>
<![CDATA[  writelog(oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[  iloc_SetZones = False  ]]>
<![CDATA[
]]>
<![CDATA[End If]]>
<![CDATA[
]]>
<![CDATA[  oSetup.path=sSetupPath]]>
<![CDATA[
]]>
<![CDATA[   if err.number<>0 then]]>
<![CDATA[
]]>
<![CDATA[   	writelog("Error:")]]>
<![CDATA[
]]>
<![CDATA[   	writelog err.number]]>
<![CDATA[
]]>
<![CDATA[   	writelog err.description]]>
<![CDATA[
]]>
<![CDATA[   	err.clear]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[''web   if WriteDCOSetup() then]]>
<![CDATA[
]]>
<![CDATA[''web      iloc_SetZones = true]]>
<![CDATA[
]]>
<![CDATA[''web   else]]>
<![CDATA[
]]>
<![CDATA[''web      iloc_SetZones = false]]>
<![CDATA[
]]>
<![CDATA[     ''web   end if ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="iloc_SetDetailZones" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	iloc_SetDetailZones = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oSetup = CurrentObj.SetupObject]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If(oSetup Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Error - SetupObject Not Found in iloc_SetDetailZones.  Does the DCO exist?")]]>
<![CDATA[
]]>
<![CDATA[		iloc_SetDetailZones = True]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("Setup Object path:'" & oSetup.Path & "'")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[   sSetupPath=oSetup.path]]>
<![CDATA[
]]>
<![CDATA[If oSetup.readlock(sSetupPath) Then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	If(oPage Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Error - Can Not get currentObj in iloc_SetDetailZones.")]]>
<![CDATA[
]]>
<![CDATA[    iloc_SetDetailZones = True]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Find Template ID for oPage]]>
<![CDATA[
]]>
<![CDATA[	sTempl = oPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	writelog("Template ID:'" & sTempl & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Len(sTempl)=0 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Error - Template ID not found in iloc_SetDetailZones.")]]>
<![CDATA[
]]>
<![CDATA[		iloc_SetDetailZones = True]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   'Call processRunTimeSubFields(oSetup, oPage, sTempl, arXY)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Call ProcessRunTimeDetailFields(oSetup, oPage, sTempl)]]>
<![CDATA[
]]>
<![CDATA[	Call GetDetailBottomEdge(oSetup, oPage, sTempl)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If oSetup.WriteSetup(sSetupPath)=False Then]]>
<![CDATA[
]]>
<![CDATA[			writelog("Unable to save Setup DCO:'" & oSetup.path & "'")]]>
<![CDATA[
]]>
<![CDATA[			iloc_SetDetailZones = True]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			writelog("Saved DCO Setup:'" & oSetup.path & "'")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		oSetup.UnlockIt()]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("unable to save DCO because it was locked '" & oSetup.path & "'")]]>
<![CDATA[
]]>
<![CDATA[		iloc_SetDetailZones = True ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[   oSetup.Path=sSetupPath]]>
<![CDATA[
]]>
<![CDATA[	   if err.number<>0 then]]>
<![CDATA[
]]>
<![CDATA[   	writelog("Error:")]]>
<![CDATA[
]]>
<![CDATA[   	writelog err.number]]>
<![CDATA[
]]>
<![CDATA[   	writelog err.description]]>
<![CDATA[
]]>
<![CDATA[   	err.clear]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[	''web   if WriteDCOSetup() then]]>
<![CDATA[
]]>
<![CDATA[	''web      iloc_SetDetailZones = true]]>
<![CDATA[
]]>
<![CDATA[	''web   else]]>
<![CDATA[
]]>
<![CDATA[	''web      iloc_SetDetailZones = false]]>
<![CDATA[
]]>
<![CDATA[     ''web   end if ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="iloc_AdjustZones" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   Dim arImageOffset]]>
<![CDATA[
]]>
<![CDATA[   on error resume next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oSetup = CurrentObj.SetupObject]]>
<![CDATA[
]]>
<![CDATA[   sSetupPath=oSetup.path]]>
<![CDATA[
]]>
<![CDATA[If oSetup.readlock(sSetupPath) Then]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ' set Image Overlay Offset]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   'Find Image Offset information]]>
<![CDATA[
]]>
<![CDATA[   sOffset = CurrentObj.Variable("Image_Offset") ]]>
<![CDATA[
]]>
<![CDATA[   If Len(sOffSet)=0 Then sOffSet=oPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[   If Len(sOffSet)=0 Then ]]>
<![CDATA[
]]>
<![CDATA[      Set oChild = oPage.FindChild("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[      If Not(oChild Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[          sOffset = Trim(oChild.Text)]]>
<![CDATA[
]]>
<![CDATA[          sOffset = Replace(sOffset,";","")			]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If(sOffset="") Then]]>
<![CDATA[
]]>
<![CDATA[      ioX = 0]]>
<![CDATA[
]]>
<![CDATA[      ioY = 0]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      arImageOffset = Split(sOffset,",")]]>
<![CDATA[
]]>
<![CDATA[      If(UBound(arImageOffset) <> 1) Then]]>
<![CDATA[
]]>
<![CDATA[         ioX = 0]]>
<![CDATA[
]]>
<![CDATA[         ioY = 0       ]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[         ioX = CInt(arImageOffset(0))]]>
<![CDATA[
]]>
<![CDATA[         ioY = CInt(arImageOffset(1))         ]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ' find assigned template]]>
<![CDATA[
]]>
<![CDATA[   sTempl = ""]]>
<![CDATA[
]]>
<![CDATA[   sTempl = oPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[   If(CStr(sTempl) = "" ) Then]]>
<![CDATA[
]]>
<![CDATA[      writelog "unable find out template ID"]]>
<![CDATA[
]]>
<![CDATA[      iloc_AdjustZones = False]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ' variable to help find out DETAILS dimension]]>
<![CDATA[
]]>
<![CDATA[   Dim arXY]]>
<![CDATA[
]]>
<![CDATA[   arXY = Split("0,0,0,0",",")]]>
<![CDATA[
]]>
<![CDATA[   arXY(0) = 0]]>
<![CDATA[
]]>
<![CDATA[   arXY(1) = 0]]>
<![CDATA[
]]>
<![CDATA[   arXY(2) = 0]]>
<![CDATA[
]]>
<![CDATA[   arXY(3) = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Call AdjustSetupSubfields(oSetup, oPage, sTempl, arXY, ioX, ioY)]]>
<![CDATA[
]]>
<![CDATA[   Call GetDetailBottomEdge(oSetup, oPage, sTempl)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   writelog("save DCO Setup from " & oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	   If(oSetup.WriteSetup(sSetupPath)) Then]]>
<![CDATA[
]]>
<![CDATA[	      writelog("save DCO into local copy")]]>
<![CDATA[
]]>
<![CDATA[	      writelog(oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[	      iloc_AdjustZones = True]]>
<![CDATA[
]]>
<![CDATA[	   Else]]>
<![CDATA[
]]>
<![CDATA[	   		writelog("unable to save DCO into local copy")]]>
<![CDATA[
]]>
<![CDATA[	      writelog(oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[	      iloc_AdjustZones = False]]>
<![CDATA[
]]>
<![CDATA[	   End If]]>
<![CDATA[
]]>
<![CDATA[	   oSetup.UnlockIt()]]>
<![CDATA[
]]>
<![CDATA[	 Else]]>
<![CDATA[
]]>
<![CDATA[	 			writelog("unable to save DCO because it was locked")]]>
<![CDATA[
]]>
<![CDATA[	      writelog(oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[	 	iloc_AdjustZones = False]]>
<![CDATA[
]]>
<![CDATA[	 End If]]>
<![CDATA[
]]>
<![CDATA[    oSetup.Path=sSetupPath]]>
<![CDATA[
]]>
<![CDATA[	if err.number<>0 then]]>
<![CDATA[
]]>
<![CDATA[   	writelog("Error:")]]>
<![CDATA[
]]>
<![CDATA[   	writelog err.number]]>
<![CDATA[
]]>
<![CDATA[   	writelog err.description]]>
<![CDATA[
]]>
<![CDATA[   	err.clear]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[''web   if WriteDCOSetup() then]]>
<![CDATA[
]]>
<![CDATA[''web      iloc_AdjustZones = true]]>
<![CDATA[
]]>
<![CDATA[''web   else]]>
<![CDATA[
]]>
<![CDATA[''web      iloc_AdjustZones = false]]>
<![CDATA[
]]>
<![CDATA[     ''web   end if ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="IsPageDataMissing" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  If(CurrentObj.NumOfChildren = 0) Then]]>
<![CDATA[
]]>
<![CDATA[    IsPageDataMissing = True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    IsPageDataMissing = False]]>
<![CDATA[
]]>
<![CDATA[  End If ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="iloc_AssignPageType" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   iloc_AssignPageType = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If InitFPDB=False then ]]>
<![CDATA[
]]>
<![CDATA[      writeLog("No connection to FP Database.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If(IsNumeric(strParam)) Then]]>
<![CDATA[
]]>
<![CDATA[      writeLog("param in iloc_AssignPageType is numeric: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      writeLog("param in iloc_AssignPageType is non-numeric: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[      sSQL = "select pt_PageTypeID,pt_PageType from PageType where pt_PageType='" & strParam & "'"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Dim oRecSet]]>
<![CDATA[
]]>
<![CDATA[      Set oRecSet = Conn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If DBErrTrap(conn, "iloc_AssignPageType") Then]]>
<![CDATA[
]]>
<![CDATA[         oRecSet.Close()]]>
<![CDATA[
]]>
<![CDATA[         writeLog("iloc_AssignPageType Database error after: " & sSQL )]]>
<![CDATA[
]]>
<![CDATA[         Set oRecSet=Nothing]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If oRecSet.state = 0 Then									]]>
<![CDATA[
]]>
<![CDATA[          writelog(Space(4) & "Unable to open recordset.")	]]>
<![CDATA[
]]>
<![CDATA[          Set oRecSet = Nothing]]>
<![CDATA[
]]>
<![CDATA[      End If ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If oRecSet.eof Or oRecSet.bof Then			]]>
<![CDATA[
]]>
<![CDATA[          writelog(Space(4) & "No records returned.")		]]>
<![CDATA[
]]>
<![CDATA[          writelog(Space(4) & "Insert as Page type into PageType page.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          sSQL1 = "insert into PageType(pt_PageType) values ('"& strParam &"')"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          Conn.Execute(sSQL1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          If DBErrTrap(conn, "GetDataArray1") Then]]>
<![CDATA[
]]>
<![CDATA[             writeLog("GetDataArray1 Database error after: " & sSQL1 )]]>
<![CDATA[
]]>
<![CDATA[             Exit Function]]>
<![CDATA[
]]>
<![CDATA[          End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' reread again ? what is the purpose?]]>
<![CDATA[
]]>
<![CDATA[         oRecSet.Close]]>
<![CDATA[
]]>
<![CDATA[         Set oRecSet = Conn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[         If DBErrTrap(conn, "iloc_AssignPageType") Then]]>
<![CDATA[
]]>
<![CDATA[            oRecSet.Close()]]>
<![CDATA[
]]>
<![CDATA[            writeLog("iloc_AssignPageType Database error after: " & sSQL )]]>
<![CDATA[
]]>
<![CDATA[            Set oRecSet=Nothing]]>
<![CDATA[
]]>
<![CDATA[            Exit Function]]>
<![CDATA[
]]>
<![CDATA[         End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['''         call ExecuteSQL(bInter, bDebug, sSQL1)]]>
<![CDATA[
]]>
<![CDATA['''          Set oRecSet = oConn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[      nRowCount = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      oRecSet.MoveFirst]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      writelog("Retrieved value from database: " & oRecSet.Fields.Item(0).Value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Select Case oRecSet.Fields.Item(0).Type]]>
<![CDATA[
]]>
<![CDATA[          Case 3  ' int]]>
<![CDATA[
]]>
<![CDATA[             strParam = CInt(oRecSet.Fields.Item(0).Value)]]>
<![CDATA[
]]>
<![CDATA[             writelog("Obtained new value: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[          Case Else]]>
<![CDATA[
]]>
<![CDATA[             writelog("got nonnumeric value") ]]>
<![CDATA[
]]>
<![CDATA[             strParam = CStr(oRecSet.Fields.Item(0).Value)]]>
<![CDATA[
]]>
<![CDATA[             writelog("Obtained new value: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[      End Select]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oRecSet = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   nTemplateID = CInt(CurrentObj.Variable("TemplateID"))]]>
<![CDATA[
]]>
<![CDATA[   sSQL2 = "Update Template set tp_PageType=" & CInt(strParam) &_]]>
<![CDATA[
]]>
<![CDATA[           " where tp_TemplateID="& nTemplateID]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   conn.Execute(sSQL2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If DBErrTrap(conn, "iloc_AssignPageType") Then]]>
<![CDATA[
]]>
<![CDATA[      writeLog("iloc_AssignPageType Database error after: " & sSQL2 )]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      writelog("Update successful for nTemplateID: " & nTemplateID)]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   iloc_AssignPageType = True ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<help>
  <![CDATA[
'****************************************************
' Intellocate.rrx - Adds Zone's position info into the runtime DCO via the web verify task.

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.

'****************************************************

]]>

<ref id="iloc_SetZones" >
  <ap>None.</ap>  
  <h>
    Writes the position coordinates of a new fingerprint's zoned fields from a page's Data 
    file to the Pos properties of the corresponding Field objects in the Document Hierarchy file (.xml).
    <e>
      <b>iloc_SetZones()</b>
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if a fingerprint match has not occurred, or if the Document Hierarchy file 
    (.xml) cannot be saved.  Otherwise, <b>True.</b>
  </ret>

</ref>
   
<ref id="iloc_SetDetailZones">
  <ap>None.</ap>  
  <h>
    Writes the position coordinates of a new fingerprint's Detail Line fields 
    from a page's Data file to the Pos properties of the corresponding Detail Line 
    Field objects of the application's Document Hierarchy.
    <e>
      <b>iloc_SetDetailZones()</b>
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
   
<ref id="iloc_AdjustZones" >
  <ap>None.</ap>
  <h>
    Updates fingerprint-specific position coordinates for Field objects in the 
    Document Hierarchy based on the locations listed for the current source page's Data file (.xml)<br/><br/>

    This action is designed to be used on existing fingerprints only.  It will only update fields
    that do not have position information.  Existing fields will not be updated, even if the position
    information for those fields has changed. 
    <e>
      <b>iloc_AdjustZones()</b>
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if a fingerprint match has not occurred and a Template ID 
    value has not been assigned to the current page, or if the Document 
    Hierarchy file cannot be saved. Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="IsPageDataMissing" >
  <ap>None.</ap>  
  <h>
    Checks to see that the current page data exists. 
    This action does not physically check for the existence of a data file.  It confirms
    that a valid page data is loaded into memory.<br/><br/>
    <e>
      <b>IsPageDataMissing()</b>
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>True</b> if the current page does not have page data. Otherwise, <b>False.</b>
  </ret>
</ref>
   
<ref id="iloc_AssignPageType" >
  <ap>
    The value of the page type to assign to the current page.  The input parameter must be one of the following:<br/>
    1. A numeric value that corresponds to the Page Type.<br/>
    2. A string value of the page type name.
  </ap>  
  <h>
    Assigns a required Page Type value to a newly created fingerprint.
    The assigned value corresponds to the values configured in the PageType table within the fingerprint database.
    These values are custom defined for each application.
    If a string value is passed as a parameter, this action will look up the corresponding numeric value within the database.<br/>
    <e>
      <scr>Iloc_AssignPageType("2")</scr><br/>
      This example assigns a page type of 2 to the new fingerprint.<br/><br/>
      
      <scr>Iloc_AssignPageType("PageSeparator")</scr><br/>
      This example assigns a page type of "PageSeparator" to the new fingerprint.<br/>
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the numeric value cannot be retrieved from the fingerprint database or if there is
    no connection to the fingerprint database. Otherwise, <b>True.</b>
  </ret>
</ref>
</help>

</rrx>
<rrx namespace="Invoice" src="c:\datacap\RRS\Invoice.dll">

<i ref="rrunner">
</i>
<i ref="validations">
</i>
<i ref="lookup">
</i>
<g>
</g>
<af name="SetDynamicDetailZones" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    The parameter is the Zone Bottom field. If more than one field is listed, ]]>
<![CDATA[
]]>
<![CDATA['    Zone Bottom must be first field, and additional fields are ignored.]]>
<![CDATA[
]]>
<![CDATA['    ]]>
<![CDATA[
]]>
<![CDATA['    This action takes the position of the line items and it builds the line coordinates from them]]>
<![CDATA[
]]>
<![CDATA['    and then it sets the details zones from that top line to the bottom of the CCO.]]>
<![CDATA[
]]>
<![CDATA['    ]]>
<![CDATA[
]]>
<![CDATA['      LoadCCOFromField()      ]]>
<![CDATA[
]]>
<![CDATA['      SetDynamicDetailZones("Zone Bottom,Notes")]]>
<![CDATA[
]]>
<![CDATA['      ZoneBOTTOM_ImageBottom()]]>
<![CDATA[
]]>
<![CDATA['      ScanDetails()]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['     Page level.]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    False if no children exist.  Otherwise, True.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim oLineItem]]>
<![CDATA[
]]>
<![CDATA[Dim oSubField]]>
<![CDATA[
]]>
<![CDATA[Dim PosAr]]>
<![CDATA[
]]>
<![CDATA[Dim LineULHx]]>
<![CDATA[
]]>
<![CDATA[Dim LineULHy]]>
<![CDATA[
]]>
<![CDATA[Dim LineLRHx]]>
<![CDATA[
]]>
<![CDATA[Dim LineLRHy]]>
<![CDATA[
]]>
<![CDATA[Dim i]]>
<![CDATA[
]]>
<![CDATA[Dim FieldAr]]>
<![CDATA[
]]>
<![CDATA[Dim oZoneBottomField]]>
<![CDATA[
]]>
<![CDATA[Dim ZoneBottomY]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   LineULHx = 1000000]]>
<![CDATA[
]]>
<![CDATA[   LineULHy = 1000000]]>
<![CDATA[
]]>
<![CDATA[   LineLRHx = 0]]>
<![CDATA[
]]>
<![CDATA[   LineLRHy = 0]]>
<![CDATA[
]]>
<![CDATA[   Writelog("SetDynamicDetailZones active")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.NumOfChildren > 0 then]]>
<![CDATA[
]]>
<![CDATA[      Set oLineItem = CurrentObj.GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("No Children.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      SetDynamicDetailZones = False]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("LineItem: " & oLineItem.ID)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   for i = 0 to oLineItem.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[     Set oSubField = oLineItem.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Evaluating " & oSubField.Type)  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     if (oSubField.Variable("Position") <> "") AND (InStr("," & StrParam & ",","," & oSubField.Type & ",") = 0) then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Processing " & oSubField.Type) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.Variable("POS-" & oSubField.Type) = oSubField.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        PosAr = Split(oSubField.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[        if cLng(PosAr(0)) < cLng(LineULHx) AND cLng(PosAr(0)) > 0 then]]>
<![CDATA[
]]>
<![CDATA[           LineULHx = PosAr(0)]]>
<![CDATA[
]]>
<![CDATA[        End if   ]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[        if cLng(PosAr(1)) < cLng(LineULHy) AND cLng(PosAr(0)) > 0 then]]>
<![CDATA[
]]>
<![CDATA[           LineULHy = PosAr(1)]]>
<![CDATA[
]]>
<![CDATA[        End if            ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        if cLng(PosAr(2)) > cLng(LineLRHx) then]]>
<![CDATA[
]]>
<![CDATA[           LineLRHx = PosAr(2)]]>
<![CDATA[
]]>
<![CDATA[        End if   ]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[        if cLng(PosAr(3)) > cLng(LineLRHy) then]]>
<![CDATA[
]]>
<![CDATA[           LineLRHy = PosAr(3)]]>
<![CDATA[
]]>
<![CDATA[        End if            ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     oSubField.Variable("TestPos") = LineULHx & "," & LineULHy & "," & LineLRHx & "," & LineLRHy]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   next 'i  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   'LineULHx = cLng(LineULHx) - 20]]>
<![CDATA[
]]>
<![CDATA[   'LineULHy = cLng(LineULHy) - 1]]>
<![CDATA[
]]>
<![CDATA[   'LineLRHx = cLng(LineLRHx) + 20]]>
<![CDATA[
]]>
<![CDATA[   'LineLRHy = cLng(LineLRHy) + 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Variable("LineItemPos") = cStr(CCO.Left) & "," & LineULHy & "," & cStr(CCO.Right) & "," & LineLRHy]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   LineULHx = cLng(LineULHx) -10]]>
<![CDATA[
]]>
<![CDATA[   LineULHy = cLng(LineULHy) - 1]]>
<![CDATA[
]]>
<![CDATA[   LineLRHx = cLng(LineLRHx) + 10]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Handle ZoneBottom ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   FieldAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("FieldAr(0)=" & FieldAr(0))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oZoneBottomField = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oZoneBottomField = oLineItem.FindChild(FieldAr(0))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ZoneBottomY = cStr(CCO.Bottom)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Variable("Position") =  cStr(CCO.Left) & "," & LineULHy & "," & cStr(CCO.Right) & "," & ZoneBottomY]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While CurrentObj.NumOfChildren > 0]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.DeleteChild(0)]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[   'DCO.Write(Pilot.DCOFile)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   SetDynamicDetailZones = TRUE]]>
<![CDATA[
]]>
	</g>
</af>
<af name="LoadCCOFromField" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ '   None.]]>
<![CDATA[
]]>
<![CDATA[ ' ]]>
<![CDATA[
]]>
<![CDATA[ '   This action loads the DCO from a field object.]]>
<![CDATA[
]]>
<![CDATA[ '   The verify panels do not load the CCO into the scripting engine so this action acomplishes that task.  ]]>
<![CDATA[
]]>
<![CDATA[ '   This action is required for any invoice action that uses the CCO.]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ '     LoadCCOFromField()]]>
<![CDATA[
]]>
<![CDATA[ '     SetDynamicDetailZones("Zone Bottom,Notes")]]>
<![CDATA[
]]>
<![CDATA[ '     ZoneBOTTOM_ImageBottom()]]>
<![CDATA[
]]>
<![CDATA[ '     ScanDetails()]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ ' ]]>
<![CDATA[
]]>
<![CDATA[ '     Field Level.]]>
<![CDATA[
]]>
<![CDATA[ ' ]]>
<![CDATA[
]]>
<![CDATA[ '   False, if this action is not called on a field or if the CCO file does not exist.  Otherwise, True.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	LoadCCOFromField = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if CurrentObj.Parent.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Action must be on a field that is a child of a page.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim sFileName ]]>
<![CDATA[
]]>
<![CDATA[	sFileName = Left(CurrentObj.Parent.ImageName,len(CurrentObj.Parent.ImageName) - 3) & "cco"]]>
<![CDATA[
]]>
<![CDATA[  writelog("Attempting to load: " & sFileName)]]>
<![CDATA[
]]>
<![CDATA[	Dim lbCCOCreator]]>
<![CDATA[
]]>
<![CDATA[	set lbCCOCreator = CreateObject("CCO._CCOCreator.1")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	if FileMgr.FileExists(sFileName) then ]]>
<![CDATA[
]]>
<![CDATA[		set CCO = lbCCOCreator.load(sFileName)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Loading CCO '" & sFileName & "' ")]]>
<![CDATA[
]]>
<![CDATA[		LoadCCOFromField = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("CCO: " & sFileName & "' does not Exist.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ 	Set lbCCOCreator = nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oField = CurrentObj]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ScanLineItemDynamic" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   A comma separated list of any fields that should be ignored.]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ '   This action scans the line items from the CCO that was loaded into the field.  It is like]]>
<![CDATA[
]]>
<![CDATA[ '   ScanLineItem but uses the CCO loaded for the field and reads position variables from the line item level.]]>
<![CDATA[
]]>
<![CDATA[ '   It is required for Find Details functionality.  It saves the positions of the line and of the feids at the detail]]>
<![CDATA[
]]>
<![CDATA[ '   level so all of the line items can be erased and recreated.]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ '     FPXMLUsed()]]>
<![CDATA[
]]>
<![CDATA[ '     ScanLineItemDynamic("ZoneBottom,Notes")]]>
<![CDATA[
]]>
<![CDATA[ '  ]]>
<![CDATA[
]]>
<![CDATA[ ' Field Level.]]>
<![CDATA[
]]>
<![CDATA[ ' ]]>
<![CDATA[
]]>
<![CDATA[ '   Always True.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ScanLineItemDynamic=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog(sName)]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.CreateFields()]]>
<![CDATA[
]]>
<![CDATA[	nCount=CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To nCount-1]]>
<![CDATA[
]]>
<![CDATA[		Set oField=CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		Writelog(oField.ID)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		If Not oField Is Nothing  Then]]>
<![CDATA[
]]>
<![CDATA[      if InStr("," & StrParam & ",","," & oField.Type & ",") = 0 then ]]>
<![CDATA[
]]>
<![CDATA[			  oField.Variable("Position")= CurrentObj.Parent.variable("POS-" & oField.Type)]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	ScanLineItemDynamic=True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PopulateZNLineItemFieldDynamic" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    This action is like the PopulateZNLineItemField but it uses the CCO that was]]>
<![CDATA[
]]>
<![CDATA['    loaded into memory by LoadCCOFromField, instead of the global CCO.]]>
<![CDATA[
]]>
<![CDATA['    It populates the fingerprint’s Data file with the recognized value contained inside]]>
<![CDATA[
]]>
<![CDATA['    the zone of a child Field object of a LINEITEM parent field. This action should]]>
<![CDATA[
]]>
<![CDATA['    only be used with sub-fields of the LINEITEM field - ItemID, ItemDesc,]]>
<![CDATA[
]]>
<![CDATA['    Quantity, Price in the <i>Invoices</i> application.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  PopulateZNLineItemFieldDynamic=False]]>
<![CDATA[
]]>
<![CDATA[  sPos=CurrentObj.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  If( sPos<>"" and sPos <> "0,0,0,0" ) Then]]>
<![CDATA[
]]>
<![CDATA[    If Not AdjustPosToParentDynamic(CurrentObj,1) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Ready for DCOFieldFromCCO")]]>
<![CDATA[
]]>
<![CDATA[    PopulateZNLineItemFieldDynamic=DCOFieldFromCCO(CurrentObj, CCO)]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    PopulateZNLineItemFieldDynamic=true]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CalculateNotesZone" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['   This action creates a zone between detail lines, so the text between lines can ]]>
<![CDATA[
]]>
<![CDATA['   be recognized.]]>
<![CDATA[
]]>
<![CDATA[Dim oLineItem]]>
<![CDATA[
]]>
<![CDATA[Dim oNextLineItem]]>
<![CDATA[
]]>
<![CDATA[Dim i]]>
<![CDATA[
]]>
<![CDATA[Dim oNotesField]]>
<![CDATA[
]]>
<![CDATA[Dim NoteULHx]]>
<![CDATA[
]]>
<![CDATA[Dim NoteULHy]]>
<![CDATA[
]]>
<![CDATA[Dim NoteLRHx]]>
<![CDATA[
]]>
<![CDATA[Dim NoteLRHy]]>
<![CDATA[
]]>
<![CDATA[Dim PosAr1]]>
<![CDATA[
]]>
<![CDATA[Dim PosAr2]]>
<![CDATA[
]]>
<![CDATA[Dim PosAr3]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CalculateNotesZone = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.NumOfChildren = 0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("No children found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   For i = 0 to CurrentObj.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[      Set oLineItem = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[      PosAr1 = Split(oLineItem.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[      NoteULHx = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[      NoteULHy = PosAr1(3)       ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Set NoteULHx to: " & cStr(NoteULHx))]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Set NoteULHy to: " & cStr(NoteULHy))]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[      if i = CurrentObj.NumOfChildren - 1 then]]>
<![CDATA[
]]>
<![CDATA[         PosAr2 = Split(CurrentObj.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[         NoteLRHx = CCO.Right ]]>
<![CDATA[
]]>
<![CDATA[         NoteLRHy = PosAr2(3)]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Last Child - Set NoteLRHx to: " & cStr(NoteLRHx))]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Last Child - Set NoteLRHy to: " & cStr(NoteLRHy))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         Set oNextLineItem = CurrentObj.GetChild(i+1)]]>
<![CDATA[
]]>
<![CDATA[         PosAr3 = Split(oNextLineItem.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[         NoteLRHx = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[         NoteLRHy = PosAr3(1)]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Not Last Child - Set NoteLRHx to: " & cStr(NoteLRHx))]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Not Last Child - Set NoteLRHy to: " & cStr(NoteLRHy))]]>
<![CDATA[
]]>
<![CDATA[      End if ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      oLineItem.FindChild("Notes").Variable("Position") = NoteULHx & "," & NoteULHy & "," & NoteLRHx & "," & NoteLRHy]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Set Notes positon to: " & oLineItem.FindChild("Notes").Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[   Next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFingerPrintClass" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    Two comma separated parameters:]]>
<![CDATA[
]]>
<![CDATA['    1. The database connection string.  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA['    2. Fingerprint class.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    This action connects to the fingerprint database and verifies that the specified fingerprint]]>
<![CDATA[
]]>
<![CDATA['    class contains the fingerprint ID of the current page.  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim oConn]]>
<![CDATA[
]]>
<![CDATA[Dim oRS]]>
<![CDATA[
]]>
<![CDATA[Dim oRS1]]>
<![CDATA[
]]>
<![CDATA[Dim sSQL]]>
<![CDATA[
]]>
<![CDATA[Dim RetnAr]]>
<![CDATA[
]]>
<![CDATA[Dim Retn]]>
<![CDATA[
]]>
<![CDATA[Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[Dim ConnectionString]]>
<![CDATA[
]]>
<![CDATA[Dim sTID]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   IsFingerprintClass = FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a page level.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ParamAr= Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if uBound(ParamAr) <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Wrong number of parameters.  Expecting (DSN,FingerPrintClass)")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oConn = CreateObject("ADODB.Connection")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   ConnectionString = Trim(ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   ' Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[   sSmartParam=MetaWord(ConnectionString)]]>
<![CDATA[
]]>
<![CDATA[   If sSmartParam<>"" and ConnectionString<>sSmartParam Then ]]>
<![CDATA[
]]>
<![CDATA[     'attempt to decrypt value]]>
<![CDATA[
]]>
<![CDATA[     bRes = [securecall]sSmartParam,ConnectionString[/securecall]   ]]>
<![CDATA[
]]>
<![CDATA[     If bRes=False Then Writelog("Value not Decrypted.")]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("No result from Smart Parameter parsing. Using the original parameter string.") ]]>
<![CDATA[
]]>
<![CDATA[   End if ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   oConn.Open(FormatADOConn(ConnectionString))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	 If oConn.State <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Unable to open Connection to DB.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("DB Connection Open.")]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[   sTID = trim(CurrentObj.variable("TemplateID"))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   If len(sTID) = 0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("No TemplateID variable value. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   sSQL = "Select tp_HostID from Template where tp_TemplateID = " & sTID & ";"]]>
<![CDATA[
]]>
<![CDATA[   sSQL = ModifySQLByDBType(oConn,sSQL)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("sSQL=" & sSQL)]]>
<![CDATA[
]]>
<![CDATA[   Set oRS = oConn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If oRS.EOF Or oRS.BOF Then ]]>
<![CDATA[
]]>
<![CDATA[      IsFingerprintClass = False ]]>
<![CDATA[
]]>
<![CDATA[      writelog("RecordSet Returns EOF or BOF. Exiting Function.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Retn = oRS.GetString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog  ("Returned: " & Retn)]]>
<![CDATA[
]]>
<![CDATA[   if Len(Retn) > 1 then]]>
<![CDATA[
]]>
<![CDATA[      RetnAr=Split(Retn,chrW(13))]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   Retn = RetnAr(uBound(RetnAr)-1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Retn: " & Retn) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if IsNumeric(Retn) then]]>
<![CDATA[
]]>
<![CDATA[      HostID = Retn]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Did not get a valid HostID. Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Writelog(sSQL)]]>
<![CDATA[
]]>
<![CDATA[      oConn.Close]]>
<![CDATA[
]]>
<![CDATA[      set oRS = Nothing]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   sSQL = "Select hs_RefName from Host where hs_HostID = " & Trim(cStr(HostID)) & ";"  ]]>
<![CDATA[
]]>
<![CDATA[   sSQL = ModifySQLByDBType(oConn,sSQL)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("sSQL=" & sSQL)]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   Set oRS1 = oConn.Execute(sSQL)  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oRS1.BOF or oRS1.EOF then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Nothing found.Exiting")]]>
<![CDATA[
]]>
<![CDATA[      oConn.Close]]>
<![CDATA[
]]>
<![CDATA[      set oRS = Nothing]]>
<![CDATA[
]]>
<![CDATA[      set oRS1 = Nothing]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if   ]]>
<![CDATA[
]]>
<![CDATA[   Retn = oRS1.GetString]]>
<![CDATA[
]]>
<![CDATA[   Retn = Left(Retn,len(Retn)-1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Retn='" & Retn & "' Second Parameter='" & ParamAr(1) & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if InStr("," & ParamAr(1) & ","  ,   "," & Retn & ",") > 0 then]]>
<![CDATA[
]]>
<![CDATA[      IsFingerPrintClass = TRUE]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[       IsFingerPrintClass = FALSE]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   oConn.Close         ]]>
<![CDATA[
]]>
<![CDATA[   set oRS = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oRS1 = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Call ErrorHandler("Function IsFingerPrintClass")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="iloc_SetDetailSimple" access="public" bInter="bInter" bDebug="bDebug" strParam="sDetailName">
	<g>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA['   The detail Datacap Object (DCO) Type.]]>
<![CDATA[
]]>
<![CDATA['   This action fills the Setup DCO from Runtime Data file. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[    Dim oPage]]>
<![CDATA[
]]>
<![CDATA[    Dim sFPID]]>
<![CDATA[
]]>
<![CDATA[    Dim oSetup]]>
<![CDATA[
]]>
<![CDATA[    Dim oLineItem]]>
<![CDATA[
]]>
<![CDATA[    Dim oDetail]]>
<![CDATA[
]]>
<![CDATA[    Dim xOffset]]>
<![CDATA[
]]>
<![CDATA[    Dim yOffset]]>
<![CDATA[
]]>
<![CDATA[    Dim nLeft, nTop, nRight, nBottom]]>
<![CDATA[
]]>
<![CDATA[    Dim nLineLeft, nLineTop, nLineRight, nLineBottom]]>
<![CDATA[
]]>
<![CDATA[    Dim LinePosAr]]>
<![CDATA[
]]>
<![CDATA[    Dim DetailPosAr]]>
<![CDATA[
]]>
<![CDATA[    Dim oSetupNode_Detail]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	iloc_SetDetailSimple = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    xOffset = clng(0)]]>
<![CDATA[
]]>
<![CDATA[    yOffset = clng(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   	Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	If oPage Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Current DCO node found.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    if oPage.ObjectType<>2 Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Current DCO must be Type Page.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Find Template ID for oPage]]>
<![CDATA[
]]>
<![CDATA[	sFPID = oPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	If Len(sFPID)=0 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Template ID found.")]]>
<![CDATA[
]]>
<![CDATA[        Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        writelog("Template ID:'" & sFPID & "'")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Find the offset for oPage]]>
<![CDATA[
]]>
<![CDATA[    sOffset = oPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[    If len(sOffset)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        writelog("Image Offset is '" & sOffset & "'")]]>
<![CDATA[
]]>
<![CDATA[        aOffset = Split(sOffset,",")]]>
<![CDATA[
]]>
<![CDATA[        If IsNumeric(aOffset(0)) then xOffset=clng(aOffset(0))]]>
<![CDATA[
]]>
<![CDATA[        If IsNumeric(aOffset(1)) then yOffset=clng(aOffset(1))]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oSetup = CurrentObj.SetupObject]]>
<![CDATA[
]]>
<![CDATA[	If(oSetup Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("SetupObject Not Found.")]]>
<![CDATA[
]]>
<![CDATA[        Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("Setup path:'" & oSetup.Path & "'")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	If oSetup.readlock(oSetup.path) Then]]>
<![CDATA[
]]>
<![CDATA[		'Process The Detail]]>
<![CDATA[
]]>
<![CDATA[		Set oDetail = oPage.FindChild(Trim(sDetailName))]]>
<![CDATA[
]]>
<![CDATA[		If Not(oDetail is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[			Set oLineItem=oDetail.GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[			If oLineItem is Nothing then]]>
<![CDATA[
]]>
<![CDATA[				Writelog("No First Child field found - Exiting.")]]>
<![CDATA[
]]>
<![CDATA[				Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[				Set oDetail = Nothing]]>
<![CDATA[
]]>
<![CDATA[				Exit Function]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			'Writelog("First Field Found:'" & oLineItem & "'.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			nLineLeft   = "" 'clng(0)]]>
<![CDATA[
]]>
<![CDATA[			nLineTop    = "" 'clng(0)]]>
<![CDATA[
]]>
<![CDATA[			nLineRight  = "" 'clng(0)]]>
<![CDATA[
]]>
<![CDATA[			nLineBottom = "" 'clng(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			'Loop through LineItem Subfields]]>
<![CDATA[
]]>
<![CDATA[			For i = 1 to (oLineItem.NumOfChildren-Len(oLineItem.Text))]]>
<![CDATA[
]]>
<![CDATA[				Set oSubField = oLineItem.GetChild(i-1)]]>
<![CDATA[
]]>
<![CDATA[				If Not(oSubField is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[					sPosition = Trim(oSubField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[					Writelog(oSubField.Type & " has a DCO position of " & sPosition) ]]>
<![CDATA[
]]>
<![CDATA[					if Len(oDetail.Variable("POS-" & oSubField.ID)) > 7 then]]>
<![CDATA[
]]>
<![CDATA[						sPosition = oDetail.Variable("POS-" & oSubField.ID) ]]>
<![CDATA[
]]>
<![CDATA[						Writelog(oSubField.Type & " has a captured position of " & sPosition) ]]>
<![CDATA[
]]>
<![CDATA[					end if]]>
<![CDATA[
]]>
<![CDATA[					aPosition = Split(sPosition & "," ,",")]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[					'check runtime field for position info]]>
<![CDATA[
]]>
<![CDATA[					If sPosition<>"0,0,0,0" and len(sPosition)>0 and ubound(aPosition)=4 then]]>
<![CDATA[
]]>
<![CDATA[						Set oSetupNode_SubField = oSetup.GetNodeByName(3,oSubField.Type)]]>
<![CDATA[
]]>
<![CDATA[						If Not(oSetupNode_SubField is Nothing) then  ]]>
<![CDATA[
]]>
<![CDATA[	                                   ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[							'Adjust for Image_Offset & save to SetupNode    ]]>
<![CDATA[
]]>
<![CDATA[							 nLeft   = clng(aPosition(0)) + xOffset]]>
<![CDATA[
]]>
<![CDATA[							 nTop    = clng(aPosition(1)) + yOffset           ]]>
<![CDATA[
]]>
<![CDATA[							 nRight  = clng(aPosition(2)) + xOffset ]]>
<![CDATA[
]]>
<![CDATA[							 nBottom = clng(aPosition(3)) + yOffset]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[							 Writelog("Setting SubField Zone to:'" & CStr(nLeft) & "," & CStr(nTop) & "," & CStr(nRight) & "," & CStr(nBottom) & "'")]]>
<![CDATA[
]]>
<![CDATA[							 oSetupNode_SubField.Variable("Pos" & sFPID) = CStr(nLeft) & "," & CStr(nTop) & "," & CStr(nRight) & "," & CStr(nBottom)]]>
<![CDATA[
]]>
<![CDATA[	                        ]]>
<![CDATA[
]]>
<![CDATA[							 'Adjust LineItem field]]>
<![CDATA[
]]>
<![CDATA[							 If nLineLeft = ""   then nLineLeft = nLeft   ]]>
<![CDATA[
]]>
<![CDATA[							 If nLineTop = ""    then nLineTop = nTop ]]>
<![CDATA[
]]>
<![CDATA[							 If nLineRight = ""  then nLineRight = nRight ]]>
<![CDATA[
]]>
<![CDATA[							 If nLineBottom = "" then nLineBottom = nBottom ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							 If nLineLeft>nLeft     Then nLineLeft = nLeft ]]>
<![CDATA[
]]>
<![CDATA[							 If nLineTop>nTop       Then nLineTop = nTop]]>
<![CDATA[
]]>
<![CDATA[							 If nLineRight<nRight   Then nLineRight = nRight]]>
<![CDATA[
]]>
<![CDATA[							 If nLineBottom<nBottom Then nLineBottom = nBottom]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							Writelog("Setupnode is Nothing!")]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[						Set oSetupNode_SubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			Next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		   'if oLineItem.Variable("Position") <> "" then]]>
<![CDATA[
]]>
<![CDATA[		   '    LinePosAr = Split(oLineItem.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[		   '    Writelog("Line item unadjusted positions" & oLineItem.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		   'end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		   if oLineItem.Parent.Variable("LineItemPos") <> "" then]]>
<![CDATA[
]]>
<![CDATA[			   LinePosAr = Split(oLineItem.Parent.Variable("LineItemPos"),",")]]>
<![CDATA[
]]>
<![CDATA[			   Writelog("Line item unadjusted positions" & oLineItem.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		   if uBound(LinePosAr) = 3 then]]>
<![CDATA[
]]>
<![CDATA[			  nLineLEft = cLng(LinePosAr(0)) + xOffset ]]>
<![CDATA[
]]>
<![CDATA[			  nLineTop = cLng(LinePosAr(1)) + yOffset ]]>
<![CDATA[
]]>
<![CDATA[			  nLineRight = cLng(LinePosAr(2)) + xOffset ]]>
<![CDATA[
]]>
<![CDATA[			  nLineBottom = cLng(LinePosAr(3)) + yOffset ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			   Set oSetupNode_LineItem = oSetup.GetNodeByName(3,oLineItem.Type)]]>
<![CDATA[
]]>
<![CDATA[			   If Not(oSetupNode_LineItem is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[				   Writelog("Setting LineItem Zone to:'" & CStr(nLineLeft) & "," & CStr(nLineTop) & "," & CStr(nLineRight) & "," & CStr(nLineBottom) & "'")]]>
<![CDATA[
]]>
<![CDATA[				   oSetupNode_LineItem.Variable("Pos" & sFPID) = CStr(nLineLeft) & "," & CStr(nLineTop) & "," & CStr(nLineRight) & "," & CStr(nLineBottom)]]>
<![CDATA[
]]>
<![CDATA[			   End if]]>
<![CDATA[
]]>
<![CDATA[			   Set oSetupNode_LineItem = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		   else]]>
<![CDATA[
]]>
<![CDATA[			   Writelog("Line Postition was invalid")]]>
<![CDATA[
]]>
<![CDATA[		   end if]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[		   if oDetail.Variable("Position") <> "" then]]>
<![CDATA[
]]>
<![CDATA[			   DetailPosAr = Split(oDetail.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[			   Writelog("Detail unadjusted positions" & oDetail.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		   if uBound(DetailPosAr) = 3 then]]>
<![CDATA[
]]>
<![CDATA[			  nLineLEft = cLng(DetailPosAr(0)) + xOffset ]]>
<![CDATA[
]]>
<![CDATA[			  nLineTop = cLng(DetailPosAr(1)) + yOffset ]]>
<![CDATA[
]]>
<![CDATA[			  nLineRight = cLng(DetailPosAr(2)) + xOffset ]]>
<![CDATA[
]]>
<![CDATA[			  nLineBottom = cLng(DetailPosAr(3)) + yOffset ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			   Set oSetupNode_Detail = oSetup.GetNodeByName(3,oDetail.Type)]]>
<![CDATA[
]]>
<![CDATA[			   If Not(oSetupNode_Detail is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[				   Writelog("Setting Detail Zone to:'" & CStr(nLineLeft) & "," & CStr(nLineTop) & "," & CStr(nLineRight) & "," & CStr(nLineBottom) & "'")]]>
<![CDATA[
]]>
<![CDATA[				   oSetupNode_Detail.Variable("Pos" & sFPID) = CStr(nLineLeft) & "," & CStr(nLineTop) & "," & CStr(nLineRight) & "," & CStr(nLineBottom)]]>
<![CDATA[
]]>
<![CDATA[			   End if]]>
<![CDATA[
]]>
<![CDATA[			   Set oSetupNode_Detail = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		   else]]>
<![CDATA[
]]>
<![CDATA[			   Writelog("Detail Postition was invalid")]]>
<![CDATA[
]]>
<![CDATA[		   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Detail Field not found.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[	   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If oSetup.WriteSetup(oSetup.path)=False Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Unable to save Setup DCO:'" & oSetup.path & "'")  ]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Saved DCO Setup:'" & oSetup.path & "'")]]>
<![CDATA[
]]>
<![CDATA[					iloc_SetDetailSimple = True]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		oSetup.UnlockIt()]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[	  writelog("unable to save DCO because it was locked")]]>
<![CDATA[
]]>
<![CDATA[	  writelog(oSetup.path)]]>
<![CDATA[
]]>
<![CDATA[	End If 'readlock]]>
<![CDATA[
]]>
<![CDATA[    Set oLineItem = Nothing]]>
<![CDATA[
]]>
<![CDATA[    Set oDetail = Nothing]]>
<![CDATA[
]]>
<![CDATA[    Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsMultipageDocument" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' This action is used to determine if the current object is a document with multiple pages attached.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   IsMultipageDocument = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType = 0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action cannot be on a batch object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oDoc = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While oDoc.ObjectType > 1]]>
<![CDATA[
]]>
<![CDATA[      Set oDoc = oDoc.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oDoc.ObjectType = 0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Document object not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Document has " & oDoc.NumOfChildren & " page(s).")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   if oDoc.NumOfChildren > 1 then]]>
<![CDATA[
]]>
<![CDATA[      IsMultipageDocument = True]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsSinglePageDocument" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['  This action is used to determine if the current object is a document with only 1 page attached.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   IsSinglePageDocument = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType = 0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action cannot be on a batch object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oDoc = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While oDoc.ObjectType > 1]]>
<![CDATA[
]]>
<![CDATA[      Set oDoc = oDoc.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oDoc.ObjectType = 0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Document object not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Document has " & oDoc.NumOfChildren & " page(s).")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   if oDoc.NumOfChildren = 1 then]]>
<![CDATA[
]]>
<![CDATA[      IsSinglePageDocument = True]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CreateFingerprint" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[ '   This action will create a fingerprint for the current page.  ]]>
<![CDATA[
]]>
<![CDATA[ '   Forces the creation of a new fingerprint using the current image, even if there is an existing]]>
<![CDATA[
]]>
<![CDATA[ '   fingerprint.  A typical scenario is when there is a very similar fingerprint that]]>
<![CDATA[
]]>
<![CDATA[ '   incorrectly matches the current image, such as two invoices]]>
<![CDATA[
]]>
<![CDATA[ '   that are very similar.  When the new invoice is received in the future, it should]]>
<![CDATA[
]]>
<![CDATA[ '   now match on this new fingerprint.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	CreateFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("CreateFingerprint skipping. Image file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- CreateFingerprint for: "& CurrentObj.ImageName & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	retn = oFingerprint.AddNewFingerprint(CurrentObj,CurrentObj.Type)]]>
<![CDATA[
]]>
<![CDATA[	If bFailRule = True Then]]>
<![CDATA[
]]>
<![CDATA[		CreateFingerprint = False]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		CreateFingerprint = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("CreateFingerprint returns " & CreateFingerprint)]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetPicChar" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    This action should not be used, as it is scheduled to be removed in future versions.]]>
<![CDATA[
]]>
<![CDATA['    It has been replaced by PIC_SetPictureCharacter in Picture.rrx.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[Dim PicCharNum]]>
<![CDATA[
]]>
<![CDATA[   SetPicChar = FALSE]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   PicCharNum = Left(StrParam,1)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Len(StrParam) < 3 then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("SetPicChar parameter must be a single digit numeric followed by a comma, followed by the allowable characters")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Not IsNumeric(PicCharNum) then    'first character must be a digit]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("SetPicChar parameter must be a single digit numeric followed by a comma, followed by the allowable characters")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if mid(StrParam,2,1) <> "," then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("SetPicChar parameter must be a single digit numeric followed by a comma, followed by the allowable characters")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   PicCharAr(PicCharNum) = Right(StrParam,Len(StrParam) - 2)  ]]>
<![CDATA[
]]>
<![CDATA[   WriteLog("Picture Character " & cStr(PicCharNum) & " is set to: " &  PicCharAr(PicCharNum))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   SetPicChar = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="WriteErrorMessage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[ '   Writes the message to field level variable message that appears in the status bar.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  DCOMessage(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  WriteErrorMessage = FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsInList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['   A string that is a superset of the expected 'Text' value.]]>
<![CDATA[
]]>
<![CDATA['   This action validates that the value of a field is contained within a given string.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   IsInList = FALSE]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Action must be on a field object. Exiting")]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if InStr("," & StrParam & ","   ,    "," & CurrentObj.Text & ",") > 0  then]]>
<![CDATA[
]]>
<![CDATA[      IsInList = TRUE]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.Text = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsInINI" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    A comma separated string of:]]>
<![CDATA[
]]>
<![CDATA['    1. The INI Filename.]]>
<![CDATA[
]]>
<![CDATA['    2. The section within the INI file.]]>
<![CDATA[
]]>
<![CDATA['    3. The keword to find in the section.]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    Reads the value of the specified key in the INI file.  It compares the value of the current]]>
<![CDATA[
]]>
<![CDATA['    field with the with the string in the INI file.  The field must be a substring of the string in the]]>
<![CDATA[
]]>
<![CDATA['    INI file.]]>
<![CDATA[
]]>
<![CDATA['   ]]>
<![CDATA[
]]>
<![CDATA['     IsInINI("C:\MyDir\settings.ini", "mysection", "mykey")      ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next       ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[  Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[  Dim oFS]]>
<![CDATA[
]]>
<![CDATA[  Dim SearchList]]>
<![CDATA[
]]>
<![CDATA[  Dim DCOValue]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  IsInINI = FALSE]]>
<![CDATA[
]]>
<![CDATA[  ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If uBound(ParamAr) <> 2 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Improper number of parameters.  Parameters are a CSV value of the 1) INI Filename 2) Section & 3) Keyword.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If Not oFS.FileExists(ParamAr(0)) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Could not find the INI file specified: "  & ParamAr(0) & ".   Parameters are Filename,Section,Keyword ")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("Looking for section [" & ParamAr(1) & "] key '" & ParamAr(2) & "' in INI file:'" & ParamAr(0) & "'." ) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  SearchList = Pilot.GetProfileString(ParamAr(1), ParamAr(2),"",ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType < 3 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Calling DCO is not a field, using variable 'Text' as value source.")]]>
<![CDATA[
]]>
<![CDATA[    DCOValue = CurrentObj.Variable("Text")]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    DCOValue = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If SearchList = "" then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Unable to find section [" & ParamAr(1) & "] with key '" & ParamAr(2) & "'.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Returned key value:'" & SearchList & "'. Checking if returned value is in calling DCO value of '" & DCOValue & "'.")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If InStr("," & SearchList & ","  , "," & DCOValue & ",") > 0 then]]>
<![CDATA[
]]>
<![CDATA[    IsInINI = TRUE]]>
<![CDATA[
]]>
<![CDATA[    Writelog("DCO value was found in the INI returned value.")]]>
<![CDATA[
]]>
<![CDATA[    'Next call sets value to high confidence (Text=Text)]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Text = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("DCO value was NOT found in the INI returned value.")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DetailFix" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    Calculates the quantity, price and line total for when one of them is blank within a detail field.]]>
<![CDATA[
]]>
<![CDATA['    This calculation is performed for all detail lines on the page.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[Dim oQtyField]]>
<![CDATA[
]]>
<![CDATA[Dim oPriceField]]>
<![CDATA[
]]>
<![CDATA[Dim oLineTotalField]]>
<![CDATA[
]]>
<![CDATA[Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   DetailFix = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.NumOfChildren = 0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("There were no children fields.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[       WriteLog("There are " &  CurrentObj.NumOfChildren & "  children")]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Set oQtyField = Nothing]]>
<![CDATA[
]]>
<![CDATA[      Set oPriceField = Nothing]]>
<![CDATA[
]]>
<![CDATA[      Set oLineTotalField = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Set oQtyField = CurrentObj.FindChild("Qty")]]>
<![CDATA[
]]>
<![CDATA[      Set oPriceField = CurrentObj.FindChild("Price")]]>
<![CDATA[
]]>
<![CDATA[      Set oLineTotalField = CurrentObj.FindChild("LineTotal")]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("The Qty is :" & oQtyField.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[	  'WriteLog("The Price is :" & CurrentObj.FindChild("Price") & "'")]]>
<![CDATA[
]]>
<![CDATA[	  'WriteLog("The LineTotal is :" & CurrentObj.FindChild("LineTotal") & "'")]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[      if oQtyField Is Nothing then]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Unable to find Qty field.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if oPriceField Is Nothing then]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Unable to find Price field.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if oLineTotalField Is Nothing then]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Unable to find LineTotal field.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[      if Trim(oQtyField.Text) <> "" And Not IsNumeric(oQtyField.Text) then]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Non-numeric Qty found.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[          Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if Trim(oPriceField.Text) <> "" And Not IsNumeric(oPriceField.Text) then]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Non-numeric Price found.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[          Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if Trim(oLineTotalField.Text) <> "" And Not IsNumeric(oLineTotalField.Text) then]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Non-numeric Line total found.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[          Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if (Trim(oQtyField.Text) = "" AND Trim(oPriceField.Text) = "") OR (Trim(oLineTotalField.Text) = "" AND Trim(oPriceField.Text) = "") OR (Trim(oQtyField.Text) = "" AND Trim(oLineTotalField.Text) = "") Then]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Missing too many values for calculation")]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if Trim(oQtyField.Text) = "" then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Qty was blank")]]>
<![CDATA[
]]>
<![CDATA[          oQtyField.Text = cStr( cDbl(oLineTotalField.text) / cDbl(oPriceField.text))]]>
<![CDATA[
]]>
<![CDATA[           'oQtyField.Text = cStr( oLineTotalField.text / oPriceField.text)]]>
<![CDATA[
]]>
<![CDATA[          'Round to nearest whole number]]>
<![CDATA[
]]>
<![CDATA[          'oQtyField.Text =  cStr(cLng(cDbl(oQtyField.Text) + 0.5))]]>
<![CDATA[
]]>
<![CDATA[          oQtyField.Variable("Calculated") = "YES"]]>
<![CDATA[
]]>
<![CDATA[          CurrentObj.Variable("Calculated Field") = "Qty"]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Calculated QTY (" & oQtyField.Text & ") from Price (" &  oPriceField.Text & ") and LineTotal(" & oLineTotalField.Text & ")")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If Trim(oPriceField.Text) = "" then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Price was blank")]]>
<![CDATA[
]]>
<![CDATA[         oPriceField.Text = cStr( cDbl(oLineTotalField.Text) / cDbl(oQtyField.Text))]]>
<![CDATA[
]]>
<![CDATA[         oPriceField.Variable("Calculated") = "YES"]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Variable("Calculated Field") = "Price"]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Calculated Price (" & oPriceField.Text & ") from Qty (" &  oQtyField.Text & ") and LineTotal(" & oLineTotalField.Text & ")")]]>
<![CDATA[
]]>
<![CDATA[         oPriceField.Text = FormatCurrency(oPriceField.Text,2,-1) ]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if Trim(oLineTotalField.Text) = "" then]]>
<![CDATA[
]]>
<![CDATA[       WriteLog("LineTotal blank")]]>
<![CDATA[
]]>
<![CDATA[         oLineTotalField.Text = cStr( cDbl(oPriceField.Text) * cDbl(oQtyField.Text))]]>
<![CDATA[
]]>
<![CDATA[         oLineTotalField.Variable("Calculated") = "YES"]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Variable("Calculated Field") = "LineTotal"]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Calculated LineTotal (" & oLineTotalField.text & ") from Qty (" &  oQtyField.Text & ") and Price(" & oPriceField.Text & ")")]]>
<![CDATA[
]]>
<![CDATA[         oLineTotalField.Text = FormatCurrency(oLineTotalField.Text,2,-1)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CheckForSticky" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[      '    For new fingerprints this action checks to see if there another matching fingerprint ]]>
<![CDATA[
]]>
<![CDATA['    within the same batch that has already been verified, where it can ]]>
<![CDATA[
]]>
<![CDATA['    use it to obtain zone information.  An example is when a batch contains two similar]]>
<![CDATA[
]]>
<![CDATA['    invoices, which have never been processed by the system before.  Once the first]]>
<![CDATA[
]]>
<![CDATA['    invoice is zoned during verify, the same new fingerprint can be used]]>
<![CDATA[
]]>
<![CDATA['    on the second invoice.  This is only needed on new matching fingerprints within the same batch]]>
<![CDATA[
]]>
<![CDATA['    because a fingerprints zones are saved at export time and are available for subsequent batches.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[    Dim j]]>
<![CDATA[
]]>
<![CDATA[    Dim k]]>
<![CDATA[
]]>
<![CDATA[    Dim ThisFingerprintID]]>
<![CDATA[
]]>
<![CDATA[    Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[    Dim oPage]]>
<![CDATA[
]]>
<![CDATA[    Dim oSourceField]]>
<![CDATA[
]]>
<![CDATA[    Dim oDestField]]>
<![CDATA[
]]>
<![CDATA[    Dim PosAr]]>
<![CDATA[
]]>
<![CDATA[    Dim OffSetAr]]>
<![CDATA[
]]>
<![CDATA[    Dim oSourceLineItemField]]>
<![CDATA[
]]>
<![CDATA[    Dim oDestLineItemField]]>
<![CDATA[
]]>
<![CDATA[    Dim oDetails]]>
<![CDATA[
]]>
<![CDATA[    Dim oLineItem]]>
<![CDATA[
]]>
<![CDATA[    Dim oCopyVendor]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    CheckForSticky = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ThisFingerprintID = CurrentObj.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Current page TemplateID = '" & ThisFingerprintID &"', DCO.NumOfChildren = '" & DCO.NumOfChildren & "'")]]>
<![CDATA[
]]>
<![CDATA[    For i = 0 To DCO.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[       Set oDoc = DCO.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[       Set oPage = oDoc.GetChild(0)      ]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Type = '" & oPage.Type & "', TemplateID = '" & oPage.Variable("TemplateID") & "', oPage.Status = '" & oPage.Status & "'")]]>
<![CDATA[
]]>
<![CDATA[       If oPage.Type = "Main_Page" And oPage.Variable("TemplateID") = ThisFingerprintID And (oPage.Status = 0 OR oPage.Status = 73) Then   ]]>
<![CDATA[
]]>
<![CDATA[        If Not oPage.FindChild("Vendor") Is Nothing Then         ]]>
<![CDATA[
]]>
<![CDATA[            If Not CurrentObj.FindChild("Vendor") Is Nothing Then             ]]>
<![CDATA[
]]>
<![CDATA[              Set oCopyVendor=CurrentObj.FindChild("Vendor")]]>
<![CDATA[
]]>
<![CDATA[              oCopyVendor.Text=oPage.FindChild("Vendor").Text]]>
<![CDATA[
]]>
<![CDATA[            else]]>
<![CDATA[
]]>
<![CDATA[              Writelog("Destination Vendor field not available")            ]]>
<![CDATA[
]]>
<![CDATA[            end if]]>
<![CDATA[
]]>
<![CDATA[         else]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Source Vendor field not available")          ]]>
<![CDATA[
]]>
<![CDATA[         end if]]>
<![CDATA[
]]>
<![CDATA[          OffSetAr = Split(CurrentObj.Variable("Image_Offset"),",")             ]]>
<![CDATA[
]]>
<![CDATA[          'Writelog("Vendor = '" & CurrentObj.FindChild("Vendor").Text & "', Image_Offset = '" & CurrentObj.Variable("Image_Offset") & "'") ]]>
<![CDATA[
]]>
<![CDATA[          For j = 0 To CurrentObj.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[             Set oSourceField = oPage.GetChild(j) ]]>
<![CDATA[
]]>
<![CDATA[             Writelog("oSourceField: " & oSourceField.ID)         ]]>
<![CDATA[
]]>
<![CDATA[             Set oDestField = CurrentObj.GetChild(j)]]>
<![CDATA[
]]>
<![CDATA[             oDestField.Text = ""]]>
<![CDATA[
]]>
<![CDATA[             writelog ("Writing positions for " & oSourceField.Type) ]]>
<![CDATA[
]]>
<![CDATA[             If oSourceField.Variable("Position") <> "0,0,0,0" Then]]>
<![CDATA[
]]>
<![CDATA[                PosAr = Split(oSourceField.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[                oDestField.Variable("Position") = cStr(clng(PosAr(0))- cLng(OffsetAr(0))) & "," & cStr(cLng(PosAr(1))-cLng(OffsetAr(1))) & "," & cStr(cLng(PosAr(2))-cLng(OffsetAr(0))) & "," & cStr(cLng(PosAr(3))-cLng(OffsetAr(1))) ]]>
<![CDATA[
]]>
<![CDATA[            'oDestField.Variable("Position") = cStr(clng(PosAr(0))) & "," & cStr(cLng(PosAr(1))) & "," & cStr(cLng(PosAr(2))) & "," & cStr(cLng(PosAr(3))) ]]>
<![CDATA[
]]>
<![CDATA[             End If]]>
<![CDATA[
]]>
<![CDATA[             if (oSourceField.ID = "Vendor") Or (oSourceField.ID = "Vendor_Number") then]]>
<![CDATA[
]]>
<![CDATA[                  oDestField.Text = oSourceField.Text]]>
<![CDATA[
]]>
<![CDATA[             end if ]]>
<![CDATA[
]]>
<![CDATA[          Next 'j ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          Set oSourceLineItemField = Nothing            ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          Set oSourceLineItemField = oPage.FindChild("Details").GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If Not oSourceLineItemField Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[             set oDetails = CurrentObj.FindChild("Details")]]>
<![CDATA[
]]>
<![CDATA[             Writelog("Found Details Field")]]>
<![CDATA[
]]>
<![CDATA[             oDetails.CreateFields()]]>
<![CDATA[
]]>
<![CDATA[             Set oLineItem = oDetails.GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[             oLineItem.CreateFields()]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[             Set oDestLineItemField = CurrentObj.FindChild("Details").GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[             PosAr = Split(oSourceLineItemField.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[             'msgbox(oSourceLineItemField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[             oDestLineItemField.Variable("Position") = cStr(clng(PosAr(0))- cLng(OffsetAr(0))) & "," & cStr(cLng(PosAr(1))-cLng(OffsetAr(1))) & "," & cStr(cLng(PosAr(2))-cLng(OffsetAr(0))) & "," & cStr(cLng(PosAr(3))-cLng(OffsetAr(1))) ]]>
<![CDATA[
]]>
<![CDATA[             'msgbox(oDestLineItemField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[             Writelog("NumOfChildren = '" & oDestLineItemField.NumOfChildren & "'")]]>
<![CDATA[
]]>
<![CDATA[             For k = 0 To oDestLineItemField.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[                Set oSourceField = oSourceLineItemField.GetChild(k)]]>
<![CDATA[
]]>
<![CDATA[                Set oDestField = oDestLineItemField.GetChild(k)]]>
<![CDATA[
]]>
<![CDATA[               ' msgbox ("Writing positions for " & oDestField.Type & "  " &oDestField.Variable("Position") ) ]]>
<![CDATA[
]]>
<![CDATA[               'Writelog("Writing positions for " & oDestField.Type & "  " &oDestField.Variable("Position") ) ]]>
<![CDATA[
]]>
<![CDATA[                If oSourceField.Variable("Position") <> "0,0,0,0" Then]]>
<![CDATA[
]]>
<![CDATA[                   PosAr = Split(oSourceField.Variable("Position"),",")]]>
<![CDATA[
]]>
<![CDATA[                   oDestField.Variable("Position") = cStr(clng(PosAr(0))- cLng(OffsetAr(0))) & "," & cStr(cLng(PosAr(1))-cLng(OffsetAr(1))) & "," & cStr(cLng(PosAr(2))-cLng(OffsetAr(0))) & "," & cStr(cLng(PosAr(3))-cLng(OffsetAr(1))) ]]>
<![CDATA[
]]>
<![CDATA[                   'msgbox("Dest-" & oDestField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[                oDestField.Variable("Position") = cStr(clng(PosAr(0))) & "," & cStr(cLng(PosAr(1))) & "," & cStr(cLng(PosAr(2))) & "," & cStr(cLng(PosAr(3))) ]]>
<![CDATA[
]]>
<![CDATA[                End If               ]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[             Next 'k]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          End If ]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Setting Sticky = Yes")          ]]>
<![CDATA[
]]>
<![CDATA[          CurrentObj.Variable("Sticky") = "Yes"]]>
<![CDATA[
]]>
<![CDATA[          Set oSourceLineItemField = Nothing]]>
<![CDATA[
]]>
<![CDATA[          Exit Function   ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[       End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Next 'i ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Setting Sticky = No")]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable("Sticky") = "No"]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetStickyNo" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA['    This action sets the 'Sticky' indicator to 'No', indicating that there are no sticky fingerprints.]]>
<![CDATA[
]]>
<![CDATA['    Sticky fingerprints are a way of identifying a page within a single verify session, when another]]>
<![CDATA[
]]>
<![CDATA['    form of the same type appears after a previous form had just been zoned.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Variable("Sticky") = "No"]]>
<![CDATA[
]]>
<![CDATA[   SetStickyNo = TRUE]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ClearErrorMsg" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['  This action clears the current error message.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   ClearErrorMsg = TRUE]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Variable("ErrorMessage") = ""]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Current Error Message: " & CurrentObj.Variable("ErrorMessage"))]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AddToErrorMsg" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['  The error message text.]]>
<![CDATA[
]]>
<![CDATA['  Appends the suplied text to any existing error message string.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim oPage]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   AddToErrorMsg = FALSE   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("This action must be on a field object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While oPage.ObjectType > 2]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Current Page is: " & oPage.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   oPage.Variable("ErrorMessage") = oPage.Variable("ErrorMessage") & StrParam & chrW(13)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Error message currently set to: " & oPage.Variable("ErrorMessage"))]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AddToDetailErrorMsg" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['   The error message text.]]>
<![CDATA[
]]>
<![CDATA['    Appends additional text to the existing error message.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[Dim oPage]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   AddToDetailErrorMsg = FALSE   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("This action must be on a field object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While oPage.ObjectType > 2]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Current Page is: " & oPage.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   oPage.Variable("ErrorMessage") = oPage.Variable("ErrorMessage") & "Lineitem " & cStr(CurrentObj.Parent.Parent.FindChildIndex(CurrentObj.Parent.ID) + 1) & "-" & StrParam & chrW(13)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Error message currently set to: " & oPage.Variable("ErrorMessage"))]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsStationIDSuffix" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[ '   The expected Station ID suffix.]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ '   This action will test the current station ID.  It checks that the specified parameter matches the right most portion of]]>
<![CDATA[
]]>
<![CDATA[ '   the station ID.  This can be useful if you have stations with different sufixes and you want to control]]>
<![CDATA[
]]>
<![CDATA[ '   actions based on the station name.]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ '     IsStationIDSuffix("-Test")]]>
<![CDATA[
]]>
<![CDATA[ '     CloseConnection()]]>
<![CDATA[
]]>
<![CDATA[ '     OpenConnection("@APPVAR(*/lookupdb:cs)")]]>
<![CDATA[
]]>
<![CDATA[ '     ]]>
<![CDATA[
]]>
<![CDATA[ '     In this example, If the station name is "Validate-Test", the action will]]>
<![CDATA[
]]>
<![CDATA[ '     return true and continue executing the following actions.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   IsStationIDSuffix = False]]>
<![CDATA[
]]>
<![CDATA[   if Len(StrParam) > len(Pilot.Station) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Specified suffix was longer than then current StationID " & Pilot.Station & ". Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   if Right(Pilot.Station,len(StrParam)) = StrParam then]]>
<![CDATA[
]]>
<![CDATA[      IsStationIDSuffix = TRUE]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ExecuteSQLBind" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ ' This action should not be used, as it is scheduled to be removed in future versions.    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[Dim oCmd]]>
<![CDATA[
]]>
<![CDATA[Dim oParam]]>
<![CDATA[
]]>
<![CDATA[Dim oRS]]>
<![CDATA[
]]>
<![CDATA[Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ExecuteSQLBind = FALSE]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   If Not isobject(oConn) Or oConn is Nothing then]]>
<![CDATA[
]]>
<![CDATA[      writelog("No DB Connection Object. Aborting Task.")]]>
<![CDATA[
]]>
<![CDATA[      nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If oConn.State =0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("DB Connection is Closed.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oCmd = CreateObject("ADODB.Command")]]>
<![CDATA[
]]>
<![CDATA[   Set oParam = oCmd.CreateParameter("HostID",200,1,50)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Setting oCmd.CommandText to: " & ParamAr(0) )]]>
<![CDATA[
]]>
<![CDATA[   oCmd.CommandText = ParamAr(0)]]>
<![CDATA[
]]>
<![CDATA[   oCmd.CommandType = 1]]>
<![CDATA[
]]>
<![CDATA[   oCmd.ActiveConnection = oConn]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   for i = 1 to uBound(ParamAr)]]>
<![CDATA[
]]>
<![CDATA[    'oCmd.Parameters.Append oParam]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Setting parameter " & cStr(i-1) & " to " & ReturnNamedValue(ParamAr(i)) )]]>
<![CDATA[
]]>
<![CDATA[    'oCmd(i-1).Value = ReturnNamedValue(ParamAr(i))]]>
<![CDATA[
]]>
<![CDATA[   ' oCmd(i-1).Value = "1083"]]>
<![CDATA[
]]>
<![CDATA[   next 'i   ]]>
<![CDATA[
]]>
<![CDATA[   'msgbox oCmd.CommandText]]>
<![CDATA[
]]>
<![CDATA[   'msgbox oCmd(0).Value]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oRS = oCmd.Execute]]>
<![CDATA[
]]>
<![CDATA[   'msgbox "Here"]]>
<![CDATA[
]]>
<![CDATA[   str = ""]]>
<![CDATA[
]]>
<![CDATA[   oRS.movefirst]]>
<![CDATA[
]]>
<![CDATA[   Do While NOT oRS.EOF]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      for i = 0 to oRS.fields.count - 1]]>
<![CDATA[
]]>
<![CDATA[         str = str & " " & oRS.fields(i).value]]>
<![CDATA[
]]>
<![CDATA[      next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      writelog(str)]]>
<![CDATA[
]]>
<![CDATA[      str = ""]]>
<![CDATA[
]]>
<![CDATA[      oRS.movenext]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Loop]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   ExecuteSQLBind = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Is_JobNamePrefix" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   Tests the left most portion of the job name to see if it matches the provided prefix.  The comparison]]>
<![CDATA[
]]>
<![CDATA[ '   is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   WriteLog("Jobname: " &  Pilot.JobName)]]>
<![CDATA[
]]>
<![CDATA[   if uCase(Left(Pilot.JobName,Len(StrParam))) = uCase(StrParam) then]]>
<![CDATA[
]]>
<![CDATA[      Is_JobNamePrefix = TRUE]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Is_JobNamePrefix = FALSE]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ReadFPXMLZones" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    Comma separated parameters:]]>
<![CDATA[
]]>
<![CDATA['    1. The fingerprint directory.  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA['    2. A comma separated list of the detail lines.]]>
<![CDATA[
]]>
<![CDATA['     ]]>
<![CDATA[
]]>
<![CDATA['    This action reads the zones from the FPXML into the objects for the page and stores the specified ]]>
<![CDATA[
]]>
<![CDATA['    fileds so that when it creates detail lines it knows the positions of the detail line's fields.]]>
<![CDATA[
]]>
<![CDATA['    ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[Dim oFS]]>
<![CDATA[
]]>
<![CDATA[Dim oField]]>
<![CDATA[
]]>
<![CDATA[Dim FingerprintDir]]>
<![CDATA[
]]>
<![CDATA[Dim sFPXML]]>
<![CDATA[
]]>
<![CDATA[Dim xFPXML]]>
<![CDATA[
]]>
<![CDATA[Dim xDoc]]>
<![CDATA[
]]>
<![CDATA[Dim oLineItemField]]>
<![CDATA[
]]>
<![CDATA[Dim oSubField]]>
<![CDATA[
]]>
<![CDATA[Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ReadFPXMLZones = FALSE]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   FingerprintDir = MetaWord(Trim(ParamAr(0)))]]>
<![CDATA[
]]>
<![CDATA[   if Right(FingerprintDir,1) <> "\" then]]>
<![CDATA[
]]>
<![CDATA[      FingerprintDir = FingerprintDir & "\"]]>
<![CDATA[
]]>
<![CDATA[   End if ]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType = 2 then]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a page object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   if oPage.Variable("TemplateID") = "" then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Setting to test")]]>
<![CDATA[
]]>
<![CDATA[      oPage.Variable("TemplateID") = "1068"]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   sFPXML = FingerprintDir & oPage.Variable("TemplateID") & ".xml" ]]>
<![CDATA[
]]>
<![CDATA[   writelog("Attempting to read: " & sFPXML) ]]>
<![CDATA[
]]>
<![CDATA[   if Not oFS.FileExists(sFPXML) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("FPXML does not exist: " & sFPXML)]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set xDoc=CreateObject("MSXML2.DOMDocument")]]>
<![CDATA[
]]>
<![CDATA[   xDoc.async=False]]>
<![CDATA[
]]>
<![CDATA[   xDoc.Load(sFPXML)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   For i=0 To oPage.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[     Set oField=oPage.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Processing: " & oField.Type)]]>
<![CDATA[
]]>
<![CDATA[     sType = oField.Type  ]]>
<![CDATA[
]]>
<![CDATA[     sPos=xDoc.selectSingleNode(".//F[@type='" & sType & "']/V[@n='Position']").text]]>
<![CDATA[
]]>
<![CDATA[     oField.Variable("Position")=sPos]]>
<![CDATA[
]]>
<![CDATA[     Writelog(oField.Type & ".Variable(Position) was set to: " & sPos)]]>
<![CDATA[
]]>
<![CDATA[     if oField.Type = ParamAr(1) then]]>
<![CDATA[
]]>
<![CDATA[     sPos=xDoc.selectSingleNode(".//F[@type='" & ParamAr(2) & "']/V[@n='Position']").text]]>
<![CDATA[
]]>
<![CDATA[        oField.Variable("LineItemPos") = sPos ]]>
<![CDATA[
]]>
<![CDATA[        Writelog(oField.Type & ".Variable(LineItemPos) was set to: " & sPos)]]>
<![CDATA[
]]>
<![CDATA[        for j = 3 to uBound(ParamAr)]]>
<![CDATA[
]]>
<![CDATA[           sPos=xDoc.selectSingleNode(".//F[@type='" & ParamAr(j) & "']/V[@n='Position']").text]]>
<![CDATA[
]]>
<![CDATA[           oField.Variable("POS-" & ParamAr(j)) = sPos]]>
<![CDATA[
]]>
<![CDATA[           Writelog(oField.Type & ".Variable(POS-" & ParamAr(j) & ") was set to " & sPos)]]>
<![CDATA[
]]>
<![CDATA[           Writelog("Looping j")]]>
<![CDATA[
]]>
<![CDATA[        next 'j  ]]>
<![CDATA[
]]>
<![CDATA[     end if  ]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Looping i")]]>
<![CDATA[
]]>
<![CDATA[   Next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ReadFPXMLZones = TRUE]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FPXMLUsed" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA['    This action indicates if FPXML format fingerprint files are being used.  Call this action if you are]]>
<![CDATA[
]]>
<![CDATA[ '   using fingerprints from FPXML with Invoice.rrx.    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While oPage.ObjectType > 2]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oPage.Variable("ZoneRead") = "FPXML" then]]>
<![CDATA[
]]>
<![CDATA[      FPXMLUsed = TRUE]]>
<![CDATA[
]]>
<![CDATA[   else ]]>
<![CDATA[
]]>
<![CDATA[      FPXMLUsed = FALSE]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SwitchMMDD" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="">
	<g>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    This action is intended to switch US Month and Day date values.  It will swap the first two characters]]>
<![CDATA[
]]>
<![CDATA['    of the field value with the two characters following the separator.]]>
<![CDATA[
]]>
<![CDATA['   ]]>
<![CDATA[
]]>
<![CDATA[Dim DateAr]]>
<![CDATA[
]]>
<![CDATA[Dim SepUsed]]>
<![CDATA[
]]>
<![CDATA[Dim SepCount]]>
<![CDATA[
]]>
<![CDATA[Dim i]]>
<![CDATA[
]]>
<![CDATA[Dim OldVal]]>
<![CDATA[
]]>
<![CDATA[Dim OldConf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   OldVal = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[   oldConf = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Starting value: " & CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[   SwitchMMDD = False]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   SepCount = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Call AllowOnlyChars(False,False,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" & StrParam)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   'Remove Extra Spaces]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   While InStr(CurrentObj.Text,"  ") > 0 ]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.Text = Replace(CurrentObj.Text,"  "," ")]]>
<![CDATA[
]]>
<![CDATA[   wend  ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   For i = 1 to Len(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[         if InStr(StrParam,mid(CurrentObj.Text,i,1)) > 0 then]]>
<![CDATA[
]]>
<![CDATA[            SepCount = SepCount + 1]]>
<![CDATA[
]]>
<![CDATA[            if SepUsed = "" then]]>
<![CDATA[
]]>
<![CDATA[            SepUsed = mid(CurrentObj.Text,i,1)]]>
<![CDATA[
]]>
<![CDATA[         end if]]>
<![CDATA[
]]>
<![CDATA[      end if   ]]>
<![CDATA[
]]>
<![CDATA[   next 'i]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("SepCount: " & cStr(SepCount))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if SepCount = 2 then]]>
<![CDATA[
]]>
<![CDATA[      DateAr = Split(CurrentObj.Text,SepUsed)]]>
<![CDATA[
]]>
<![CDATA[      CurrentObj.Text = DateAr(1) & SepUsed & DateAr(0) & SepUsed & DateAr(uBound(DateAr))]]>
<![CDATA[
]]>
<![CDATA[      SwitchMMDD = TRUE]]>
<![CDATA[
]]>
<![CDATA[    end if  ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    writelog(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ValidateVendor" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ' ValidateVendor exists in Flex.rrx and invoice.rrx.  This is to single source it.]]>
<![CDATA[
]]>
<![CDATA[     ValidateVendor = ValidateVendorPrivate(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="FindExportImage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    One of the following values: ]]>
<![CDATA[
]]>
<![CDATA['    1. Document Level TIFF.]]>
<![CDATA[
]]>
<![CDATA['    2. Document Level PDF.]]>
<![CDATA[
]]>
<![CDATA['    3. Page Level TIO.]]>
<![CDATA[
]]>
<![CDATA['    4. Page Level TIF.]]>
<![CDATA[
]]>
<![CDATA['   ]]>
<![CDATA[
]]>
<![CDATA['    This action searches the batch directory for a file that corresponds to the current page that contains the current]]>
<![CDATA[
]]>
<![CDATA['    field.  The file extension must match the extension specified with the input parameter.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[Dim oPage]]>
<![CDATA[
]]>
<![CDATA[Dim oFS]]>
<![CDATA[
]]>
<![CDATA[   FindExportImage = False]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a field object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While oPage.ObjectType > 2]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oPage.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Unable to find page object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oDoc = oPage]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   While oDoc.ObjectType > 1]]>
<![CDATA[
]]>
<![CDATA[      Set oDoc = oDoc.parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   if oDoc.ObjectType <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Unable to find document object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if InStr(",1,2,3,4,","," & StrParam & ",") < 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Invaid string parameter.  Expecting 1, 2, 3, or 4.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Strparam = "1" then]]>
<![CDATA[
]]>
<![CDATA[      if oFS.FileExists(Pilot.BatchDir & "\" & oDoc.ID & ".tif") then]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Text =  Pilot.BatchDir & "\" & oDOc.ID & ".tif"]]>
<![CDATA[
]]>
<![CDATA[         FindExportImage = TRUE]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         Writelog( Pilot.BatchDir & "\" & oDoc.ID & ".tif was not found.") ]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if   ]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Strparam = "2" then]]>
<![CDATA[
]]>
<![CDATA[      if oFS.FileExists(Pilot.BatchDir & "\" & Pilot.BatchID & oDoc.ID & ".pdf") then]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Text =  Pilot.BatchDir & "\" & Pilot.BatchID & oDoc.ID & ".pdf"]]>
<![CDATA[
]]>
<![CDATA[         FindExportImage = TRUE]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         Writelog( Pilot.BatchDir & "\" & Pilot.BatchID & oDoc.ID & ".pdf was not found." )]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Strparam = "3" then]]>
<![CDATA[
]]>
<![CDATA[      if oFS.FileExists(Pilot.BatchDir & "\" & oPage.ID & ".tio") then]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Text =  Pilot.BatchDir & "\" & oPage.ID & ".tio"]]>
<![CDATA[
]]>
<![CDATA[         FindExportImage = TRUE]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         Writelog( Pilot.BatchDir & "\" & oPage.ID & ".tio was not found." )]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Strparam = "4" then]]>
<![CDATA[
]]>
<![CDATA[      if oFS.FileExists(Pilot.BatchDir & "\" & oPage.ID & ".tif") then]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Text =  Pilot.BatchDir & "\" & oPage.ID & ".tif"]]>
<![CDATA[
]]>
<![CDATA[         FindExportImage = TRUE]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[         Writelog( Pilot.BatchDir & "\" & oPage.ID & ".tif was not found." )]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SwapImages" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA['    Two extensions:]]>
<![CDATA[
]]>
<![CDATA['    1. The extension to be saved as TIF.]]>
<![CDATA[
]]>
<![CDATA['    2. The extension that current tif is saved as.]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    This action interchanges the TIF for the current page with another TIF that has the same file name but]]>
<![CDATA[
]]>
<![CDATA['    a different extension.  One possible use is if you had a backup of the TIF and need to restore it.]]>
<![CDATA[
]]>
<![CDATA['    The current TIF will be named with the new extension while the other named TIF, is renamed to have a TIF extension.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[Dim oPage]]>
<![CDATA[
]]>
<![CDATA[Dim oFS]]>
<![CDATA[
]]>
<![CDATA[Dim CurrentTIFF]]>
<![CDATA[
]]>
<![CDATA[Dim ProcessedTIFF]]>
<![CDATA[
]]>
<![CDATA[Dim OriginalTIFF]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   SwapImages = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType < 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action will not work from a document or batch level.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   While oPage.ObjectType = 3 ]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oPage.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Field was not on a page.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if uBound(ParamAr) <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Invalid number of parameters.  Expecting (ext1,ext2).  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Left(ParamAr(0),1) <> "." then]]>
<![CDATA[
]]>
<![CDATA[      ParamAr(0) = "." & ParamAr(0)]]>
<![CDATA[
]]>
<![CDATA[      Writelog("First extension changed to: " & ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Left(ParamAr(1),1) <> "." then]]>
<![CDATA[
]]>
<![CDATA[      ParamAr(1) = "." & ParamAr(1)]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Second extension changed to: " & ParamAr(1))]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CurrentTIFF = oPage.ImageName]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ProcessedTIFF = Left(CurrentTIFF,InStrRev(CurrentTIFF,".") - 1)  & ParamAr(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Moving " & CurrentTIFF & " to " & ProcessedTiFF)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oFS.FileExists(CurrentTIFF) then]]>
<![CDATA[
]]>
<![CDATA[      Call oFS.CopyFile(CurrentTIFF,ProcessedTIFF)]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Moved Processed")]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      writelog("File not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   OriginalTIFF = Left(CurrentTIFF,InStrRev(CurrentTIFF,".") - 1)  & ParamAr(0)        ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oFS.FileExists(OriginalTIFF) then]]>
<![CDATA[
]]>
<![CDATA[      Call oFS.CopyFile(OriginalTIFF,CurrentTIFF)]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Moved Original")]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Original File not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   SwapImages = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AlterDatebyDay" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    The number of days to add.]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    This action will add the specified number of days to the date contained in the current field.  The original character]]>
<![CDATA[
]]>
<![CDATA['    confidence is not changed.  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim OldConf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   AlterDatebyDay = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a field object only.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Not IsNumeric(StrParam) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Expecting numeric parameter.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   OldConf = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Text = DateAdd("d",cLng(StrParam),CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.ConfidenceString = OldConf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ]]>
	</g>
</af>
<af name="CheckFreeDiskSpace" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA['    Two comma separated parameters:]]>
<![CDATA[
]]>
<![CDATA['    1. The path to Settings.ini that contains the 'LowDiskSpaceThreshold' setting.]]>
<![CDATA[
]]>
<![CDATA['    2. The letter drive of the drive to check.    ]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    Reads the 'LowDiskSpaceThreshold' setting from the [Notifications] section of the Settings.ini file.  If the]]>
<![CDATA[
]]>
<![CDATA['    available disk space is lower than the value specified in the INI file, then a notification will be created.]]>
<![CDATA[
]]>
<![CDATA['    If the 'LowDiskSpaceThreashold' is missing from the INI file, the default value of 3000 bytes will be used.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim oFS]]>
<![CDATA[
]]>
<![CDATA[Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[Dim Threshold]]>
<![CDATA[
]]>
<![CDATA[Dim oDrive]]>
<![CDATA[
]]>
<![CDATA[Dim DriveFreeSpace]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CheckFreeDiskSpace = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 0 then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Action was designed to run from batch level only.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   StrParam = MetaWord(Trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = SPlit(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if uBound(ParamAr) <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Invalid number of parameters.  Expecting SettingsFile,DriveLetter).  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Not oFS.FileExists(ParamAr(0)) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("SettingsFile was not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   set oDrive = oFS.GetDrive(oFS.GetDriveName(ParamAr(1)))   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   DriveFreeSpace =  FormatNumber(oDrive.FreeSpace/(1024 * 1024),0) ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Free Space: " &  DriveFreeSpace)  ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Threshold = Pilot.GetProfileString("Notifications","LowDiskSpaceThreshold","3000",ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Current Threshold Setting: " & Threshold)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if cLng(DriveFreeSpace) >= cLng(Threshold) then]]>
<![CDATA[
]]>
<![CDATA[      if Pilot.GetProfileString("Notifications","LowDiskNotificationSent","",ParamAr(0)) = "Yes" then ]]>
<![CDATA[
]]>
<![CDATA[         Call Pilot.SetProfileString("Notifications","LowDiskNotificationSent","No",ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[         writelog("Cleared Notification")]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[      CheckFreeDiskSpace = TRUE]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      if Pilot.GetProfileString("Notifications","LowDiskNotificationSent","",ParamAr(0)) = "No" then ]]>
<![CDATA[
]]>
<![CDATA[         Call Pilot.SetProfileString("Notifications","LowDiskNotificationSent","Yes",ParamAr(0))]]>
<![CDATA[
]]>
<![CDATA[         writelog("Marked Notification to Send")]]>
<![CDATA[
]]>
<![CDATA[         CheckFreeDiskSpace = TRUE]]>
<![CDATA[
]]>
<![CDATA[      end if      ]]>
<![CDATA[
]]>
<![CDATA[   end if  ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="CheckAndFixDecimal" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    Replaces the space or , with .]]>
<![CDATA[
]]>
<![CDATA['    This can be used to fix errors where the decimal is not recognized and leaves a blank in that area, ]]>
<![CDATA[
]]>
<![CDATA['    also this can be used for conversion for European numbers that use a comma to separate dollars from cents]]>
<![CDATA[
]]>
<![CDATA['    so $100,00 becomes $100.00 or $100 00 becomes $100.00.]]>
<![CDATA[
]]>
<![CDATA['    ]]>
<![CDATA[
]]>
<![CDATA[   Dim oldCOnf]]>
<![CDATA[
]]>
<![CDATA[   Dim NewText]]>
<![CDATA[
]]>
<![CDATA[   CheckandFixDecimal = False ]]>
<![CDATA[
]]>
<![CDATA[   If CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a field object")]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   if Len(CurrentObj.Text) < 3  then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Length is too short for currency.  Exiting FALSE")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   Writelog("The Starting value is :" & CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[   oldConf = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if Mid(CurrentObj.Text,len(CurrentObj.Text) - 2,1) = " " OR  Mid(CurrentObj.Text,len(CurrentObj.Text) - 2,1) = ","  then]]>
<![CDATA[
]]>
<![CDATA[       NewText = Left(CurrentObj.Text,Len(CurrentObj.Text) - 3) & "." & Right(CurrentObj.Text,2)]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Converting " & CurrentObj.Text & " to " & NewText) ]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Text = NewText]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.ConfidenceString = oldCOnf]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("The value of :" & CurrentObj.Text & " doesn't fall in the criteria of a space or comma followed by two digits")]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CheckAndFixDecimal = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AllMixedCase" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA['    This action will change the value of the current field to be Title case.  The first letter of]]>
<![CDATA[
]]>
<![CDATA['    each word will be capitalized.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim i]]>
<![CDATA[
]]>
<![CDATA[Dim oldConf]]>
<![CDATA[
]]>
<![CDATA[Dim MixedString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   AllMixedCase = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action is designed for field object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function   ]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   writelog("Getting confidence")]]>
<![CDATA[
]]>
<![CDATA[   oldConf = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   for i = 1 to len(CurrentObj.Text) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      if i = 1 then]]>
<![CDATA[
]]>
<![CDATA[         MixedString = uCase(Left(CurrentObj.Text,1))]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[         if mid(CurrentObj.Text,i-1,1) = " " then]]>
<![CDATA[
]]>
<![CDATA[            MixedString = MixedString & uCase(mid(CurrentObj.Text,i,1))]]>
<![CDATA[
]]>
<![CDATA[         else]]>
<![CDATA[
]]>
<![CDATA[            MixedString = MixedString & lCase(mid(CurrentObj.Text,i,1)) ]]>
<![CDATA[
]]>
<![CDATA[         end if]]>
<![CDATA[
]]>
<![CDATA[      end if]]>
<![CDATA[
]]>
<![CDATA[      Writelog(MixedString)]]>
<![CDATA[
]]>
<![CDATA[   next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Text = MixedString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.ConfidenceString = oldConf]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CaptureOpInfo" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA['    An optional prefix to the variable name.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA['    This action will capture the Operator, Station ID and current time and place them into variables.  The variables will be]]>
<![CDATA[
]]>
<![CDATA['    named based on the provided variable prefix, like this: "prefix Operator", "prefix Station" and "prefix Time".]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    CapatureOpInfo = TRUE]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Trim(StrParam) = "" Then StrParam = Pilot.TaskID]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable(StrParam & " " & "Operator") = Pilot.Operator]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable(StrParam & " " & "Station") = Pilot.Station]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable(StrParam & " " & "Time") = Now()]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GenerateDetails" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['    This action sets up a field in APT and puts a detail subfield on every page.  This extra detail subfield]]>
<![CDATA[
]]>
<![CDATA['    appears on all pages of a multi-page invoice, allowing every page to be viewed.    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  Dim oPage]]>
<![CDATA[
]]>
<![CDATA[  Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[  Dim NumPages]]>
<![CDATA[
]]>
<![CDATA[  Dim oLineItem]]>
<![CDATA[
]]>
<![CDATA[  Dim oField]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   GenerateDetails = False]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a field object. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.Parent.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a field that is a child of a page object.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj.Parent]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if oPage.Parent.ObjectType <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Action must be on a field in a document structure.  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   Set oDoc = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Proper structure found")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   NumPages = oDoc.NumOfChildren   ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Detected " & NumPages & " pages.")   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   For i = CurrentObj.NumOfChildren-1 To 0 Step -1]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.DeleteChild(i)]]>
<![CDATA[
]]>
<![CDATA[   Next]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   For i = 0 to NumPages - 1      'children indexes are 0 based]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Creating line for page " & cStr(i+1) ) ]]>
<![CDATA[
]]>
<![CDATA[      Set oLineItem = CurrentObj.AddChild(3,"Page_No" & cStr(i+1) ,-1)      ]]>
<![CDATA[
]]>
<![CDATA[      oLineItem.Type = "Page_No"      ]]>
<![CDATA[
]]>
<![CDATA[      oLineItem.Status = 0]]>
<![CDATA[
]]>
<![CDATA[      oLineItem.Variable("Position") = "90,90,210,210"]]>
<![CDATA[
]]>
<![CDATA[      oLineItem.Variable("IMAGEFILE") = oDoc.GetChild(i).Variable("IMAGEFILE")]]>
<![CDATA[
]]>
<![CDATA[      Set oField = oLineItem.AddChild(3,"TIFF",0)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      oField.Variable("IMAGEFILE") = oDoc.GetChild(i).Variable("IMAGEFILE")]]>
<![CDATA[
]]>
<![CDATA[      oField.Variable("Position") = "100,100,200,200"]]>
<![CDATA[
]]>
<![CDATA[      oField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[      oField.Text = Right(oField.Variable("IMAGEFILE"),12)]]>
<![CDATA[
]]>
<![CDATA[      oField.Type = "TIFF"]]>
<![CDATA[
]]>
<![CDATA[   next 'i]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   GenerateDetails = TRUE]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[   Call ErrorHandler("GenerateDetails")      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IncrementBatchVar" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ '   The name of the variable to increment.]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ '   This action increments a batch level variable by 1.  If the variable does not already exist, it will be created.]]>
<![CDATA[
]]>
<![CDATA[ '   If the variable exists but the value is not numeric, the variable will be set to 1.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   Dim CurrentValue]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   IncrementBatchVar = TRUE]]>
<![CDATA[
]]>
<![CDATA[   CurrentValue = DCO.Variable(strParam)]]>
<![CDATA[
]]>
<![CDATA[   if Not IsNumeric(CurrentValue) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Creating batch variable: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[      DCO.Variable(strParam) = "1"]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   DCO.Variable(StrParam) = cStr(cLng(DCO.Variable(StrParam)) + 1)      ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SendOutlookNotification" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ '   The extension of the attachment.  The attachment is expected to be named the same as the current document ID.]]>
<![CDATA[
]]>
<![CDATA[ '  ]]>
<![CDATA[
]]>
<![CDATA[ '   This action uses outlook to send a notification to specified e-mail addresses.  The message within the email]]>
<![CDATA[
]]>
<![CDATA[ '   is determined by previous calls to actions that have set notification, such as CheckFreeDiskSpace.]]>
<![CDATA[
]]>
<![CDATA[ '   ]]>
<![CDATA[
]]>
<![CDATA[ '   Note that this action has some requirements such as Outlook installed on the machine and logged]]>
<![CDATA[
]]>
<![CDATA[ '   in with an ID that has appropriate permissions to send emails.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[Dim oOutlook]]>
<![CDATA[
]]>
<![CDATA[Dim oMail]]>
<![CDATA[
]]>
<![CDATA[Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[Dim MailTo]]>
<![CDATA[
]]>
<![CDATA[Dim StrMessage]]>
<![CDATA[
]]>
<![CDATA[Dim oFS]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      SendOutlookNotification = TRUE]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Set oDoc = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[      While oDoc.ObjectType > 1]]>
<![CDATA[
]]>
<![CDATA[         Set oDoc = oDoc.Parent]]>
<![CDATA[
]]>
<![CDATA[      Wend]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      if oDoc.ObjectType <> 1 then]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Document object not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Set oOutlook = Nothing]]>
<![CDATA[
]]>
<![CDATA[      Set oOutlook = CreateObject("Outlook.Application")]]>
<![CDATA[
]]>
<![CDATA[      if oOutlook Is Nothing then]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Could not create Outlook object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Set oMail = oOutlook.CreateItem(0)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   SettingsFile = Pilot.GetProfileString("Files","Settings","*",Pilot.ProjectPath)]]>
<![CDATA[
]]>
<![CDATA[   If SettingsFile = "*" Then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Missing settings file " & Pilot.ProjectPath & ".  Exiting.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Settings file: " & SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   MailTo = Pilot.GetProfileString("Notifications",CurrentObj.Text,"*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[   if MailTo = "*" then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Could not find email address in settings.ini.  Exiting - " & CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   if Left(StrParam,1) <> "." then]]>
<![CDATA[
]]>
<![CDATA[      StrParam = "." & StrParam]]>
<![CDATA[
]]>
<![CDATA[   End if   ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   oMail.To = MailTo]]>
<![CDATA[
]]>
<![CDATA[   oMail.Subject = "Taskmaster Notification - " & oDoc.ID]]>
<![CDATA[
]]>
<![CDATA[   Set oFS = CreateObject("Scripting.FileSystemObject")]]>
<![CDATA[
]]>
<![CDATA[   if oFS.FileExists(Pilot.BatchDir & "\" & oDoc.ID & StrParam) then]]>
<![CDATA[
]]>
<![CDATA[      oMail.Attachments.Add(Pilot.BatchDir & "\" & oDoc.ID & StrParam)]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Could not find attachment: " & Pilot.BatchDir & "\" & oDoc.ID & StrParam) ]]>
<![CDATA[
]]>
<![CDATA[   end if     ]]>
<![CDATA[
]]>
<![CDATA[   strMessage = "Reason for notification: " & CurrentObj.Text & vbcrlf & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[   strMessage = strMessage & "Operator: " & CurrentObj.Parent.Variable("Verify Operator") & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[   strMessage = strMessage & "Station: " & CurrentObj.Parent.Variable("Verify Station") & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[   strMessage = strMessage & "Time: " & CurrentObj.Parent.Variable("Verify Time") & vbcrlf ]]>
<![CDATA[
]]>
<![CDATA[   strMessage = strMessage & "Comments: " & CurrentObj.Parent.Variable("comments") & vbcrlf ]]>
<![CDATA[
]]>
<![CDATA[   oMail.Body = strMessage]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[   oMail.Send]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Set oMail = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oOutlook = Nothing  ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="UpdateFPStats" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[ '   This action updates the fingerprint statistics in the fingerprint database.    ]]>
<![CDATA[
]]>
<![CDATA[ '   It keeps track of the last accessed fingerprint and the number of times a fingerprint is accessed.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[Dim oCmd]]>
<![CDATA[
]]>
<![CDATA[Dim oParam1]]>
<![CDATA[
]]>
<![CDATA[Dim oParam2]]>
<![CDATA[
]]>
<![CDATA[Dim DateHit]]>
<![CDATA[
]]>
<![CDATA[Dim oRS]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ON ERROR RESUME NEXT]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   UpdateFPStats = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oConn.State = 0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Connection to the rules/fingerprint database was not found.Exiting.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if CurrentObj.ObjectType <> 2 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("This action was designed to operate on a page level object only.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oCmd = CreateObject("ADODB.Command")]]>
<![CDATA[
]]>
<![CDATA[   Set oParam1 = oCmd.CreateParameter("P1",200,1,50)]]>
<![CDATA[
]]>
<![CDATA[   Set oParam2 = oCmd.CreateParameter("P1",200,1,50)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   sSQL = "UPDATE Template SET tp_HitCount = tp_HitCOunt + 1, tp_LastHit = ? WHERE tp_TemplateID = ?"]]>
<![CDATA[
]]>
<![CDATA[   sSQL = ModifySQLByDBType(oCmd,sSQL)]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   oCmd.CommandText = sSQL]]>
<![CDATA[
]]>
<![CDATA[   oCmd.CommandType = 1]]>
<![CDATA[
]]>
<![CDATA[   oCmd.ActiveConnection = oConn]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Connection set")]]>
<![CDATA[
]]>
<![CDATA[   oCmd.Parameters.Append oParam1]]>
<![CDATA[
]]>
<![CDATA[   oCmd.Parameters.Append oParam2]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Parameters set")]]>
<![CDATA[
]]>
<![CDATA[   Writelog("TemplateID = " & CurrentObj.Variable("TemplateID"))]]>
<![CDATA[
]]>
<![CDATA[   oCmd(0).Value = Date()]]>
<![CDATA[
]]>
<![CDATA[   oCmd(1).Value = CurrentObj.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if oCmd(1).Value = "" then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("No TemplateID found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Ready to do oCmd.Execute")]]>
<![CDATA[
]]>
<![CDATA[   oRS = oCmd.Execute]]>
<![CDATA[
]]>
<![CDATA[   Writelog("SQL Executed")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oCmd = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oParam1 = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oParam2 = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oRS = Nothing]]>
<![CDATA[
]]>
<![CDATA[   ERR.CLEAR]]>
<![CDATA[
]]>
<![CDATA[   UpdateFPStats = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<help>
<![CDATA[
'*****************************************************************
'Invoice rrx Action Help 
'IBM Confidential
'
'OCO Source Materials
'
'5725-C15 5725-C69
'© Copyright IBM Corp. 1994, 2015
'The source code for this program is not published or otherwise
'divested of its trade secrets, irrespective of what has been 
'deposited with the U.S. Copyright Office.
'-----------------------------------------------------------------
'
' Version 8.0.1.11 Updated 12/21/2010 PHofle
'   * Converted to .Net Dll
'
' Version 8.0.1.12 Updated 05/15/2013 RFerin
'   * Updated the help to list the base actions to use instead of: Is_InCharSet, Is_JobName, IsChildFieldBlank, IsChildFieldValue, IsTaskName, MovePDF, PareseImageName, SetToDocIDMPTIFF
'
'*************************************************
'
']]>
<ref id="SetDynamicDetailZones"  >
  <ap>
    The parameter is the Zone Bottom field. If more than one field is listed, 
    Zone Bottom must be first field, and additional fields are ignored.
  </ap>
  <h>  
    This action takes the position of the line items and it builds the line coordinates from them
    and then it sets the details zones from that top line to the bottom of the CCO.
    <e>
      LoadCCOFromField()<br/>      
      <b>SetDynamicDetailZones("Zone Bottom,Notes")</b><br/>
      ZoneBOTTOM_ImageBottom()<br/>
      ScanDetails()
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if no children exist.  Otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="LoadCCOFromField"  >
  <ap>None.</ap>
  <h>
    This action loads the DCO from a field object.
    The verify panels do not load the CCO into the scripting engine so this action acomplishes that task.  
    This action is required for any invoice action that uses the CCO.
    <e>
      <b>LoadCCOFromField()</b><br/>
      SetDynamicDetailZones("Zone Bottom,Notes")<br/>
      ZoneBOTTOM_ImageBottom()<br/>
      ScanDetails()
    </e>
  </h>
  <lvl>Field Level.</lvl>
  <ret>
    <b>False,</b> if this action is not called on a field or if the CCO file does not exist.  Otherwise, <b>True.</b>
  </ret>
</ref>
  
  
<ref id="ScanLineItemDynamic"  >
  <ap>
    A comma separated list of any fields that should be ignored.
  </ap>
  <h>
    This action scans the line items from the CCO that was loaded into the field.  It is like
    ScanLineItem but uses the CCO loaded for the field and reads position variables from the line item level.
    It is required for Find Details functionality.  It saves the positions of the line and of the feids at the detail
    level so all of the line items can be erased and recreated.
    <e>
      FPXMLUsed()<br/>
      <b>ScanLineItemDynamic("ZoneBottom,Notes")</b>
    </e>
  </h>
  <lvl>Field Level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
  
<ref id="AllowOnlyChars"  >
  <ap>
    A list of all characters allowed within the field.
  </ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.
    Instead, use the AllowOnlyChars action in the Validations action library.
    <br/><br/>
    <b>*** Original Help Description ***</b><br/>
    This action will match the field characters with the allowed set of characters.  If the field contains
    characters that are not in the allowed set, the characters will be deleted from the field.
    The comparison is case sensitive. 
    <e>
      CheckAnFixDecimal()<br/>
      Is_InCharSet("01234567890.,-$ ")<br/>
      <b>AllowOnlyChars("0123456789.-")</b>
    </e>
  </h>
  <lvl>
    Field Level.
  </lvl>
  <ret>
    <b>False,</b> if this action is called at the wrong level.  Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="PopulateZNLineItemFieldDynamic"  >
  <ap>
    None.
  </ap>
  <h>
    This action is like the PopulateZNLineItemField but it uses the CCO that was
    loaded into memory by LoadCCOFromField, instead of the global CCO.
    It populates the fingerprint’s Data file with the recognized value contained inside
    the zone of a child Field object of a LINEITEM parent field. This action should
    only be used with sub-fields of the LINEITEM field - ItemID, ItemDesc,
    Quantity, Price in the <i>Invoices</i> application.
    <e>
      FPXMLUsed()<br/>
      <b>PopulateZNLineItemFieldDynamic()</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True,</b> if there is no field position or if the data was found in a zone.
    <b>False,</b> if there is a zone defined but it is blank.    
  </ret>
</ref>
<ref id="CalculateNotesZone"  >
  <ap>
    None.
  </ap>
  <h>
    This action creates a zone between detail lines, so the text between lines can 
    be recognized.
    <e>
      <b>CalculateNotesZone()</b>
    </e>
  </h>
  <lvl>Field level, on the detail field.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="ParseImageName"  >
  <ap>
    None.
  </ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.  Instead, use the FileIO action library.
    Use SplitFileName with smart parameters.  For example: <br/><br/>

    SplitFileName("@P.ScanSrcPath","","","@P\Fieldname.Text","")<br/>
    See the action help for details.<br/><br/><br/>


    <b>*** Deprecated Help Description ***</b><br/>
    This action extracts only the file name from the variable 'ScanSrcPath' and
    places it into the 'Text' variable of the current object.  It is expected that the file
    name contains an underscore and only the value up to the underscore is kept.
    <e>
      <b>ParseImageName()</b>
    </e>
  </h>
  <lvl>Document or Page level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="IsFingerPrintClass"  >  
  <ap>
    Two comma separated parameters:<br/>
    1. The database connection string.  Smart parameters are supported.<br/>
    2. Fingerprint class.
  </ap>
  <h>
    This action connects to the fingerprint database and verifies that the specified fingerprint
    class contains the fingerprint ID of the current page.  
    <e>
      ChkDCOStatus("75")<br/>      
      <b>IsFingerPrintClass("@APPVAR(*/fingerprintconn:cs)+,[New]")</b><br/>
      DeleteFingerprint()<br/>
      IncrementBatchVar("Deleted New Fingerprint")<br/><br/>

      A parameter of [New] checks to see if the fingerprint exists in the new class,
      and if it does, follow on actions can perform further processing.
    </e>
  </h>
  <lvl>
    Page Level.
  </lvl>
  <ret>
    <b>False,</b> if called with the wrong number of parameters, on the wrong level, if the 
    fingerprint ID does not exist in the specified class.
  </ret>
</ref>
  
<ref id="iloc_SetDetailSimple"  strParam="sDetailName" >
  <ap>
    The detail Datacap Object (DCO) Type.
  </ap>
  <h>
    This action fills the Setup DCO from Runtime Data file.    
    <e>
      SetFingerprint("@P\Vendor")<br/>
      iloc_SetZones()<br/>
      <b>iloc_SetDetailSimple("Details")</b><br/>
      IncrementBatchVar("Intellocate Fingerprint")
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level, if the DCO node cannot be found, if the fingerprint ID is not
    found, or if the setup DCO cannot be saved.  Otherwise, <b>True.</b>
  </ret>
</ref>
		
  
<ref id="Is_InCharSet"  >
  <ap>
    A list of valid characters.
  </ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.  
    It is recommended that you no longer use this action.  Instead, use the Picture action library.  
    First call the action PIC_SetPictureCharacter to set the list of valid 
    characters with a custom picture string.  Multiple lists can be defined as necessary.  
    Then call PIC_ApplyPictureString to validate the field with the custom picture string.
    See the action help for details.<br/><br/><br/>


    <b>*** Deprecated Help Description ***</b><br/>
    This action checks the 'Text' value of the current field to confirm that each of the characters are
    contained within the specified set of expected characters.  If one or more characters are not in the specified
    set, the action returns false.<br/><br/>
    
    <b>Note:</b> The comparison is case sensitive.
    <e>
      CheckAndFixDecimal()<br/>      
      <b>Is_InCharSet("0123456789.,-$ ")</b>
    </e>
  </h>
  <lvl>Field Level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level, if the 'Text' value of the current object is empty or if
    a character in the 'Text' variable of the current object does not exist in the specified character set.
    Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="IsMultipageDocument"  >
  <ap>
    None.
  </ap>
  <h>
    This action is used to determine if the current object is a document with multiple pages attached.
    <e>
      <b>IsMultipageDocument()</b>
    </e>
  </h>
  <lvl>
    Document level.
  </lvl>
  <ret>
    <b>False,</b> if called at the Batch level, the document object cannot be found, 
    or if the document does not have more than 1 child.
    Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="IsSinglePageDocument"  >
  <ap>
    None.
  </ap>
  <h>
    This action is used to determine if the current object is a document with only 1 page attached.
    <e>
      <b>IsSinglePageDocument()</b><br/>
      PopulateZNField()
    </e>
  </h>
  <lvl>Document level.</lvl>
  <ret>
    <b>False,</b> if not called on a document object or if the document does not contain exactly one page.
    <b>True,</b> if the document contains one page.
  </ret>
</ref>
  
<ref id="DoMsgbox"  >
  <ap>
    The message to display.  
  </ap>
  <h>
    This Action is Deprecated, its functionality is no longer supported.
    
    The message is displayed to the user and they must press "OK" to continue.<br/><br/>
    
    <b>Note:</b> This action must not be used within a ruleset that is run
    unattended or processing will stop.
    <e>
      CheckDCOStatus("75")<br/>
      <b>DoMsgbox("The page was deleted.")</b>
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="IsChildFieldValue"  >
  <ap>
    Two comma separated parameters:<br/>
    1. The name of the variable to check.<br/>
    2. The value to compare.
  </ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.  Instead, use the rrunner action library.
    Use rrCompare with smart parameters.  For example, <br/><br/>

    rrCompare("Expected Value", "@F\MyFieldToTest")<br/>
    See the action help for details.<br/><br/><br/>


    <b>*** Deprecated Help Description ***</b><br/>
    
    This action locates a child field and compares its value to the one passed in.  This action
    can be used to perform actions if a field contains a specific value.
    <e>
      <b>IsChildFieldValue("Add_New_Fingerprint,YES")</b>      
    </e>
  </h>
  <lvl>Document Level</lvl>
  <ret>
    <b>False,</b> if the field is not found, the number of parameters is incorrect
    or if it is called at the wrong level.  Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="CreateFingerprint"  >
  <ap>
    None.
  </ap>
  <h>
    This action will create a fingerprint for the current page.  
    Forces the creation of a new fingerprint using the current image, even if there is an existing
    fingerprint.  A typical scenario is when there is a very similar fingerprint that
    incorrectly matches the current image, such as two invoices
    that are very similar.  When the new invoice is received in the future, it should
    now match on this new fingerprint.
    <e>
      IsChildFieldValue("Add_New_Fingerprint,YES")<br/>
      SetFingerprintDir("@APPPATH(fingerprint)")<br/>
      SetFingerprintRecogPriority("True")<br/>
      RecognizePageOCR_S()<br/>
      <b>CreateFingerprint()</b><br/>
      SetFingerprint("@P\Vendor")<br/>
      iloc_SetDetailSimple("Details")<br/>
      IncrementBatchVar("Verify requested Add Fingerprint")
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True,</b> if a new fingerprint has been created.  Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="SetPicChar"  >
  <ap>
  </ap>
  <h>
    This action should not be used, as it is scheduled to be removed in future versions.
    It has been replaced by PIC_SetPictureCharacter in Picture.rrx.
  </h>
</ref>

<ref id="WriteErrorMessage"  >
  <ap>
    The error message.
  </ap>
  <h>    
    Writes the message to field level variable message that appears in the status bar. The message is stored in the MESSAGE variable.
    <e>
      GetDCOStatus("75")<br/>
      <b>WriteErrorMessage("The page is set to a deleted status.")</b>
    </e>
  </h>
  <lvl>All levels.</lvl>
  <ret>
    Always <b>False.</b>
  </ret>
</ref>
  
<ref id="IsInList"  >
  <ap>
    A string that is a substring of the expected 'Text' value.
  </ap>
  <h>
    This action validates that the value of a field is contained within a given string.
    <e>
      <b>IsInList("Hello Larry")</b>
      <br/><br/>
      In this example, if the field 'Text' value is 'Larry', the action will return true.
    </e>
  </h>
  <lvl>Field Level.</lvl>
  <ret>
    <b>True,</b> if the value of the Text variable of the current field is contained within the specified list.
  </ret>
</ref>
  
<ref id="IsInINI"  >
  <ap>
    A comma separated string of:<br/>
    1. The INI Filename.<br/>
    2. The section within the INI file.<br/>
    3. The keyword to find in the section.
  </ap>
  <h>
    Note: When possible it is recommended to use the generic actions that read and write INI files in the FileIO action library.<br/><br/> 
    Reads and returns to the action the value of the specified key in the INI file.  It compares the value of the current
    field with the with the string in the INI file.  The field must be a substring of the string in the
    INI file.
    <e>
      <b>IsInINI("C:\MyDir\settings.ini", "mysection", "mykey")</b><br/><br/>      
    </e>    
  </h>
  <lvl>Field Level.</lvl>
  <ret>
    <b>True,</b> if the value of the current field is a substring within the string specified in the INI file.
    Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="IsTaskName"  >
  <ap>
    The expected task name.
  </ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.  Instead, use the rrunner action library.
    Use rrCompare to test using smart parameters.  For example: <br/><br/>

    rrCompare("MyExpectedName", "@TASKNAME")<br/>
    See the action help for details.<br/><br/><br/>


    <b>*** Deprecated Help Description ***</b><br/>

    This action will check the name of the currently running task to see if it matches the specified task name.
    If it matches, it will return True.
    <e>
      IsTaskName("Verify")<br/>
      <b>LoadCCOFromField()</b><br/>
      PopulateZNField()
    </e>
  </h>
  <lvl>Any levels.</lvl>
  <ret>
    <b>True,</b> if the specified name matches the currently running task.  Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="DetailFix"  >  
  <ap>None.</ap>
  <h>
    Calculates the quantity, price and line total for when one of them is blank within a detail field.
    This calculation is performed for all detail lines on the page.
    <e>
      <b>DetailFix()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level.<br/>
    <b>False,</b> The any of following fields do not exist or are not numeric: Qty, Price and LineTotal.<br/>
    Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="CheckForSticky"  >
  <ap>None.</ap>
  <h>
    For new fingerprints this action checks to see if there another matching fingerprint 
    within the same batch that has already been verified, where it can 
    use it to obtain zone information.  An example is when a batch contains two similar
    invoices, which have never been processed by the system before.  Once the first
    invoice is zoned during verify, the same new fingerprint can be used
    on the second invoice.  This is only needed on new matching fingerprints within the same batch
    because a fingerprints zones are saved at export time and are available for subsequent batches.
    <e>
      <b>CheckForSticky()</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
      
  
<ref id="IsCurrentObjVariable"  >  
  <h>
    This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrCompare in rrunner.
    <e>
      <b>rrCompare("@F.Sticky","No")</b><br/>
      SkipChildren()
    </e>
  </h>
</ref>
  
<ref id="IsChildFieldBlank"  >
  <ap>
    The name of a child field of the current object.
  </ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.  Instead, use the rrunner action library.
    Use rrCompare with smart parameters.  For example, <br/><br/>

    rrCompare("@EMPTY", "@F\MyFieldToTest")<br/>
    See the action help for details.<br/><br/><br/>


    <b>*** Deprecated Help Description ***</b><br/>    
    
    Searches for a child field that matches the provided parameter.  If it matches and if the text value
    is empty, then this action returns true, causing the next action in the ruleset to run.
    <e>
      <b>IsChildFieldBlank("Qty")</b>
    </e>
  </h>
  <lvl>
    Field Level.
  </lvl>
  <ret>
    <b>True,</b> if the child field is located and if it has an empty text field.  Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="SetStickyNo"  >
  <ap>None.</ap>
  <h>
    This action sets the 'Sticky' indicator to 'No', indicating that there are no sticky fingerprints.
    Sticky fingerprints are a way of identifying a page within a single verify session, when another
    form of the same type appears after a previous form had just been zoned.
    <e>
      IsCurrentObjVariable("Sticky,Yes")<br/>
      <b>SetStickyNo()</b>
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="ClearErrorMsg"  >
  <ap>None.</ap>
  <h>
    This action clears the current error message.
    <e>
      Status_Preserve_OFF()<br/>
      <b>ClearErrorMsg()</b><br/>
      CaptureOpInfo()<br/>
      rrCompare("@P\Routing_Instructions","None")
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
 
<ref id="AddToErrorMsg"  >
  <ap>
    The error message text.
  </ap>
  <h>
    Appends the suplied text to any existing error message string.
    <e>
      <b>AddToErrorMsg("Vendor Number cannot be blank.")</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>False.</b>
  </ret>
</ref>
  
<ref id="AddToDetailErrorMsg"  >  
  <ap>
    The error message text.
  </ap>
  <h>
    Appends additional text to the existing error message.
    <e>
      <b>AddToDetailErrorMsg("Description cannot be blank.")</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>False.</b>
  </ret>
</ref>
  
<ref id="IsStationIDSuffix"  >
  <ap>
    The expected Station ID suffix.
  </ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.
    Instead, use the rrCompareCaseLength or rrCompareNotCaseLength action in the rrunner action library
    with the @STATION smart parameter.<br/><br/>
    For example: rrCompareCaseLength("-Test","@STATION", "False", 5, "False")
    <br/><br/>

    <b>*** Deprecated Help Description ***</b><br/>
    This action will test the current station ID.  It checks that the specified parameter matches the right most portion of
    the station ID.  This can be useful if you have stations with different sufixes and you want to control
    actions based on the station name.
    <e>
      <b>IsStationIDSuffix("-Test")</b><br/>
      CloseConnection()<br/>
      OpenConnection("@APPVAR(*/lookupdb:cs)")<br/><br/>
      
      In this example, If the station name is "Validate-Test", the action will
      return true and continue executing the following actions.
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    <b>False,</b> if the suffix is longer than the current Station ID or if the
    specified suffix does not match the Station ID.  Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="OpenConnection"  >
  <h>
    This action should not be used, as it is scheduled to be removed in future versions.
    It has been replaced by OpenConnection in Lookup.rrx.
  </h>
</ref>
  
<ref id="ExecuteSQLBind"  >
  <h>
    This action should not be used, as it is scheduled to be removed in future versions.    
  </h>
</ref>
  
<ref id="Is_JobName"  >
  <ap>
    The name of the job name you expect for the current job.
  </ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.  Instead, use the rrunner action library.
    Use rrCompare to test the job name using the smart parameter @JOBNAME.  <br/><br/>
    
    For example: <br/>
    rrCompare("MyExpectedName", "@JOBNAME")<br/>
    See the action help for details.<br/><br/><br/>


    <b>*** Deprecated Help Description ***</b><br/>
    This action will compare the provided job name with the name of the currently running job.  This can
    be useful, if you wish to perform actions based on different job names.  The comparison is case sensitive.
    <e>
      <b>Is_JobName("Demo-Multipage TIFF")</b><br/>
      PageIDByVariableChange("ScanSrcPath,Main_Page,Trailing_Page")
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    <b>True,</b> if the current job matches the provided name.  Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="Is_JobNamePrefix"  >
  <ap>
    The prefix you are expecting for the current job.
  </ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.
    Instead, use the rrCompareCaseLength or rrCompareNotCaseLength action in the rrunner action library
    with the @JOBNAME smart parameter.<br/><br/>
    For example: rrCompareCaseLength("Main","@JOBNAME", "False", 4, "True")<br/><br/>

    <b>*** Deprecated Help Description ***</b><br/>
    Tests the left most portion of the job name to see if it matches the provided prefix.  The comparison
    is case sensitive.
    <e>     
      <b>Is_JobNamePrefix("Test")</b><br/><br/>
      
      If the current job name is "TestRecognition", the action will return True.
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    <b>True,</b> if the left most portion matches.  Otherwise, False.
  </ret>
</ref>
  
<ref id="SaveObjectVariable"  >  
  <h>
    This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrSet in rrunner.
    <e>
      rrSet("Normal","@P.RecogType")<br/>
      Is_JobName("Demo-Dot Matrix") <br/>     
      rrSet("s_fg","7")<br/>
      rrSet("s_ml","3")<br/>
      rrSet("Dot_Matrix","@P.RecogType")<br/>
      rrCompare("Normal","@P.RecogType")
    </e>
  </h>
</ref>
  
<ref id="ReadFPXMLZones"  >
  <ap>
    Comma separated parameters:<br/>
    1. The fingerprint directory.  Smart parameters are supported.<br/>
    2. A comma separated list of the detail lines.
  </ap>  
  <h>
    This action reads the zones from the FPXML into the objects for the page and stores the specified 
    fileds so that when it creates detail lines it knows the positions of the detail line's fields.
    <e>
      <b>ReadFPXMLZones("@APPPATH(fingerprint),details,lineid,itemdesc,qty,price,linetotal")</b><br/>
      rrSet("FPXML","@P.ZoneRead")<br/>
      IsMultipageDocument()<br/>
      SetEOL("|")
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level or if the FPXML does not exist.  Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="FPXMLUsed"  >
  <ap>None.</ap>
  <h>
    This action indicates if FPXML format fingerprint files are being used.  Call this action if you are
    using fingerprints from FPXML with Invoice.rrx.    
    <e>
      <b>FPXMLUsed()</b><br/>
      ZoneBOTTOM_ImageBottom()<br/>
      ScanDetails()
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True,</b> if a FPXML fingerprint file exist for the current page object.  Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="SwitchMMDD"  qi="">
  <ap>
    A list of separators.
  </ap>
  <h>
    This action is intended to switch US Month and Day date values.  It will swap the first two characters
    of the field value with the two characters following the separator.
    <e>
      <b>SwitchMMDD("/")</b><br/><br/>
      
      In this example, the value "03/09/10" becomes "09/03/10".
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True,</b> if two separators are found and the separators are swapped.  Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="ValidateVendor"  >
  <ap>
    The connection string to the lookup database.  Smart Parameters are supported.
  </ap>
  <h>
    Checks to see if the current vendor, vendor number and zip code exist on the same record in the lookup database.
    The fields that are validated are: Vendor, Vendor_Number and Remittance_Zip.
    <e>
      SetIsOverrideable("False")<br/>
      <b>ValidateVendor("@APPVAR(*/lookupdb:cs)")</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False,</b> if the connection cannot be opened or if the settings file cannot be found.<br/>
    <b>False,</b> if these fields cannot be found: Vendor, Vendor_Number or Remittance_Zip.<br/>
    <b>False,</b> if the vendor cannot be found in the database.<br/>
    Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="FindExportImage"  >
  <ap>
    One of the following values:<br/> 
    1. Document Level TIFF.<br/>
    2. Document Level PDF.<br/>
    3. Page Level TIO.<br/>
    4. Page Level TIF.
  </ap>
  <h>
    This action searches the batch directory for a file that corresponds to the current page that contains the current
    field.  The file extension must match the extension specified with the input parameter.
    <e>
      <b>FindExportImage("1")</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level or if the input parameter is invalid.
    <b>True,</b> if the correctly named file of with the specified extension exists in the batch directory.
  </ret>
</ref>
  
<ref id="SwapImages"  >
  <ap>
    Two extensions:<br/>
    1. The extension to be saved as TIF.<br/>
    2. The extension that current tif is saved as.
  </ap>
  <h>
    This action interchanges the TIF for the current page with another TIF that has the same file name but
    a different extension.  One possible use is if you had a backup of the TIF and need to restore it.
    The current TIF will be named with the new extension while the other named TIF, is renamed to have a TIF extension.
    <e>
      <b>SwapImages("TIO,TIB")</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level, if the wrong number of parameters are specified,
    or if the original file cannot be found.
    <b>True,</b> if the file extensions are interchanged.
  </ret>
</ref>
  
<ref id="AlterDatebyDay"  >
  <ap>
    The number of days to add.
  </ap>
  <h>
    This action will add the specified number of days to the date contained in the current field.  The original character
    confidence is not changed.  
    <e>
      <b>AlterDatebyDay("7")</b><br/><br/>

      This example adds one week to the date contained in the field.  If the date crosses
      over a month or year boundary, they will be adjusted appropriately.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level or if the input is not numeric.  Otherwise, <b>True.</b>
  </ret>
</ref>
    
<ref id="SetToDocIDMPTIFF"  >
  <ap>
    The path to the exported tiff files.
  </ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.  Instead, use the rruner action library.
    Use rrSet with smart parameters.  For example: <br/><br/>

    rrSet("@APPPATH(export)+\+@ID+.tif","@F\FieldName.text")<br/>
    See the action help for details.<br/><br/><br/>


    <b>*** Deprecated Help Description ***</b><br/>

    This action builds a full path to the a tiff file and sets the field text to this value.
    The path consists of the export path + DOCID + .TIF.
    The value is put into the field
    so it can be access later in the application, if necessary.  It only builds the path.
    The action does not output the TIF file.
    <e>
      <b>SetToDocIDMPTIFF("@APPPATH(export)")</b>
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="CheckFreeDiskSpace"  >
  <ap>
    Two comma separated parameters:<br/>
    1. The path to ini file that contains the 'LowDiskSpaceThreshold' setting.<br/>
    2. The letter drive of the drive to check (letter drive must be accompanied by a colon, i.e C:).    
  </ap>
  <h>
    Reads the 'LowDiskSpaceThreshold' setting from the [Notifications] section of the ini file specified in the first parameter.  If the
    available disk space is lower than the value specified in the INI file, then a notification will be created in the INI file. The notification is created under the [Notifications] section of the ini file, under the "LowDiskNotificationSent" setting. This setting will be set to "Yes".
    If the 'LowDiskSpaceThreashold' is missing from the INI file, the default value of 3000 bytes will be used.
    If a notification has been previously created, and the disk space has been increased since the last time the action ran, then the notification will be removed from the ini file (LowDiskNotificationSent will be set to "No")
    <e>
      <b>CheckFreeDiskSpace("C:\Datacap\APT\dco_APT\settings.ini,C:")</b><br/><br/>
      Scan()<br/>
    </e>
  </h>
  <lvl>Batch level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level, if parameters are missing or if the settings.ini file cannot be found.
    Otherwise, <b>True.</b>
  </ret>
</ref>
     
  
<ref id="CheckAndFixDecimal"  >
  <ap>None.</ap>
  <h>
    Replaces the space or , with .
    This can be used to fix errors where the decimal is not recognized and leaves a blank in that area, 
    also this can be used for conversion for European numbers that use a comma to separate dollars from cents
    so $100,00 becomes $100.00 or $100 00 becomes $100.00.
    <e>
      CheckAndFixDecimal()<br/>
      Is_InCharSet("0123456789.,-$")<br/>
      AllowOnlyChars("0123456789.-")<br/>
      IsFieldCurrency()
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="MovePDF"  >
  <ap>
    The target directory for the PDF.  Smart Parameters are supported.
  </ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.  Instead, use the FileIO action library.
    Use RenameFile to move the file using smart parameters.  For example: <br/><br/>

    RenameFile("@DCO(BATCHDIR)+\+MyFile.pdf","@APPPATH(export)+\+MyFile.pdf",true)<br/>
    See the action help for details.<br/><br/><br/>


    <b>*** Deprecated Help Description ***</b><br/>

    This action copies the PDF associated with the current DCO document to the specified directory. The PDF document name must match the name/ID of the current DCO document for the copy to take place.
    <e>
      <b>MovePDF("@APPPATH(export)")</b>
    </e>
  </h>
  <lvl>Document level.</lvl>
  <ret>
    <b>False,</b> if the document cannot be found, if the source file does not exist or if the target file does exist.
    Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="AllMixedCase"  >
  <ap>None.</ap>
  <h>
    This action will change the value of the current field to be Title case.  The first letter of
    each word will be capitalized.
    <e>
      <b>AllMixedCase()</b><br/><br/>
      
      If the field in this example is "hello, i MUST be going.", the text will be changed to "Hello, I Must Be Going."
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="CaptureOpInfo"  >
  <ap>
    An optional prefix to the variable name.
  </ap>
  <h>
    This action will capture the Operator, Station ID and current time and place them into variables.  The variables will be
    named based on the provided variable prefix, like this: "prefix Operator", "prefix Station" and "prefix Time". If a prefix is not provided, the task name is used as the prefix by default.
    <e>
      Status_Preserve_OFF()<br/>
      ClearErrorMsg()<br/>
      <b>CaptureOpInfo("Production")</b><br/>
      rrCompare("@P\Routing_Instructions","None")<br/><br/>
      
      In this example, the variables created will be "Production Operator", "Production Station" and "Production Time".
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="GenerateDetails"  >
  <ap>None.</ap>
  <h>
    This action sets up a field in APT and puts a detail subfield on every page.  This extra detail subfield
    appears on all pages of a multi-page invoice, allowing every page to be viewed.    
    <e>
      <b>GenerateDetails()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False,</b> if called on the wrong level.  Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="IsCurrentObjValue"  >
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by rrCompare in rrunner.<br/>
    Use the @VALUE parameter to access the 'Text' variable of the current object and provide the comparison text string.
    <e>
      <b>rrCompare("@VALUE","Yes")</b><br/>  
      SetPageStatus("75")<br/>
      SetDocStatus("128")
    </e>
  </h>
</ref>
  
<ref id="IncrementBatchVar"  >
  <ap>
    The name of the variable to increment.
  </ap>
  <h>
    This action increments a batch level variable by 1.  If the variable does not already exist, it will be created.
    If the variable exists but the value is not numeric, the variable will be set to 1.
    <e>
      <b>rrCompareNot("@P.RecogStatus","1")</b><br/>
      SetDocStatus("128")<br/>
      IncrementBatchVar("Recog - Deleted Document")
    </e>
  </h>
  <lvl>Any level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="SendOutlookNotification"  >
  <ap>
    The extension of the attachment.  The attachment is expected to be named the same as the current document ID.
  </ap>
  <h>
    This action uses outlook to send a notification to specified e-mail addresses.  The message within the email
    is determined by previous calls to actions that have set notification, such as CheckFreeDiskSpace.<br/><br/>
    
    Note that this action has some requirements such as Outlook installed on the machine and logged
    in with an ID that has appropriate permissions to send emails.
    <e>
      <b>SendOutlookNotification(".pdf")</b>
    </e>
  </h>
  <lvl>Document level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level, if the connection to Outlook could not be established,
    or if email addresses could not be found in Settings.ini.
  </ret>
  <see>
    CheckFreeDiskSpace
  </see>
</ref>
  
<ref id="UpdateFPStats"  >
  <ap>None.</ap>
  <h>
    This action updates the fingerprint statistics in the fingerprint database.    
    It keeps track of the last accessed fingerprint and the number of times a fingerprint is accessed.
    <e>
      <b>UpdateFPStats()</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False,</b> if called at the wrong level or if the fingerprint does not exist.
    Otherwise, <b>True.</b>
  </ret>
</ref></help>


</rrx>
<rrx namespace="IOverlay" src="c:\datacap\RRS\IOverlay.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<af name="Overlay" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'Combines the current image with the image file specified by the SetBackgroundImage action into ]]>
<![CDATA[
]]>
<![CDATA[  'a new image replacing the current image.  This action is used to reinstate a form background ]]>
<![CDATA[
]]>
<![CDATA[  'that was 'dropped out' during scanning.]]>
<![CDATA[
]]>
<![CDATA[  ' Note: The parameter of the preceding <b>SetBackgroundImage</b>action can be a smart parameter that]]>
<![CDATA[
]]>
<![CDATA[  '  locates a <b>paths.ini</b>file in the same folder that contains the application's Document Hierarchy file.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim sOverlay]]>
<![CDATA[
]]>
<![CDATA[  Dim X, Y, rtn]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Overlay = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then ]]>
<![CDATA[
]]>
<![CDATA[     'CurrentObj must be a dco page]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Overlay: object is not a page.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Look for field 'Image_Offset']]>
<![CDATA[
]]>
<![CDATA[  writelog("Looking for Image_Offset field.")]]>
<![CDATA[
]]>
<![CDATA[	Set fldImgOvr = CurrentObj.FindChild( "Image_Offset" )]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'If Image_Offset field is not found look for field 'IMAGEOVERLAYOFFSET']]>
<![CDATA[
]]>
<![CDATA[  If (fldImgOvr Is Nothing) Then ]]>
<![CDATA[
]]>
<![CDATA[     writelog("Looking for IMAGEOVERLAYOFFSET field.") ]]>
<![CDATA[
]]>
<![CDATA[     Set fldImgOvr = CurrentObj.FindChild("IMAGEOVERLAYOFFSET")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Check that one of the fields was returned]]>
<![CDATA[
]]>
<![CDATA[	If (fldImgOvr Is Nothing) Then ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Couldn't find the image offset field...")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Image to Overlay:'" & CurrentObj.ImageName & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	rtn = -1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Get the value and filter for spaces and semi-colon (autofld.dll puts a semi-colon at the end of the field value)]]>
<![CDATA[
]]>
<![CDATA[  sOverlay = Trim(fldImgOvr.Text)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If (sOverlay = "") or (sOverlay = ";") Then]]>
<![CDATA[
]]>
<![CDATA[    writelog("Looking for Image_Offset page variable")]]>
<![CDATA[
]]>
<![CDATA[    sOverlay = CurrentObj.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sOverlay = Trim(Replace(sOverlay,";",""))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If (sOverlay <> "") Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Overlay field value:" & sOverlay)]]>
<![CDATA[
]]>
<![CDATA[			aXY = Split(sOverlay, ",")]]>
<![CDATA[
]]>
<![CDATA[			X = CLng(aXY(0))]]>
<![CDATA[
]]>
<![CDATA[			Y = CLng(aXY(1)) ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("X: " & X & "; Y: " & Y)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[			rtn = g_oImageOverlay.Overlay(CurrentObj.ImageName, X, Y) ]]>
<![CDATA[
]]>
<![CDATA[			CatchOverlayError("")]]>
<![CDATA[
]]>
<![CDATA[  else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("no overlay offset info found.")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If(rtn = 0) Then ]]>
<![CDATA[
]]>
<![CDATA[			If X < 0 Then X = 0]]>
<![CDATA[
]]>
<![CDATA[			If Y < 0 Then Y = 0]]>
<![CDATA[
]]>
<![CDATA[			Call ov_ZoneChildren(CurrentObj, 0, X, Y)]]>
<![CDATA[
]]>
<![CDATA[			Overlay = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetBackgroundImage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Designates the Image file that will overlay the current page's image."]]>
<![CDATA[
]]>
<![CDATA[  'Full path to the overlay Image file.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetBackgroundImage = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=""]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    strParam=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter parsing. Using original parameter '" & strparam & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Check for valid path from parameter]]>
<![CDATA[
]]>
<![CDATA[  If IsAlive(FileMgr) Then]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    If Not FileMgr.FileExists(strParam) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("File not found:'" & strParam & "'")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("File '" & strParam & "' exists.")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  g_oImageOverlay.BackgroundImage = StrParam]]>
<![CDATA[
]]>
<![CDATA[	CatchOverlayError("")]]>
<![CDATA[
]]>
<![CDATA[	SetBackgroundImage = True ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="SetHaloBackground" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Enables or disables a halo of white pixels around any black pixels from the current ]]>
<![CDATA[
]]>
<![CDATA[  'image where they would otherwise touch pixels from the background. This makes the foreground information easier to read."]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'String value to enable a halo ("<b>True</b>") or prevent a halo ("<b>False</b>").</ap>	]]>
<![CDATA[
]]>
<![CDATA[	'<h>Enables or disables a halo of white pixels around any black pixels from the current image ]]>
<![CDATA[
]]>
<![CDATA[  ' where they would otherwise touch pixels from the background.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetHaloBackgroung = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If (StrParam = "true") Then]]>
<![CDATA[
]]>
<![CDATA[		g_oImageOverlay.HaloBackground = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		g_oImageOverlay.HaloBackground = False]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	SetHaloBackground = True ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="SetDitheringBackground" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'String value to enable dithering ("<b>True</b>") or disable dithering ("<b>False</b>").</ap>]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetDitheringBackground= False]]>
<![CDATA[
]]>
<![CDATA[	StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If (StrParam = "true") Then]]>
<![CDATA[
]]>
<![CDATA[		g_oImageOverlay.DitheringBackground = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		g_oImageOverlay.DitheringBackground = False]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	SetDitheringBackground= True]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************************
' IOverlay.rrx - Image Overlay Actions
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2013 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'************************************************************************
]]>

<ref id="Overlay" access="public" bInter="bInter" bDebug="bDebug" qi="Combines the current image with the image file specified by the SetBackgroundImage action into a new image replacing the current image.  This action is used to reinstate a form background that was 'dropped out' during scanning.">
	<ap>None.<br/>
    <br/>
    <b>Note:</b> 1) The parameter of the preceding <b>SetBackgroundImage</b> action can be a smart parameter that
    locates a file.<br/>
    2) Looks for a field type called <b>Image_Offset</b> or <b>IMAGEOVERLAYOFFSET</b> containing a comma separated 
    value containing the ammount of X and Y pixel offset for the overlay image. These fields are automatically generated 
    by running <b>FindFingerprint</b>, <b>CalculateOffset</b>, <b>WordFind_Offset</b>, <b>CalculateLocalOffset</b>, <b>Autofield()</b>, and
    most of the <b>PatternMatch.rrx</b> actions.
    <br/><br/>
  </ap>
	<h>
    <e>
      SetBackgroundImage(c:\ParentDir\mclaims\process\hcfa\hcfa.tif)<br/>
      <b>Overlay()</b><br/><br/>
      
      In this example, the <b>Overlay</b> action uses the file name and path in the parameter of 
      the <b>SetBackgroundImage</b> action to locate the Background Image file.
      
      SetBackgroundImage((@APPPATH(formdir)+\+ub04.tif)<br/>
      <b>Overlay(</b>)<br/><br/>
      
      Here, the <b>SetBackgroundImage</b> action uses a smart parameter to load the file name with
      the directory path coming from the application service. 

	    <b><i>Alert!</i></b><b> SetBackgroundImage</b> must be called before <b>Overlay</b>. Other actions 
      such as <b>SetHaloBackground</b> and <b>SetDithering</b> are optional and, if used, should precede 
      the call to the <b>Overlay</b> action.
		</e>
	</h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the action is not applied to a <b>Page</b> object; if it cannot locate
    the Background Image file; or if the action encounters an error of a different kind.
    Otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="SetBackgroundImage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Designates the Image file that will overlay the current page's image.">
	<ap>Full path to the overlay Image file.</ap>
	<h>Designates the Image file that will overlay the current page's image. Smart Parameters supported.
		<e><b>SetBackgroundImage(c:\ParentDir\mclaims\process\hcfa\hcfat.tif)</b><br/>
		<scr>SetDitheringBackground(True)</scr><br/>
		<scr>SetHaloBackground(True)</scr><br/>
		<scr>Overlay()</scr> 
		</e>
	</h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if image does not exist, otherwise <b>True.</b>
  </ret>

</ref>
	
<ref id="SetHaloBackground" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Enables or disables a halo of white pixels around any black pixels from the current image where they would otherwise touch pixels from the background. This makes the foreground information easier to read.">
	<ap>String value to enable a halo ("<b>True</b>") or prevent a halo ("<b>False</b>").</ap>	
	<h>Enables or disables a halo of white pixels around any black pixels from the current image 
   where they would otherwise touch pixels from the background.<br/><br/>

	This makes the foreground information easier to read.
		<e><scr>SetBackgroundImage(c:\ParentDir\mclaims\process\hcfa\hcfat.tif)</scr><br/>
      <scr>SetDitheringBackground(True)</scr><br/>
      <b>SetHaloBackground(True)</b><br/>
      <scr>Overlay()</scr> 
		</e>
	</h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
	
<ref id="SetDitheringBackground" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<ap>String value to enable dithering ("<b>True</b>") or disable dithering ("<b>False</b>").</ap>
	<lvl>All.</lvl>
	<ret>Always <b>True.</b></ret>
	<h>Enables or disables dithering of the background image.<br/><br/>

     Dithering will make the background image appear lighter than the current image's information so that 
     visually it appears less prominent. 
     <e><scr>SetBackgroundImage(c:\ParentDir\mclaims\process\hcfa\hcfat.tif)</scr><br/>
       <b>SetDitheringBackground(True)</b><br/>
       <scr>SetHaloBackground(True)</scr><br/>
       <scr>Overlay()</scr> 
     </e>
	</h>
</ref>
</help>
</rrx>
<rrx namespace="Locate" src="c:\datacap\RRS\Locate.dll">

<i ref="rrunner">
</i>
<i ref="recog_shared">
</i>
<g>
</g>
<g>
</g>
<g>
</g>
<f name="AddKeyList" access="public">
	<p name="KeyName">
	</p>
	<p name="KeyWord_01">
	</p>
	<p name="KeyWord_02">
	</p>
	<p name="KeyWord_03">
	</p>
	<p name="KeyWord_04">
	</p>
	<p name="KeyWord_05">
	</p>
	<p name="KeyWord_06">
	</p>
	<p name="KeyWord_07">
	</p>
	<p name="KeyWord_08">
	</p>
	<p name="KeyWord_09">
	</p>
	<p name="KeyWord_10">
	</p>
	<p name="KeyWord_11">
	</p>
	<p name="KeyWord_12">
	</p>
	<p name="KeyWord_13">
	</p>
	<p name="KeyWord_14">
	</p>
	<p name="KeyWord_15">
	</p>
	<p name="KeyWord_16">
	</p>
	<p name="KeyWord_17">
	</p>
	<p name="KeyWord_18">
	</p>
	<p name="KeyWord_19">
	</p>
	<p name="KeyWord_20">
	</p>
	<p name="KeyWord_21">
	</p>
	<p name="KeyWord_22">
	</p>
	<p name="KeyWord_23">
	</p>
	<p name="KeyWord_24">
	</p>
	<p name="KeyWord_25">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    ' Adds list to dictionary ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    Dim sExtn]]>
<![CDATA[
]]>
<![CDATA[    Dim nExtnPos]]>
<![CDATA[
]]>
<![CDATA[    Dim sKeyNameExtn]]>
<![CDATA[
]]>
<![CDATA[    Dim sListTest]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    AddKeyList=TRUE    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    sExtn = ".key"]]>
<![CDATA[
]]>
<![CDATA[    nExtnPos = InStrRev(KeyName,sExtn,vbTextCompare)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    'Add the '.key' extension for file i/o compatibility]]>
<![CDATA[
]]>
<![CDATA[    If nExtnPos>5 or nExtnPos<=0 then sKeyNameExtn = KeyName & sExtn]]>
<![CDATA[
]]>
<![CDATA[ 		    ]]>
<![CDATA[
]]>
<![CDATA[    If dictKEYFILES.Exists(KeyName) or dictKEYFILES.Exists(KeyNameExtn) then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Key '" & KeyName & "' already exists in Dictionary. Returning True.")   ]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    sList = KeyWord_01 & vbcrlf & KeyWord_02 & vbcrlf & KeyWord_03 & vbcrlf & KeyWord_04 & vbcrlf & KeyWord_05 & vbcrlf & _ ]]>
<![CDATA[
]]>
<![CDATA[            KeyWord_06 & vbcrlf & KeyWord_07 & vbcrlf & KeyWord_08 & vbcrlf & KeyWord_09 & vbcrlf & KeyWord_10 & vbcrlf & _]]>
<![CDATA[
]]>
<![CDATA[            KeyWord_11 & vbcrlf & KeyWord_12 & vbcrlf & KeyWord_13 & vbcrlf & KeyWord_14 & vbcrlf & KeyWord_15 & vbcrlf & _]]>
<![CDATA[
]]>
<![CDATA[            KeyWord_16 & vbcrlf & KeyWord_17 & vbcrlf & KeyWord_18 & vbcrlf & KeyWord_19 & vbcrlf & KeyWord_20 & vbcrlf & _]]>
<![CDATA[
]]>
<![CDATA[            KeyWord_21 & vbcrlf & KeyWord_22 & vbcrlf & KeyWord_23 & vbcrlf & KeyWord_24 & vbcrlf & KeyWord_25 & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    sListTest = sList]]>
<![CDATA[
]]>
<![CDATA[    sListTest = replace(sListTest,vbcrlf,"")]]>
<![CDATA[
]]>
<![CDATA[    sListTest = replace(sListTest,Space(1),"")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If len(sListTest)=0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Empty List '" & KeyName & "' not added to Key List dictionary. Returning False.")]]>
<![CDATA[
]]>
<![CDATA[      AddKeyList=False]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Call dictKEYFILES.Add(sKeyNameExtn, sList)]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Added " & KeyName & " file to Key List dictionary.")]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<af name="SetKeyFileEncodingAsUnicode" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   Determines if a key file uses ANSI or Unicode encoding.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	if UCase(StrParam) = "TRUE" Then]]>
<![CDATA[
]]>
<![CDATA[     gKeyFileEncoding = True]]>
<![CDATA[
]]>
<![CDATA[     writelog("Param: '" & StrParam & "'  Setting to Unicode key file mode")]]>
<![CDATA[
]]>
<![CDATA[  else]]>
<![CDATA[
]]>
<![CDATA[     gKeyFileEncoding = false]]>
<![CDATA[
]]>
<![CDATA[     writelog("Param: '" & StrParam & "'  Setting to ANSI key file mode")]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetKeyFileAsEncoding = True	]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function SetKeyFileEncoding")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="WordFind" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   A word or phrase to find on the page.]]>
<![CDATA[
]]>
<![CDATA[ ']]>
<![CDATA[
]]>
<![CDATA[ '   The current page be searched to find the word or phrase.  The location of the first]]>
<![CDATA[
]]>
<![CDATA[ '   word or phrase that matches the parameter will be remembered so it can be]]>
<![CDATA[
]]>
<![CDATA[ '   utilized by subsequent actions.  Word matching is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[ '   To improve matching,]]>
<![CDATA[
]]>
<![CDATA[ '   this action automatically adjusts the search criteria to allow for]]>
<![CDATA[
]]>
<![CDATA[ '   common character substitutions.  For example, if the list includes]]>
<![CDATA[
]]>
<![CDATA[ '   "will" and the recognition read "wi11", a match will still occur.]]>
<![CDATA[
]]>
<![CDATA[ '   Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim L,R,T,B]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  WordFind=False]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  strKey = RegExBuild(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[  WordFind = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function WordFind")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="SelectParentBlock" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   ' Moves the block "zone" area to the area defined by the parent block. ]]>
<![CDATA[
]]>
<![CDATA[   ' The currently selected word is not changed because it is contained in the parent block.]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[	 SelectParentBlock = False]]>
<![CDATA[
]]>
<![CDATA[	 if (not LoadDocStructurePage) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	 SelectParentBlock = g_DLayout.SelectParentBlock]]>
<![CDATA[
]]>
<![CDATA[   if (SelectParentBlock) Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Parent block is now the current area of interest for block actions.")]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Parent block was not selected.")]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[	 Call ErrorHandler("Function SelectParentBlock")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<f name="IsSelectedBlockType" access="public">
	<p name="StrParam">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[    	]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    IsSelectedBlockType = False]]>
<![CDATA[
]]>
<![CDATA[    if (not LoadDocStructurePage) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    Dim blockType]]>
<![CDATA[
]]>
<![CDATA[    blockType = g_DLayout.GetCurrentBlockType()    ]]>
<![CDATA[
]]>
<![CDATA[    if (lcase(blockType) = lcase(StrParam)) Then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Currently selected block: '" & blockType & "' matches '" & StrParam & "'")]]>
<![CDATA[
]]>
<![CDATA[       IsSelectedBlockType = True]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Currently selected block: '" & blockType & "' does not match '" & StrParam & "'")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Call ErrorHandler("Function IsSelectedBlockType")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<f name="GetSelectedBlockType" access="public">
	<p name="varTarget">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[  	]]>
<![CDATA[
]]>
<![CDATA[	Dim sDestination]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  GetSelectedBlockType = false]]>
<![CDATA[
]]>
<![CDATA[  if (not LoadDocStructurePage) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim blockType]]>
<![CDATA[
]]>
<![CDATA[  blockType = g_DLayout.GetCurrentBlockType()    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GetSelectedBlockType = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sDestination = Trim(varTarget)]]>
<![CDATA[
]]>
<![CDATA[	If len(sDestination) = 0 Then sDestination = DCONavType()	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	GetSelectedBlockType = DCONavSetValue(sDestination,blockType)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("GetSelectedBlockType") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<f name="SelectParentBlockType" access="public">
	<p name="selectType">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[    	]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    SelectParentBlockType = False]]>
<![CDATA[
]]>
<![CDATA[    if (not LoadDocStructurePage) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    selectType = MetaWord(selectType)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    SelectParentBlockType = g_DLayout.SelectParentBlockType(selectType)]]>
<![CDATA[
]]>
<![CDATA[    if (SelectParentBlockType) Then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Found block : '" & selectType & "'")       ]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Could not find block : '" & selectType & "'")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Call ErrorHandler("Function SelectParentBlockType")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<f name="SelectParentBlockOuterType" access="public">
	<p name="selectType">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[    	]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    SelectParentBlockOuterType = False]]>
<![CDATA[
]]>
<![CDATA[    if (not LoadDocStructurePage) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    selectType = MetaWord(selectType)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    SelectParentBlockOuterType = g_DLayout.SelectParentBlockOuterType(selectType)    ]]>
<![CDATA[
]]>
<![CDATA[    if (SelectParentBlockOuterType) Then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Found block : '" & selectType & "'")       ]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Could not find block : '" & selectType & "'")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Call ErrorHandler("Function SelectParentBlockOuterType")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="GoSiblingBlockNext" access="public">
	<p name="count">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ' Moves to the next sibling block.  Because the current word cannot exist in the ]]>
<![CDATA[
]]>
<![CDATA[  ' sibling block, the currently select word is changed to the first word in the sibling.]]>
<![CDATA[
]]>
<![CDATA[  ' For example, if the current block is a line, the next line becomes the current block]]>
<![CDATA[
]]>
<![CDATA[  ' and the current word becomes the first word block found within the line block.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  Dim sWordPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim sWordText]]>
<![CDATA[
]]>
<![CDATA[	GoSiblingBlockNext = False]]>
<![CDATA[
]]>
<![CDATA[	if (not LoadDocStructurePage) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  count = trim(MetaWord(count))]]>
<![CDATA[
]]>
<![CDATA[  If Not IsNumeric(count) Then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("The parameter '" & count & "' is not numeric.  Current block has not changed.")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	GoSiblingBlockNext = g_DLayout.GoSiblingBlockNext(CInt(count))]]>
<![CDATA[
]]>
<![CDATA[  if (GoSiblingBlockNext = False) Then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Could not go to next sibling block.  Position not changed.")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' The current word will have changed, need to update the DCO with that new word position.]]>
<![CDATA[
]]>
<![CDATA[  sWordPosition = g_DLayout.GetCurrentWordPosition]]>
<![CDATA[
]]>
<![CDATA[  sWordText = g_DLayout.GetCurrentWordText]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("New selected word = " & sWordText & " pos = " & sWordPosition)    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0) 'Assume start of CCD and we will find the first word in the block.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  bResult = KeySearch(sWordText, sWordPosition, 1) ]]>
<![CDATA[
]]>
<![CDATA[  if (bResult) Then]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Positioned CCO word: " & sWordText)]]>
<![CDATA[
]]>
<![CDATA[  else]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Could not find word: '" & sWordText & "' in pos: " & sWordPosition) ' if this happens then cco != document structure.]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  GoSiblingBlockNext = bResult]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoSiblingBlockNext")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<f name="GoSiblingBlockPrevious" access="public">
	<p name="count">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ' Moves to the previous sibling block.  Because the current word cannot exist in the ]]>
<![CDATA[
]]>
<![CDATA[  ' sibling block, the currently select word is changed to the first word in the sibling.]]>
<![CDATA[
]]>
<![CDATA[  ' For example, if the current block is a line, the previous line becomes the current block]]>
<![CDATA[
]]>
<![CDATA[  ' and the current word becomes the first word block found within the line block.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  Dim sWordPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim sWordText]]>
<![CDATA[
]]>
<![CDATA[	GoSiblingBlockPrevious = False]]>
<![CDATA[
]]>
<![CDATA[	if (not LoadDocStructurePage) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  count = trim(MetaWord(count))]]>
<![CDATA[
]]>
<![CDATA[  If Not IsNumeric(count) Then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("The parameter '" & count & "' is not numeric.  Current block has not changed.")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	GoSiblingBlockPrevious = g_DLayout.GoSiblingBlockPrevious(CInt(count))]]>
<![CDATA[
]]>
<![CDATA[  if (GoSiblingBlockPrevious = False) Then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Could not go to previous sibling block.  Position not changed.")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' The current word will have changed, need to update the DCO with that new word position.]]>
<![CDATA[
]]>
<![CDATA[  sWordPosition = g_DLayout.GetCurrentWordPosition]]>
<![CDATA[
]]>
<![CDATA[  sWordText = g_DLayout.GetCurrentWordText]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("New selected word = " & sWordText & " pos = " & sWordPosition)    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0) 'Assume start of CCD and we will find the first word in the block.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  GoSiblingBlockPrevious = KeySearch(sWordText, sWordPosition, 1) ]]>
<![CDATA[
]]>
<![CDATA[  if (GoSiblingBlockPrevious) Then]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Positioned CCO word: " & sWordText)]]>
<![CDATA[
]]>
<![CDATA[  else]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Could not find word: '" & sWordText & "' in pos: " & sWordPosition) ' if this happens then cco != document structure.]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoSiblingBlockNext")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<af name="UpdateFieldWithBlock" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ' Updates the field zone coordinates with the coordinates of the currently selected block.]]>
<![CDATA[
]]>
<![CDATA[  UpdateFieldWithBlock = false]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim L1,W1,L2,W2]]>
<![CDATA[
]]>
<![CDATA[	Dim v_left,v_top,v_right,v_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim v1_left,v1_top,v1_right,v1_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim v2_left,v2_top,v2_right,v2_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue, sConfidence]]>
<![CDATA[
]]>
<![CDATA[	Dim Wx,Lx,Cx]]>
<![CDATA[
]]>
<![CDATA[	Dim Cleft ,Ctop ,Cright ,Cbottom]]>
<![CDATA[
]]>
<![CDATA[	Dim sEOL,n]]>
<![CDATA[
]]>
<![CDATA[	Dim Wxstart,Wxend]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim aSplit]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType <> 3) Then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action must be called at field level. Exiting")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function	'must be a page or a field]]>
<![CDATA[
]]>
<![CDATA[  End if  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if (not LoadDocStructurePage) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sEOL=Space(1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sPosition = g_DLayout.GetCurrentBlockPosition()]]>
<![CDATA[
]]>
<![CDATA[  aSplit = Split(sPosition & ",",",")]]>
<![CDATA[
]]>
<![CDATA[  v1_left = CLng(aSplit(0))]]>
<![CDATA[
]]>
<![CDATA[  v1_top = CLng(aSplit(1))]]>
<![CDATA[
]]>
<![CDATA[  v1_right = CLng(aSplit(2))]]>
<![CDATA[
]]>
<![CDATA[  v1_bottom = CLng(aSplit(3))]]>
<![CDATA[
]]>
<![CDATA[  ' Writelog("L=" &  v1_left & ", T=" & v1_top & ", R=" & v1_right & ", B=" & v1_bottom)]]>
<![CDATA[
]]>
<![CDATA[	If v1_left=0 and v1_top=0 and v1_right=0 and v1_bottom=0 then]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Position information found. Exiting Action")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Expand Zone for viewability - check image border boundries]]>
<![CDATA[
]]>
<![CDATA[	v1_left = v1_left-2]]>
<![CDATA[
]]>
<![CDATA[	If v1_left<0 then v1_left=0]]>
<![CDATA[
]]>
<![CDATA[	v1_top = v1_top-2]]>
<![CDATA[
]]>
<![CDATA[	If v1_top<0 then v1_top=0]]>
<![CDATA[
]]>
<![CDATA[	v1_right = v1_right+2]]>
<![CDATA[
]]>
<![CDATA[	If v1_right>CCO.Right then v1_right=CCO.Right]]>
<![CDATA[
]]>
<![CDATA[	v1_bottom = v1_bottom+2]]>
<![CDATA[
]]>
<![CDATA[	If v1_bottom>CCO.bottom then v1_right=CCO.bottom ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text=""]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(v1_left-2, v1_top-2, v1_right+2, v1_bottom+2)]]>
<![CDATA[
]]>
<![CDATA[  writelog("Zone set to: " & v1_left-2 & ", " & v1_top-2 & ", " & v1_right+2 & ", " & v1_bottom+2)	]]>
<![CDATA[
]]>
<![CDATA[  'writelog("Zone set to: " & CurrentObj.Variable("Position"))	]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[	Dim oCCO]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- SnapCCO2DCO for: " & CurrentObj.ID & " -----")]]>
<![CDATA[
]]>
<![CDATA[	goSnapper.SnapCCOtoDCO CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  Set oCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[     	 ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(3) & "UpdateField    Value Found: '" & CurrentObj.Text & "'    Confidence: '" & CurrentObj.ConfidenceString & "' ")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(logwindow) Then]]>
<![CDATA[
]]>
<![CDATA[		Call ShowCurrPosFromCCO()]]>
<![CDATA[
]]>
<![CDATA[	 	ValueUP.Text = CurrentObj.Text				]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	UpdateFieldWithBlock = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function UpdateFieldWithBlock")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="RegExFindNext_InBlock" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ '   A word or phrase to find in the current field.  The parameter is expected to be]]>
<![CDATA[
]]>
<![CDATA[ '   a Regular Expression.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   Starting from the location of a previously found word, this action locates the first]]>
<![CDATA[
]]>
<![CDATA[ '   occurrence of a word or phrase in the current field where the input search term]]>
<![CDATA[
]]>
<![CDATA[ '   is specified as a regular expression.]]>
<![CDATA[
]]>
<![CDATA[ '   The search is started from the location of a previously found word in the currently selected block "zone".]]>
<![CDATA[
]]>
<![CDATA[ '   Any field coordinates are ignored.]]>
<![CDATA[
]]>
<![CDATA[ '   The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	    ]]>
<![CDATA[
]]>
<![CDATA[	RegExFindNext_InBlock = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Check for Page or Field level.  Not sure about Document level yet.]]>
<![CDATA[
]]>
<![CDATA[  If ((CurrentObj.ObjectType <> 2) and (CurrentObj.ObjectType <> 3)) Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action must be called at field level. Exiting")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function	'must be a page or a field]]>
<![CDATA[
]]>
<![CDATA[  End if  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if (not LoadDocStructurePage) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sPosition = g_DLayout.GetCurrentBlockPosition() ' Put the boundries to the current block.  Whole page if no block set.]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of current block = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	strKey = StrParam	]]>
<![CDATA[
]]>
<![CDATA[  bResult = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[  if (bResult) Then SetDocumentStuctureWordToCCOWord ' Update the document structure with the current word position]]>
<![CDATA[
]]>
<![CDATA[	RegExFindNext_InBlock = bResult]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function RegExFindNext_InBlock")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="WordFind_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  'A word or phrase to find in the current zoned field.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  The current field will be searched to find the word or phrase.  The location of the first]]>
<![CDATA[
]]>
<![CDATA[  '  word or phrase that matches the parameter will be remembered so it can be]]>
<![CDATA[
]]>
<![CDATA[  '  utilized by subsequent actions.  Word matching is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[ '   To improve matching,]]>
<![CDATA[
]]>
<![CDATA[ '   this action automatically adjusts the search criteria to allow for]]>
<![CDATA[
]]>
<![CDATA[ '   common character substitutions.  For example, if the list includes]]>
<![CDATA[
]]>
<![CDATA[ '   "will" and the recognition read "wi11", a match will still occur.]]>
<![CDATA[
]]>
<![CDATA[ '   Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WordFind_InZone=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	strKey = RegExBuild(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[	WordFind_InZone = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function WordFind_InZone")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="WordFindNext" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  'A word or phrase to find on the page, following a previously found word.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  The current page will be searched to find the word or phrase, starting from the location]]>
<![CDATA[
]]>
<![CDATA[  '  remembered from the last search, such as from WordFind.  The location of the first]]>
<![CDATA[
]]>
<![CDATA[  '  word or phrase that matches the parameter will now be remembered so it can be]]>
<![CDATA[
]]>
<![CDATA[  '  utilized by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[  '  Word matching is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ' To improve matching,]]>
<![CDATA[
]]>
<![CDATA[   ' this action automatically adjusts the search criteria to allow for]]>
<![CDATA[
]]>
<![CDATA[   ' common character substitutions.  For example, if the list includes]]>
<![CDATA[
]]>
<![CDATA[   ' "will" and the recognition read "wi11", a match will still occur.]]>
<![CDATA[
]]>
<![CDATA[   ' Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim L,R,T,B]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		WordFindNext=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[		L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[		T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[		R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[		B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		strKey = RegExBuild(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[		WordFindNext = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Call ErrorHandler("Function WordFindNext")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="WordFindNext_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  'A word or phrase to find in the current field, following a previously found word.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  The current field will be searched to find the word or phrase, starting from the]]>
<![CDATA[
]]>
<![CDATA[  '  remembered location of a previous find.  The new location of the first]]>
<![CDATA[
]]>
<![CDATA[  '  word or phrase in the field that matches the parameter will now be remembered so it can be]]>
<![CDATA[
]]>
<![CDATA[  '  utilized by subsequent actions.    ]]>
<![CDATA[
]]>
<![CDATA[  '  Word matching is case sensitive.']]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    To improve matching,]]>
<![CDATA[
]]>
<![CDATA['    this action automatically adjusts the search criteria to allow for]]>
<![CDATA[
]]>
<![CDATA['    common character substitutions.  For example, if the list includes]]>
<![CDATA[
]]>
<![CDATA['    "will" and the recognition read "wi11", a match will still occur.]]>
<![CDATA[
]]>
<![CDATA['    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	WordFindNext_InZone=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	strKey = RegExBuild(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[	WordFindNext_InZone = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function WordFindNext_InZone")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="RegExFind" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  A word or phrase to find on the current page.  The parameter is expected to be]]>
<![CDATA[
]]>
<![CDATA[  '  a Regular Expression.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Locates the first occurrence of a word or phrase on the current page where the input search term]]>
<![CDATA[
]]>
<![CDATA[  '  is specified as a regular expression.]]>
<![CDATA[
]]>
<![CDATA[  '  The search is started from the first word the current page.  The location of the ]]>
<![CDATA[
]]>
<![CDATA[  '  found word or phrase will be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[  '  The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  Dim L,R,T,B]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim strKey]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  RegExFind=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'StrParam is a built Regular expression]]>
<![CDATA[
]]>
<![CDATA[  strKey = StrParam]]>
<![CDATA[
]]>
<![CDATA[  RegExFind = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function RegExFind")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="RegExFind_InBlock" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  A word or phrase to find on the current page.  The parameter is expected to be]]>
<![CDATA[
]]>
<![CDATA[  '  a Regular Expression.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Locates the first occurrence of a word or phrase on the current page where the input search term]]>
<![CDATA[
]]>
<![CDATA[  '  is specified as a regular expression.]]>
<![CDATA[
]]>
<![CDATA[  '  The search is started from the first word the current page.  The location of the ]]>
<![CDATA[
]]>
<![CDATA[  '  found word or phrase will be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[  '  The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  Dim L,R,T,B]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim strKey]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  RegExFind_InBlock=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if (not LoadDocStructurePage) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = g_DLayout.GetCurrentBlockPosition() ' Put the boundries to the current block.  Whole page if no block set.]]>
<![CDATA[
]]>
<![CDATA[  if ((sPosition = "0,0,0,0") or (sPosition="")) Then]]>
<![CDATA[
]]>
<![CDATA[     sPosition = cstr(L & "," & T & "," & R & "," & B) ' Use the whole page.]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Search area set to the whole page")]]>
<![CDATA[
]]>
<![CDATA[  end if   ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'StrParam is a built Regular expression]]>
<![CDATA[
]]>
<![CDATA[  strKey = StrParam]]>
<![CDATA[
]]>
<![CDATA[  RegExFind_InBlock = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[  if (RegExFind_InBlock) Then RegExFind_InBlock = SetDocumentStuctureWordToCCOWord ' Update the document structure with the current word position]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function RegExFind_InBlock")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="RegExFind_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[ '   A word or phrase to find in the current field.  The parameter is expected to be]]>
<![CDATA[
]]>
<![CDATA[ '   a Regular Expression.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '  Locates the first occurrence of a word or phrase in the current field where the input search term]]>
<![CDATA[
]]>
<![CDATA[ '   is specified as a regular expression.]]>
<![CDATA[
]]>
<![CDATA[ '   The search is started from the first word of the current field.  The location of the]]>
<![CDATA[
]]>
<![CDATA[ '   found word or phrase will be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[ '   The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	RegExFind_InZone=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	strKey = StrParam]]>
<![CDATA[
]]>
<![CDATA[	RegExFind_InZone = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function RegExFind_InZone")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="RegExFindNext" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  A word or phrase to find on the current page.  The parameter is expected to be]]>
<![CDATA[
]]>
<![CDATA[  '  a Regular Expression.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Starting from the location of a previously found word, this action locates the first]]>
<![CDATA[
]]>
<![CDATA[  '  occurrence of a word or phrase on the current page where the input search term]]>
<![CDATA[
]]>
<![CDATA[  '  is specified as a regular expression.]]>
<![CDATA[
]]>
<![CDATA[  '  The search is started from the location of a previously found word.  The location of the]]>
<![CDATA[
]]>
<![CDATA[  '  found word or phrase will now be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[  '  The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim L,R,T,B]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		RegExFindNext=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[		L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[		T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[		R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[		B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'StrParam is a built Regular expression]]>
<![CDATA[
]]>
<![CDATA[		strKey = StrParam]]>
<![CDATA[
]]>
<![CDATA[		RegExFindNext = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Call ErrorHandler("Function RegExFindNext")]]>
<![CDATA[
]]>
<![CDATA[			 ]]>
	</g>
</af>
<af name="RegExFindNext_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[ '   A word or phrase to find in the current field.  The parameter is expected to be]]>
<![CDATA[
]]>
<![CDATA[ '   a Regular Expression.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   Starting from the location of a previously found word, this action locates the first]]>
<![CDATA[
]]>
<![CDATA[ '   occurrence of a word or phrase in the current field where the input search term]]>
<![CDATA[
]]>
<![CDATA[ '   is specified as a regular expression.]]>
<![CDATA[
]]>
<![CDATA[ '   The search is started from the location of a previously found word in the current field.  The location of the]]>
<![CDATA[
]]>
<![CDATA[ '   found word or phrase will be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[ '   The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	RegExFindNext_InZone=False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	strKey = StrParam]]>
<![CDATA[
]]>
<![CDATA[	RegExFindNext_InZone = KeySearch(strKey, sPosition, 1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function RegExFindNext_InZone")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="FindKeyList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   The name of the Keyword text file.  The file will contain a list of words or phrases,]]>
<![CDATA[
]]>
<![CDATA[ '   separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ '   The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA[ '   1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA[ '   2. The file name only, with no extension specified.  The application will look in ]]>
<![CDATA[
]]>
<![CDATA[ '   the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[ '   Opens the Keyword file you specify as a parameter, then checks the]]>
<![CDATA[
]]>
<![CDATA[ '   words on the current page against the keywords in the list to find a match.  The location of the]]>
<![CDATA[
]]>
<![CDATA[ '   found word or phrase that matches an entry in the keyword file ]]>
<![CDATA[
]]>
<![CDATA[ '   will be remembered so the result can be used by subsequent actions.    ]]>
<![CDATA[
]]>
<![CDATA[ '   Word matching is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   To improve matching, ]]>
<![CDATA[
]]>
<![CDATA[ '   this action automatically adjusts the search criteria to allow for]]>
<![CDATA[
]]>
<![CDATA[ '   common character substitutions.  For example, if the list includes]]>
<![CDATA[
]]>
<![CDATA[ '   "will" and the recognition read "wi11", a match will still occur.]]>
<![CDATA[
]]>
<![CDATA[ '   Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  FindKeyList = False]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey) 		]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindKeyList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="FindKeyList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   The name of the Keyword text file.  The file will contain a list of words or phrases, ]]>
<![CDATA[
]]>
<![CDATA[ '   separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA[ '   1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA[ '   2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA[ '   the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ '   Opens the Keyword file you specify as a parameter, then checks the]]>
<![CDATA[
]]>
<![CDATA[ '   words in the current field of the source page's .cco file against the keywords]]>
<![CDATA[
]]>
<![CDATA[ '   in the key file list to find a match.  The location of the]]>
<![CDATA[
]]>
<![CDATA[ '   found word or phrase that matches an entry in the keyword file]]>
<![CDATA[
]]>
<![CDATA[ '   will be remembered so the result can be used by subsequent actions.    ]]>
<![CDATA[
]]>
<![CDATA[ '   Word matching is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindKeyList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey)]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindKeyList_InZone = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindNextKeyList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  '  The name of the Keyword text file.  The file will contain a list of words, separated by new lines,]]>
<![CDATA[
]]>
<![CDATA[  '  that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA[ '   1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA[ '   2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA[ '   the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextKeyList = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey) 		]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextKeyList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="FindNextKeyList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   The name of the Keyword text file.  The file will contain a list of words, separated by new lines,]]>
<![CDATA[
]]>
<![CDATA[ '   that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA[ '   1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA[ '   2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA[ '   the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextKeyList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey)]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextKeyList_InZone = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindDBList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[' An SQL statement whose result returns a word or phrase, or a list of word or phrases.    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindDBList = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = GetDBKeyList(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey) 		]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[	  Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindDBList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindDBList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['    An SQL statment whose result returns a word or phrase, or a list of word or phrases.]]>
<![CDATA[
]]>
<![CDATA['    ]]>
<![CDATA[
]]>
<![CDATA['    This action issues an SQL query against the lookup database, returning a list]]>
<![CDATA[
]]>
<![CDATA['    of words or phrases that will be located in the current field.  The search is performed]]>
<![CDATA[
]]>
<![CDATA['    from the first word of the current field.  Initially, the first listed word or phrase]]>
<![CDATA[
]]>
<![CDATA['    is searched for in the field.  If there is no match, it will search for the next word or]]>
<![CDATA[
]]>
<![CDATA['    phrase returned from the database.  This continues until a match is found or none of the returned words]]>
<![CDATA[
]]>
<![CDATA['    are contained on the page.  The location of the]]>
<![CDATA[
]]>
<![CDATA['    found word or phrase will be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA['    The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindDBList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = GetDBKeyList(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[      strKey = RegExBuild(bInteractive, bDebug, strKey)]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[	  Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindDBList_InZone = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindNextDBList" accessed="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['    An SQL statement whose result returns a word or phrase, or a list of word or phrases.]]>
<![CDATA[
]]>
<![CDATA[' ]]>
<![CDATA[
]]>
<![CDATA['    This action issues an SQL query against the lookup database, returning a list]]>
<![CDATA[
]]>
<![CDATA['    of words or phrases that will be located on the current page.  Starting from the]]>
<![CDATA[
]]>
<![CDATA['    location of a previously found word, the search is performed.]]>
<![CDATA[
]]>
<![CDATA['    Initially, the first listed word or phrase from the SQL query]]>
<![CDATA[
]]>
<![CDATA['    is searched for on the page.  If there is no match, it will search for the next word or]]>
<![CDATA[
]]>
<![CDATA['    phrase returned from the database. This continues until a match is found or none of the returned words]]>
<![CDATA[
]]>
<![CDATA['    are contained on the page.  The location of the]]>
<![CDATA[
]]>
<![CDATA['    found word or phrase will be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA['    The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextDBList = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = GetDBKeyList(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey) 		]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[	  Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextDBList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindNextDBList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   An SQL statement whose result returns a word or phrase, or a list of word or phrases.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextDBList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = GetDBKeyList(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey)]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[	  Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextDBList_InZone = bReturn  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindRegExList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['    The name of the Keyword text file.  The file will contain a list of words or phrases,]]>
<![CDATA[
]]>
<![CDATA[ '   separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA[ '   1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA[ '   2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA[ '   the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindRegExList = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,False) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[    strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then	]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindRegExList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindRegExList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    The name of the Keyword text file.  The file will contain a list of words or phrases,]]>
<![CDATA[
]]>
<![CDATA['    separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA['    1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA['    2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA['   the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindRegExList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,False) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[	  Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindRegExList_InZone = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindNextRegExList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   The name of the Keyword text file.  The file will contain a list of words or phrases,]]>
<![CDATA[
]]>
<![CDATA[ '   separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA[ '   1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA[ '   2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA[ '   the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextRegExList = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,False) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then	]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[	  Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextRegExList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindNextRegExList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The name of the Keyword text file.  The file will contain a list of words or phrases,]]>
<![CDATA[
]]>
<![CDATA['    separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA['    1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA['    2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA['    the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextRegExList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,1,False) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, 1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[	  Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindNextRegExList_InZone = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastWord" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['   A word or phrase to find on the page.]]>
<![CDATA[
]]>
<![CDATA['   The current page will be searched to find the last occurrence of a word or phrase. ]]>
<![CDATA[
]]>
<![CDATA['   The location of the last]]>
<![CDATA[
]]>
<![CDATA['   word or phrase that matches the parameter will be remembered so it can be]]>
<![CDATA[
]]>
<![CDATA['   utilized by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim L,R,T,B]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim strKey]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  FindLastWord=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[    Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[		L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[		T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[		R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[		B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Setup CCO position to Last Line & Word]]>
<![CDATA[
]]>
<![CDATA[		Call CCO.SetCurrentPosition(CCO.Count,CCO.Item(CCO.Count).Count, CCO.Count,CCO.Item(CCO.Count).Count)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		strKey = RegExBuild(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[		FindLastWord = KeySearch(strKey, sPosition, -1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Call ErrorHandler("Function FindLastWord")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastWord_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['The target word to locate within the current zone.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    The current field will be searched to find the word or phrase.  The location of the last]]>
<![CDATA[
]]>
<![CDATA['    occurrence of the word or phrase that matches the parameter will be remembered so it can be]]>
<![CDATA[
]]>
<![CDATA['    utilized by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA['    Word matching is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	FindLastWord_InZone=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   	'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	strKey = RegExBuild(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[	FindLastWord_InZone = KeySearch(strKey, sPosition, -1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function FindLastWord_InZone")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastKeyList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The name of the Keyword text file.  The file will contain a list of words or phrases, ]]>
<![CDATA[
]]>
<![CDATA['    separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA['    1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA['    2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA['    the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastKeyList = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,-1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        'writelog("Process Keyfile pre-regexbuild: " & strKey)]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey) 		]]>
<![CDATA[
]]>
<![CDATA[        'writelog("Process Keyfile post-regexbuild: " & strKey)]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, -1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastKeyList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastKeyList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  '  The name of the Keyword text file.  The file will contain a list of words or phrases, ]]>
<![CDATA[
]]>
<![CDATA[  '  separated by new lines, that will be used for matching.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  '  The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA[  '  1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA[  '  2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA[  '  the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastKeyList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,-1,True) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        strKey = RegExBuild(bInteractive, bDebug, strKey)]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, -1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastKeyList_InZone = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastRegEx" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    A word or phrase to find on the current page.  The parameter is expected to be]]>
<![CDATA[
]]>
<![CDATA['    a Regular Expression.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA['    Locates the last occurrence of a word or phrase on the current page where the input search term]]>
<![CDATA[
]]>
<![CDATA['    is specified as a regular expression.]]>
<![CDATA[
]]>
<![CDATA['    The search is started from the first word of the current page.]]>
<![CDATA[
]]>
<![CDATA['    The location of the]]>
<![CDATA[
]]>
<![CDATA['    found word or phrase will be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA['   The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim L,R,T,B]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		FindLastRegEx=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[       	'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[    	Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[		L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[		T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[		R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[		B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		FindLastRegEx = KeySearch(strParam, sPosition, -1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Call ErrorHandler("Function RegExFindLast")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastRegEx_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   A word or phrase to find in the current field.  The parameter are expected to be]]>
<![CDATA[
]]>
<![CDATA[ '   a Regular Expression.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ '   Locates the last occurrence of a word or phrase in the current field where the input search term]]>
<![CDATA[
]]>
<![CDATA[ '   is specified as a regular expression.]]>
<![CDATA[
]]>
<![CDATA[ '   The search is started from the first word of the current field.]]>
<![CDATA[
]]>
<![CDATA[ '   The location of the]]>
<![CDATA[
]]>
<![CDATA[ '   found word or phrase will be remembered so the result can be used by subsequent actions.]]>
<![CDATA[
]]>
<![CDATA[ '   The search is case sensitive.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim strKey]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	FindLastRegEx_InZone=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	FindLastRegEx_InZone = KeySearch(strParam, sPosition, -1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function FindLastRegEx_InZone")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastRegExList" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The name of the Keyword text file.  The file will contain a list of words or phrases,]]>
<![CDATA[
]]>
<![CDATA['    separated by new lines, that will be used for matching.  The entries in the]]>
<![CDATA[
]]>
<![CDATA['    keyword file are expected to be regular expressions.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA['    1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA['    2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA['    the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastRegExList = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'Set Search Zone to Entire CCO]]>
<![CDATA[
]]>
<![CDATA[  L = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[  T = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[  R = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[  B = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sPosition = cstr(L & "," & T & "," & R & "," & B)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,-1,False) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then	]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, -1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastRegExList = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindLastRegExList_InZone" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The name of the Keyword text file.  The file will contain a list of words or phrases,]]>
<![CDATA[
]]>
<![CDATA['    separated by new lines, that will be used for matching.  The entries in the]]>
<![CDATA[
]]>
<![CDATA['    keyword file are expected to be regular expressions.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    The file name can be provided in one of two ways:]]>
<![CDATA[
]]>
<![CDATA['    1. A full path name of the file, including the extension.]]>
<![CDATA[
]]>
<![CDATA['    2. The file name only, with no extension specified.  The application will look in]]>
<![CDATA[
]]>
<![CDATA['    the process directory and the file must have a ".key" extension.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim KeyList]]>
<![CDATA[
]]>
<![CDATA[  Dim aKeys,strKey,Found,Kx]]>
<![CDATA[
]]>
<![CDATA[  Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[  Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  bReturn = False	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastRegExList_InZone = False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Set CCO Start Search Position]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(0,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="0,0,0,0" then sPosition=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  KeyList = ReadKeyFile(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bAggregateListSearch=True then]]>
<![CDATA[
]]>
<![CDATA[    If Aggregate_List_Search(KeyList,sPosition,-1,False) then bReturn=True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    aKeys = Split(KeyList & vbCrLf, vbCrLf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For Kx = 0 To UBound(aKeys)-1 ]]>
<![CDATA[
]]>
<![CDATA[      strKey = Trim(aKeys(Kx))]]>
<![CDATA[
]]>
<![CDATA[      If Len(strKey)>0 Then]]>
<![CDATA[
]]>
<![CDATA[        If KeySearch(strKey, sPosition, -1) then]]>
<![CDATA[
]]>
<![CDATA[          bReturn = True]]>
<![CDATA[
]]>
<![CDATA[          Exit For]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    Next 'sKey]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindLastRegExList_InZone = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<g>
</g>
<af name="GoPreviousWord" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['    An Integer indicating the number of words to move leftwards from the current position.]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    Moves <var>n</var> words to the left of the current word, in the same line.']]>
<![CDATA[
]]>
<![CDATA[' GoLeftWord was renamed to GoPreviousWord so the functionality is understood for BiDi text.  The meaning is the same for LTR and RTL text.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoPreviousWord = False]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(Strparam) Or Len(Trim(Strparam)) = 0 Then StrParam = "1"]]>
<![CDATA[
]]>
<![CDATA[	nSteps = CLng(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If JumpToWordH(bInteractive, bDebug, -nSteps) Then]]>
<![CDATA[
]]>
<![CDATA[		GoPreviousWord = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoPreviousWord") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="GoLeftWord" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['    An Integer indicating the number of words to move leftwards from the current position.]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    Moves <var>n</var> words to the left of the current word, in the same line.']]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' GoLeftWord has been renamed to GoPrevousWord.  This action now passed through to the new action.]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  GoLeftWord = GoPreviousWord(bInter, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoLeftWord") ]]>
	</g>
</af>
<af name="GoNextWord" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ ' An Integer indicating the number of words to move to the right.  ]]>
<![CDATA[
]]>
<![CDATA[ ' ]]>
<![CDATA[
]]>
<![CDATA[ ' Moves <var>n</var> words to the right of the current word, in the same line. ]]>
<![CDATA[
]]>
<![CDATA[ ' GoRightWord was renamed to GoNextWord so the functionality is understood for BiDi text.  The meaning is the same for LTR and RTL text.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoNextWord = False]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(Strparam) Or Len(Trim(Strparam)) = 0 Then StrParam = "1"]]>
<![CDATA[
]]>
<![CDATA[	nSteps = CLng(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If JumpToWordH(bInteractive, bDebug, nSteps) Then		]]>
<![CDATA[
]]>
<![CDATA[		GoNextWord = True]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoNextWord") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="GoRightWord" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ' GoRightWord is deprecated due to a name change to GoNextWord.  This action now passes through to the new action.]]>
<![CDATA[
]]>
<![CDATA[ 	GoRightWord = GoNextWord(bInter, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoRightWord") ]]>
	</g>
</af>
<af name="GoAboveWord" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[' An Integer indicating the number of lines above the current word.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[' Moves to a word which is above the current word by <var>n</var> lines.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoAboveWord = False	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(Strparam) Or Len(Trim(Strparam)) = 0 Then StrParam = "1"]]>
<![CDATA[
]]>
<![CDATA[	nSteps = CLng(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If JumpToWordV(bInteractive, bDebug, -nSteps) Then]]>
<![CDATA[
]]>
<![CDATA[		GoAboveWord = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoAboveWord") ]]>
	</g>
</af>
<af name="GoBelowWord" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    An Integer indicating the number of lines below the current word.  ]]>
<![CDATA[
]]>
<![CDATA['  ]]>
<![CDATA[
]]>
<![CDATA['    Moves to a word which is below the current word by <var>n</var> lines.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoBelowWord = False	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(Strparam) Or Len(Trim(Strparam)) = 0 Then StrParam = "1"]]>
<![CDATA[
]]>
<![CDATA[	nSteps = CLng(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If JumpToWordV(bInteractive, bDebug, nSteps) Then]]>
<![CDATA[
]]>
<![CDATA[		GoBelowWord = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoBelowWord") ]]>
	</g>
</af>
<af name="GoFirstWord" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['   This action navigates to the first word on the current line. If the page's ]]>
<![CDATA[
]]>
<![CDATA['   Fingerprint file (.cco)  does not have a Line position, the action defaults ]]>
<![CDATA[
]]>
<![CDATA['   to the first line of the current zone - or page, if a zone is not present.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[    Dim L1,L2,W1,W2]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[    Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[    Dim arData]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoFirstWord = False	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Get Current Zone boundry]]>
<![CDATA[
]]>
<![CDATA[    Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("New Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Final Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[    If sPosition="" then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	arData=Split(sPosition, ",")]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To UBound(arData)]]>
<![CDATA[
]]>
<![CDATA[		If trim(arData(i))="" then]]>
<![CDATA[
]]>
<![CDATA[			arData(i)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[		else]]>
<![CDATA[
]]>
<![CDATA[			arData(i)=CLng(arData(i))]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Start CCO Position lines:" & L1 & "-" & L2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count>0 Then ]]>
<![CDATA[
]]>
<![CDATA[        'If no CCO position then default to 1st line in zone or page if no zone]]>
<![CDATA[
]]>
<![CDATA[    	If L1=0 then]]>
<![CDATA[
]]>
<![CDATA[            Call CCO.LocateLines(arData(1),arData(3),L1,L2)]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Locate Lines " & L1 & "-" & L2)]]>
<![CDATA[
]]>
<![CDATA[            If L1=0 then L1=1]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	    W1=1]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[        Call CCO.SetCurrentPosition(L1,W1,L1,W1)]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Position set to Line " & L1 & " Word " & W1)]]>
<![CDATA[
]]>
<![CDATA[        GoFirstWord=True]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoFirstWord") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GoLastWord" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' If the source page's Fingerprint file (.cco) does not have a Line position, ]]>
<![CDATA[
]]>
<![CDATA[  '  the action defaults to the first line in the current zone or page, if no zone is present.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Dim L1,L2,W1,W2]]>
<![CDATA[
]]>
<![CDATA[	  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[    Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[    Dim arData]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoLastWord = False	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Get Current Zone boundry]]>
<![CDATA[
]]>
<![CDATA[    Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		'Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If sPosition="" then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    arData=Split(sPosition, ",")]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To UBound(arData)]]>
<![CDATA[
]]>
<![CDATA[		If trim(arData(i))="" then]]>
<![CDATA[
]]>
<![CDATA[			arData(i)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[		else]]>
<![CDATA[
]]>
<![CDATA[			arData(i)=CLng(arData(i))]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count>0 Then ]]>
<![CDATA[
]]>
<![CDATA[        'If no CCO position then default to 1st line in zone or page if no zone]]>
<![CDATA[
]]>
<![CDATA[        If L2=0 then ]]>
<![CDATA[
]]>
<![CDATA[            Call CCO.LocateLines(arData(1),arData(3),L1,L2)]]>
<![CDATA[
]]>
<![CDATA[            If L2=0 then L2=1             ]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	    W2=CCO.Item(L2).Count]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Call CCO.SetCurrentPosition(L2,W2,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Position set to Line " & L2 & " Word " & W2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        GoLastWord =True]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoLastWord") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GoFirstLine" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  '  This action moves to the first line of the current zone, or to the first line ]]>
<![CDATA[
]]>
<![CDATA[  '  of the source page if there is no zone.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Dim L1,L2,W1,W2]]>
<![CDATA[
]]>
<![CDATA[	  Dim oParent]]>
<![CDATA[
]]>
<![CDATA[    Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[    Dim arData]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoFirstLine = False	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Get Current Zone boundry]]>
<![CDATA[
]]>
<![CDATA[    Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		'Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If sPosition="" then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	arData=Split(sPosition, ",")]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To UBound(arData)]]>
<![CDATA[
]]>
<![CDATA[		If trim(arData(i))="" then]]>
<![CDATA[
]]>
<![CDATA[			arData(i)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[		else]]>
<![CDATA[
]]>
<![CDATA[			arData(i)=CLng(arData(i))]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count>0 Then ]]>
<![CDATA[
]]>
<![CDATA[        'If no CCO position then default to 1st line in zone or page if no zone]]>
<![CDATA[
]]>
<![CDATA[    	Call CCO.LocateLines(arData(1),arData(3),L1,L2)]]>
<![CDATA[
]]>
<![CDATA[        If L1=0 then L1=1]]>
<![CDATA[
]]>
<![CDATA[        W1=1]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[        Call CCO.SetCurrentPosition(L1,W1,L1,W1)]]>
<![CDATA[
]]>
<![CDATA[         Writelog("Position set to Line " & L1 & " Word " & W1)]]>
<![CDATA[
]]>
<![CDATA[        GoFirstLine=True]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoFirstLine") ]]>
	</g>
</af>
<af name="GoLastLine" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   This action navigates to the last line in the current zone, or to the last ]]>
<![CDATA[
]]>
<![CDATA[ '   line in the current page if a zone is not present.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Dim L1,L2,W1,W2]]>
<![CDATA[
]]>
<![CDATA[    Dim oParent]]>
<![CDATA[
]]>
<![CDATA[    Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[    Dim arData]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    GoLastLine = False	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Get Current Zone boundry]]>
<![CDATA[
]]>
<![CDATA[    Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[    sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[      Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[      sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[      'Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[    Wend]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If sPosition="" then ]]>
<![CDATA[
]]>
<![CDATA[      sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    arData=Split(sPosition, ",")]]>
<![CDATA[
]]>
<![CDATA[    For i=0 To UBound(arData)]]>
<![CDATA[
]]>
<![CDATA[      If trim(arData(i))="" then]]>
<![CDATA[
]]>
<![CDATA[        arData(i)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[      else]]>
<![CDATA[
]]>
<![CDATA[        arData(i)=CLng(arData(i))]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[    Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    If CCO.Count>0 Then ]]>
<![CDATA[
]]>
<![CDATA[        'If no CCO position then default to last line in zone; page if no zone]]>
<![CDATA[
]]>
<![CDATA[        Call CCO.LocateLines(arData(1),arData(3),L1,L2)]]>
<![CDATA[
]]>
<![CDATA[        If L2=0 then L2=1             ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        'If no position info for bottom position use last line]]>
<![CDATA[
]]>
<![CDATA[        If arData(3)=0 then L2=CCO.Count]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[	      W2=CCO.Item(L2).Count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Call CCO.SetCurrentPosition(L2,W2,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Position set to Line " & L2 & " Word " & W2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        GoLastLine =True]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoLastLine") ]]>
	</g>
</af>
<af name="GoDownLine" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ' An Integer indicating the number of lines below the current line.  ]]>
<![CDATA[
]]>
<![CDATA[   ' Moves to the first word of a line that is <var>n</var> lines below the current line. ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	GoDownLine = False	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(Strparam) Or Len(Trim(Strparam)) = 0 Then StrParam = "1"]]>
<![CDATA[
]]>
<![CDATA[	nSteps = CLng(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If JumpToLine(bInteractive, bDebug, nSteps) Then]]>
<![CDATA[
]]>
<![CDATA[		GoDownLine = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoDownLine") ]]>
	</g>
</af>
<af name="GoUpLine" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   'An Integer indicating the number of lines above the current line.  ]]>
<![CDATA[
]]>
<![CDATA[  '   Moves to the first word of a line that is <var>n</var> lines above the current line.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoUpLine = False	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(Strparam) Or Len(Trim(Strparam)) = 0 Then StrParam = "1"]]>
<![CDATA[
]]>
<![CDATA[	nSteps = CLng(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If JumpToLine(bInteractive, bDebug, -nSteps) Then]]>
<![CDATA[
]]>
<![CDATA[		GoUpLine = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function GoUpLine") ]]>
	</g>
</af>
<af name="UpdateField" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA['    Updates the appropriate field in the current page's Data file with the recognized ]]>
<![CDATA[
]]>
<![CDATA['    (and possibly formatted!) value of the located word.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim L1,W1,L2,W2]]>
<![CDATA[
]]>
<![CDATA[	Dim v_left,v_top,v_right,v_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim v1_left,v1_top,v1_right,v1_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim v2_left,v2_top,v2_right,v2_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue, sConfidence]]>
<![CDATA[
]]>
<![CDATA[	Dim Wx,Lx,Cx]]>
<![CDATA[
]]>
<![CDATA[	Dim Cleft ,Ctop ,Cright ,Cbottom]]>
<![CDATA[
]]>
<![CDATA[	Dim sEOL,n]]>
<![CDATA[
]]>
<![CDATA[	Dim Wxstart,Wxend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	UpdateField=False]]>
<![CDATA[
]]>
<![CDATA[	sEOL=Space(1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("CCO Position:" & L1 & "," & W1 & "," & L2 & "," & W2)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If L1=0 and W1=0 then]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Position information found. Exiting Action")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'First Word Positions]]>
<![CDATA[
]]>
<![CDATA[	v1_left = CCO.Item(L1).Item(W1).Left]]>
<![CDATA[
]]>
<![CDATA[	v1_top = CCO.Item(L1).Item(W1).Top]]>
<![CDATA[
]]>
<![CDATA[	v1_right = CCO.Item(L1).Item(W1).Right]]>
<![CDATA[
]]>
<![CDATA[	v1_bottom = CCO.Item(L1).Item(W1).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Last Word Positions]]>
<![CDATA[
]]>
<![CDATA[	v2_left = CCO.Item(L2).Item(W2).Left]]>
<![CDATA[
]]>
<![CDATA[	v2_top = CCO.Item(L2).Item(W2).Top]]>
<![CDATA[
]]>
<![CDATA[	v2_right = CCO.Item(L2).Item(W2).Right]]>
<![CDATA[
]]>
<![CDATA[	v2_bottom = CCO.Item(L2).Item(W2).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Merge Positions]]>
<![CDATA[
]]>
<![CDATA[	If v2_left < v1_left then v1_left = v2_left]]>
<![CDATA[
]]>
<![CDATA[	If v2_top < v1_top then v1_top = v2_top]]>
<![CDATA[
]]>
<![CDATA[	If v2_right > v1_right then v1_right = v2_right]]>
<![CDATA[
]]>
<![CDATA[	If v2_bottom > v1_bottom then v1_bottom = v2_bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CheckMCCOImageReference(CurrentObj,L1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Expand Zone for viewability - check image border boundries]]>
<![CDATA[
]]>
<![CDATA[	v1_left = v1_left-2]]>
<![CDATA[
]]>
<![CDATA[	If v1_left<0 then v1_left=0]]>
<![CDATA[
]]>
<![CDATA[	v1_top = v1_top-2]]>
<![CDATA[
]]>
<![CDATA[	If v1_top<0 then v1_top=0]]>
<![CDATA[
]]>
<![CDATA[	v1_right = v1_right+2]]>
<![CDATA[
]]>
<![CDATA[	If v1_right>CCO.Right then v1_right=CCO.Right]]>
<![CDATA[
]]>
<![CDATA[	v1_bottom = v1_bottom+2]]>
<![CDATA[
]]>
<![CDATA[	If v1_bottom>CCO.bottom then v1_right=CCO.bottom ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text=""]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(v1_left-2, v1_top-2, v1_right+2, v1_bottom+2)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(trim(L2))=0 then L2=L1]]>
<![CDATA[
]]>
<![CDATA[	If len(trim(W2))=0 then W2=W1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For Lx = L1 to L2]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Wxstart=1]]>
<![CDATA[
]]>
<![CDATA[		Wxend=CCO.Item(Lx).Count]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Lx=L1 Then Wxstart=W1]]>
<![CDATA[
]]>
<![CDATA[		If Lx=L2 Then Wxend=W2]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		For Wx = Wxstart to Wxend]]>
<![CDATA[
]]>
<![CDATA[			For Cx = 1 to CCO.Item(Lx).Item(Wx).Count]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[				sValue = ASCW(CCO.Item(Lx).Item(Wx).Item(Cx).Value)]]>
<![CDATA[
]]>
<![CDATA[				sConfidence = CCO.Item(Lx).Item(Wx).Item(Cx).confidence]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[				Set cObj = CurrentObj.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[				nChar = cObj.AddValue(CLng(sValue), CLng(sConfidence))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				  Cleft = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Left)]]>
<![CDATA[
]]>
<![CDATA[				   Ctop = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Top)]]>
<![CDATA[
]]>
<![CDATA[				 Cright = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Right)]]>
<![CDATA[
]]>
<![CDATA[				Cbottom = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Bottom)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		        bRes = cObj.SetPosition(Cleft ,Ctop ,Cright ,Cbottom)		]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[			Next 'Cx]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			'Add Space to DCO Value Between Words]]>
<![CDATA[
]]>
<![CDATA[			If Wx<Wxend then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				Set cObj = CurrentObj.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[				nChar = cObj.AddValue(CLng(32), CLng(9))]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		        bRes = cObj.SetPosition(Clng(0) ,Clng(0) ,Clng(0) ,Clng(0))]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		Next 'Wx]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'Add EOL character(s) to DCO Value between Lines]]>
<![CDATA[
]]>
<![CDATA[		If Lx<L2 then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If IsAlive(g_SetEOL) Then sEOL = g_SetEOL]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			For n = 1 to len(sEOL)]]>
<![CDATA[
]]>
<![CDATA[				Set cObj = CurrentObj.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[				nChar = cObj.AddValue(CLng(ASCW(Mid(sEOL,n,1))), CLng(9))]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			   bRes = cObj.SetPosition(Clng(0) ,Clng(0) ,Clng(0) ,Clng(0))]]>
<![CDATA[
]]>
<![CDATA[		   ]]>
<![CDATA[
]]>
<![CDATA[		   Next 'n]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Next 'Lx]]>
<![CDATA[
]]>
<![CDATA[     	 ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(3) & "UpdateField    Value Found: '" & CurrentObj.Text & "'    Confidence: '" & CurrentObj.ConfidenceString & "' ")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(logwindow) Then]]>
<![CDATA[
]]>
<![CDATA[		Call ShowCurrPosFromCCO()]]>
<![CDATA[
]]>
<![CDATA[	 	ValueUP.Text = CurrentObj.Text				]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	UpdateField = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function UpdateField")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="UpdateDCOField" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   String value of the target field's name, as a <b>Field</b> object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[ '   This action updates the size and position coordinates of the <b>Field</b>object ]]>
<![CDATA[
]]>
<![CDATA[ '   representing the field identified by the parameter. Typically, the action follows ]]>
<![CDATA[
]]>
<![CDATA[ '   earlier actions and events which modify the field's width and height, or its ]]>
<![CDATA[
]]>
<![CDATA[ '   precise placement on the current source page. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim L1,W1,L2,W2]]>
<![CDATA[
]]>
<![CDATA[  Dim v_left,v_top,v_right,v_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim v1_left,v1_top,v1_right,v1_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim v2_left,v2_top,v2_right,v2_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue, sConfidence]]>
<![CDATA[
]]>
<![CDATA[  Dim Wx,Lx,Cx]]>
<![CDATA[
]]>
<![CDATA[  Dim Cleft ,Ctop ,Cright ,Cbottom]]>
<![CDATA[
]]>
<![CDATA[  Dim oField]]>
<![CDATA[
]]>
<![CDATA[  Dim sEOL,n]]>
<![CDATA[
]]>
<![CDATA[  Dim Wxstart,Wxend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	UpdateDCOField=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[  Writelog("CCO Position:" & L1 & "," & W1 & "," & L2 & "," & W2)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If L1=0 and W1=0 then]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Position information found. Exiting Action")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'First Word Positions]]>
<![CDATA[
]]>
<![CDATA[	v1_left = CCO.Item(L1).Item(W1).Left]]>
<![CDATA[
]]>
<![CDATA[	v1_top = CCO.Item(L1).Item(W1).Top]]>
<![CDATA[
]]>
<![CDATA[	v1_right = CCO.Item(L1).Item(W1).Right]]>
<![CDATA[
]]>
<![CDATA[	v1_bottom = CCO.Item(L1).Item(W1).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Last Word Positions]]>
<![CDATA[
]]>
<![CDATA[	v2_left = CCO.Item(L2).Item(W2).Left]]>
<![CDATA[
]]>
<![CDATA[	v2_top = CCO.Item(L2).Item(W2).Top]]>
<![CDATA[
]]>
<![CDATA[	v2_right = CCO.Item(L2).Item(W2).Right]]>
<![CDATA[
]]>
<![CDATA[	v2_bottom = CCO.Item(L2).Item(W2).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Merge Positions]]>
<![CDATA[
]]>
<![CDATA[	If v2_left < v1_left then v1_left = v2_left]]>
<![CDATA[
]]>
<![CDATA[	If v2_top < v1_top then v1_top = v2_top]]>
<![CDATA[
]]>
<![CDATA[	If v2_right > v1_right then v1_right = v2_right]]>
<![CDATA[
]]>
<![CDATA[	If v2_bottom > v1_bottom then v1_bottom = v2_bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oField = DCONav(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If oField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Target DCO not found.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CheckMCCOImageReference(oField,L1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oField.Text=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Expand Zone for viewability - check image border boundries]]>
<![CDATA[
]]>
<![CDATA[	v1_left = v1_left-2]]>
<![CDATA[
]]>
<![CDATA[	If v1_left<0 then v1_left=0]]>
<![CDATA[
]]>
<![CDATA[	v1_top = v1_top-2]]>
<![CDATA[
]]>
<![CDATA[	If v1_top<0 then v1_top=0]]>
<![CDATA[
]]>
<![CDATA[	v1_right = v1_right+2]]>
<![CDATA[
]]>
<![CDATA[	If v1_right>CCO.Right then v1_right=CCO.Right]]>
<![CDATA[
]]>
<![CDATA[	v1_bottom = v1_bottom+2]]>
<![CDATA[
]]>
<![CDATA[	If v1_bottom>CCO.bottom then v1_right=CCO.bottom ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call oField.SetPosition(v1_left-2, v1_top-2, v1_right+2, v1_bottom+2)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(trim(L2))=0 then L2=L1]]>
<![CDATA[
]]>
<![CDATA[	If len(trim(W2))=0 then W2=W1]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For Lx = L1 to L2]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Wxstart=1]]>
<![CDATA[
]]>
<![CDATA[		Wxend=CCO.Item(Lx).Count]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Lx=L1 Then Wxstart=W1]]>
<![CDATA[
]]>
<![CDATA[		If Lx=L2 Then Wxend=W2]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		For Wx = Wxstart to Wxend]]>
<![CDATA[
]]>
<![CDATA[			For Cx = 1 to CCO.Item(Lx).Item(Wx).Count]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[				sValue = ASCw(CCO.Item(Lx).Item(Wx).Item(Cx).Value)]]>
<![CDATA[
]]>
<![CDATA[				sConfidence = CCO.Item(Lx).Item(Wx).Item(Cx).confidence]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[				Set cObj = oField.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[				nChar = cObj.AddValue(CLng(sValue), CLng(sConfidence))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				  Cleft = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Left)]]>
<![CDATA[
]]>
<![CDATA[				   Ctop = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Top)]]>
<![CDATA[
]]>
<![CDATA[				 Cright = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Right)]]>
<![CDATA[
]]>
<![CDATA[				Cbottom = Clng(CCO.Item(Lx).Item(Wx).Item(Cx).Bottom)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		        bRes = cObj.SetPosition(Cleft ,Ctop ,Cright ,Cbottom)		]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[			Next 'Cx]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			'Add Space to DCO Value Between Words]]>
<![CDATA[
]]>
<![CDATA[			If Wx<Wxend then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				Set cObj = oField.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[				nChar = cObj.AddValue(CLng(32), CLng(9))]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		        bRes = cObj.SetPosition(Clng(0) ,Clng(0) ,Clng(0) ,Clng(0))]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		Next 'Wx]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'Add EOL character(s) to DCO Value between Lines]]>
<![CDATA[
]]>
<![CDATA[		If Lx<L2 then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If IsAlive(g_SetEOL) Then sEOL = g_SetEOL]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			For n = 1 to len(sEOL)]]>
<![CDATA[
]]>
<![CDATA[				Set cObj = oField.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[				nChar = cObj.AddValue(CLng(ASCW(Mid(sEOL,n,1))), CLng(9))]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			   bRes = cObj.SetPosition(Clng(0) ,Clng(0) ,Clng(0) ,Clng(0))]]>
<![CDATA[
]]>
<![CDATA[		   ]]>
<![CDATA[
]]>
<![CDATA[		   Next 'n]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Next 'Lx]]>
<![CDATA[
]]>
<![CDATA[     	 ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(3) & "UpdateDCOField    Value Found: '" & oField.Text & "'    Confidence: '" & oField.ConfidenceString & "' Image:'" & oField.Variable("IMAGEFILE") &"'")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(logwindow) Then]]>
<![CDATA[
]]>
<![CDATA[		Call ShowCurrPosFromCCO()]]>
<![CDATA[
]]>
<![CDATA[	 	ValueUP.Text = oField.Text				]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	UpdateDCOField = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function UpdateDCOField")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="SetRect" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[ 'Four coordinates designating the rectangle's size and location: X,Y,W,H.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Dim vals]]>
<![CDATA[
]]>
<![CDATA[	Dim nX,nY,nW,nH]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	vals = Split(strParam,",",4)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nX = CLng(Trim(vals(0))) ]]>
<![CDATA[
]]>
<![CDATA[	nY = CLng(Trim(vals(1))) ]]>
<![CDATA[
]]>
<![CDATA[	nW = CLng(Trim(vals(2))) ]]>
<![CDATA[
]]>
<![CDATA[	nH = CLng(Trim(vals(3))) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(nX,nY,nX+nW,nY+nH)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetRect = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetRect")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="MergeNextWord" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['    An Integer indicating the number of words to the right, starting from the previously ]]>
<![CDATA[
]]>
<![CDATA['    found word, to be placed into a field.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    Places the located word with one or more words to the right, on the same line, ]]>
<![CDATA[
]]>
<![CDATA['    into the current object field.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Dim L1,W1,L2,W2]]>
<![CDATA[
]]>
<![CDATA[	Dim Wx]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(StrParam) Or IsNull(StrParam) Then StrParam = 1 ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Abs(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	MergeNextWord=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[	If L1=0 then L1=1]]>
<![CDATA[
]]>
<![CDATA[	If L2=0 then L2=1]]>
<![CDATA[
]]>
<![CDATA[	If W1=0 then W1=1]]>
<![CDATA[
]]>
<![CDATA[	If W2=0 then W2=1]]>
<![CDATA[
]]>
<![CDATA[	     ]]>
<![CDATA[
]]>
<![CDATA[	For Wx = 1 To StrParam]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'Check if there is a word to the right to merge with]]>
<![CDATA[
]]>
<![CDATA[		If CCO.Item(L2).count < (W2 + Wx) Then ]]>
<![CDATA[
]]>
<![CDATA[			MergeNextWord = True]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Call CCO.SetCurrentPosition(L1,W1,L2,W2 + Wx)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	Next 'Wx]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("MergeNextWord New Value: " & GetCurrValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) Then]]>
<![CDATA[
]]>
<![CDATA[		ShowCurrPosFromCCO()]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	MergeNextWord = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function MergeNextWord")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="MergeWordRT" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA['    An Integer indicating the number of words to the right, starting from the previously ]]>
<![CDATA[
]]>
<![CDATA['    found word, to be placed into a field.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    Places the located word with one or more words to the right, on the same line, ]]>
<![CDATA[
]]>
<![CDATA['    into the current object field.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  MergeWordRT = MergeNextWord(bInter, bDebug, StrParam)	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function MergeWordRT")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="IsNumber" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   An Integer (0-100) indicating the minimum percentage of characters that must be numeric.]]>
<![CDATA[
]]>
<![CDATA[ '   If no parameter is specified, the value defaults to 100 percent; all characters must be numeric.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim Value, TrueCount, FalseCount, TFRatio]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter is not Numeric. Setting to 100")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If StrParam < 0 Then ]]>
<![CDATA[
]]>
<![CDATA[		StrParam = 0]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter is negative value. Setting to Zero")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If StrParam > 100 Then ]]>
<![CDATA[
]]>
<![CDATA[		StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter is Greater than 100. Setting to 100")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsNumber = False]]>
<![CDATA[
]]>
<![CDATA[	TrueCount = 0]]>
<![CDATA[
]]>
<![CDATA[	FalseCount = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Value = Trim(GetCurrValue)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Checking Value of '" & Value & "'.")]]>
<![CDATA[
]]>
<![CDATA[	ValueLen = len(Value)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{N} or \p{Number}: any kind of numeric character in any script. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Nd} or \p{Decimal_Digit_Number}: a digit zero through nine in any script except ideographic scripts. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Nl} or \p{Letter_Number}: a number that looks like a letter, such as a Roman numeral. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{No} or \p{Other_Number}: a superscript or subscript digit, or a number that is not a digit 0..9 (excluding numbers from ideographic scripts). ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	For Cx = 1 To Len(value)]]>
<![CDATA[
]]>
<![CDATA[    sCharacter=Mid(value,Cx,1)]]>
<![CDATA[
]]>
<![CDATA[		If DCGlobalStrings.RegExIsMatch(sCharacter,"\p{N}") Then]]>
<![CDATA[
]]>
<![CDATA[			TrueCount = TrueCount + 1]]>
<![CDATA[
]]>
<![CDATA[    Elseif DCGlobalStrings.RegExIsMatch(sCharacter,"\p{Mn}") Then]]>
<![CDATA[
]]>
<![CDATA[      ValueLen = ValueLen - 1]]>
<![CDATA[
]]>
<![CDATA[		Else	]]>
<![CDATA[
]]>
<![CDATA[			FalseCount = FalseCount + 1]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next 'Cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TFRatio = (StrParam/100)*ValueLen]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If TrueCount >= TFRatio and ValueLen>0 Then IsNumber = True]]>
<![CDATA[
]]>
<![CDATA[	If ValueLen <= 0 Then ValueLen = 1 ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(3) & "Value is " & (TrueCount/ValueLen)*100 & "% Numeric") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNumber=False Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("value contains less than " & StrParam & "% numeric characters.") ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="IsAlpha" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    An Integer (0-100) indicating the minimum percentage of characters that need to be alphabetic. ]]>
<![CDATA[
]]>
<![CDATA['    If no value is provided, the percentage defaults to 100; all characters must be alphabetic.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim Value, TrueCount, FalseCount, TFRatio, Ck]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	IsAlpha = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	' StrParam is a value between 0 and 100]]>
<![CDATA[
]]>
<![CDATA[	' This action determines the percentage of numbers required to return True]]>
<![CDATA[
]]>
<![CDATA[	' Defaults to 100% ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter is not Numeric. Setting to 100")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If StrParam < 0 Then ]]>
<![CDATA[
]]>
<![CDATA[		StrParam = 0]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter is negative value. Setting to Zero")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If StrParam > 100 Then ]]>
<![CDATA[
]]>
<![CDATA[		StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter is Greater than 100. Setting to 100")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TrueCount = 0]]>
<![CDATA[
]]>
<![CDATA[	FalseCount = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Value = Trim(GetCurrValue)]]>
<![CDATA[
]]>
<![CDATA[ValueLen = len(Value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' \p{L} or \p{Letter}: any kind of letter from any language. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Ll} or \p{Lowercase_Letter}: a lowercase letter that has an uppercase variant. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Lu} or \p{Uppercase_Letter}: an uppercase letter that has a lowercase variant. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Lt} or \p{Titlecase_Letter}: a letter that appears at the start of a word when only the first letter of the word is capitalized. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{L&} or \p{Letter&}: a letter that exists in lowercase and uppercase variants (combination of Ll, Lu and Lt). ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Lm} or \p{Modifier_Letter}: a special character that is used like a letter. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Lo} or \p{Other_Letter}: a letter or ideograph that does not have lowercase and uppercase variants. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Mn} : a non spacing mark - used with non composite character sets.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  For Cx = 1 To Len(value)]]>
<![CDATA[
]]>
<![CDATA[    sCharacter=Mid(value,Cx,1)]]>
<![CDATA[
]]>
<![CDATA[		If DCGlobalStrings.RegExIsMatch(sCharacter,"\p{L}") Then]]>
<![CDATA[
]]>
<![CDATA[			TrueCount = TrueCount + 1]]>
<![CDATA[
]]>
<![CDATA[    Elseif DCGlobalStrings.RegExIsMatch(sCharacter,"\p{Mn}") Then]]>
<![CDATA[
]]>
<![CDATA[      ValueLen = ValueLen - 1]]>
<![CDATA[
]]>
<![CDATA[		Else	]]>
<![CDATA[
]]>
<![CDATA[			FalseCount = FalseCount + 1]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next 'Cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TFRatio = (StrParam/100)*ValueLen]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If TrueCount >= TFRatio and ValueLen>0 Then IsAlpha = True]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(3) & "Value is " & (TrueCount/ValueLen)*100 & "% Alphabetic") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If IsAlpha Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Value is at least " & StrParam & "% Alphabetic") ]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Value is not at least " & StrParam & "% Alphabetic") ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="MergePreviousWord" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['    An Integer indicating the number of words to the left of the previously found field,]]>
<![CDATA[
]]>
<![CDATA['    to be placed into the current object field.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    Merges the located word with one or more words to the left, on the same line.]]>
<![CDATA[
]]>
<![CDATA['    MergePreviousWord replaced the action MergeWordLF]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim L1,W1,L2,W2]]>
<![CDATA[
]]>
<![CDATA[	Dim Wx]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(StrParam) Or IsNull(StrParam) Then StrParam = 1 ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Abs(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	MergePreviousWord=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[  If L1=0 then L1=1]]>
<![CDATA[
]]>
<![CDATA[	If L2=0 then L2=1]]>
<![CDATA[
]]>
<![CDATA[	If W1=0 then W1=1]]>
<![CDATA[
]]>
<![CDATA[	If W2=0 then W2=1]]>
<![CDATA[
]]>
<![CDATA[	     ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Starting from leading and trailing words:" & L1 & "," & W1 & ":" & L2 & "," & W2)     ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Merging up to '" & strparam & "' words Left.")     ]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[	For Wx = 1 To StrParam]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'Check if there is a word to the left to merge with]]>
<![CDATA[
]]>
<![CDATA[    If (W1 - Wx)<=0 Then     ]]>
<![CDATA[
]]>
<![CDATA[			MergePreviousWord = True]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    Call CCO.SetCurrentPosition(L1,W1-Wx,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Next 'Wx]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("MergePreviousWord New Value: " & GetCurrValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) Then]]>
<![CDATA[
]]>
<![CDATA[		ShowCurrPosFromCCO()]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	MergePreviousWord = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function MergePreviousWord")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="MergeWordLF" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    An Integer indicating the number of words to the left of the previously found field,]]>
<![CDATA[
]]>
<![CDATA['    to be placed into the current object field.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    Merges the located word with one or more words to the left, on the same line.]]>
<![CDATA[
]]>
<![CDATA['    This action has been deprecated and replaced by MergePreviousWord because that name is more appropriate for LTR and RTL BiDi text.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  MergeWordLF = MergePreviousWord(bInter, bDebug, StrParam)	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function MergeWordLF")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsDateValue" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Determines if the recognized value of the located word has an acceptable Date format.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim Value]]>
<![CDATA[
]]>
<![CDATA[  Dim slocale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  IsDateValue=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  IsDateValue = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Value = GetCurrValue()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  writelog("Checking Value:'" & Value & "' ")]]>
<![CDATA[
]]>
<![CDATA[  slocale = DetermineLocale]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  IsDateValue = DCGlobalDates.IsDate(Value,slocale) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  writelog(DCGlobalDates.GetLog())]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="FilterIt" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ '   A String containing the character(s) to be removed. ]]>
<![CDATA[
]]>
<![CDATA[ '   <b>Alert!</b> This action removes every instance of the character or characters.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("FilterIt: Calling RemoveType...")]]>
<![CDATA[
]]>
<![CDATA[	FilterIt = RemoveType(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="SelectSnippet" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '  1.</b> The character that is to appear in the Snippet field if a value is not ]]>
<![CDATA[
]]>
<![CDATA[ '   available. "~" is the default.]]>
<![CDATA[
]]>
<![CDATA[ '  2.</b> The magnification of the value's image. "1" = 100% and is the default.]]>
<![CDATA[
]]>
<![CDATA[ '  ]]>
<![CDATA[
]]>
<![CDATA[ '   Used in conjunction with directional actions, this action will populate a Snippet ]]>
<![CDATA[
]]>
<![CDATA[ '   field with the recognized value of the located word.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim Lx, Wx]]>
<![CDATA[
]]>
<![CDATA[  Dim L1,W1,L2,W2]]>
<![CDATA[
]]>
<![CDATA[  Dim v_left,v_top,v_right,v_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim v1_left,v1_top,v1_right,v1_bottom]]>
<![CDATA[
]]>
<![CDATA[  Dim v2_left,v2_top,v2_right,v2_bottom]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = StrParam & ", "]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = " ,1"]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(aStrParam(1)) Then aStrParam(1) = "1"]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("SelectSnippet: setting default area...")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SelectSnippet=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[	If L1=0 then L1=1]]>
<![CDATA[
]]>
<![CDATA[	If L2=0 then L2=1]]>
<![CDATA[
]]>
<![CDATA[	If W1=0 then W1=1]]>
<![CDATA[
]]>
<![CDATA[	If W2=0 then W2=1]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	writelog("Showing CCO " & L1 & "," & W1 & " to " & L2 & "," & W2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'First Word Positions]]>
<![CDATA[
]]>
<![CDATA[	v1_left = CCO.Item(L1).Item(W1).Left]]>
<![CDATA[
]]>
<![CDATA[	v1_top = CCO.Item(L1).Item(W1).Top]]>
<![CDATA[
]]>
<![CDATA[	v1_right = CCO.Item(L1).Item(W1).Right]]>
<![CDATA[
]]>
<![CDATA[	v1_bottom = CCO.Item(L1).Item(W1).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Last Word Positions]]>
<![CDATA[
]]>
<![CDATA[	v2_left = CCO.Item(L2).Item(W2).Left]]>
<![CDATA[
]]>
<![CDATA[	v2_top = CCO.Item(L2).Item(W2).Top]]>
<![CDATA[
]]>
<![CDATA[	v2_right = CCO.Item(L2).Item(W2).Right]]>
<![CDATA[
]]>
<![CDATA[	v2_bottom = CCO.Item(L2).Item(W2).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Merge Positions]]>
<![CDATA[
]]>
<![CDATA[	If v2_left < v1_left then v1_left = v2_left]]>
<![CDATA[
]]>
<![CDATA[	If v2_top < v1_top then v1_top = v2_top]]>
<![CDATA[
]]>
<![CDATA[	If v2_right > v1_right then v1_right = v2_right]]>
<![CDATA[
]]>
<![CDATA[	If v2_bottom > v1_bottom then v1_bottom = v2_bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	v1_bottom = v1_bottom + ((v1_bottom - v1_top) * (2 * aStrParam(1)))  ]]>
<![CDATA[
]]>
<![CDATA[	 v1_right = v1_right + ((v1_right - v1_left) * (.75 * aStrparam(1)))]]>
<![CDATA[
]]>
<![CDATA[	  v1_left = v1_left - (15 * aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	   v1_top = v1_top - (15 * aStrParam(1)) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(v1_left, v1_top, v1_right, v1_bottom)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.text = aStrParam(0)		]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CheckMCCOImageReference(CurrentObj,L1)	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) Then]]>
<![CDATA[
]]>
<![CDATA[		ValueUp.text = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[		Call ShowRect (v1_left, v1_top, v1_right, v1_bottom)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SelectSnippet = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SelectSnippet")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="DefaultValue" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA['    The String value assigned to the bound <b>Field</b> object of the Document Hierarchy ]]>
<![CDATA[
]]>
<![CDATA['    that represents the current field.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) Then Valuetxt.text = strParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text = StrParam]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) Then ValueUp.text = StrParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	DefaultValue = True]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="MaxLength" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'An Integer specifying the maximum number of characters the word can contain.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim wCount, msg]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = " "]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	MaxLength = False ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	wCount = clng(LenT(GetCurrValue()))]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[	If IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		If wCount <= CLng(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[			MaxLength = True]]>
<![CDATA[
]]>
<![CDATA[			msg = vbCr & "MaxLength returns TRUE."]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			If wCount >= CLng(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[				bOverride=False]]>
<![CDATA[
]]>
<![CDATA[				msg = vbCr & "MaxLength returns FALSE."]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		msg = "Parameter is not Numeric, MaxLength returns False."]]>
<![CDATA[
]]>
<![CDATA[		writelog(msg)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	writelog("MaxLength: Set to " & StrParam & " Characters. Count is " & wCount & ". " & msg)]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="MinLength" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'An Integer specifying the minimum number of characters the word can contain.  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim wCount, msg]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = " "]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	MinLength = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	wCount = clng(LenT(GetCurrValue()))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		If wCount >= clng(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[			MinLength = True]]>
<![CDATA[
]]>
<![CDATA[			msg = vbCr & "MinLength returns TRUE."]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			msg = vbCr & "MinLength returns FALSE."]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		msg = "Parameter is not Numeric, MinLength returns False."]]>
<![CDATA[
]]>
<![CDATA[		Writelog(msg)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("MinLength: Set to " & StrParam & " Characters. Count is " & wCount & ". " &  msg)]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="IsCurrency" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  This CCO action determines if the value of the located word is 100% numeric and ]]>
<![CDATA[
]]>
<![CDATA[  '  includes a two-digit decimal amount.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  '  The field must contain a two digit currency value.  The decimal separator can be a period or]]>
<![CDATA[
]]>
<![CDATA[  '  comma.  The action will ignore leading and trailing spaces.  The field cannot contain]]>
<![CDATA[
]]>
<![CDATA[  '  a currency symbol.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	IsCurrency = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentValue = GetCurrValue()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalStrings.RegExIsMatch(CurrentValue,"[^\p{N}\p{Sc}\.\,\'\s]") Then]]>
<![CDATA[
]]>
<![CDATA[		If Len(Trim(CurrentValue))>=3 Then]]>
<![CDATA[
]]>
<![CDATA[			If Left(Right(CurrentValue,3),1) = "." Or Left(Right(CurrentValue,3),1) = "," Then]]>
<![CDATA[
]]>
<![CDATA[				IsCurrency = True]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("IsCurrency returns " & IsCurrency)]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function IsCurrency")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="ScanRT" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ' Numeric value of the number of words to be evaluated to the right of the current word.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   ' ScanRT (scan right) looks for a word or words in positions that are slightly above or below the ]]>
<![CDATA[
]]>
<![CDATA[   ' line on which the current word rests.]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim Up_xL,Up_yB,Dn_xL,Dn_yT,CM,CR,DistUp,DistDN,l,w]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ScanRT=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Check the parameter is numeric (default to 1 if not)]]>
<![CDATA[
]]>
<![CDATA[  If Not IsNumeric(Strparam) Or Len(Trim(Strparam)) = 0 Then StrParam = "1"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  '///Word Code Relationship Diagram -]]>
<![CDATA[
]]>
<![CDATA[	'///WordCode:     Ln   LL	Hn   RR    Rn       Ln     LS      RS     Rn      HL    RH        HH]]>
<![CDATA[
]]>
<![CDATA[	'///TargetWord-> ---- ----  --  ----  ----  :  ----  ------  ------  ---- :  ----  ----  :  ------  	]]>
<![CDATA[
]]>
<![CDATA[	'///CurrentCCO->          ------                        ---------            ----------     ------]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[  ScanRT = True]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If JumpToWordH(bInteractive, bDebug,  CLng(strParam)) Then	]]>
<![CDATA[
]]>
<![CDATA[    'go right n words on same line]]>
<![CDATA[
]]>
<![CDATA[  elseif CodeUP("R1",1) And NoCodeUP("L,S,H",1) And CodeDN("R1",1) And NoCodeDN("L,S,H",1) Then]]>
<![CDATA[
]]>
<![CDATA[    writelog("find closest R1 word coordinates")	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[			Call CCO.GetCurrentPosition(L1,W1,L2,W2)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[			If L1=0 then L1=1]]>
<![CDATA[
]]>
<![CDATA[			If L2=0 then L2=1]]>
<![CDATA[
]]>
<![CDATA[			If W1=0 then W1=1]]>
<![CDATA[
]]>
<![CDATA[			If W2=0 then W2=1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Up_xL = CCO.Item(L2-1).Item( (InStr(LineMapUp(1),"R1")+2) /3).Left]]>
<![CDATA[
]]>
<![CDATA[			Up_yB = CCO.Item(L2-1).Item( (InStr(LineMapUp(1),"R1")+2) /3).bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Dn_xL = CCO.Item(L2+1).Item( (InStr(LineMapDN(1),"R1")+2) /3).Left]]>
<![CDATA[
]]>
<![CDATA[			Dn_yT = CCO.Item(L2+1).Item( (InStr(LineMapDN(1),"R1")+2) /3).Top]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			CM = CCO.Item(L2).Item(W2).Bottom - CCO.Item(L2).Item(W2).Top]]>
<![CDATA[
]]>
<![CDATA[			CR = CCO.Item(L2).Item(W2).Right]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			DistUp = ( (Up_xL-CR)^2 + (Up_yB-CM)^2 )]]>
<![CDATA[
]]>
<![CDATA[			DistDN = ( (Dn_xL-CR)^2 + (Dn_yT-CM)^2 )]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			writelog(Space(4) & "DistUP: " & DistUp & "   DistDN: " & DistDN)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			If CLng(DistUP) > CLng(DistDN) Then ]]>
<![CDATA[
]]>
<![CDATA[				writelog(Space(6) & "UPto")]]>
<![CDATA[
]]>
<![CDATA[				Call GoUpTo(bInteractive, bDebug,"R1,1") ]]>
<![CDATA[
]]>
<![CDATA[			Else ]]>
<![CDATA[
]]>
<![CDATA[				writelog(Space(6) & "DNto")]]>
<![CDATA[
]]>
<![CDATA[				Call GoDnTo(bInteractive, bDebug,"R1,1")]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		elseif CodeUP("R1",1) And NoCodeUP("L,S,H",1) And countUP(1)=1 Then]]>
<![CDATA[
]]>
<![CDATA[			writelog(Space(4) & "CodeUP('R1',1) And NoCodeUP('L,S,H',1)")]]>
<![CDATA[
]]>
<![CDATA[			If countUP(1) = 1 Then Call GoUpTo(bInteractive, bDebug,"R1,1") 	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		elseif CodeDN("R1",1) And NoCodeDN("L,S,H",1) And countDN(1) = 1  Then]]>
<![CDATA[
]]>
<![CDATA[			writelog(Space(4) & "CodeDN('R1',1) And NoCodeDN('L,S,H',1)")]]>
<![CDATA[
]]>
<![CDATA[			If countDN(1) = 1 Then Call GoDnTo(bInteractive, bDebug,"R1,1")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		elseif CodeUP("R1",1) And NoCodeUP("S,LL,H",1) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog(Space(4) & "CodeUP('R1',1) And NoCodeUP('S,LL,H',1)") 	]]>
<![CDATA[
]]>
<![CDATA[			Call GoUpto(bInteractive, bDebug,"R1,1")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		elseif CodeDN("R1",1) And NoCodeDN("S,LL,H",1) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog(Space(4) & "CodeUP('R1',1) And NoCodeUP('S,LL,H',1)") 	]]>
<![CDATA[
]]>
<![CDATA[			Call GoDNto(bInteractive, bDebug,"R1,1")]]>
<![CDATA[
]]>
<![CDATA[ 						]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			ScanRT = False]]>
<![CDATA[
]]>
<![CDATA[			writelog(Space(4) & "ScanRT = False")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ScanRT returns "  & ScanRT)]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function ScanRT")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="GroupWords" access="public" bInter="bInter" bDebug="bDebug" strParam="nSpaces">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Long value of the maximum character width separating words to the right and left of the current word.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    'Groups any words to the left and right of a located word if the target words are]]>
<![CDATA[
]]>
<![CDATA[    'themselves separated by a character width equal to or less than the character]]>
<![CDATA[
]]>
<![CDATA[    'width you specify as a parameter.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GroupWords = GroupCCOWords(nSpaces, "ALL") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GroupNextWords" access="public" bInter="bInter" bDebug="bDebug" strParam="nSpaces">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   ' Long value of the maximum character width separating words to the right of the current word.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   ' Groups words to the right of the located word if the target words are separated]]>
<![CDATA[
]]>
<![CDATA[   ' by a character width equal to or less than the character width you specify as a parameter.]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[	GroupNextWords = GroupCCOWords(nSpaces, "RIGHT") ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function GroupNextWords")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="GroupWordsRIGHT" access="public" bInter="bInter" bDebug="bDebug" strParam="nSpaces">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   ' Long value of the maximum character width separating words to the right of the current word.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   ' Groups words to the right of the located word if the target words are separated]]>
<![CDATA[
]]>
<![CDATA[   ' by a character width equal to or less than the character width you specify as a parameter.]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[	GroupWordsRIGHT = GroupCCOWords(nSpaces, "RIGHT") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GroupPreviousWords" access="public" bInter="bInter" bDebug="bDebug" strParam="nSpaces">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Long value of the maximum character width separating words to the left of the current word.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Groups only words to the left of the located word if the target words are]]>
<![CDATA[
]]>
<![CDATA[  '  separated by a character width equal to or less than the character width you specify as a parameter.]]>
<![CDATA[
]]>
<![CDATA[  '  GroupWordsLEFT was changed to GroupPreviousWords so the functionality makes sense for LTR and RTL text.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GroupPreviousWords = GroupCCOWords(nSpaces, "LEFT") ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function GroupPreviousWords")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="GroupWordsLEFT" access="public" bInter="bInter" bDebug="bDebug" strParam="nSpaces">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Long value of the maximum character width separating words to the left of the current word.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Groups only words to the left of the located word if the target words are]]>
<![CDATA[
]]>
<![CDATA[  '  separated by a character width equal to or less than the character width you specify as a parameter.]]>
<![CDATA[
]]>
<![CDATA[  '  This action has been deprecated and replaced by the new action GroupPreviousWords to make it clearer in the case of BiDi text.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GroupWordsLEFT = GroupCCOWords(nSpaces, "LEFT") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsValue" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  '  The value to be compared to the object's recognized value.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Determines if the recognized value of a word of the current page is identical ]]>
<![CDATA[
]]>
<![CDATA[  '  to the value you enter as a parameter.]]>
<![CDATA[
]]>
<![CDATA[  '  If you want to check only a subset of the field, use ValueInField.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Dim lenV, ValueUP, cntV]]>
<![CDATA[
]]>
<![CDATA[	IsValue = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  value = GetCurrValue() ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  value = Trim(value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(2) & "Looking for '" & Strparam & "'. Current CCO value is '" & value & "'.")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Ucase(strParam) = Ucase(value) Then IsValue = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) Then]]>
<![CDATA[
]]>
<![CDATA[		Call ShowCurrPosFromCCO()]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsValue_RegEx" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    A Regular Expression that will be used for comparison with the recognized value of the word.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA['    Determines if the recognized value of a word of the current page is identical]]>
<![CDATA[
]]>
<![CDATA['    to the value you enter as a parameter.  The parameter will be evaluated as]]>
<![CDATA[
]]>
<![CDATA['    as regular expression when compared to the recognized text.]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[  Dim bFound]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsValue_RegEx = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Search Value:" & StrParam)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sValue= Replace(GetCurrValue,"~"," ")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[  WriteLog(Space(2) & "Looking for " & Strparam & ". Current CCO value is " & svalue)]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[	IgnoreCase = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  bFound = g_ValueMatch(sValue, StrParam, IgnoreCase)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		IsValue_RegEx = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Matches Found")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) Then]]>
<![CDATA[
]]>
<![CDATA[		Call ShowCurrPosFromCCO()]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="ValueInField" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ 'The value that is to be matched with a portion of the value in the current field.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   Checks if the parameter you enter is within the value of the current field represented ]]>
<![CDATA[
]]>
<![CDATA[ '   by the bound <b>Field</b> object of the Document Hierarchy.  Only a portion of the field's]]>
<![CDATA[
]]>
<![CDATA[ '   value needs to match the parameter.  If the entire field must match, use IsValue.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim modStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim Match]]>
<![CDATA[
]]>
<![CDATA[	Dim Matches]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ValueInField = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sValue= Space(1) & Replace(GetFieldValue,"~"," ")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Look in string: " & sValue)		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Check for and protect against RegEx reserved characters]]>
<![CDATA[
]]>
<![CDATA[	StrParam = DCGlobalStrings.RegExEscape(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Parameter after regex escape: " & StrParam)		]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	IgnoreCase = True]]>
<![CDATA[
]]>
<![CDATA[	bFound = g_ValueMatch(sValue, StrParam, IgnoreCase)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		ValueInField = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Matches Found")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="ValueInField_RegEx" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    The portion of the value to find in the field.  The parameter is expected]]>
<![CDATA[
]]>
<![CDATA['    to be expressed as a regular expression.  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    This action checks if the Regular Expression you specify as the parameter ]]>
<![CDATA[
]]>
<![CDATA['    is equivalent to the value of the current field.  Only a part of the field must match]]>
<![CDATA[
]]>
<![CDATA['    the parameter.  To match the entire value of the field, use IsValueRegEx.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ValueInField_RegEx = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Search Value:" & StrParam)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sValue= Space(1) & Replace(GetFieldValue,"~"," ")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Look in string: " & sValue)		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IgnoreCase = True]]>
<![CDATA[
]]>
<![CDATA[	bFound = g_ValueMatch(sValue, StrParam, IgnoreCase)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		ValueInField_RegEx = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Matches Found")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ValueInField_Fuzzy" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    'String value to be matched to the current field's value, using fuzzy matching procedures.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    'Checks if there is a "fuzzy" match of the parameter's value with the value in the current field.]]>
<![CDATA[
]]>
<![CDATA[    'Only a portion of the field's value needs to match.]]>
<![CDATA[
]]>
<![CDATA[    'The match is performed by allowing for common substitutions that can occur during]]>
<![CDATA[
]]>
<![CDATA[    'recognition.  These substitutions include characters: B8, Z2, S5, oO0 and iItl1.]]>
<![CDATA[
]]>
<![CDATA[    	]]>
<![CDATA[
]]>
<![CDATA[	Dim modStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim Match]]>
<![CDATA[
]]>
<![CDATA[	Dim Matches]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[	Dim oValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ValueInField_Fuzzy = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Original Value:" & StrParam)]]>
<![CDATA[
]]>
<![CDATA[	modStrParam = RegExBuild(bInteractive, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sValue= Space(1) & Replace(GetFieldValue,"~"," ")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Look in string: " & sValue)		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IgnoreCase = True]]>
<![CDATA[
]]>
<![CDATA[	bFound = g_ValueMatch(sValue, modStrParam, IgnoreCase)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		ValueInField_Fuzzy = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("No Matches Found")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
	</g>
</af>
<af name="WordFind_Offset" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    1. String value of a keyword that the action is to find on both the fingerprint and recognized image.]]>
<![CDATA[
]]>
<![CDATA['    2. An optional parameter that specifies the offset threshold.  If not specified, the default value is 100 pixels.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    This action locates a word or phrase on both the recognized page and on the fingerprint.]]>
<![CDATA[
]]>
<![CDATA['    The positioning of both locations are compared to determine an offset value.  The calculated]]>
<![CDATA[
]]>
<![CDATA['    difference is stored in the DCO of the current page in the variable Image_Offset.  This value]]>
<![CDATA[
]]>
<![CDATA['    will be used by subsequent actions, such as ReadZones, to compensate for ]]>
<![CDATA[
]]>
<![CDATA['    the difference so the field data is properly located.]]>
<![CDATA[
]]>
<![CDATA[  		]]>
<![CDATA[
]]>
<![CDATA[	Dim oPage]]>
<![CDATA[
]]>
<![CDATA[	Dim nThreshold]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim Temp_CCO]]>
<![CDATA[
]]>
<![CDATA[	Dim L,W]]>
<![CDATA[
]]>
<![CDATA[	Dim nLiveTop, nLiveLeft]]>
<![CDATA[
]]>
<![CDATA[	Dim nFPIDTop, nFPIDLeft]]>
<![CDATA[
]]>
<![CDATA[	Dim nFPID]]>
<![CDATA[
]]>
<![CDATA[	Dim sFPIDFile]]>
<![CDATA[
]]>
<![CDATA[	Dim sSQL, aResult]]>
<![CDATA[
]]>
<![CDATA[	Dim nOffSetX, nOffSetY]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WordFind_Offset = TRUE]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While not(oPage.ObjectType<=2)	]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oPage.Parent()	]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Check for page object]]>
<![CDATA[
]]>
<![CDATA[	If oPage.ObjectType <>2 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Calling DCO must be of Type PAGE")]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Check if page has a fingerprint ID]]>
<![CDATA[
]]>
<![CDATA[	nFPID = oPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(nFPID)=0 or Not(Isnumeric(nFPID)) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("FingerPrint ID not found on Run Time CCO. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Split & Check Parameters]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & "," , ",")]]>
<![CDATA[
]]>
<![CDATA[	sKeyWord = aStrparam(0)]]>
<![CDATA[
]]>
<![CDATA[	nThreshold = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(nThreshold)=0 or Not(Isnumeric(nThreshold)) Then]]>
<![CDATA[
]]>
<![CDATA[		nThreshold = cint(100)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Distance Threshold is set to '" & nThreshold & "' pixels.") ]]>
<![CDATA[
]]>
<![CDATA[		nThreshold = cint(nThreshold)		]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Find Word & Positions on Live CCO]]>
<![CDATA[
]]>
<![CDATA[	If Not(WordFind(bInter, bDebug,sKeyWord)) Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Keyword not found on Run Time CCO. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(L,W)]]>
<![CDATA[
]]>
<![CDATA[	If L=0 then L=1]]>
<![CDATA[
]]>
<![CDATA[	If W=0 then W=1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nLiveTop = CCO.Item(L).Item(W).Top]]>
<![CDATA[
]]>
<![CDATA[	nLiveLeft = CCO.Item(L).Item(W).Left]]>
<![CDATA[
]]>
<![CDATA[	Writelog("LiveX=" & nLiveLeft & ", LiveY=" & nLiveTop)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find & Load Fingerprint CCO file]]>
<![CDATA[
]]>
<![CDATA[	sSQL = "SELECT tp_CCOPath FROM Template WHERE tp_TemplateID=" & nFPID & ";"]]>
<![CDATA[
]]>
<![CDATA[	aResult = GetDataArray(sSQL)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(aResult(0,0)) or aResult(0,0)="" then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Null or Empty Value returned from DB FPID file lookup. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sFPIDFile = aResult(0,0)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not FileMgr.FileExists(sFPIDFile) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("File:" & sFPIDFile & " not found. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set Temp_CCO = CCO]]>
<![CDATA[
]]>
<![CDATA[	Set CCO = CCOCreator.Load(sFPIDFile)]]>
<![CDATA[
]]>
<![CDATA[	If CCO is Nothing Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("FPID CCO could not be loaded. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Set CCO = Temp_CCO]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find Word & Positions on FPID CCO]]>
<![CDATA[
]]>
<![CDATA[	If Not(WordFind(bInter, bDebug,sKeyWord)) Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Keyword not found on FPID CCO. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Set CCO = Temp_CCO]]>
<![CDATA[
]]>
<![CDATA[		Set Temp_CCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(L,W)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If L=0 then L=1]]>
<![CDATA[
]]>
<![CDATA[	If W=0 then W=1]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nFPIDTop = CCO.Item(L).Item(W).Top]]>
<![CDATA[
]]>
<![CDATA[	nFPIDLeft = CCO.Item(L).Item(W).Left]]>
<![CDATA[
]]>
<![CDATA[	Writelog("FPIDX=" & nLiveLeft & ", FPIDY=" & nLiveTop)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Switch Page CCO back]]>
<![CDATA[
]]>
<![CDATA[	Set CCO = Temp_CCO]]>
<![CDATA[
]]>
<![CDATA[	Set Temp_CCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Compare Live vs. FPID and calculate Offset]]>
<![CDATA[
]]>
<![CDATA[	nOffSetX = nFPIDLeft - nLiveLeft]]>
<![CDATA[
]]>
<![CDATA[	nOffSetY = nFPIDTop - nLiveTop]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (abs(nOffSetX)<= nThreshold) and (abs(nOffSetX)<= nThreshold) then]]>
<![CDATA[
]]>
<![CDATA[		oPage.Variable("Image_Offset") = cstr(nOffsetX) & "," & cstr(nOffSetY)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("New OffSet Calculated: (" & cstr(nOffsetX) & "," &  cstr(nOffSetY) & ").")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("OffSet (" & cstr(nOffsetX) & "," &  cstr(nOffSetY) & ") was beyond the Set threshold. Exiting Action")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WordFind_Offset = True]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<f name="AggregateKeyList" access="public">
	<p name="SearchAll" type="bool">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ' Toggles Key list searches to merge all words in the list into a single query.]]>
<![CDATA[
]]>
<![CDATA[  	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	g_bAggregateListSearch=SearchAll]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  AggregateKeyList=True		]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="SetVirtualPageStartPosition" access="public">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ' This action identifies the current position of the locate cursor as the start of the VPB. Before calling this action, ]]>
<![CDATA[
]]>
<![CDATA[  ' the user will use the standard locate actions to locate the starting position of the VPB.  Internally this will ]]>
<![CDATA[
]]>
<![CDATA[  ' simply setup a variable that remembers the current locate position.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  SetVirtualPageStartPosition = false]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType < 2) Then ]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Only page or field level is supported.")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.GetCurrentPosition(g_Saved_VPBStart_L1,g_Saved_VPBStart_W1,g_Saved_VPBStart_L2,g_Saved_VPBStart_W2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' do we care if a locate hasn't been performed? Probably not.]]>
<![CDATA[
]]>
<![CDATA[	writelog("Saved current CCO Pos: " & g_Saved_VPBStart_L1 & "," & g_Saved_VPBStart_W1 & " to " & g_Saved_VPBStart_L2 & "," & g_Saved_VPBStart_W2)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetDocumentStuctureWordToCCOWord]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if IsAlive(g_DLayout) Then ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Saving information for VPB Start.") 	]]>
<![CDATA[
]]>
<![CDATA[     SetVirtualPageStartPosition = g_DLayout.VPBSaveStartPosition() ]]>
<![CDATA[
]]>
<![CDATA[  Else   ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Error: The layout object was not loaded. Returning false.") 	]]>
<![CDATA[
]]>
<![CDATA[  End If  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetVirtualPageStartPosition")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="SetVirtualPageEndPosition" access="public">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ' This action identifies the current position of the locate cursor as the end of the VPB.  ]]>
<![CDATA[
]]>
<![CDATA[  ' Before calling this action, the user will use the standard locate actions to find the end of the VPB. ]]>
<![CDATA[
]]>
<![CDATA[  ' Internally this will set an internal variable to the ending position of the block.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  SetVirtualPageEndPosition = false]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType < 2) Then ]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Only page or field level is supported.")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.GetCurrentPosition(g_Saved_VPBEnd_L1,g_Saved_VPBEnd_W1,g_Saved_VPBEnd_L2,g_Saved_VPBEnd_W2)]]>
<![CDATA[
]]>
<![CDATA[	writelog("Saved current CCO Pos: " & g_Saved_VPBEnd_L1 & "," & g_Saved_VPBEnd_W1 & " to " & g_Saved_VPBEnd_L2 & "," & g_Saved_VPBEnd_W2)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetDocumentStuctureWordToCCOWord]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if IsAlive(g_DLayout) Then ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Saving information for VPB End.") 	]]>
<![CDATA[
]]>
<![CDATA[     SetVirtualPageEndPosition =  g_DLayout.VPBSaveEndPosition()   ]]>
<![CDATA[
]]>
<![CDATA[  Else   ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Error: The layout object was not loaded. Returning false.") 	]]>
<![CDATA[
]]>
<![CDATA[  End If  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function SetVirtualPageStartPosition")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="CreateVirtualZone" access="public">
	<p name="sFieldName">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ' This action requires that SetVirtualPageStartPosition and SetVirtualEndPosition have been called.  ]]>
<![CDATA[
]]>
<![CDATA[  ' This action then does the work to create the field and set the zone coordinates to the position, ]]>
<![CDATA[
]]>
<![CDATA[  ' based on the virtual page coordinates.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  CreateVirtualZone = false]]>
<![CDATA[
]]>
<![CDATA[  if (not LoadDocStructurePage) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function  ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[  ' This action must be called on page or field level.]]>
<![CDATA[
]]>
<![CDATA[  sPageType = MetaWord(sPageType)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if IsAlive(g_DLayout) Then ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Creating VPB") 	]]>
<![CDATA[
]]>
<![CDATA[     g_DLayout.DatacapRRCurrentDCO = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[     g_DLayout.DatacapRRDCO = DCO]]>
<![CDATA[
]]>
<![CDATA[     CreateVirtualZone = g_DLayout.VPBCreateVirtualZone(sFieldName) ]]>
<![CDATA[
]]>
<![CDATA[  Else   ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Error: The layout object was not loaded. Returning false.") 	]]>
<![CDATA[
]]>
<![CDATA[  End If  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (CreateVirtualZone) Then   ]]>
<![CDATA[
]]>
<![CDATA[     'Get the child field object]]>
<![CDATA[
]]>
<![CDATA[     Set theField = CurrentObj.FindChild(sFieldName)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("----- SnapCCO2DCO for: " & theField.ID & " -----")]]>
<![CDATA[
]]>
<![CDATA[     goSnapper.SnapCCOtoDCO theField]]>
<![CDATA[
]]>
<![CDATA[  End If     ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function CreateVirtualZone")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="CreateVirtualPage" access="public">
	<p name="sPageType">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ' This action requires that SetVirtualPageStartPosition and SetVirtualEndPosition have been called.  ]]>
<![CDATA[
]]>
<![CDATA[  ' This action then does the work to create the extracted portion of the text, ]]>
<![CDATA[
]]>
<![CDATA[  ' creating the new page that contains only the designated block.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  CreateVirtualPage = false]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[  ' Because start and end must be previously called, this action can be run on any level.]]>
<![CDATA[
]]>
<![CDATA[  sPageType = MetaWord(sPageType)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if IsAlive(g_DLayout) Then ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Creating VPB") 	]]>
<![CDATA[
]]>
<![CDATA[     g_DLayout.DatacapRRCurrentDCO = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[     g_DLayout.DatacapRRDCO = DCO]]>
<![CDATA[
]]>
<![CDATA[     CreateVirtualPage = g_DLayout.VPBCreateVirualPage(Pilot.BatchDir, sPageType) '(DCO) ]]>
<![CDATA[
]]>
<![CDATA[  Else   ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Error: The layout object was not loaded. Returning false.") 	]]>
<![CDATA[
]]>
<![CDATA[  End If  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function CreateVirtualPage")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="LocatePositionSave" access="public">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  LocatePositionSave = false]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType < 2) Then ]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Only page or field level is supported.")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.GetCurrentPosition(g_Saved_L1,g_Saved_W1,g_Saved_L2,g_Saved_W2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' do we care if a locate hasn't been performed? Probably not.]]>
<![CDATA[
]]>
<![CDATA[	writelog("Saved current CCO Pos: " & g_Saved_L1 & "," & g_Saved_W1 & " to " & g_Saved_L2 & "," & g_Saved_W2)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if IsAlive(g_DLayout) Then ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Saving current block information") 		]]>
<![CDATA[
]]>
<![CDATA[     Call g_DLayout.BlockPositionSave()]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  LocatePositionSave = true]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function LocatePositionSave")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="LocatePositionRestore" access="public">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  LocatePositionRestore = false]]>
<![CDATA[
]]>
<![CDATA[  If IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType < 2) Then ]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Only page or field level is supported.")]]>
<![CDATA[
]]>
<![CDATA[     exit function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call CCO.SetCurrentPosition(g_Saved_L1,g_Saved_W1,g_Saved_L2,g_Saved_W2) ]]>
<![CDATA[
]]>
<![CDATA[	writelog("Restored CCO Pos: " & g_Saved_L1 & "," & g_Saved_W1 & " to " & g_Saved_L2 & "," & g_Saved_W2)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if IsAlive(g_DLayout) Then ]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Saving current block information") 		]]>
<![CDATA[
]]>
<![CDATA[     Call g_DLayout.BlockPositionRestore()]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  LocatePositionRestore = true]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function LocatePositionRestore")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="Find_IgnoreCase" access="public">
	<p name="IgnoreCase" type="bool">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ' Toggles regular expression searches character case default.]]>
<![CDATA[
]]>
<![CDATA[  	  ' By default searches are case sensitive.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	g_LocateIgnoreCase=IgnoreCase]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Find_IgnoreCase=True		]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<help>
<![CDATA[
'************************************************************
' help.xml for Locate 

' Licensed Materials - Property of IBM
' â€œRestricted Materials of IBMâ€
' 5725-C15 5725-C69
'
' Â© Copyright IBM Corp. 1994, 2017 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'------------------------------------------------------------
'
' Version 8.0.1.41 
' Updated 12/23/2010 PHofle
' * Converted into a .NET DLL for using resources that allow translation of the Datacap Studio help
'
' Updated 05.17.2011 PHofle
' * fixed help tags
'
' Version 8.1.0.53 
' Updated 4/11/2011 PHofle
' * Fixed help for action SetRect SPR 34347
'
' Version 8.1.0.57 
' Updated 4/19/2011 PHofle
' * Changed help for action UpdateDCOfield to include smartparameter enabled and works
'   at page and field level.
'
' 
'************************************************************
]]>
<ref id="WordFind">
  <ap>
    A word or phrase to find on the page.
  </ap>
  <h>
    The current page is searched to find the whole word or phrase.  The location of the first
    word or phrase that matches the parameter will be remembered so it can be
    utilized by subsequent actions.  Matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur. 
    Will only match values with whole word boundries, ie will not search for 
    parts of a word or characters within words.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e>
      <b>WordFind("Sales Tax")</b><br/>
      <scr>GoRightWord("1")</scr><br/>
      <scr>IsCurrency()</scr><br/>
      <scr>UpdateField</scr><br/><br/>

      In this example, the WordFind action looks for the first occurrence of
      "Sales Tax" within the current page, always starting at the first word of the page.
      If the phrase "Sales Tax" is found, the subsequent actions will operate based
      on the location of the found phrase.
    </e>
  </h>
  <lvl>Page or Field level.</lvl>
  <ret>
    <b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b>
  </ret>
  <see>
    <scr>WordFindNext</scr>, <scr>FindKeyList</scr>,<scr>AddKeyList</scr>
  </see>
     </ref>
 <ref id="WordFind_InZone">
  <ap>A word or phrase to find in the current zoned field.</ap>
  <h>
    The current field will be searched to find the word or phrase.  The location of the first
    word or phrase that matches the parameter will be remembered so it can be
    utilized by subsequent actions.  Matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>WordFind_InZone("Sub Total")</b><br/>
      GoRightWord("1")<br/>
      IsCurrency()
      In this example, the WordFind action looks for the first occurrence of
      "Sub Total" within the current field, always starting at the first word of the zone.
      If the phrase "Sub Total" is found, the subsequent actions will operate based
      on the location of the found phrase.
    </e>
    </h>
    <lvl>Page or field</lvl>
    <ret><b>True</b> if the word or phrase is located in the field. Otherwise, <b>False.</b></ret>
    <see><scr>WordFind, WordFindNext, WordFindNext_InZone</scr>
    </see>
     </ref>
 <ref id="WordFindNext">
  <ap>A word or phrase to find on the page, following a previously found word or phrase.</ap>
  <h>
    The current page will be searched to find the word or phrase, starting from the location
    remembered from the last search, such as from WordFind.  The location of the first
    word or phrase that matches the parameter will now be remembered so it can be
    utilized by subsequent actions.
    Matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><scr>WordFind("Total")</scr>
    <br/><b>WordFindNext("Total")</b><br/><b>WordFindNext("Total")</b><br/><scr>GoRightWord("1")</scr>
    <br/><scr>IsCurrency()</scr>
    <br/><scr>UpdateField</scr>
    <br/><br/>

      In this sequence, the Locate rule locates the third instance of 
      the word "Total" in the current page.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the parameter is located. Otherwise, <b>False.</b></ret>
    <see><scr>WordFind</scr>
    , <scr>FindLastWord</scr>
    </see>
     </ref>
 <ref id="WordFindNext_InZone">
  <ap>A word or phrase to find in the current field, following a previously found word or phrase.</ap>
  <h>
    The current field will be searched to find the word or phrase, starting from the
    remembered location of a previous find.  The new location of the first
    word or phrase in the field that matches the parameter will now be remembered so it can be
    utilized by subsequent actions.    
    Matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e>
      WordFind_InZone(ItemID)<br/>
      WordFindNext_InZone(Desc)<br/><br/>
      
      In this example, the WordFind_InZone action looks for the first occurrence of
      "ItemID" within the current field, always starting at the first word of the zone.
      If the phrase "ItemID" is found, the word "Desc" will be looked for in the
      current field, starting after the location of "ItemID".  If "Desc" is found,
      any subsequent actions will operate based
      on the location of that found phrase.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if the parameter is located. Otherwise, <b>False.</b></ret>
    <see><scr>WordFind_InZone</scr>
    , <scr>FindLastWord_InZone</scr>
    </see>
     </ref>
 <ref id="RegExFind">
  <ap>
    A word or phrase to find on the current page.  The parameter is expected to be
    a Regular Expression.
  </ap>
  <h>
    Locates the first occurrence of a word or phrase on the current page where the input search term
    is specified as a regular expression.
    The search is started from the first word on the current page.  The location of the 
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.
    <e><b>RegExFind("Da.e")</b><br/>
      GoRightWord("1")<br/>
      IsDateValue()<br/>
      UpdateField()<br/><br/>
      RegExFind will look for the first occurrence of a word or phrase that matches the regular expression.
      If a match is found, it continues processing by moving one word to the right of the result
      of RegExFind and acts on that word.  If it is a date format, UpdateField will place the
      value into the current field.      
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList, RegExFind_InZone, RegExFindNext.
  </see>
     </ref>
 <ref id="RegExFind_InZone">
  <ap>
    A word or phrase to find in the current field.  The parameter is expected to be
    a Regular Expression.
  </ap>
  <h>
    Locates the first occurrence of a word or phrase in the current field where the input 
    search term is specified as a regular expression.
    The search is started from the first word of the current field.  The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.
    <e><b>RegExFind_InZone("Da.e")</b><br/>
      GoRightWord("1")<br/>
      IsDateValue()<br/>
      UpdateField()<br/><br/>
      RegExFind_InZone will look for the first occurrence of a word or phrase that matches 
      the regular expression. If a match is found, it will continue processing by moving 
      one word right of the result of RegExFind and act on that word.  If it is a date 
      format, UpdateField will place the value into the current field.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if the word or phrase is located in the current field. Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList, RegExFindNext_InZone.
  </see>
     </ref>
 <ref id="RegExFindNext">
  <ap>
    A word or phrase to find on the current page.  The parameter is expected to be
    a Regular Expression.
  </ap>
  <h>
    Starting from the location of a previously found word or phrase, this action locates the first
    occurrence of a word or phrase on the current page where the input search term
    is specified as a regular expression.
    The search is started from the location of a previously found word or phrase.  The 
    location of the found word or phrase will now be remembered so the result can be used 
    by subsequent actions. The search is case sensitive.
    <e>
      RegExFind("ItemID")<br/><b>RegExFindNext("Desc")</b><br/><br/>
      In this sequence, the first action looks for "ItemID". If the search
      succeeded, RegExFindNext looks for the first occurrence of "Desc" that comes after "ItemID".
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList, RegExFind_InZone, RegExFindNext.
  </see>
     </ref>
 <ref id="RegExFindNext_InZone">
  <ap>
    A word or phrase to find in the current field.  The parameter is expected to be
    a Regular Expression.
  </ap>
  <h>
    Starting from the location of a previously found word or phrase, this action locates the first
    occurrence of a word or phrase in the current field where the input search term
    is specified as a regular expression.
    The search is started from the location of a previously found word or phrase in the current 
    field.  The location of the found word or phrase will be remembered so the result can be 
    used by subsequent actions. The search is case sensitive.
    <e>
      RegExFind_InZone("ItemID")<br/><b>RegExFindNext_InZone("Desc")</b><br/><br/>
      In this sequence, the first action looks for "ItemID". If the search
      succeeded, RegExFindNext looks for the first occurrence of "Desc" that comes after "ItemID".
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList, RegExFind_InZone, RegExFindNext.
  </see>
     </ref>
 <ref id="FindKeyList">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.<br/><br/>
    
    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in 
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases on the current page against the keywords in the list to find a match.
    The location of the found word or phrase that matches an entry in the keyword file 
    will be remembered so the result can be used by subsequent actions.    
    Matching is case sensitive.<br/><br/>

    To improve matching, 
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindKeyList("InvNum")</b><br/><br/>

      This action searches the current page, from first word to the last word of the current page, 
      for the first keyword in the Invoices Number Keyword file (InvNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the next word in InvNum.key, starting from first word
      of the current page, repeating this search pattern until a match is found, 
      or until there are no more keywords.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if at least one word on the page matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindNextKeyList, FindLastKeyList, AddKeyList
  </see>
     </ref>
 <ref id="FindKeyList_InZone">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases, 
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases in the current field of the source page's .cco file against the keywords
    in the key file list to find a match.  The location of the
    found word or phrase that matches an entry in the keyword file
    will be remembered so the result can be used by subsequent actions.    
    Matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindKeyList_InZone("Line_Items")</b><br/><br/>

      This action searches the current bound zone for the
      first keyword in the Keyword file (Line_Items.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the next word in Line_Items.key, from the beginning 
      of the current bound zone, repeating this search pattern until 
      a match is found, or until there are no more keywords.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if at least one word in the current bound zone matches any 
    word or pattern in the Keyword file.  Otherwise, <b>False.</b></ret>
   <see>
     FindNextKeyList, FindLastKeyList, AddKeyList
   </see>
     </ref>
 <ref id="FindNextKeyList">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the words or 
    phrases on the current page against the keywords in the list to find a match.
    The search starts from the last word that had been found using an action such as
    FindKeyList or FindNextKeyList.  The location of the
    found word or phrase that matches an entry in the keyword file
    will be remembered so the result can be used by subsequent actions.
    Matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e>
      FindKeyList("Tax")<br/><b>FindNextKeyList("IRS")</b><br/><br/>

      Starting from the word or phrase that was located in the FindKeyList action, 
      this action searches the current page, starting from that previously found word, for the
      first word or phrase in the first line of the Keyword file (IRS.key).
      If successful, the search stops and remembers the location of that new 
      word for subsequent actions;
      if not, the action continues searching using the next word or phrase in IRS.key, 
      starting again from the location word previously found by FindKeyList(Tax), 
      repeating this search pattern until a match is found,
      or until there are no more keywords in the file.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if at least one word or phrase on the page, starting from the previously located
    word, matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
   <see>
     FindLastKeyList, AddKeyList, FindKeyListInZone, FindNextKeyList_InZone
   </see>
     </ref>
 <ref id="FindNextKeyList_InZone">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases in the current field against the keywords in the list to find a match.
    The search starts from the last word that had been found using an action such as
    FindKeyList_InZone or FindNextKeyList_InZone.  The location of the
    found word or phrase that matches an entry in the keyword file
    will be remembered so the result can be used by subsequent actions.
    Matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e>
      FindKeyList_InZone("Inventory")<br/><b>FindNextKeyList_InZone("Parts")</b><br/><br/>

      This action searches the current field, starting from the first word of the zone, for the
      first occurrence of a word or phrase in the Keyword file "Inventory.key".  If a match is found,
      the application will then look for a word from within the Keyword file "Parts.key",
      starting from the previously found word from the FindKeyList_InZone action and using the
      first word or phrase in the "Parts.key" file.
      If successful, the search stops and remembers the location of the new word for subsequent actions;
      if not, the action continues searching using the next word in "Parts.key", starting again from the
      location of previously found word in the zone, repeating this search pattern until a match is found,
      or until there are no more keywords in the file.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>False</b> if the Fingerprint file(.cco) of the current source 
    page has not been loaded, or is empty. Otherwise, <b>True.</b></ret>
     </ref>
  <see>
    FindLastKeyList, AddKeyList, FindKeyListInZone
  </see>
 <ref id="FindDBList">
  <ap>
    An SQL statement whose result returns a word or phrase, or a list of words or phrases.    
  </ap>
  <h>
    This action issues an SQL query against the lookup database, returning a list
    of words or phrases that will be located on the current page.  The search is performed
    from the first word of the current page.  Initially, the first listed word or phrase
    is searched for on the page.  If there is no match, it will search for the next word or
    phrase returned from the database. This continues until a match is found or none of the returned words
    are contained on the page.  The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindDBList("Select LastName from Providers")</b><br/><br/>
      This example will obtain a list of last names from a provider table and find the first
      matching occurrence on the page.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see>
    FindDBList_InZone, FindNextDBList.
  </see>
     </ref>
 <ref id="FindDBList_InZone">
  <ap>
    An SQL statment whose result returns a word or phrase, or a list of word or phrases.
  </ap>
  <h>
    This action issues an SQL query against the lookup database, returning a list
    of words or phrases that will be located in the current field.  The search is performed
    from the first word of the current field.  Initially, the first listed word or phrase
    is searched for in the field.  If there is no match, it will search for the next word or
    phrase returned from the database.  This continues until a match is found or none of the returned words
    are contained on the page.  The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindDBList("Select LastName from Providers")</b><br/><br/>
      This example will obtain a list of last names from a provider table and find the first
      matching occurrence on the page.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see>
    FindNextDBList_InZone, FindNextDBList.
  </see>
     </ref>
 <ref id="FindNextDBList">
  <ap>
    An SQL statement whose result returns a word or phrase, or a list of word or phrases.
  </ap>
  <h>
    This action issues an SQL query against the lookup database, returning a list
    of words or phrases that will be located on the current page.  Starting from the
    location of a previously found word, the search is performed.
    Initially, the first listed word or phrase from the SQL query
    is searched for on the page.  If there is no match, it will search for the next word or
    phrase returned from the database. This continues until a match is found or none of the returned words
    are contained on the page.  The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e>
      WordFind("Hello")<br/><b>FindNextDBList("Select LastName from Providers")</b><br/><br/>
      This example will first locate the word, "Hello".  Once found, it will then 
      obtain a list of last names from a provider table and find the first
      matching occurrence on the page that occurs after the word "Hello".
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see>
    FindDBList_InZone, FindDBList.
  </see>
     </ref>
 <ref id="FindNextDBList_InZone">
  <ap>
    An SQL statement whose result returns a word or phrase, or a list of word or phrases.
  </ap>
  <h>
    This action issues an SQL query against the lookup database, returning a list
    of words or phrases that will be located on the current field.  Starting from the
    location of a previously found word, the search is performed.
    Initially, the first listed word or phrase from the SQL query
    is searched for on the page.  If there is no match, it will search for the next word or
    phrase returned from the database. This continues until a match is found or none of the returned words
    are contained on the page.  The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e>
      WordFind_InZone("Hello")<br/><b>FindNextDBList("Select LastName from Providers")</b><br/><br/>
      This example will first locate the word, "Hello" in the current field.  Once found, it will then
      obtain a list of last names from a provider table and find the first
      matching occurrence in the field that occurs after the word "Hello".
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if the word or phrase is located in the field. Otherwise, <b>False.</b></ret>
    <see>
    WordFind_InZone, FindDBList.
  </see>
     </ref>
 <ref id="FindRegExList">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases on the current page against the keywords in the list to find a match.  The
    entries in the keyword file are expected to be regular expressions.<br/><br/>

    To perform the action, the search first looks for the first word or phrase in the keyword
    file.  If the word is found on the page, the search stops.  If no match is found,
    the next line from the keyword file is read and again the entire page is searched.  This
    process continues until a match is found or all of the lines in the keyword file have
    been read.  The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    Word matching is case sensitive.<br/><br/><e><b>FindRegExList("InvoiceNum")</b>

      This action searches the current page, from the first word of the current page, for the
      first keyword in the Keyword file (InvoiceNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the next word in InvoiceNum.key, starting from first word
      of the current page, repeating this search pattern until a match is found,
      or until there are no more keywords.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if at least one word on the page matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList_InZone, FindLastKeyList, FindNextRegExList
  </see>
     </ref>
 <ref id="FindRegExList_InZone">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases on the current page against the keywords in the list to find a match.  The
    entries in the keyword file are expected to be regular expressions.<br/><br/>

    To perform the action, the search first looks for the first word or phrase in the keyword
    file.  If the word or phrase is found in the current field zone, the search stops.  If no match is found,
    the next line from the keyword file is read and again the current field zone is searched.  This
    process continues until a match is found or all of the lines in the keyword file have
    been read.  The location of the
    found word or phrase that matches an entry in the keyword file
    will be remembered so the result can be used by subsequent actions.
    Word matching is case sensitive.<br/><br/><e><b>FindRegExList_InZone("InvoiceNum")</b>

      This action searches the current page, from the first word of the current field, for the
      first keyword in the Keyword file (InvoiceNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the next word in InvoiceNum.key, starting from first word
      of the current field, repeating this search pattern until a match is found,
      or until there are no more keywords.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>True</b> if at least one word on the page matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList, FindLastKeyList, FindNextRegExList, AddKeyList
  </see>
     </ref>
 <ref id="FindNextRegExList">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, starting from the location of
    a previous find, this action checks the words or phrases
    on the current page against the keywords in the list to find a match.  The
    entries in the keyword file are expected to be regular expressions.<br/><br/>

    To perform the action, the search first looks for the first word or phrase in the keyword
    file.  Starting from the location of the last find, if the word is found, the search stops.  If no match is found,
    the next line from the keyword file is read and again the search starts from the result of
    a previous find.  This
    process continues until a match is found or all of the lines in the keyword file have
    been read.  The location of the
    found word or phrase that matches an entry in the keyword file
    will be remembered so the result can be used by subsequent actions.
    Word matching is case sensitive.<br/><br/><e>
      FindRegExList("InvoiceNum")<br/><b>FindNextRegExList("InvoiceNum")</b><br/><br/>

      This action searches the current page, starting from the result of the FindRegExList action, for the
      first keyword in the Keyword file (InvoiceNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the next word in InvoiceNum.key, 
      repeating this search pattern until a match is found,
      or until there are no more keywords.  Although this example shows FindNextRegExList 
      using the same keyword file, it is allowed to use a different keyword file.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if at least one word on the page, that follows the result of a previous find,
    matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList_InZone, FindLastKeyList, FindNextRegExList_InZone, AddKeyList
  </see>
     </ref>
 <ref id="FindNextRegExList_InZone">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, starting from the location of
    a previous find, this action checks the words or phrases 
    in the current field against the keywords in the list to find a match.  The
    entries in the keyword file are expected to be regular expressions.<br/><br/>

    To perform the action, the search first looks for the first word or phrase in the keyword
    file.  Starting from the location of the last find, if the word is found, the search stops.  If no match is found,
    the next line from the keyword file is read and again the search starts from the result of
    a previous find.  This
    process continues until a match is found or all of the lines in the keyword file have
    been read.  The location of the
    found word or phrase that matches an entry in the keyword file
    will be remembered so the result can be used by subsequent actions.
    Word matching is case sensitive.<br/><br/><e>
      FindRegExList_InZone("InvoiceNum")<br/><b>FindNextRegExList_InZone("InvoiceNum")</b><br/><br/>

      This action searches the current page, starting from the result of the FindRegExList_InZone action, 
      for the first keyword in the Keyword file (InvoiceNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the next word in InvoiceNum.key,
      repeating this search pattern until a match is found,
      or until there are no more keywords.  Although this example shows FindNextRegExList_InZone
      using the same keyword file, it is allowed to use a different keyword file.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>True</b> if at least one word in the field, that follows the result of a previous find,
    matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList_InZone, FindLastKeyList, FindNextRegExList_InZone, AddKeyList
  </see>
     </ref>
 <ref id="FindLastWord">
  <ap>A word or phrase to find on the page.</ap>
  <h>
    The current page will be searched to find the last occurrence of a word or phrase. 
    The location of the last
    word or phrase that matches the parameter will be remembered so it can be
    utilized by subsequent actions.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindLastWord("Total")</b><br/>
      GoRightWord("1")<br/>
      IsCurrency()<br/><br/>
      
      This sequence finds the last instance of "Total" on the current page; 
      moves right one word; and checks to be sure that the word has a Currency value.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see><scr>WordFind,</scr>
    <scr>WordFindNext</scr>
    </see>
     </ref>
 <ref id="FindLastWord_InZone">
  <ap>The word or phrase to locate within the current zone.</ap>
  <h>
    The current field will be searched to find the word or phrase.  The location of the last
    occurrence of the word or phrase that matches the parameter will be remembered so it can be
    utilized by subsequent actions.
    Word matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindLastWord_InZone("Total")</b><br/>
      GoRightWord("1")<br/>
      IsCurrency()<br/><br/>
      
      This sequence attempts to find the last occurrence of "Total" in the current zone. 
      It then locates and validates a Currency amount for the Total field, assuming
      the currency amount is to the right of the word "Total".
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if the word or phrase is located in the field. Otherwise, <b>False.</b></ret>
    <see><scr>WordFind_InZone,</scr>
    <scr>WordFindNext_InZone</scr>
    </see>
     </ref>
 <ref id="FindLastKeyList">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases, 
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases on the current page against the keywords in the list to find a match.
    The current page will be searched to find the last occurrence of word or phrase.  
    The location of the last occurrence
    word or phrase that matches an entry in the keyword file will be remembered so it can be
    utilized by subsequent actions.
    Word matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>
    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindLastKeyList("InvNum")</b><br/><br/>

      This action searches the current page for the
      last instance of a match with the first keyword in the Keyword file (InvNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching using the next word in InvNum.key, matching the last occurrence
      of the word, repeating this search pattern until a match is found,
      or until there are no more keywords.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if at least one word on the page matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindKeyList, FindNextKeyList, AddKeyList
  </see>
     </ref>
 <ref id="FindLastKeyList_InZone">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases, 
    separated by new lines, that will be used for matching.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases in the current bound zone against the keywords in the list to find a match.
    The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    Word matching is case sensitive.<br/><br/>

    To improve matching,
    this action automatically adjusts the search criteria to allow for
    common character substitutions.  For example, if the list includes
    "will" and the recognition read "wi11", a match will still occur.<br/><br/>

    Common substitutions include characters: B8, Z2, S5, oO0 and iItl1.
    <e><b>FindLastKeyList_InZone("ClaimsData")</b><br/><br/>

      This action searches the current bound zone for the
      last instance of a match with the first keyword in the Keyword file (ClaimsData.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching using the next word in ClaimsData.key, matching the last occurrence
      of the word, repeating this search pattern until a match is found,
      or until there are no more keywords.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if at least one word on the page matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindKeyList_InZone, FindNextKeyList_InZone, AddKeyList
  </see>
     </ref>
 <ref id="FindLastRegEx">
  <ap>
    A word or phrase to find on the current page.  The parameter is expected to be
    a Regular Expression.
  </ap>
  <h>
    Locates the last occurrence of a word or phrase on the current page where the input search term
    is specified as a regular expression.
    The search is started from the first word of the current page.
    The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.
    <e><b>FindLastRegEx("Da.e")</b><br/>
      GoRightWord("1")<br/>
      IsDateValue()<br/>
      UpdateField()<br/><br/>
      FindLastRegEx will look for the last occurrence of a word that matches the regular expression.
      If it match is found, it will continue processing by moving one word right to the result
      of RegExFind and act on that word.  In this example, if it is a date format, 
      UpdateField will place the value into the current field.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList, RegExFind_InZone, RegExFindNext.
  </see>
     </ref>
 <ref id="FindLastRegEx_InZone">
  <ap>
    A word or phrase to find in the current field.  The parameter is expected to be
    a Regular Expression.
  </ap>
  <h>
    Locates the last occurrence of a word or phrase in the current field where the input search term
    is specified as a regular expression.
    The search is started from the first word of the current field.
    The location of the
    found word or phrase will be remembered so the result can be used by subsequent actions.
    The search is case sensitive.
    <e><b>FindLastRegEx_InZone("Da.e")</b><br/>
      GoRightWord("1")<br/>
      IsDateValue()<br/>
      UpdateField()<br/><br/>
      FindLastRegEx will look for the last occurrence of a word that matches the regular expression.
      If it match is found, it will continue processing by moving one word right to the result
      of RegExFind and act on that word.  In this example, if it is a date format,
      UpdateField will place the value into the current field.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if the word or phrase is located in the field. Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList, RegExFind_InZone, RegExFindNext.
  </see>
     </ref>
 <ref id="FindLastRegExList">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.  The entries in the
    keyword file are expected to be regular expressions.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases on the current page against the keywords in the list to find a match.  The
    entries in the keyword file are expected to be regular expressions.<br/><br/>

    To perform the action, the search first looks for the last occurrence of the first word
    or phrase in the keyword file.  If the word is found on the page,
    the search stops at the last occurrence of the word.  If no match is found,
    the next line from the keyword file is read and again the entire page is searched.  This
    process continues until a match is found or all of the lines in the keyword file have
    been read.  The location of the last occurrence of a
    found word or phrase will be remembered so the result can be used by subsequent actions.
    Word matching is case sensitive.<br/><br/><e><b>FindLastRegExList("InvoiceNum")</b>

      This action searches the current page, from the first word of the current page, for the
      last occurrence of the first keyword in the Keyword file (InvoiceNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the last occurrence of the next word in InvoiceNum.key, 
      starting from top of the current page, repeating this search pattern until a match is found,
      or until there are no more keywords.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if at least one word on the page matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList_InZone, FindLastKeyList, FindNextRegExList, AddKeyList
  </see>
     </ref>
 <ref id="FindLastRegExList_InZone">
  <ap>
    The name of the Keyword text file.  The file will contain a list of words or phrases,
    separated by new lines, that will be used for matching.  The entries in the
    keyword file are expected to be regular expressions.<br/><br/>

    The file name can be provided in one of two ways:<br/>
    1. A full path name of the file, including the ".key" extension.<br/>
    2. The file name only, with no extension specified.  The application will look in
    the process directory and the file must have a ".key" extension.
  </ap>
  <h>
    Opens the Keyword file you specify as a parameter, then checks the
    words or phrases in the current field against the keywords in the list to find a match.  The
    entries in the keyword file are expected to be regular expressions.<br/><br/>

    To perform the action, the search first looks for the last occurrence of the first word
    or phrase in the keyword file.  If the word is found on the page,
    the search stops at the last occurrence of the word.  If no match is found,
    the next line from the keyword file is read and again the entire field is searched.  This
    process continues until a match is found or all of the lines in the keyword file have
    been read.
    The location of the last occurrence of a
    found word or phrase will be remembered so the result can be used by subsequent actions.
    Word matching is case sensitive.<br/><br/><e><b>FindLastRegExList_InZone("InvoiceNum")</b>

      This action searches the current page, from the first word of the current page, for the
      last occurrence of the first keyword in the Keyword file (InvoiceNum.key).
      If successful, the search stops and remembers the location of that word for subsequent actions;
      if not, the action continues searching for the last occurrence of the next word in InvoiceNum.key,
      starting from top of the current page, repeating this search pattern until a match is found,
      or until there are no more keywords.
    </e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>True</b> if at least one word in the field matches any word or pattern in the Keyword file.
    Otherwise, <b>False.</b></ret>
    <see>
    FindRegExList_InZone, FindLastKeyList, FindNextRegExList, AddKeyList
  </see>
 </ref>
  
 <ref id="GoPreviousWord">
  <ap>An integer indicating the number of words, that proceed the currently selected word, to position the internal located word position.</ap>
  <h>
    Starting from a word or phrase found by a previous Locate action, the current location position is moved to the previous words on the
    current line by the number of words indicated by the input parameter. Subsequent Locate actions can then
    perform additional operations on this new located word position.<br/><br/>
    
    Regardless of being called at the page or field level,
    this action operates on the recognized text for the current page.<br/><br/>

    The internal location position is moved the the previous word based on the reading order of the text.
    The movement will be perceived as a left directional
    movement on left-to-right text.  The movement will be perceived as a right directional movement on right-to-left text.
    <br/><br/>

    Note: If the action is added with an empty or non-numeric parameter, the action will default the argument to '1'.<br/><br/>

    This action is always called after a search action has been used.
    <e>
      <scr>WordFind("Total")</scr><br/>
      <b>GoPreviousWord("1")</b><br/>
      <scr>GoBelowWord("1")</scr><br/>
      <scr>UpdateField()</scr>
      <br/><br/>

      In this example, the locate action WordFind will search the entire page, from top to bottom,
      looking for the word "Total".  Once found, the internal word pointer will move to the previous
      word, then to the word below the word.  The field associated with this ruleset will have
      it's zone coordinates updated with the position of the current word.
      
      Given this scenario where the page has a table with columns such as Tax and Total similar to this:<br/>
      <b>Tax Total</b><br/>
      344.76  13,774.00<br/>
      The actions above will locate the Tax amount 344.76 and set the field zone to that word.<br/><br/>
      
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if a word is found. Otherwise, <b>False.</b></ret>
    <see>
      GoNextWord, FindWord, FindKeyList
    </see>
 </ref>
  
 <ref id="GoLeftWord">
  <ap>An integer indicating the number of words to move to the left.</ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.
    Instead, use the GoPreviousWord action in the Locate action library.
    <br/><br/>
    
    Starting from a word or phrase found by a previous Locate action, the location position is moved to the left on the
    current line by the number of words indicated by the input parameter. Subsequent Locate actions can then
    perform additional operations on this located word.  Regardless of being called at the page or field level,
    this action operates on the recognized text for the current page.<br/>

    Note: If the action is added with an empty or non-numeric parameter, the action will default the argument to '1'.<br/><br/>

    This action is always called after a search action has been used.
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if a word is found. Otherwise, <b>False.</b></ret>
    <see><scr>GoRightWord</scr>
    , <scr>FindWord</scr>
    , <scr>FindKeyList</scr>
    </see>
 </ref>

  <ref id="GoNextWord">
    <ap>An integer indicating the number of words, that follow the currently selected word, to position the internal located word position.</ap>
    <h>
      Starting from a word or phrase found by a previous Locate action, the selected word location position is moved to the next word on the
      current line by the number of words indicated by the input parameter. Subsequent Locate actions can then
      perform additional operations on this new located word position.<br/><br/>  
      
      Regardless of being called at the page or field level,
      this action operates on the recognized text for the current page.<br/><br/>

      The internal location position is moved the the next word based on the reading order of the text.
      The movement will be perceived as a right directional
      movement on left-to-right text.  The movement will be perceived as a left directional movement on right-to-left text.
      <br/><br/>

      Note: If the action is added with an empty or non-numeric parameter, the action will default the argument to '1'.<br/><br/>

      This action is always called after a search action has been used.
      <e>
        <scr>WordFind("Tax")</scr><br/>
        <b>GoNexttWord("1")</b><br/>
        <scr>GoBelowWord("1")</scr><br/>
        <scr>UpdateField()</scr>
        <br/><br/>

        In this example, the locate action WordFind will search the entire page, from top to bottom,
        looking for the word "Tax".  Once found, the internal word pointer will move to the next
        word, then to the word below the word.  The field associated with this ruleset will have
        it's zone coordinates updated with the position of the current word.

        Given this scenario where the page has a table with columns such as Tax and Total similar to this:<br/>
        <b>Tax &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; Total</b><br/>
        344.76  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0; 13,774.00<br/>
        The actions above will locate the amount 13,774.00 and set the field zone to that word.<br/><br/>
      </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      <b>True</b> if a word is found. Otherwise, <b>False.</b>
    </ret>
  </ref>  
  
 <ref id="GoRightWord">
  <ap>An integer indicating the number of words to move to the right.</ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.
    Instead, use the GoNextWord action in the Locate action library.
    <br/><br/>
    
    Starting from a word or phrase found by a previous Locate action, the location position is moved to the right on the
    current line by the number of words indicated by the input parameter. Subsequent Locate actions can then
    perform additional operations on this located word.  Regardless of being called at the page or field level,
    this action operates on the recognized text for the current page.<br/>

    Note: If the action is added with an empty or non-numeric parameter, the action will default the argument to '1'.<br/><br/>

    This action is always called after a search action has been used.
    <e>
      <scr>WordFind("Tax")</scr><br/>
      <b>GoRightWord("1")</b><br/>
      <scr>GoBelowWord("1")</scr><br/>
      <scr>UpdateField()</scr>
      <br/><br/>
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if a word is found. Otherwise, <b>False.</b></ret>
 </ref>
  
 <ref id="GoAboveWord">
  <ap>An integer indicating the number of lines to move up.</ap>
  <h>
    Starting from a word or phrase found by a previous Locate action, the location position is moved to a 
    word directly above it by the number of lines indicated by the input parameter. 
    Subsequent Locate actions can then perform additional operations on this located word. 
    Regardless of being called at the page or field level, this action operates on the recognized 
    text for the current page.<br/>

    Note: If the action is added with an empty or non-numeric parameter, the action will default the argument to '1'.<br/><br/>
    <e><scr>WordFind("Total")</scr>
    <br/><b>GoAboveWord("1")</b><br/><scr>GoRightWord("1")</scr>
    <br/><scr>UpdateField()</scr>
    <br/><br/>

      This sequence finds the word which is the 
      Tax field's entered value ("29.78") when a fingerprint has these fields and values:<br/><b>Tax</b> 29.78<br/><b>Total</b> 234.70
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if a word is found. Otherwise, <b>False.</b></ret>
    <see><scr>GoBelowWord</scr>
    </see>
     </ref>
 <ref id="GoBelowWord">
  <ap>An integer indicating the number of lines to move down.</ap>
  <h>
    Starting from a word or phrase found by a previous Locate action, the location position is moved 
    to a word directly below it by the number of lines indicated by the input parameter. 
    Subsequent Locate actions can then perform additional operations on this located word.
    Regardless of being called at the page or field level,
    this action operates on the recognized text for the current page.<br/>

    Note: If the action is added with an empty or non-numeric parameter, the action will default the argument to '1'.<br/><br/>

    This action is always called after a search action has been used.
    <e><scr>WordFind("Tax")</scr>
    <br/><b>GoBelowWord("1")</b><br/><scr>GoRightWord("1")</scr>
    <br/><scr>UpdateField()</scr>
    <br/><br/>

      This sequence finds the word which is the Total field's 
      entered value ("234.70") when a fingerprint has these fields:<br/><b>Tax</b> 29.78<br/><b>Total</b> 234.70
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the word or phrase is found. Otherwise, <b>False.</b></ret>
    <see>
    GoAboveWord, FindWord, FindKeyList, RegExFind
  </see>
     </ref>
 <ref id="GoFirstWord">
  <ap>None.</ap>
   <h>
     Starting from a word or phrase found by a previous Locate action, the location position is moved to the first word
     on the current line. If the page's Fingerprint file (.cco) does not have a line position, the action
     defaults to the first word on the first line of the current zone, or on the first line of
     the current page if a zone is not present. Subsequent Locate actions can then perform additional operations
     on this located word. Regardless of being called at the page or field level, this action operates on the
     recognized text for the current page.<br/><br/>

     <e>
       <b>GoFirstWord()</b>
     </e>
   </h>
    <lvl>Page or field level.</lvl>
    <ret><b>False</b> if the page's Fingerprint file (.cco) is not available or if 
    it is empty. Otherwise, <b>True.</b></ret>
    <see>WordFind, FindKeyList, RegExFind</see>
     </ref>
 <ref id="GoLastWord">
  <ap>None.</ap>
  <h>
    Starting from a word or phrase found by a previous Locate action, the location position is moved to the last word
    on the current line. If the page's Fingerprint file (.cco) does not have a line position, the action
    defaults to the last word on the first line of the current zone, or on the first line of
    the current page if a zone is not present. Subsequent Locate actions can then perform additional operations
    on this located word.  Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.<br/><br/>
    
    <e><b>GoLastWord()</b></e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>False</b> if the Fingerprint file (.cco) is not available, or if it is empty. Otherwise, <b>True.</b></ret>
    <see>WordFind, FindKeyList, RegExFind</see>
     </ref>
 <ref id="GoFirstLine">
  <ap>None.</ap>
  <h>
    Starting from the current position, the location position is moved to the first line of the current zone,
    or to the first line on the page if a zone is not present. Subsequent Locate actions can then perform
    additional operations from this position. Regardless of being called at the page or field level, this action
    operates on the recognized text for the current page.<br/><br/>

    <e><b>GoFirstLine()</b></e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>False</b> if the page's Fingerprint file(.cco) is unavailable or empty. Otherwise, <b>True.</b></ret>
    <see>WordFind, FindKeyList, RegExFind</see>
     </ref>
 <ref id="GoLastLine">
  <ap>None.</ap>
  <h>
    Starting from the current position, the location position is moved to the last line and word of the current zone,
    or to the last line and word on the page if a zone is not present. Subsequent Locate actions can then perform
    additional operations from this position. Regardless of being called at the page or field level, this action
    operates on the recognized text for the current page.<br/><br/>
    
    <e><b>GoLastLine()</b></e>
    </h>
    <lvl>Page or field.</lvl>
    <ret><b>False</b> if the source page's Fingerprint file (.cco) is not available, or
    if it is empty. Otherwise, <b>True.</b></ret>
    <see>WordFind, FindKeyList, RegExFind</see>
     </ref>
 <ref id="GoDownLine">
  <ap>An integer indicating the number of lines to move down below the current line.</ap>
  <h>
    Starting from the current position, the location position is moved down by the number of lines indicated
    in the input parameter and is moved to the first word of that line.<br/>

    Note: If the action is added with an empty or non-numeric parameter, the action will default the argument to '1'.<br/><br/>

    This action is always called after a search action has been used.
    <e><scr>FindKeyList("Invoice")</scr>
    <br/><b>GoDownLine("1")</b><br/><scr>GoRightWord("1")</scr>
    <br/><scr>UpdateField()</scr>
    <br/><br/>

      This sequence finds the word which is the Number field's entered value ("10034") 
      when a fingerprint has these fields:<br/>
      INVOICE<br/>
      Number: 10034
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if a line is found. Otherwise, <b>False.</b></ret>
    <see>
    GoUpLine, FindWord, FindKeyList
  </see>
     </ref>
 <ref id="GoUpLine">
  <ap>An integer indicating the number of lines to move up above the current line.</ap>
  <h>
    Starting from the current position, the location position is moved up by the number of lines indicated
    in the input parameter and is moved to the first word of that line.

    Note: If the action is added with an empty or non-numeric parameter, the action will default the argument to '1'.<br/><br/>

    This action is always called after a search action has been used.
    <e><scr>FindKeyList("Invoice")</scr>
    <br/><b>GoUpLine("1")</b><br/><scr>GoRightWord("1")</scr>
    <br/><scr>UpdateField()</scr>
    <br/><br/>

      This sequence finds and extracts the entered value of the Date field ("2/13/03"), 
      in a fingerprint with these words:<br/><br/>

      Date: 2/13/03<br/>
      INVOICE
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if a line is found. Otherwise, <b>False.</b></ret>
    <see>
    GoDownLine, FindWord, FindKeyList, RegExFind
  </see>
     </ref>
 <ref id="UpdateField">
  <ap>None.</ap>
  <h>
    Updates the appropriate field in the current page's Data file with the recognized 
    (and possibly formatted) value of the located word or phrase.<br/><br/>
    <b>Important</b> An entered value that the UpdateField action places in a Data file 
    becomes a captured value, and can be processed by Validation and Export RuleSets.
    <e><scr>FindKeyList("Date")</scr>
    <br/><scr>GoRightWord("1")</scr>
    <br/><scr>IsDateValue()</scr>
    <br/><b>UpdateField()</b><br/><br/>

      The first action in the sequence finds a word or phrase that identifies the Date Field 
      object of the current page. This is the field's static value - probably its title.<br/><br/>

      The next action moves right one word or phrase to locate the field's entered value - 
      a recognized date such as 12/31/2002. The third action checks to be sure the 
      value has an acceptable Date format.<br/><br/>

      The concluding UpdateField action takes place only if the others are successful. 
      It adds the field's entered value to the current page's Data file, where it is a 
      captured value awaiting the attention of upcoming rules with Validate and Export actions.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret>
    Always <b>True.</b></ret>
     </ref>
 <ref id="UpdateDCOField">
  <ap>
    String value of the target field's name (Smart Parameter enabled), as a <b>Field</b> object of the Document Hierarchy.
  </ap>
  <h>
    This action updates the size and position coordinates of the <b>Field</b> object 
    representing the field identified by the parameter. Typically, the action follows 
    earlier actions and events which modify the field's width and height, or its 
    precise placement on the current source page. <br/><br/>
    Do not confuse this action with the <b>UpDateField</b>action, 
    which updates Text values.  This action does not update a field's Text value. 
    Instead, it modifies the size and location parameters of a field or zone.
    <e>
      To find a sibling field 'Preparer_Name':<br/>
      <b>UpdateDCOField("..\Preparer_Name")</b><br/><br/>

      To find a child field 'Preparer_Name':<br/>
      <b>UpdateDCOField("Preparer_Name")</b></e>
    </h>
    <lvl>Page or Field level.</lvl>
    <ret><b>False</b> if: the source page's Fingerprint file (.cco) is not available or is empty; 
    if the target field cannot be found; or if there is no information about the target 
    field's starting and ending sizes and locations. Otherwise, <b>True.</b></ret>
 </ref>
  
 <ref id="SetRect">
  <ap>Four comma separated coordinates designating the rectangle's size and location: X, Y, Width and Height.</ap>
  <h>
    Updates the zone of the current field.
    <e><b>SetRect("0,0,100,200")</b><br/><br/>

      This action changes the field's zone postion to a rectangle at coordinates 0, 0, which is 100 wide and 200 high. <br/><br/>

      This action is useful if you wish to change the zone to a specific area of the image 
      where you know your value resides.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret>
    Always <b>True.</b></ret>
 </ref>

  <ref id="MergeNextWord">
    <ap>
      An integer indicating the number of words following the previously
      located word or phrase, to be considered a single entity.
    </ap>
    <h>
      Merges the located word or phrase with one or more words that follow it on the same line.
      This does not change the text on the page and does not remove any characters or spaces.
      The action only changes the internal size of the currently
      selected word being manipulated with the locate actions.
      For example, if a word was located, this action is called with the value 2, then
      the located word and the two words that follow the word will be considered a single
      entity when performing subsequent actions, such as UpdateField.<br/><br/>
      
      Regardless of being called at the page or field level, this action operates on the
      recognized text for the current page.<br/><br/>
      <e>
        <scr>WordFind("Jan")</scr>
        <br/><b>MergeNextWord("1")</b><br/>
        <scr>UpdateField()</scr>
        <br/><br/>

        Given the following cco string:<br/>
        Invoice Date: Jan 2000<br/><br/>

        The result of <scr>WordFind("Jan")</scr>
        is to locate the highlighted word:<br/>
        Invoice Date: <b>Jan</b> 2000<br/><br/>
        <scr>MergeNextWord("1")</scr>
        will consolidate that value with the year value that follows it:<br/>
        Invoice Date: <b>Jan 2000</b><br/><br/>
        
        <scr>UpdateField</scr>
        saves the entire value, "Jan 2000" is saved to the calling object field.
      </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>
      <scr>MergePreviousWord</scr>
    </see>
  </ref>  
  
 <ref id="MergeWordRT">
  <ap>
    An integer indicating the number of words to the right, starting from the previously 
    found word or phrase, to be placed into a field.</ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.
    Instead, use the MergeNextWord action in the Locate action library.
    <br/><br/>
    
    Places the located word or phrase with one or more words to the right, on the same line,
    into the current object field.
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.
    <e><scr>WordFind("Jan")</scr>
    <br/><b>MergeWordRT("1")</b><br/>
    <scr>UpdateField()</scr>
    <br/><br/>

     Given the following cco string:<br/>
     Invoice Date: Jan 2000<br/><br/>

     The result of <scr>WordFind("Jan")</scr> is to locate the highlighted word:<br/>
     Invoice Date: <b>Jan</b> 2000<br/><br/>
      
     <scr>MergeWordRt("1")</scr>
     will consolidate that value with the year value to its right:<br/>
     Invoice Date: <b>Jan 2000</b><br/><br/>
      
     <scr>UpdateField</scr>
     saves the entire value, "Jan 2000" is saved to the calling object field.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
    Always <b>True.</b></ret>
    <see><scr>MergeWordLF</scr>
    </see>
 </ref>
  
 <ref id="IsNumber">
  <ap>
    An integer (0-100) indicating the minimum percentage of characters that must be numeric.
    If no parameter is specified, the value defaults to 100 percent; all characters must be numeric.
  </ap>
  <h>
    Using the current location of a previously located word or phrase, this action determines if the
    characters are numeric. By testing the type of characters recognized in the current word or phrase,
    it is possible for an application to determine it has located the type of data that is
    required, and then take subsequent actions based on the result of the test. This action
    does not consider the decimal symbol, digit grouping symbol or a currency symbol to be
    numeric. Regardless of being called at the page or field level, this action operates on
    the recognized text for the current page. <br/><br/>
    
    <e><scr>WordFind("Total")</scr>
    <br/><scr>GoRightWord("1")</scr>
    <br/><scr>IsNumber("100")</scr>
    <br/><br/>
      
      If the located word's recognized value is: #755<br/><br/>
      <b>IsNumber("75")</b>  returns TRUE<br/>
      <b>IsNumber("80")</b>  returns FALSE</e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the located value meets the parameter's requirement for an integer.  Otherwise, <b>False.</b></ret>
    <see>
    IsAlpha, IsCurrency, IsDateValue, FindWord, FindWordList, RegExFind
  </see>
     </ref>
 <ref id="IsAlpha">
  <ap>
    An integer (0-100) indicating the minimum percentage of characters that must be alphabetic. 
    If no value is provided, the percentage defaults to 100; all characters must be alphabetic.
  </ap>
  <h>
    Using the current location of a previously located word or phrase, this action determines if the characters
    are alphabetic. By testing the type of characters recognized in the current word or phrase, it is possible
    for an application to determine it has located the type of data that is required, and then take
    subsequent actions based on the result of the test. Regardless of being called at the page or
    field level, this action operates on the recognized text for the current page.<br/><br/>
    
    <e><scr>FindKey(Name)</scr>
    <br/><scr>GoRightWord("1")</scr>
    <br/><scr>IsAlpha("100")</scr>
    <br/>
            
      If the located word's recognized value is:  ABC1<br/>
      <b>IsAlpha("75")</b> returns TRUE<br/>
      <b>IsAlpha("80")</b> returns FALSE</e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the minimum percentage of characters specified by the parameter is alphabetic. Otherwise, <b>False.</b></ret>
    <see><scr>IsCurrency</scr>
    , <scr>IsDateValue</scr>
    , <scr>IsNumber</scr>
    </see>
 </ref>

  <ref id="MergePreviousWord">
    <ap>
      An integer indicating the number of words or phrases prior to the currnt located word position,
      to be considered as a single entity.
    </ap>
    <h>
      Merges the located word or phrase with one or more words with previous words, on the same line.
      This does not change the text on the page and does not remove any characters or spaces.  
      The action only changes the internal size of the currently
      selected word being manipulated with the locate actions.
      For example, if a word was located, this action is called with the value 2, then
      the located word and the two words prior to the word will be considered a single
      entity when performing subsequent actions, such as UpdateField.<br/><br/>

      A "word" in this context is a string of characters, which may include spaces.
      This action is used when the value searched for may have spaces in it.
      Regardless of being called at the page or field level, this action operates on the
      recognized text for the current page.<br/><br/>
      <e>
        <scr>WordFind("2000")</scr>
        <br/><b>MergePreviousWord("1")</b><br/>
        <scr>UpdateField()</scr>
        <br/><br/>

        Given the following cco string:<br/>
        Invoice Date: Jan 2000<br/><br/>
        
        <scr>FindWord("2000")</scr>
        will locate the highlighted value:<br/>
        Invoice Date: Jan <b>2000</b><br/><br/>
        
        <b>MergePreviousWord("1")</b> will consolidate it with the text "Jan":<br/>
        Invoice Date: <b>Jan 2000</b><br/><br/>

        ...so that the <scr>UpdateField</scr>
        action will save the entire value, "Jan 2000" into the current
        object's field.
      </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>
      <scr>MergeNextWord</scr>
    </see>
  </ref>

  <ref id="MergeWordLF">
  <ap>
    An integer indicating the number of words or phrases to the left of the previously found field,
    to be placed into the current object field.
  </ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.
    Instead, use the MergePreviousWord action in the Locate action library.
    <br/><br/>
    
    Merges the located word or phrase with one or more words to the left, on the same line.<br/><br/>

    A "word" in this context is a string of characters, which may include spaces.
    This action is used when the value searched for may have spaces in it.
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.
    <e><scr>WordFind("2000")</scr>
    <br/><b>MergeWordLF("1")</b><br/>
    <scr>UpdateField()</scr>
    <br/><br/>

      Given the following cco string:<br/>
      Invoice Date: Jan 2000<br/><br/><scr>FindWord("2000")</scr>
     will locate the highlighted value:<br/>
      Invoice Date: Jan <b>2000</b><br/><br/>
      
      <b>MergeWordLF("1")</b> will consolidate it with the text "Jan":<br/>
      Invoice Date: <b>Jan 2000</b><br/><br/>

      ...so that the <scr>UpdateField</scr>
     action will save the entire value, "Jan 2000" into the current
      object's field.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
    Always <b>True.</b></ret>
    <see><scr>MergeWordRT</scr></see>
 </ref>
  
 <ref id="IsDateValue">
  <ap>None.</ap>
  <h>
    Using the current location of a previously located word or phrase, this action determines if the characters
    are in a valid date format and are a valid date.  By testing the type of characters recognized in
    the current word or phrase, it is possible for an application to determine it has located the type of data
    that is required, and then take subsequent actions based on the result of the test. Regardless of
    being called at the page or field level, this action operates on the recognized text for the current
    page.<br/>
    Note: This action is dynamic locale aware.<br/><br/>
    
    <e>
      If the located word's recognized value is:    01/01/2003<br/><b>IsDateValue()</b> returns TRUE<br/><br/>

      If the located word's recognized value is:    January 01,2003<br/><b>IsDateValue()</b> returns TRUE<br/><br/>

      If the located word's recognized value is:    13/13/2003<br/><b>IsDateValue()</b> returns FALSE</e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the located value is an acceptable Date. Otherwise, <b>False.</b></ret>
    <see>
    IsAlpha, IsCurrency, IsNumber, WordFind, FindKeyList, RegExFind
  </see>
     </ref>
 <ref id="FilterIt">
  <ap>
    A string containing the character(s) to be removed. <br/><br/>
    <b>Alert</b> This action removes every instance of the character or characters.
  </ap>
  <h>
    Removes all instances of each character you enter as a parameter from the located word or phrase.
    <e>
      <b>FilterIt("-")</b><br/>
      31-Dec-01 becomes 31Dec01<br/><br/>
      
      <b>FilterIt("1")</b><br/>
      31-Dec-01 becomes 3-Dec-0<br/><br/>

      <b>FilterIt("1-")</b><br/>
      31-Dec-01 becomes 3Dec0<br/><br/>
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret>
    Always <b>True.</b></ret>
    <see><scr>DeleteString</scr>
    </see>
     </ref>
 <ref id="SelectSnippet">
  <ap>
    <b>1.</b> The character that is to appear in the Snippet field if a value is not 
    available. "~" is the default.<br/>
    <b>2.</b> The size of the captured value's snippet image.<br/>
    "1" is 1x of the actual word area, and is the default.<br/>
    "2" is 2x of the actual word area, the zone is twice the size of the selected target word.<br/>
    ".5" is 1/2 the actual word area, not recommended as only a portion of the target word would 
    display in the snippet at verify time.
    
  </ap>
  <h>
    Used in conjunction with directional actions, this action will populate a Snippet
    field with the recognized value of the located word or phrase.<br/><br/>

    This action is usually the last rule of a Locate RuleSet, and is used when the
    probable area of the sought after value has been found.
    <e>
      <scr>FindKeyInList("InvNum")</scr><br/>
      <scr>GoRightWord("1")</scr><br/>
      <b>SelectSnippet("~,1")</b><br/><br/>

      This sequence first tries to locate an Invoices Number keyword in the current page.
      If successful, the next action attempts to lock onto a word or phrase to the right of the located word or phrase.<br/><br/>

      If that word is present, the <scr>SelectSnippet</scr> action will place the 
      image of the word's recognized value into the Snippet of the applicable Field object. 
      The Data Entry operator can then determine if the Snippet contains the correct 
      value and can enter the data into the accompanying Data Edit field in the Data Entry Panel.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret>
    Always <b>True.</b></ret>
     </ref>
 <ref id="DefaultValue">
  <ap>
    The String value assigned to the bound <b>Field</b> object of the Document Hierarchy 
    that represents the current field.
  </ap>
  <h>
    Sets the captured value of the current field to the String value you enter as a parameter.<br/><br/><e><b>DefaultValue("Bill Paid")</b><br/><br/><b>DefaultValue("Past Due")</b></e>
    </h>
    <lvl>Field level only.</lvl>
    <ret>
    Always <b>True.</b></ret>
     </ref>
 <ref id="MaxLength">
  <ap>An integer specifying the maximum number of characters the word or phrase can contain.</ap>
  <h>
    Compares the number of characters in the located word or phrase to a maximum number you supply as the parameter.
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.
    <e>
      If the recognized value of the located word or phrase is: ANYTHING<br/>
      <b>MaxLength("14")</b> returns TRUE<br/>
      <b>MaxLength("8")</b> returns TRUE<br/>
      <b>MaxLength("3")</b> returns FALSE</e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>False</b> if the parameter is not Numeric, or if the actual number of
    characters exceeds the parameter. Otherwise, <b>True.</b></ret>
    <see><scr>MinLength</scr>
    </see>
     </ref>
 <ref id="MinLength">
  <ap>An integer specifying the minimum number of characters the word or phrase can contain.</ap>
  <h>
    Compares the number of characters in the located word or phrase to a minimum number you supply as the parameter.
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.
    <e>
      If the recognized value of the word or phrase is: ABC1<br/>
      <b>MinLength("4")</b> returns TRUE<br/>
      <b>MinLength("3")</b> returns TRUE<br/>
      <b>MinLength("6")</b> returns FALSE</e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>False</b> if the parameter is not Numeric, or if the actual number of characters 
    is less than the parameter. Otherwise, <b>True.</b></ret>
    <see><scr>MaxLength</scr>
    </see>
     </ref>
 <ref id="IsCurrency">
  <ap>None.</ap>
  <h>
    Using the current location of a previously located word or phrase, this action determines if the characters are in a valid
    currency format and are a valid currency value.  By testing the type of characters recognized in the current word or phrase,
    it is possible for an application to determine it has located the type of data that is required, and then take
    subsequent actions based on the result of the test. Regardless of being called at the page or field level, this
    action operates on the recognized text for the current page.<br/>

    Note: This action is NOT dynamic locale aware and uses a simple regex and separator character test.<br/><br/>

    <e>
      If the recognized value of the word or phrase is: 12.00<br/><b>IsCurrency()</b> returns TRUE<br/><br/>

      If the recognized value of the word or phrase is: 12,00<br/><b>IsCurrency()</b> returns TRUE<br/><br/>

      If the recognized value of the word or phrase is: 1200<br/><b>IsCurrency()</b> returns FALSE<br/><br/>

      If the recognized value of the word or phrase is: 1,200.00<br/><b>IsCurrency()</b> returns TRUE<br/><br/>

      If the recognized value of the word or phrase is: $12.00<br/><b>IsCurrency()</b> returns TRUE</e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the located value is currency. Otherwise, <b>False.</b></ret>
    <see><scr>IsAlpha</scr>
    , <scr>IsDateValue</scr>
    , <scr>IsNumber</scr>
    </see>
     </ref>
 <ref id="ScanRT">
  <ap>Numeric value of the number of words to be evaluated to the right of the current word or phrase.</ap>
  <h>
    ScanRT (scan right) looks for a word in positions that are slightly <b>above or below</b> the 
    line on which the current word or phrase is located.<br/><br/>
    <e><scr>WordFind("Number")</scr>
    <br/><b>ScanRT("1")</b><br/><br/>

      This sequence first finds "Number" on the current page, then moves one
      word to the right as it searches for a value.<br/><br/>

      To compensate for the possibility that this value may be printed slightly 
      above or below the line on which "Number" was printed, the <scr>ScanRT</scr>
      action expands the area in which the target value can reside.  When a page is recognized, 
      skewing or data layout may cause alignment problems.  
      Words that are thought of as being on the same line, may not have been 
      recognized as being on the same line, but slightly above or below the current line.  
      This action compensates for that anomaly when looking for words right of the current 
      word location.  It uses a calculation adjustment to determine which of the words to 
      the right of the current word, should be considered to be on the same line.  
      It will then remember the location of the word that best fits this criteria.  This new
      remembered location can then be utilized by subsequent actions.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>True</b> if a word is found. Otherwise, <b>False.</b></ret>
    <see>GoRightWord</see>
     </ref>
 <ref id="GroupWords">
  <ap>Long value of the maximum character width separating words to the right and left of the current word.</ap>
  <h>
    Groups any words to the left and right of a located word if the target words are
    themselves separated by a character width equal to or less than the character
    width you specify as a parameter. 
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.
    <e><scr>WordFind("Treasury")</scr>
    <br/><b>GroupWords("1.5")</b><br/><br/>

      If a line contains these words:<br/>
      20 000 U S Treasury 7 33<br/><br/>

      the <scr>GroupWords</scr>
    action will merge "20" with "000"; "U" with "S" and "7" with "33" to produce:<br/>
      20 000 U S Treasury 7 33
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
    Always <b>True.</b></ret>
    <see><scr>GroupWordsLeft</scr>
    , <scr>GroupWordsRight</scr>
    </see>
 </ref>

  <ref id="GroupNextWords">
    <ap>A numeric value indicating the maximum character width separating words to group that follow the current word.</ap>
    <h>
      Groups words that follow currently located word, if the target words are separated
      by a character width equal to or less than the character width you specify as a parameter.
      The action only changes the internal size of the currently selected word being manipulated with the locate actions.
      For example, if a word was located, this action is called and groups two words that follow the currently located word,
      then all 3 words will be considered a single entity when performing subsequent actions, such as UpdateField.<br/><br/>
      
      Regardless of being called at the page or field level, this action operates on the
      recognized text for the current page.<br/><br/>

      The grouping of words is performed on the current line for words that appear after the current word based on the reading order of the text.
      The movement will be perceived as a right directional
      movement on left-to-right text.  The movement will be perceived as a left directional movement on right-to-left text.
      <br/><br/>
      <e>
        <scr>WordFind("US")</scr>
        <br/><b>GroupNextWords("2")</b><br/><br/>

        If a line contains these words:<br/>
        Found &#xA0;&#xA0;&#xA0;&#xA0;   20 000 US Treasury  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;   bills.<br/><br/>

        the <scr>GroupPreviousWords</scr>
        action will merge "US" with "Treasury" to produce:<br/>
        US Treasury
      </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>
      <scr>GroupWords, GroupPreviousWords</scr>
    </see>
  </ref>  
  
 <ref id="GroupWordsRIGHT">
  <ap>Long value of the maximum character width separating words to the right of the current word.</ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.
    Instead, use the GroupPreviousWords action in the Locate action library.
    <br/><br/>
    
    Groups words to the right of the located word if the target words are separated
    by a character width equal to or less than the character width you specify as a parameter.
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.
    <e><scr>WordFind("US")</scr>
    <br/><b>GroupWordsRight("2")</b><br/><br/>

      If a line contains these words:<br/>
      Found &#xA0;&#xA0;&#xA0;&#xA0;   20 000 US Treasury  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;   bills.<br/><br/>

      the <scr>GroupWordsRight</scr>
     action will merge "US" with "Treasury" to produce:<br/>
      US Treasury
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
    Always <b>True.</b></ret>
    <see>
      <scr>GroupWords, GroupWordsLeft</scr>
    </see>
 </ref>

  <ref id="GroupPreviousWords">
    <ap>A numeric value indicating the maximum character width separating words to group that precede the current word.</ap>
    <h>
      Groups only words that appear before the located word if the target words are
      separated by a character width equal to or less than the character width you specify as a parameter.
      This does not change the text on the page and does not remove any characters or spaces.
      The action only changes the internal size of the currently selected word being manipulated with the locate actions.
      For example, if a word was located, this action is called and groups two words that precede the currently located word,
      then all 3 words will be considered a single entity when performing subsequent actions, such as UpdateField.
      <br/><br/>
            
      Regardless of being called at the page or field level, this action operates on the
      recognized text for the current page.<br/><br/>

      The grouping of words is performed on the current line for words that appear before the current word based on the reading order of the text.
      The movement will be perceived as a left directional
      movement on left-to-right text.  The movement will be perceived as a right directional movement on right-to-left text.
      <br/><br/>
      <e>
        <scr>WordFind("000")</scr>
        <br/><b>GroupPreviousWords("2")</b><br/><br/>

        If a line contains these words:<br/>
        Found  &#xA0;&#xA0;&#xA0;&#xA0;  20 000 US Treasury  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;   bills.<br/><br/>

        the <scr>GroupWordsLeft</scr>
        action will merge "20" with "000" to produce:<br/>

        20 000
      </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>
      <scr>GroupWords</scr>
      , <scr>GroupNextWords</scr>
    </see>
  </ref>  
  
 <ref id="GroupWordsLEFT">
  <ap>Long value of the maximum character width separating words to the left of the current word.</ap>
  <h>
    <b>*** This Action Is Deprecated ***</b><br/>
    This action has been deprecated and is scheduled to be removed in a future release.
    It is recommended that you no longer use this action.
    Instead, use the GroupPreviousWords action in the Locate action library.
    <br/><br/>
    
    Groups only words to the left of the located word if the target words are
    separated by a character width equal to or less than the character width you specify as a parameter.
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.
    <e><scr>WordFind("000")</scr>
    <br/><b>GroupWordsLeft("2")</b><br/><br/>

      If a line contains these words:<br/>
      Found  &#xA0;&#xA0;&#xA0;&#xA0;  20 000 US Treasury  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;   bills.<br/><br/>

      the <scr>GroupWordsLeft</scr>
     action will merge "20" with "000" to produce:<br/>

      20 000 
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
    Always <b>True.</b></ret>
    <see><scr>GroupWords</scr>
    , <scr>GroupWordsRight</scr>
    </see>
 </ref>
  
 <ref id="IsValue">
  <ap>The value to be compared to the object's recognized value.</ap>
  <h>
    Using the current location of a previously located word or phrase, this action determines if the
    value matches the value of the input parameter. By testing the value recognized in the
    current word or phrase, it is possible for an application to determine it has located the data
    that is required, and then take subsequent actions based on the result of the test.
    If you want to check the value of a subset of the word or phrase, use the ValueInWord action.
    Regardless of being called at the page or field level, this action operates on the
    recognized text for the current page.<br/>

    Note: Match test is not case sensitive and does not include leading and trailing spaces.<br/><br/>

    <e><scr>WordFind("Houston")</scr>
    <br/><scr>GoRightWord("2")</scr>
    <br/><b>IsValue("77770")</b><br/><br/>

      This sequence confirms that the current page's recognized value for Houston's ZIP code is "77770". <br/><br/>

      The action returns a Boolean value: <b>True</b> if the values are the same, 
      <b>False</b> if they are not.
    </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the located value matches the parameter's value. Otherwise, <b>False.</b></ret>
    <see>ValueInField, WordFind, FindKeyList, RegExFind</see>
     </ref>
 <ref id="IsValue_RegEx">
  <ap>
    A Regular Expression that will be used for comparison with the recognized value of the word or phrase.
  </ap>
  <h>
    Using the current location of a previously located word or phrase, this action determines if the regular
    expression provided in the input parameter finds a match in the value. By testing the value recognized
    in the current word or phrase, it is possible for an application to determine it has located the data that is
    required, and then take subsequent actions based on the result of the test. Regardless of being called
    at the page or field level, this action operates on the recognized text for the current page.

    <e><scr>WordFind("Houston")</scr>
    <br/><scr>GoRightWord("2")</scr>
    <br/><b>IsValue_RegEx("Total")</b></e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret><b>True</b> if the located value matches the parameter's value. Otherwise, <b>False.</b></ret>
     </ref>
 <ref id="ValueInField">
  <ap>The value that is to be matched with a portion of the value in the current field.</ap>
  <h>
    Checks if the parameter you enter is within the value of the current field represented 
    by the bound <b>Field</b> object of the Document Hierarchy.  Only a portion of the field's
    value needs to match the parameter.  If the entire field must match, use IsValue. Case insensitive.
    <e><b>ValueInField("Invoice")</b></e>
    </h>
    <lvl>Field level.</lvl>
    <ret><b>False</b> if no match occurs. Otherwise, <b>True.</b></ret>
    <see>IsValue, ValueInFieldRegEx</see>
     </ref>
 <ref id="ValueInField_RegEx">
  <ap>
    The portion of the value to find in the field.  The parameter is expected
    to be expressed as a regular expression.</ap>
  <h>
    This action checks if the Regular Expression you specify as the parameter 
    is equivalent to the value of the current field.  Only a part of the field must match
    the parameter.  To match the entire value of the field, use IsValueRegEx.
    <e><b>ValueInField_RegEx("[\^\b\s\n\r]Inv[oO0][iItl1]ce[\b\s]*")</b></e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>False</b> if no match occurs.  Otherwise <b>True.</b></ret>
    <see>IsValue, IsValueRegEx, ValueInField</see>
     </ref>
 <ref id="ValueInField_Fuzzy">
  <ap>String value to be matched to the current field's value, using fuzzy matching procedures.</ap>
  <h>
    Checks if there is a "fuzzy" match of the parameter's value with the value in the current field.
    Only a portion of the field's value needs to match.
    The match is performed by allowing for common substitutions that can occur during
    recognition.  These substitutions include characters: B8, Z2, S5, oO0 and iItl1. Case insensitive.
    <e><b>ValueInField_Fuzzy("Invoice")</b></e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>False</b> if no match occurs. Otherwise, <b>True.</b></ret>
     </ref>
 <ref id="WordFind_Offset">
  <ap>
    1. String value of a keyword that the action is to find on both the fingerprint and recognized image.<br/>
    2. An optional parameter that specifies the offset threshold.  If not specified, the default value is 100 pixels.
  </ap>
  <h>
    This action locates a word or phrase on both the recognized page and on the fingerprint.
    The positioning of both locations are compared to determine an offset value.  The calculated
    difference is stored in the DCO of the current page in the variable Image_Offset.  This value
    will be used by subsequent actions, such as ReadZones, to compensate for 
    the difference so the field data is properly located.<br/><br/>

    For best results, the word or phrase should appear only once or the first instance of the word or phrase should
    always appear in the same location.<br/><br/>

    The threshold is the maximum distance between keywords found on the Live image and the fingerprint.
    The Default value is 100 pixels. If the keywords are more than 100 pixels apart no Offset is generated;
    preventing matches of keywords where there is more then one instance of the word to be found on an image.
    A successful matched pair will update the Image_Offset variable at the page level.<br/><br/>

    This action requires the FingerPrint CCO to have full page recognition results. Otherwise, there will be nothing to match against.<br/><br/>
    
    This action should not be located in the same ruleset where full page recognition is done. It needs to exist in a ruleset that
    is performed afterwards.    
    <e><b>WordFind_Offset("Invoice")</b></e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
    Always <b>True.</b></ret>
     </ref>
  <ref id="AggregateKeyList">
    <ap>Toggles Key list searches to merge all words or phrases in the list into a single query.</ap>
    <h>
      Use of this action changes the search behavior for all 'List' type key word search actions.
      Default behavior is to search each keyword in the list sequentially. This action with the 
      parameter set to TRUE changes the search behavior to check for all the keywords in a single
      aggregate keyword search. To change back to the default behavior use this action with the
      FALSE parameter.
      <e>
        <b>AggregateKeyList(True)</b><br/>
        <b>FindKeyList("InvNum")</b><br/><br/>

          This action searches the current page, from first word to the last word of the current page, for the
          first occurance of all keywords in the Invoices Number Keyword file (InvNum.key).
          If successful, the search stops and remembers the location of that word for subsequent actions;
          if not, the action continues searching for the next word in InvNum.key, starting from first word
          of the current page, repeating this search pattern until a match is found,
          or until there are no more keywords.
          
        </e>
    </h>
    <lvl>Any.</lvl>
    <ret>
      Always <b>True</b>.
    </ret>
    <see>
      FindKeyList, FindNextKeyList, FindLastKeyList, AddKeyList
    </see>
  </ref>
  <ref id="AddKeyList">
    <ap>
         1. String value used as a reference name for other actions to call this list of keywords or phrases.<br/>
      2-25. An optional number of up to twentyfive keywords or phrases to be used for matching.
    </ap>
    <h>
      Adds a list of keywords or phrases that can be used for matching.<br/><br/>

      This action complements the List search actions that can load a Keyword text file which 
      contains a list of words or phrases, separated by new lines, that will be used for matching.<br/>
      AddKeyList adds a list of up to 25 words or phrases without having to read or edit a file.<br/><br/>
    
      Note: You can not redefine or overwrite an existing keylist.<br/><br/>
      
      <e>
        <b>AddKeyList("InvNum","Invoice Number","Inv. Num.","Invoice #:")</b><br/>
        <b>FindKeyList("InvNum")</b><br/><br/>

        This action searches the current page, from first word to the last word of the current page, for the
        first occurance of all keywords in the Invoices Number Keyword list "InvNum".<br/>
        If successful, the search stops and remembers the location of that word for subsequent actions.<br/>
        If not successful, the action continues searching for the next keyword in the InvNum list, starting from first word
        of the current page, repeating this search pattern until a match is found, or until there are no more keywords.
      </e>
    </h>
    <lvl>Any.</lvl>
    <ret>
      <b>False</b> if no keywords or phrases are entered, otherwise <b>True</b>.
    </ret>
    <see>
      FindKeyList, FindKeyList_InZone, FindNextKeyList, FindNextKeyList_InZone, FindRegExList,
      FindRegExList_InZone, FindNextRegExList, FindNextRegExList_InZone, FindLastKeyList,
      FindLastKeyList_InZone, FindLastRegExList, FindLastRegExList_InZone, AggregateKeyList
    </see>
  </ref>

  <ref id="SetKeyFileEncodingAsUnicode">
    <ap>
      If set to "True", then key files will be opened as UNICODE encoding.  
      "False" opens key files as ASCII encoding and is the default.<br/>
      Smart parameters are supported.
    </ap>
    <h>
      Determines if the Locate key files are opened as ASCII or UNICODE.  
      A parameter value of "True" will treat key files as UNICODE format.  
      "False" will open key files as ASCII format.<br/><br/>

      This action must be called before any locate actions that use a key file.  If not called,
      then key files will be opened as ASCII.<br/>   
      <e>
        <b>SetKeyFileEncodingAsUnicode("True")</b><br/>
        FindKeyList("InvNum")<br/><br/>

        This example will open files as a UNICODE format.  The file must be in a UNICODE format
        or the text within it may be read incorrectly.<br/><br/>
        
        <b>SetKeyFileEncodingAsUnicode("False")</b><br/>
        FindKeyList("InvNum")<br/><br/>

        This example will open files as a ASCII format.  The file must be in a ASCII format
        or the text within it may be read incorrectly.
      </e>
    </h>
    <lvl>Any.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>


  <ref id="SelectParentBlock">
    <ap>
      None.
    </ap>
    <h>
      Note that this action is currently released as a preview.  The action is supported however the functionality
      may change in the next release, which may require an update to your application.<br/><br/>
      
      This action utilizes the document block layout created by the Document Analytics actions.
      The currently selected block, which denotes an area on the page, is changed to the containing block.
      This will effectively make the new area of interest larger than the previous area.<br/><br/>

      For example, if the currently selected block is a word, when SelectParentBlock is called, the
      selected word remains the same, but the area of interest is changed to the parent block,
      which would be the entire line. Subsequent actions that act on the the current block
      will now respect the line as the area of interest on the page.<br/><br/>

      Calling SelectParentBlock again would move the selected block to the parent of the line.
      The block selected will depend on the layout of the page. One typical scenario is that the
      selected block will now be a paragraph that contains multiple lines, including the word that
      was previously found.  Any block actions, such as additional searches, will be performed
      within the boundaries of this newly selected paragraph block.<br/><br/>
      
      While the block nesting layout typically follows the same pattern, the layout of blocks
      will depend on the layout of text on the page.  For predictable results, the application 
      rules may need to work on expected layouts based on the page types supported by
      the application.
      <e>
        RegExFind_InBlock("Da.e")<br/>
        <b>SelectParentBlock()</b><br/>
        <b>SelectParentBlock()</b><br/>
        UpdateFieldWithBlock()<br/><br/>

        RegExFind_InBlock will look for the first occurrence of a word or phrase that matches the regular expression.
        If a match is found, the next action will change the currently selected block from the found word to
        the entire line that contains the word.  SelectParentBlock is then called again to change
        the selected block to the parent of the current line, 
        then the current field zone is updated to contain the entire set of lines contained in the current block
        and the field value is set to all of the text within the current block.
      </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      <b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b>
    </ret>
    <see>
      SelectParentBlockType, SelectParentBlockOuterType
    </see>
  </ref>

  <ref id="IsSelectedBlockType">
    <ap>
      <b>Type:</b> The name of the expected block type.<br/>
      Smart parameters are supported.
    </ap>
    <h>
      Note that this action is currently released as a preview.  The action is supported however the functionality
      may change in the next release, which may require an update to your application.<br/><br/>
      
      This action utilizes the document block layout created by the Document Analytics actions.
      IsSelectedBlockType compares the provided block type to the type of the currently selected block.<br/><br/>

      <e>
        RegExFind_InBlock("Da.e")<br/>
        SelectParentBlock()<br/>
        <b>IsSelectedBlockType("Line")</b>
      </e>      
      This example finds a word, selects the parent of the word and then confirms that the parent is of type "Line".
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      <b>True</b> if the provided parameter matches the name of the currently selected block.  Otherwise, <b>False.</b>
    </ret>
    <see>
       GetSelectedBlockType
    </see>
  </ref>
  
  <ref id="GetSelectedBlockType">
    <ap>
      <b>Target:</b> A smart parameter that defines the target variable to
      store the type of the currently selected block.
    </ap>
    <h>
      Note that this action is currently released as a preview.  The action is supported however the functionality
      may change in the next release, which may require an update to your application.<br/><br/>
      
      This action utilizes the document block layout created by the Document Analytics actions.
      GetSelectedBlockType obtains the type of the currently selected block and stores it in the
      DCO location indicated by the target parameter.<br/><br/>
      <e>
        RegExFind_InBlock("Da.e")<br/>
        <b>GetSelectedBlockType("@X.SelectedBlock")</b><br/>
        <br/>
        Finds the block that contains the matching expression and then stores
        the name of the currently selected block in a variable called "SelectedBlock"
        on the current DCO object.  If the variable does not exist, it will be created.
        In this example, the name of the stored block would be "Word" because
        the currently selected block is the found word block.<br/><br/>
      </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      <b>True</b> if the type was successfully stored, otherwise <b>False.</b>
    </ret>
    <see>
      IsSelectedBlockType
    </see>
  </ref>
  
  <ref id="SelectParentBlockType">
    <ap>
      <b>selectType:</b> The type of the parent block to select.<br/>
      Smart parameters are supported.
    </ap>
    <h>
      Note that this action is currently released as a preview.  The action is supported however the functionality
      may change in the next release, which may require an update to your application.<br/><br/>
      
      This action utilizes the document block layout created by the Document Analytics actions.
      The action selects the parent of the current block of the type that is specified.  If the currently selected block
      has multiple parent blocks of the same type, then the parent nearest to the current block would be
      selected.<br/><br/>
      
      If the current block is of the specified type, then the action will return true and the selected block
      will remain at the current block.  When starting a new search after performing previous searches, it may be useful to
      call this action with type "Page" to reset the selected block to the page block so the entire
      page block area can be searched again using the "block" actions.
      <e>
        RegExFind_InBlock("Da.e")<br/>
        <b>SelectParentBlockType("Block")</b><br/><br/>
        
        In this example the selected block will be the one of type "Block" that is the
        nearest parent to the block containing the found word.<br/><br/>

        The following is the list of block types: Document, Page, Title, Block
        Table, Row, Cell, Paragraph, Header and Footer.<br/><br/>
        
        Assuming the page contained this nested block layout:<br/>
        [Page]<br/>
        [Block]<br/>
        [Block]<br/>
        [Line]<br/>
        [Word] "Date" [/Word]<br/>
        [/Line]<br/>
        [/Block]<br/>
        [/Block]<br/>
        [/Page]<br/><br/>
        
        The "word" block would be found, then the selected block would be the "Block" that is the parent to the "Line" block.<br/><br/>


        <b>SelectParentBlockType("Page")</b><br/>
        Specifying "Page" will select the page block as the currently selected block.
        When a previous locate has been performed, reselecting the "Page" block will
        reset the block to the page so the next action that searches within the
        selected block will search the entire page.
      </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      <b>True</b> the specified parent block is found and selected. 
      If the current block is of the specified type, then true will be returned.
      Otherwise, <b>False.</b>
    </ret>
    <see>
      SelectParentBlock, SelectParentBlockOuterType
    </see>
  </ref>

  <ref id="SelectParentBlockOuterType">
    <ap>
      <b>selectType:</b> The type of the outer most parent block to select.<br/>
      Smart parameters are supported.
    </ap>
    <h>
      Note that this action is currently released as a preview.  The action is supported how ever the functionality
      may change in the next release, which may require an update to your application.<br/><br/>
      
      This action utilizes the document block layout created by the Document Analytics actions.
      The action selects the outer most parent of the current block of the type that is specified.  If the currently selected block
      has multiple parent blocks of the same type, then the parent farthest from the current block would be
      selected.
      <e>
        RegExFind_InBlock("Da.e")<br/>
        <b>SelectParentBlockOuterType("Block")</b><br/><br/>

        In this example the selected block will be the one of type "Block" that is the
        farthest parent to the block containing the found word.<br/><br/>

        The following is the list of block types: Document, Page, Title, Block,
        Table, Row, Cell, Paragraph, Header and Footer.<br/><br/>
        
        Assuming the page contained this nested block layout:<br/>
        [Page]<br/>
        [Block]<br/>
        [Block]<br/>
        [Line]<br/>
        [Word] "Date" [/Word]<br/>
        [/Line]<br/>
        [/Block]<br/>
        [/Block]<br/>
        [/Page]<br/><br/>

        The "word" block would be found, then the selected block would be the "Block" that is the first child to the "Page" block.
      </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      <b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b>
    </ret>
    <see>
      SelectParentBlock, SelectParentBlockType
    </see>
  </ref>

  <ref id="GoSiblingBlockNext">
    <ap>
      <b>count:</b> The number of sibling blocks to move.  Smart parameters are supported.
    </ap>
    <h>
      Note that this action is currently released as a preview.  The action is supported however the functionality
      may change in the next release, which may require an update to your application.<br/><br/>
      
      This action utilizes the document block layout created by the Document Analytics actions.      
      The currently selected block in the document layout is changed to the next sibling block at
      the same level in the structure.  The number of siblings moved is determined by the input
      parameter.<br/><br/>

      When a sibling block is selected, the currently select block becomes the sibling block
      and the currently selected word is changed to the first
      word in the new block and that word may be in a nested block.  
      Any "next" type searches will start from the location
      of this selected word.<br/><br/>
      
      For example, if the currently selected block is a line and the parameter is two, then the currently
      selected block will move down two lines in the structure and the currently selected block
      will be the sibling line and the selected word will be the first word in the new line.  
      If there is no sibling at that location,
      then the current block is not changed and the action returns false.
      <e>
        RegExFind_InBlock("Da.e")<br/>
        SelectParentBlockType("Block")<br/>
        <b>GoSiblingBlockNext("2")</b><br/><br/>
        RegExFind_InBlock("Qty")<br/>

        This example will find the matching text for the regular expression "Da.e", then select the parent
        block of type "Block".  It then moves down two blocks of type "Block".  At this point, the
        currently selected block is a type block and the currently selected word is the first
        word in that block.  Then another search is performed within that new block for "Qty".
        If Qty does not exist within the bounds of that new block, the action will return false.
      </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      <b>True</b> if the sibling is found at the location specified from the currently selected block.
      Otherwise, <b>False.</b>
    </ret>
    <see>
      GoSiblingBlockPrevious
    </see>
  </ref>

  <ref id="GoSiblingBlockPrevious">
    <ap>
      <b>count:</b> The number of sibling blocks to move.  Smart parameters are supported.
    </ap>
    <h>
      Note that this action is currently released as a preview.  The action is supported however the functionality
      may change in the next release, which may require an update to your application.<br/><br/>
      
      This action utilizes the document block layout created by the Document Analytics actions.
      The currently selected block in the document layout is changed to the previous sibling block at
      the same level in the structure.  The number of siblings moved is determined by the input
      parameter.<br/><br/>

      When a sibling block is selected, the currently select block becomes the sibling block
      and the currently selected word is changed to the first
      word in the new block and that word may be in a nested block.
      Any "next" type searches will start from the location
      of this selected word.<br/><br/>
      
      For example, if the currently selected block is a line and the parameter is two, then the currently
      selected block will move up two lines in the structure.  If there is no sibling at that location,
      then the current block is not changed and the action returns false.
      <e>
        RegExFind_InBlock("Da.e")<br/>
        SelectParentBlockType("Block")<br/>
        <b>GoSiblingBlockPrevious("2")</b><br/><br/>
        RegExFind_InBlock("Qty")<br/>

        This example will find the matching text for the regular expression "Da.e", then select the parent
        block of type "Block".  It then moves up two blocks of type "Block".  At this point, the
        currently selected block is a type block and the currently selected word is the first
        word in that block.  Then another search is performed within that new block for "Qty".
        If Qty does not exist within the bounds of that new block, the action will return false.
      </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      <b>True</b> if the sibling is found at the location specified from the currently selected block.
      Otherwise, <b>False.</b>
    </ret>
    <see>
      GoSiblingBlockNext
    </see>
  </ref>

  <ref id="UpdateFieldWithBlock">
    <ap>
      None.
    </ap>
    <h>
      Note that this action is currently released as a preview.  The action is supported however the functionality
      may change in the next release, which may require an update to your application.<br/><br/>
      
      This action utilizes the document block layout created by the Document Analytics actions.
      UpdateFieldWithBlock will update the current DCO object's field zone coordinates with 
      the coordinates of the currently selected block.  The text of the field will be set
      with the contents of the text bound by the currently selected block in the document layout.
      <e>
        RegExFind_InBlock("Da.e")<br/>
        <b>SelectParentBlock()</b><br/>
        <b>SelectParentBlock()</b><br/>
        UpdateFieldWithBlock()<br/><br/>

        RegExFind_InBlock will look for the first occurrence of a word or phrase that matches the regular expression.
        If a match is found, the next action will change the currently selected block from the found word to
        the entire line that contains the word.  SelectParentBlock is then called again to change
        the selected block to the parent of the current line, likely a paragraph.
        Then the current field zone is updated to contain the entire set of lines contained in the current block
        and the field value is set to all of the text within the current block.
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>True</b> if the word or phrase is located on the page. Otherwise, <b>False.</b>
    </ret>
    <see>
       SelectParentBlock
    </see>
  </ref>

  <ref id="RegExFind_InBlock">
    <ap>
      A word or phrase to find on the current page.
      The parameter is expected to be a Regular Expression. The search is case sensitive.   
    </ap>
    <h>
      Note that this action is currently released as a preview.  The action is supported however the functionality
      may change in the next release, which may require an update to your application.<br/><br/>
      
      This action utilizes the document block layout created by the Document Analytics actions.
      The action locates the first occurrence of a word or phrase on the current page where the input search term
      is specified as a regular expression, respecting the currently selected block of the document layout.
      The search is started from the first word within the currently selected block.<br/><br/>
      
      Upon creation of the document layout the entire page is set as the currently selected block, making the
      initial search area the entire page.  Once the regular expression has been matched, the location of the
      found word or phrase will be remembered so the result can be used by subsequent actions.<br/><br/>
      
      Additionally, the found word will become the currently selected word and the block region of that word
      becomes the currently selected block area within the document block layout.
      Subsequent "block" actions will act upon the currently selected block, allowing the area of interest
      to be changed to control the area of the page that is the target of subsequent actions.<br/>      
      <e>
        <b>RegExFind_InBlock("Da.e")</b><br/>
        SelectParentBlock()<br/>
        GoRightWord("1")<br/>
        IsDateValue()<br/>
        UpdateField()<br/><br/>
        
        RegExFind_InBlock will look for the first occurrence of a word or phrase that matches the regular expression.
        If a match is found, the next action will change the currently selected block from the found word to
        the entire line that contains the word, then move to the right of the word.
        If it is a date format, UpdateField will place the value into the current field.
      </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      <b>True</b> if the word or phrase is located within the currently selected block. Otherwise, <b>False.</b>
    </ret>
    <see>
      RegExFindNext_InZone.
    </see>
  </ref>

  <ref id="RegExFindNext_InBlock">
    <ap>
      A word or phrase to find in the current field.  The parameter is expected to be
      a Regular Expression. The search is case sensitive.
    </ap>
    <h>
      Note that this action is currently released as a preview.  The action is supported however the functionality
      may change in the next release, which may require an update to your application.<br/><br/>
      
      This action utilizes the document block layout created by the Document Analytics actions.
      Starting from the location of a previously found word or phrase, this action locates the first
      occurrence of a word or phrase in the currently selected block where the input search term
      is specified as a regular expression. Once the regular expression has been matched, the location of the
      found word or phrase will be remembered so the result can be used by subsequent actions.<br/><br/>

      Additionally, the found word will become the currently selected word and the block region of that word
      becomes the currently selected block area within the document block layout.
      Subsequent "block" actions will act upon the currently selected block, allowing the area of interest
      to be changed to control the area of the page that is the target of subsequent actions.<br/>
      <e>
        RegExFind_InZone("ItemID")<br/>
        SelectParentBlock()<br/>
        GoParentBlockNext()<br/>
        <b>RegExFindNext_InZone("Description")</b><br/>
        GoRightWord("1")<br/>
        UpdateField()<br/><br/>

        In this sequence, the first action looks for "ItemID" starting from the beginning of
        the currently selected block.  If the search succeeded, the selected block is changed to the
        containing line, then changed to the following line.
        RegExFindNext_InZone looks for the first occurrence of "Description" within the line that
        follows "ItemID", selects the word that follows "Description" and updates the current field.
      </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      <b>True</b> if the word or phrase is located within the currently selected block. Otherwise, <b>False.</b>
    </ret>
    <see>
      RegExFind_InBlock
    </see>
  </ref>

  <ref id="LocatePositionSave">
    <ap>
      None.
    </ap>
    <h>
      LocatePositionSave creates a restore point for the current word position of the locate pointer.
      After calling additional locate actions that change the word location of locate pointer, 
      the previously saved position can be restored using the LocatePositionRestore action.<br/><br/>

      Using LocatePositionSave and LocatePositionRestore together
      provides an efficient way to reset the position to a located word, when the subsequent locate actions
      have moved the pointer to a located word.
      For example, when rules need to look for text in multiple directions based
      on a found word, these actions efficiently reset the internal locate
      pointer to a saved position instead of performing the original locate action a second time,
      which can require more processing time.<br/><br/>
      <e>
        Key List Right 1 Function<br/>
        + FindKeyList("InvNum")<br/>
        + <b>LocatePositionSave()</b><br/>
        + GoRightWord("1")<br/>
        + IsNumber("60")<br/>
        + UpdateField()<br/>
        Key List Down 1 Function<br/>
        + LocatePositionRestore()<br/>
        + GoBelowWord("1")<br/>
        + IsNumber("60")<br/>
        + UpdateField()<br/><br/>

        This example shows two functions.  The first performs a locate, saves the location, moves to the right and tests the word.
        If the word does not match the IsNumber criteria, then control falls to the next function which restores
        the saved locate position to the word found in the previous "FindKeyList" action and then
        looks in a different direction for a numeric value.  Alternatively, the second function could have called
        FindKeyList again, but the action to restore the last position is much more efficient.
      </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      <b>False</b> if called on the wrong level or if the COO does not exist. Otherwise, <b>True.</b>
    </ret>
    <see>
      LocatePositionRestore
    </see>
  </ref>

  <ref id="LocatePositionRestore">
    <ap>
      None.
    </ap>
    <h>
      LocatePositionRestore returns the internal locate word pointer to the word position it was on when
      LocatePositionSave was called.<br/><br/>

      Using LocatePositionSave and LocatePositionRestore together
      provides an efficient way to reset the position to a located word, when the subsequent locate actions
      have moved the pointer to a located word.
      For example, when rules need to look for text in multiple directions based
      on a found word, these actions efficiently reset the internal locate
      pointer to a saved position instead of performing the original locate action a second time,
      which can require more processing time.<br/><br/>
      <e>
        Key List Right 1 Function<br/>
        + FindKeyList("InvNum")<br/>
        + LocatePositionSave()<br/>
        + GoRightWord("1")<br/>
        + IsNumber("60")<br/>
        + UpdateField()<br/>
        Key List Down 1 Function<br/>
        + <b>LocatePositionRestore()</b><br/>
        + GoBelowWord("1")<br/>
        + IsNumber("60")<br/>
        + UpdateField()<br/><br/>

        This example shows two functions.  The first performs a locate, saves the location, moves to the right and tests the word.
        If the word does not match the IsNumber criteria, then control falls to the next function which restores
        the saved locate position to the word found in the previous "FindKeyList" action and then
        looks in a different direction for a numeric value.  Alternatively, the second function could have called
        FindKeyList again, but the action to restore the last position is much more efficient.
      </e>
    </h>
    <lvl>Page or field level.</lvl>
    <ret>
      <b>False</b> if called on the wrong level or if the COO does not exist. Otherwise, <b>True.</b>
    </ret>
    <see>
      LocatePositionSave
    </see>
  </ref>
  
  <ref id="Find_IgnoreCase">
    <ap>Toggles regular expression search case sensitivity.</ap>
    <h>
      Use of this action changes the search behavior for all 'Find' type key word search actions.
      Default behavior is a case sensitve search. This action with the parameter set to TRUE changes
      the keyword search behavior to be case insensitive. 
      To change back to the default behavior use this action with the FALSE parameter.
      <e>
        <b>Find_IgnoreCase(True)</b><br/>
        <b>WordFind("InvNum")</b><br/><br/>

        This action searches the current page, from first word to the last word of the current page, for the
        first occurance of the word "InvNum" regardless of the character case on the current page.
        If successful, the search stops and remembers the location of that word for subsequent actions;
        
      </e>
    </h>
    <lvl>Any.</lvl>
    <ret>
      Always <b>True</b>.
    </ret>
    <see>
      WordFind_InZone, WordFind_Offset, WordFindNext_InZone, WordFindNext, FindKeyList, FindNextKeyList, FindLastKeyList, AddKeyList, 
      FindDBList, FindDBList_InZone, FindKeyList_InZone, FindLastKeyList_InZone, FindLastRegEx, FindLastRegEx_InZone, FindLastRegExList, 
      FindLastRegExList_InZone, FindLastWord, FindLastWord_InZone, FindNextDBList, FindNextDBList_InZone, RegExFind, RegExFindNext, 
      RegExFind_InBlock, RegExFind_InZone
    </see>
  </ref>

  <ref id="SetVirtualPageStartPosition">
    <ap>None.</ap>
    <h>
      Use this action after performing Locate commands that identify the first word
      of a new virtual page.  This action requires that the page has an associated
      layout file and that the CCO has been populated using the CreateCcoFromLayout action.
      This action is expected to be used with CreateVirtualPage to build a new page using
      a subset of text from the current page.  See the help for CreateVirtualPage for
      more details.<br/><br/>
      <e>
        Recognize()<br/>
        CreateCcoFromLayout()<br/>
        WordFind("Hello")<br/>
        <b>SetVirtualPageStartPosition()</b><br/>
        WordFindNext("Good bye")<br/>
        GoUpLine("1")<br/>
        GoLastWord()<br/>
        SetVirtualPageEndPosition()<br/>
        CreateVirtualPage("MyNewPageType")<br/><br/>
      </e>
    </h>
    <lvl>Page level or field level.</lvl>
    <ret>
      <b>True</b> if the action is successful. <b>False</b> if an error occurs.
    </ret>
    <see>
      SetVirtualPageEndPosition, CreateVirtualPage, CreateCcoFromLayout
    </see>
  </ref>

  <ref id="SetVirtualPageEndPosition">
    <ap>None.</ap>
    <h>
      Use this action after performing Locate commands that identify the last word
      of a new virtual page.  This action requires that the page has an associated
      layout file and that the CCO has been populated using the CreateCcoFromLayout action.
      This action is expected to be used with CreateVirtualPage to build a new page using
      a subset of text from the current page.  See the help for CreateVirtualPage for
      more details.<br/><br/>
      <e>
        Recognize()<br/>
        CreateCcoFromLayout()<br/>
        WordFind("Hello")<br/>
        SetVirtualPageStartPosition()<br/>
        WordFindNext("Good bye")<br/>
        GoUpLine("1")<br/>
        GoLastWord()<br/>
        <b>SetVirtualPageEndPosition()</b><br/>
        CreateVirtualPage("MyNewPageType")<br/><br/>
      </e>
    </h>
    <lvl>Page level or field level.</lvl>
    <ret>
      <b>True</b> if the action is successful. <b>False</b> if an error occurs.
    </ret>
    <see>
      SetVirtualPageStartPosition, CreateVirtualPage, CreateCcoFromLayout
    </see>
  </ref>

  <ref id="CreateVirtualPage">
    <ap>
      The new page type for the created page can be optionally provided as a parameter to this action. 
      The provided name will be assigned
      as the type for the new DCO page that is created by this action.  If no parameter is provided, the new
      page type will default to "Other". Smart parameters are supported.
    </ap>
    <h>
      This action creates a new page that is a subset of an existing page or a subset of merged pages.
      Using the actions SetVirtualPageStartPosition and SetVirtualPageEndPosition, a segment of text from within
      the current page can be duplicated into a unique page. This approach can be useful to separate out
      a desired area of text to allow subsequent actions to work solely on the desired area.<br/><br/>

      A layout file is required to use this action and the CCO must be loaded from the layout file
      using the CreateCcoFromLayout action. The recognition of the layout file and creation of the CCO
      for the page can be performed in the same ruleset or in an earlier ruleset.  Multiple 
      pages within the same document can be merged together, using the action MergeLayoutByType, to create
      a multi-page segment of text to extracted into a new page.  For example, it is possible
      to merge together 3 pages of text and create a new page that starts with text from the bottom
      of page 1, all of the text in page 2 and text from the start of page 3.      
      When creating the new page, all of the text must be contiguous.<br/><br/>
      
      It is possible to create multiple new page subsets from a single page or single merged page.
      To do this, use the Start and End actions to define the start and end of a page,
      create the new virtual page, then define new start and end points, create another new page, etc.<br/><br/>

      The new pages that are created are no different than any other page. Actions that work on a page
      object can be used on these pages, allowing processing on these new pages as needed. For example,
      these new pages could be combined into their own new document and then processed with additional
      searches or exported.<br/><br/>

      When the new page is created, the image for the current page is copied to the name for the new
      page object and the new page object is added to the application's runtime DCO. The new
      page ID and associated image and layout file will use the name of the existing page
      with an underscore added and an number that is incremented if
      CreateVirtualPage is called multiple times on the same page.  For example, "TM000001_0".
      CreateCcoFromLayout can be called on the new page and have additional rules run on it as needed.<br/><br/>
      
      <e>
        Recognize()<br/>
        CreateCcoFromLayout()<br/>
        WordFind("Hello")<br/>
        SetVirtualPageStartPosition()<br/>
        WordFindNext("Good bye")<br/>
        GoUpLine("1")<br/>
        GoLastWord()<br/>
        SetVirtualPageEndPosition()<br/>
        <b>CreateVirtualPage("MyNewPageType")</b><br/><br/>

        This example recognizes a page, creating a layout file. The CCO is created from the layout file
        and then Locate actions are used to find the first word to include in the new page. The start of
        the new page's text segment is identified by calling SetVirtualPageStartPosition.
        The end of the text segment is located. In this example, the word "Good bye" indicates
        it is the end of the desired text.  Because the word "Good bye" should not be included
        in the new page, the located word position is moved to the last word of the line
        above the word "Good bye".  SetVirtualPageEndPosition then identifies this new position as the
        end of the new page segment.  Finally, the action CreateVirtualPage is called to
        create the new page.  After this action completes, the new page will exist in the document
        hierarchy and can be acted upon by subsequent rules and actions.<br/><br/>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      Returns <b>True</b> if the new page is created. Returns <b>False</b> if there is an error
      or if the start and end points for the block are not set.
    </ret>
    <see>
      SetVirtualPageStartPosition, SetVirtualPageEndPosition, CreateCcoFromLayout, MergeLayoutByType
    </see>
  </ref>

  <ref id="CreateVirtualZone">
    <ap>
      The name of the field which will have its zone assigned based on the previously set virtual start and end positions.
      If the field does not exist, it will be created.  Smart parameters are supported.
    </ap>
    <h>
      This action assigns zone coordinates to a field based on previously set start and end positions
      that were identified using locate actions.
      Using the actions SetVirtualPageStartPosition and SetVirtualPageEndPosition, a rectangular segment of text from within
      the current page can be identified at run time and set as a zoned area. This approach can be useful to 
      set the zone position of a field that is not a fixed location but can be determined by searching
      the recognized text to find the top-left corner and bottom-right corner of the zone area.<br/><br/>

      A layout file is required to use this action and the CCO must be loaded from the layout file
      using the CreateCcoFromLayout action. The recognition of the layout file and creation of the CCO
      for the page can be performed in the same ruleset or in an earlier ruleset.<br/><br/>

      Once the zone is set, it can be used just like a zone created from a fingerprint.
      Subsequent actions can be used to process the zoned text.<br/><br/>

      A field with coordinates set based on the contents of the recognized page can have many uses.
      One less obvious use would be for table identification when the table boundary is not
      determined by grid lines or the engine is not properly determining the table area
      even if grid lines exist.  In this scenario, use the locate actions to determine the
      top-left and bottom-right coordinates of the table with steps similar to the example below.
      This will find the table location based on the text that exists on the page. There would need
      to be expected text or positions to identify the table boundaries.
      After calling CreateVirtualZone, then the field can be identified with the variable
      y_TableZone as described in the help for the OCR/A Recognize action to provide
      table boundaries for better table identification by making a second call to the Recognize action.<br/><br/>

      <e>
        Recognize()<br/>
        CreateCcoFromLayout()<br/>
        WordFind("Hello")<br/>
        SetVirtualPageStartPosition()<br/>
        WordFindNext("Good bye")<br/>
        GoUpLine("1")<br/>
        GoLastWord()<br/>
        SetVirtualPageEndPosition()<br/>
        <b>CreateVirtualZone("MyField")</b><br/><br/>

        This example recognizes a page, creating a layout file. The CCO is created from the layout file
        and then Locate actions are used to find the first word to include in the new page. The start of
        the new page's text segment is identified by calling SetVirtualPageStartPosition.
        This location will be used at the left-top coordinate for the zone.
        The end of the text segment is located. In this example, the word "Good bye" indicates
        it is the end of the desired text.  Because the word "Good bye" should not be included
        in the new page, the located word position is moved to the last word of the line
        above the word "Good bye".  SetVirtualPageEndPosition then identifies this new position as the
        bottom-right position for the zone.  Finally, the action CreateVirtualZone is called to
        set the zone for the specified field based on the found text.<br/><br/>
      </e>
    </h>
    <lvl>Page or Field level.</lvl>
    <ret>
      Returns <b>True</b> if the zone is set on the field. Returns <b>False</b> if there is an error
      or if the start and end points for the zone are not set.
    </ret>
    <see>
      SetVirtualPageStartPosition, SetVirtualPageEndPosition, CreateCcoFromLayout, MergeLayoutByType
    </see>
  </ref>


</help>
 </rrx>
<rrx namespace="Lookup" src="c:\datacap\RRS\Lookup.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="OpenConnection" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    The Data Source Name or Connection String.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['   If the action is establishing a connection with an Oracle database,]]>
<![CDATA[
]]>
<![CDATA['   or a SQL Server database using SQL Authentication, be sure to expand the DSN parameter]]>
<![CDATA[
]]>
<![CDATA['   by adding the correct Provider, user ID and Password.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['   A smart parameters are supported to prevent plain text credentials in the application rules.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On error resume next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim i]]>
<![CDATA[
]]>
<![CDATA[  Dim sError]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	oConn.Errors.Clear]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	OpenConnection = True	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" and strParam<>sSmartParam Then ]]>
<![CDATA[
]]>
<![CDATA[    'attempt to decrypt value]]>
<![CDATA[
]]>
<![CDATA[    bRes = [securecall]sSmartParam,strParam[/securecall]   ]]>
<![CDATA[
]]>
<![CDATA[    If bRes=False Then Writelog("Value not decrypted.")]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter parsing. Using the original parameter string.") ]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	strParam = FormatADOConn(strParam)	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If oConn.State = 1 Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Connection is already Open, Function returns TRUE")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	oConn.CursorLocation=3]]>
<![CDATA[
]]>
<![CDATA[	oConn.Open(strParam)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("oConn.State = " & oConn.State)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If oConn.State = 1 Then OpenConnection = True Else OpenConnection = False : WriteLog(sError)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("OpenConnection returns " & OpenConnection )]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[	Call ConnErrHandler("Function OpenConnection")]]>
<![CDATA[
]]>
<![CDATA[		Call ErrorHandler("Function OpenConnection") ]]>
	</g>
</af>
<af name="CloseConnection" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA['Closes an open connection to your Lookup database.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ Dim i, sError]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ CloseConnection = True	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ Writelog("Close Connection...")]]>
<![CDATA[
]]>
<![CDATA[ Writelog("oConn.State = " & oConn.State)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ Call CloseDB()]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[ If oConn.State = 1 Then CloseConnection = True Else Writelog(sError)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[ Writelog("CloseConnection returns " & CloseConnection )]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[ Call ConnErrHandler("Function CloseConnection")]]>
<![CDATA[
]]>
<![CDATA[ Call ErrorHandler("Function CloseConnection") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PopulateWithResult" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    1. A number <var>n</var> indicating which value in a record retrieved by an]]>
<![CDATA[
]]>
<![CDATA['    earlier <scr>ExecuteSQL</scr> action is to be assigned to the current]]>
<![CDATA[
]]>
<![CDATA['    Field object (and added to the Data file of the current page.)]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    "1" refers to the first column in a recordset, "2" refers to the second column, etc.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    2. True or False. True causes the action to fail if the action]]>
<![CDATA[
]]>
<![CDATA['    returns a recordset with multiple lines. False permits the action to accept a recordset with multiple]]>
<![CDATA[
]]>
<![CDATA['    lines but to use values in the first record of the recordset.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & ",," , ",")]]>
<![CDATA[
]]>
<![CDATA[	bMultiReturnFail = True	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  aStrParam(0)=Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[  aStrParam(1)=Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Ucase(aStrParam(1)) = "FALSE" Then]]>
<![CDATA[
]]>
<![CDATA[		bMultiReturnFail = False]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	PopulateWithResult = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Beginning Populate With Results")	]]>
<![CDATA[
]]>
<![CDATA[	If Not(IsNumeric(aStrParam(0))) Then aStrParam(0)=1 ]]>
<![CDATA[
]]>
<![CDATA[	aStrParam(0) = CLng(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Note: g_aResults is a two dimensional array of results from a prior lookup]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If IsArray(g_aResults) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Array Found")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		writelog((UBound(g_aResults,2)+1) & " Columns in DB Array.")]]>
<![CDATA[
]]>
<![CDATA[		If (aStrParam(0) > UBound(g_aResults,2)+1) Or (aStrParam(0)<1) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Queried Column Value '" & aStrParam(0) & "' is an invalid number. Setting to '1'.") ]]>
<![CDATA[
]]>
<![CDATA[			aStrParam(0) = 1]]>
<![CDATA[
]]>
<![CDATA[		End If	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If bMultiReturnFail = True And UBound(g_aResults,1) >= 1 Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Multiple Rows returned")]]>
<![CDATA[
]]>
<![CDATA[		Else	]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Populating Current Field with Result #" & aStrParam(0) & " : '" & g_aResults(0,aStrParam(0)-1) & "' ")]]>
<![CDATA[
]]>
<![CDATA[			CurrentObj.Text = CStr(g_aResults(0,aStrParam(0)-1))]]>
<![CDATA[
]]>
<![CDATA[			PopulateWithResult = True]]>
<![CDATA[
]]>
<![CDATA[		End If	]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("PopulateWithResult returns " & PopulateWithResult)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ConnErrHandler("Function PopulateWithResult")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function PopulateWithResult") ]]>
	</g>
</af>
<af name="ExecuteSQL" access="public" bInter="bInter" bDebug="bDebug" strParam="sStringIn">
	<g>
<![CDATA[
]]>
<![CDATA[	' section 1 : SELECT * FROM [Names] WHERE Zip=%s AND State='%s';]]>
<![CDATA[
]]>
<![CDATA[	' section 2 : ZipCode, State  (Sibling DCO field names, Values are 10951 and NY)]]>
<![CDATA[
]]>
<![CDATA[	' Constructs SQL of: SELECT * FROM [Names] WHERE Zip=10951 AND State='NY';]]>
<![CDATA[
]]>
<![CDATA[	' Result is saved as the calling field value. ]]>
<![CDATA[
]]>
<![CDATA[	' Suppress Result saved to field by having a field name of '-1' in fields list]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	Dim bSuppressResult]]>
<![CDATA[
]]>
<![CDATA[	bSuppressResult = (InStr(FieldList,"-1") > 0)]]>
<![CDATA[
]]>
<![CDATA[	ExecuteSQL = ExecuteSQLEx(sStringIn, Not bSuppressResult, "")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<f name="ExecuteSQLEx" access="public">
	<p name="sStringIn">
	</p>
	<p name="sPopulate" type="bool">
	</p>
	<p name="sTarget">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[	' section 1 : SELECT * FROM [Names] WHERE Zip=%s AND State='%s';]]>
<![CDATA[
]]>
<![CDATA[	' section 2 : ZipCode, State  (Sibling DCO field names, Values are 10951 and NY)]]>
<![CDATA[
]]>
<![CDATA[	' Constructs SQL of: SELECT * FROM [Names] WHERE Zip=10951 AND State='NY';]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim oRS ]]>
<![CDATA[
]]>
<![CDATA[	Dim sSQL]]>
<![CDATA[
]]>
<![CDATA[	Dim Index]]>
<![CDATA[
]]>
<![CDATA[	Dim nSubst]]>
<![CDATA[
]]>
<![CDATA[	Dim Tmpstr]]>
<![CDATA[
]]>
<![CDATA[	Dim Counter]]>
<![CDATA[
]]>
<![CDATA[	Dim FieldVal]]>
<![CDATA[
]]>
<![CDATA[	Dim FieldList ]]>
<![CDATA[
]]>
<![CDATA[	Dim FieldArray]]>
<![CDATA[
]]>
<![CDATA[	Dim RowCount	]]>
<![CDATA[
]]>
<![CDATA[	Dim bSuppressResult]]>
<![CDATA[
]]>
<![CDATA[	Dim nStart]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ExecuteSQLEx = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Check for Connection Errors]]>
<![CDATA[
]]>
<![CDATA[	writelog("Checking connection...")]]>
<![CDATA[
]]>
<![CDATA[	If Not isobject(oConn) Or oConn is Nothing then]]>
<![CDATA[
]]>
<![CDATA[		writelog("No DB Connection Object. Aborting Task.")]]>
<![CDATA[
]]>
<![CDATA[		nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If oConn.State =0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("DB Connection is Closed.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sStringIn = Trim(sStringIn)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	g_aResults = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Index = InStrRev(sStringIn, Chr(34))	]]>
<![CDATA[
]]>
<![CDATA[	If Index > 1 Then ]]>
<![CDATA[
]]>
<![CDATA[	    sSQL = Left(sStringIn,index-1)]]>
<![CDATA[
]]>
<![CDATA[		FieldList = Mid(sStringIn,(index+2),Len(sStringIn))]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		sSQL = sStringIn]]>
<![CDATA[
]]>
<![CDATA[		FieldList = ""]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Parameter : " & sStringIn)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("    Index : " & index)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("  Raw SQL : " & sSql)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("FieldList : " & FieldList)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Pre-Substitute")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      FieldArray = Split(FieldList & ",",",")]]>
<![CDATA[
]]>
<![CDATA[      nSubst = InStr(sSQL,"%s")]]>
<![CDATA[
]]>
<![CDATA[      Counter = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	bSuppressResult = (Not sPopulate)]]>
<![CDATA[
]]>
<![CDATA[	If bSuppressResult Then Writelog("Suppressing Result to DCO.Text is ON")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  While nSubst > 0]]>
<![CDATA[
]]>
<![CDATA[	   writelog("FieldName:" & FieldArray(Counter))]]>
<![CDATA[
]]>
<![CDATA[	   FormatLen = 0]]>
<![CDATA[
]]>
<![CDATA[	   If nSubst+2<len(sSQL) Then]]>
<![CDATA[
]]>
<![CDATA[	      ch = Mid(sSQL,nSubst+2,1)]]>
<![CDATA[
]]>
<![CDATA[	      C = ASC(ch)]]>
<![CDATA[
]]>
<![CDATA[	      If(C >= 48 And C <= 57) then]]>
<![CDATA[
]]>
<![CDATA[	         FormatLen = cInt(ch)]]>
<![CDATA[
]]>
<![CDATA[	      End If]]>
<![CDATA[
]]>
<![CDATA[	   End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If FieldArray(Counter)<>"-1" Then ]]>
<![CDATA[
]]>
<![CDATA[		  FieldVal=ReturnNamedValue(FieldArray(Counter)) ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("FieldVal: '" & FieldVal & "' ")]]>
<![CDATA[
]]>
<![CDATA[			FieldVal = replace(FieldVal,"'","''")]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If FormatLen = 0 Then]]>
<![CDATA[
]]>
<![CDATA[	       sSQL = Mid(sSQL,1,nSubst-1) & FieldVal & Mid(sSQL,nSubst+2,Len(sSQL))]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[         sSQL = Mid(sSQL,1,nSubst-1) & Mid(FieldVal,1,FormatLen) & Mid(sSQL,nSubst+3,Len(sSQL))]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      nSubst = InStr(sSQL,"%s")  ]]>
<![CDATA[
]]>
<![CDATA[		End If	]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		Counter = Counter+1		]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    'Remove leading spaces and quote char]]>
<![CDATA[
]]>
<![CDATA[    If len(sSQL)>1 Then]]>
<![CDATA[
]]>
<![CDATA[        While left(sSQL,1)=CHR(34)]]>
<![CDATA[
]]>
<![CDATA[            sSQL = Right(sSQL,len(sSQL)-1) ]]>
<![CDATA[
]]>
<![CDATA[            sSQL = Trim(sSQL) ]]>
<![CDATA[
]]>
<![CDATA[            If len(sSQL)<=1 then]]>
<![CDATA[
]]>
<![CDATA[                Writelog("SQL Expression '" & sSQL & "' is less than 1 character long. Exiting Function.")]]>
<![CDATA[
]]>
<![CDATA[                Exit Function]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[    	wend]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Call ErrorHandler("Post Substitute")]]>
<![CDATA[
]]>
<![CDATA[	  sSQL = ModifySQLByDBType(oConn,sSQL)]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Constructed SQL :" & sSQL)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ExecuteSQLEx = True]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If InStr(Ucase(sSQL), "SELECT")=1 or InStr(Ucase(sSQL), "EXEC")=1 Then]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		Set oRS = oConn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[      			]]>
<![CDATA[
]]>
<![CDATA[    If IsAlive(oRS) then]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[        If oRS.State=0 Then       ]]>
<![CDATA[
]]>
<![CDATA[          writelog("RecordSet returned Closed.")]]>
<![CDATA[
]]>
<![CDATA[        Elseif oRS.EOF Or oRS.BOF Then ]]>
<![CDATA[
]]>
<![CDATA[			    ExecuteSQLEx = False ]]>
<![CDATA[
]]>
<![CDATA[			    writelog("RecordSet Returns EOF or BOF. Exiting Function.")]]>
<![CDATA[
]]>
<![CDATA[			    Call ConnErrHandler("EOF or BOF")]]>
<![CDATA[
]]>
<![CDATA[			    Exit Function]]>
<![CDATA[
]]>
<![CDATA[		    Else]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		        Tmpstr = oRS.GetString]]>
<![CDATA[
]]>
<![CDATA[        	]]>
<![CDATA[
]]>
<![CDATA[		        Writelog("Query Return String: " & Tmpstr)]]>
<![CDATA[
]]>
<![CDATA[        			]]>
<![CDATA[
]]>
<![CDATA[		        If (Len(Tmpstr) <> 0) AND (Not bSuppressResult) Then]]>
<![CDATA[
]]>
<![CDATA[					If sTarget <> "" Then]]>
<![CDATA[
]]>
<![CDATA[						Call rrSet("@STRING(" & Left(tmpstr, Len(tmpstr)-1) & ")", sTarget)]]>
<![CDATA[
]]>
<![CDATA[					Else]]>
<![CDATA[
]]>
<![CDATA[						CurrentObj.Text = Left(tmpstr, Len(tmpstr)-1)]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[		        End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		        RowCount = 0]]>
<![CDATA[
]]>
<![CDATA[		        oRS.MoveFirst]]>
<![CDATA[
]]>
<![CDATA[		        While Not oRS.EOF	]]>
<![CDATA[
]]>
<![CDATA[			        RowCount = RowCount + 1]]>
<![CDATA[
]]>
<![CDATA[			        oRS.MoveNext()]]>
<![CDATA[
]]>
<![CDATA[		        Wend]]>
<![CDATA[
]]>
<![CDATA[        	]]>
<![CDATA[
]]>
<![CDATA[		        Writelog(Space(3) & (RowCount) & " Row(s) containing " & oRS.Fields.Count & " fields found.")]]>
<![CDATA[
]]>
<![CDATA[		        ReDim g_aResults(RowCount-1,oRS.Fields.Count-1)]]>
<![CDATA[
]]>
<![CDATA[        	]]>
<![CDATA[
]]>
<![CDATA[		        oRS.MoveFirst]]>
<![CDATA[
]]>
<![CDATA[		        For Row = 0 To RowCount-1]]>
<![CDATA[
]]>
<![CDATA[			        fldStr = ""]]>
<![CDATA[
]]>
<![CDATA[			        For Fld = 0 To oRS.Fields.Count-1]]>
<![CDATA[
]]>
<![CDATA[				        if IsNull(oRS.Fields(Fld).Value) Then]]>
<![CDATA[
]]>
<![CDATA[					        g_aResults(Row,Fld) = ""]]>
<![CDATA[
]]>
<![CDATA[					        fldStr = fldStr & "["& "" & "] "]]>
<![CDATA[
]]>
<![CDATA[				        else]]>
<![CDATA[
]]>
<![CDATA[					        g_aResults(Row,Fld) = CStr(oRS.Fields(Fld).Value)]]>
<![CDATA[
]]>
<![CDATA[					        fldStr = fldStr & "["& oRS.Fields(Fld).Value & "] "]]>
<![CDATA[
]]>
<![CDATA[				        end if]]>
<![CDATA[
]]>
<![CDATA[			        Next 'Fld]]>
<![CDATA[
]]>
<![CDATA[			        Writelog("RowSet: " & fldStr)	]]>
<![CDATA[
]]>
<![CDATA[			        oRS.MoveNext]]>
<![CDATA[
]]>
<![CDATA[		        Next 'Row]]>
<![CDATA[
]]>
<![CDATA[        		]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[		    ]]>
<![CDATA[
]]>
<![CDATA[        Set oRS = Nothing]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[		End if 'IsAlive(oRS)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Call oConn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If oConn.Errors.Count=0 Then]]>
<![CDATA[
]]>
<![CDATA[		ExecuteSQLEx = True]]>
<![CDATA[
]]>
<![CDATA[		Writelog("SUCCESS: SQL Statement executed properly") ]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		ExecuteSQLEx = False]]>
<![CDATA[
]]>
<![CDATA[		Writelog("ERROR:The SQL statement DID NOT execute properly")]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ConnErrHandler("ExecuteSQLEx")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("ExecuteSQLEx")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</f>
<f name="SmartSQL" access="public">
	<p name="sStringIn">
	</p>
	<p name="sPopulate">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA['    <b>1.</b>The SQL expression you want to execute.  Smart parameters are supported within the expression.<br/>]]>
<![CDATA[
]]>
<![CDATA['    <b>2.</b>True/False value to enable or suppress populating value of any record returned from the SQL expression.<br/>]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	Dim bSuppressResult]]>
<![CDATA[
]]>
<![CDATA[	bSuppressResult = False]]>
<![CDATA[
]]>
<![CDATA[	If InStr(sPopulate,"0")>0 or ucase(sPopulate)="NO" or ucase(sPopulate)="FALSE" Then bSuppressResult = True]]>
<![CDATA[
]]>
<![CDATA[	SmartSQL = SmartSQLEx(sStringIn, Not bSuppressResult, "")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</f>
<f name="SmartSQLEx" access="public">
	<p name="sStringIn">
	</p>
	<p name="sPopulate" type="bool">
	</p>
	<p name="sTarget">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[  Dim oRS ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSQL]]>
<![CDATA[
]]>
<![CDATA[  Dim bSuppressResult]]>
<![CDATA[
]]>
<![CDATA[  Dim nStart]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[  Dim Row]]>
<![CDATA[
]]>
<![CDATA[  Dim RowCount]]>
<![CDATA[
]]>
<![CDATA[  Dim Tmpstr]]>
<![CDATA[
]]>
<![CDATA[  Dim fldstr]]>
<![CDATA[
]]>
<![CDATA[  Dim bError]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SmartSQLEx = False]]>
<![CDATA[
]]>
<![CDATA[	'oConn.Errors]]>
<![CDATA[
]]>
<![CDATA[	writelog("Checking connection...")]]>
<![CDATA[
]]>
<![CDATA[	If Not isobject(oConn) Or oConn is Nothing then]]>
<![CDATA[
]]>
<![CDATA[		writelog("No DB Connection Object. Aborting Task.")]]>
<![CDATA[
]]>
<![CDATA[		nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If oConn.State =0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("DB Connection is Closed.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sStringIn = Trim(sStringIn)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	g_aResults = ""]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Pre Smart Parameter Parsing")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	bSuppressResult = (Not sPopulate)]]>
<![CDATA[
]]>
<![CDATA[	If bSuppressResult Then Writelog("Suppressing Result to DCO Text property is ON")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Convert Smart Parameters]]>
<![CDATA[
]]>
<![CDATA[  sValue = MetaWord(sStringIn)]]>
<![CDATA[
]]>
<![CDATA[	If Len(sValue)=0 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No smart parameter return value.")]]>
<![CDATA[
]]>
<![CDATA[		sSQL=sStringIn]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sSQL=sValue]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Post Smart Parameter Parsing")]]>
<![CDATA[
]]>
<![CDATA[	sSQL = ModifySQLByDBType(oConn,sSQL)]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Constructed SQL :" & sSQL)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SmartSQLEx = True]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If InStr(Ucase(sSQL), "SELECT")=1 or InStr(Ucase(sSQL), "EXEC")=1 Then]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		Set oRS = oConn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[      			]]>
<![CDATA[
]]>
<![CDATA[    If IsAlive(oRS) then]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[        If oRS.State=0 Then       ]]>
<![CDATA[
]]>
<![CDATA[          writelog("RecordSet returned Closed.")                   ]]>
<![CDATA[
]]>
<![CDATA[		    ElseIf oRS.EOF Or oRS.BOF Then ]]>
<![CDATA[
]]>
<![CDATA[			    SmartSQLEx = False ]]>
<![CDATA[
]]>
<![CDATA[			    writelog("RecordSet Returns EOF or BOF. Exiting Function.")]]>
<![CDATA[
]]>
<![CDATA[			    Call ConnErrHandler("EOF or BOF")]]>
<![CDATA[
]]>
<![CDATA[			    Exit Function]]>
<![CDATA[
]]>
<![CDATA[		    Else]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		      Tmpstr = oRS.GetString]]>
<![CDATA[
]]>
<![CDATA[      	]]>
<![CDATA[
]]>
<![CDATA[		      Writelog("Query Return String: " & Tmpstr)]]>
<![CDATA[
]]>
<![CDATA[      			]]>
<![CDATA[
]]>
<![CDATA[		      If (Len(Tmpstr) <> 0) AND (Not bSuppressResult) Then]]>
<![CDATA[
]]>
<![CDATA[					If sTarget <> "" Then]]>
<![CDATA[
]]>
<![CDATA[						Call rrSet("@STRING(" & Left(tmpstr, Len(tmpstr)-1) & ")", sTarget)]]>
<![CDATA[
]]>
<![CDATA[					Else]]>
<![CDATA[
]]>
<![CDATA[						CurrentObj.Text = Left(tmpstr, Len(tmpstr)-1)]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[		      End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		      RowCount = 0]]>
<![CDATA[
]]>
<![CDATA[		      oRS.MoveFirst]]>
<![CDATA[
]]>
<![CDATA[		      While Not oRS.EOF	]]>
<![CDATA[
]]>
<![CDATA[			      RowCount = RowCount + 1]]>
<![CDATA[
]]>
<![CDATA[			      oRS.MoveNext()]]>
<![CDATA[
]]>
<![CDATA[		      Wend]]>
<![CDATA[
]]>
<![CDATA[      	]]>
<![CDATA[
]]>
<![CDATA[		      Writelog(Space(3) & (RowCount) & " Row(s) containing " & oRS.Fields.Count & " fields found.")]]>
<![CDATA[
]]>
<![CDATA[		      ReDim g_aResults(RowCount-1,oRS.Fields.Count-1)]]>
<![CDATA[
]]>
<![CDATA[      	]]>
<![CDATA[
]]>
<![CDATA[		      oRS.MoveFirst]]>
<![CDATA[
]]>
<![CDATA[		      For Row = 0 To RowCount-1]]>
<![CDATA[
]]>
<![CDATA[			      fldStr = ""]]>
<![CDATA[
]]>
<![CDATA[			      For Fld = 0 To oRS.Fields.Count-1]]>
<![CDATA[
]]>
<![CDATA[				      if IsNull(oRS.Fields(Fld).Value) Then]]>
<![CDATA[
]]>
<![CDATA[					      g_aResults(Row,Fld) = ""]]>
<![CDATA[
]]>
<![CDATA[					      fldStr = fldStr & "["& "" & "] "]]>
<![CDATA[
]]>
<![CDATA[				      else]]>
<![CDATA[
]]>
<![CDATA[					      g_aResults(Row,Fld) = CStr(oRS.Fields(Fld).Value)]]>
<![CDATA[
]]>
<![CDATA[					      fldStr = fldStr & "["& oRS.Fields(Fld).Value & "] "]]>
<![CDATA[
]]>
<![CDATA[				      end if]]>
<![CDATA[
]]>
<![CDATA[			      Next 'Fld]]>
<![CDATA[
]]>
<![CDATA[			      Writelog("RowSet: " & fldStr)	]]>
<![CDATA[
]]>
<![CDATA[			      oRS.MoveNext]]>
<![CDATA[
]]>
<![CDATA[		      Next 'Row]]>
<![CDATA[
]]>
<![CDATA[      		]]>
<![CDATA[
]]>
<![CDATA[		      If IsObject(LogWindow) Then ValueUp.Text = GetFieldValue]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[       End if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[       Set oRS = Nothing]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[		End if 'IsAlive(oRS)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Call oConn.Execute(sSQL)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Trap Warnings Here ]]>
<![CDATA[
]]>
<![CDATA[	 bError = DBErrTrap(oConn,"SmartSQLEx")]]>
<![CDATA[
]]>
<![CDATA[  'DBErrTrap returns True on valid error, false on warnings. Clears all errors.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If bError=False Then]]>
<![CDATA[
]]>
<![CDATA[		SmartSQLEx = True]]>
<![CDATA[
]]>
<![CDATA[		Writelog("SUCCESS: SQL Statement executed properly") ]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		SmartSQLEx = False]]>
<![CDATA[
]]>
<![CDATA[		Writelog("ERROR:The SQL statement DID NOT execute properly")]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("SmartSQLEx")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</f>
<af name="ClearLookupResults" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ' This action clears the stored results returned from a previous Lookup action such as PopulateWithResult.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ClearLookupResults=True]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Clearing Lookup Results.")]]>
<![CDATA[
]]>
<![CDATA[  g_aResults = ""]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************
' help.xml for Lookup 
'************************************************************
]]>

  <ref id="OpenConnection">
    <ap>
      Uses a data source name or connection string to open a connection to a Lookup database.<br/><br/>

      The Database Connection String, using an OLEDB or ODBC database provider.
      If the action is establishing a connection with DB2, Oracle database, or SQL Server database, you must specify the user ID and Password. Some database providers support integrated authentication, which use the credentials of the running process.

      Smart parameters are supported and recommended to prevent plain text credentials in the application rules.
    </ap>
    <h>
      This action uses the Connection String you provide as the parameter
      to open a connection to your LookUp database.
      <e>
        <b>OpenConnection("@APPVAR(*/fingerprintconn:cs)")</b><br/>
        This example opens the fingerprint database and obtains the connection information from the Application Service.
        It is recomended to use the applicaiton service so passwords are kept hidden.<br/><br/>

        <b>Access:</b><br/>
        <b>OpenConnection("Provider=MSACCESS;DSN=C:\Datacap\1040EZ\1040ezLook.mdb;UID=;PWD=;")</b><br/><br/>

        <b>Oracle:</b><br/>
        <b>OpenConnection("Provider=OraOLEDB.Oracle.1;Password=mypassword;Persist Security Info=True;User ID=myuserid;Data Source=TM2")</b><br/><br/>

        <b>SQL Server (Standard Authentication):</b><br/>
        <b>OpenConnection("Provider=SQLOLEDB;Data Source=SQLServerName;Initial Catalog=myDatabase;User ID=myUserid;Password=myPassword;")</b><br/><br/>

        <b>SQL Server (Integrated Authentication):</b><br/>
        <b>OpenConnection("Provider=SQLOLEDB;Data Source=SQLServerName;Initial Catalog=myDatabase;Integrated Security=SSPI;")</b><br/><br/>

        <b>DB2:</b><br/>
        <b>OpenConnection("Provider=IBMDADB2;Hostname=1.22.333.444;Port=50000;Data Source=DB2;Database=myDatabase;User ID=myUserid;Password=myPassword;")</b><br/>

      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if the action results in a connection to the database. Otherwise, <b>False.</b>
    </ret>
    <see>
      <scr>CloseConnection</scr>
    </see>
  </ref>
  
 <ref id="CloseConnection">
  <ap>None.</ap>
  <h>
     Closes an open connection to your Lookup database.<br/><br/>

	   Usually, this action is placed in a RuleSet that is separate from the RuleSet that opens 
     the connection and stores the data.<br/><br/>

     LookupDBClose RuleSet, for example, is run at the Batch level after all data has been 
     exported from the batch to the specified database.<br/><br/><e><b>CloseConnection()</b><br/><br/>

       This action closes the previously opened connection to the Lookup database.<br/><br/>

       This action is usually part of a separate RuleSet that prevents the 
       need to repeatedly open the connection to the database. (You can 
       open the connection once in the first RuleSet, use the database from all 
       documents and pages in the batch, then close the connection once in the second RuleSet.) 
     </e>
    </h>
    <lvl>All, but generally used as part of a separate RuleSet at the Batch level.</lvl>
    <ret><b>True,</b> even if the connection is already closed.
  </ret>
    <see><scr>OpenConnection</scr>
    </see>
     </ref>
 <!-- NOTE: LookupCurrentValue is DEPRECATED 06/03/2011 -->
 <!--
 <ref id="LookupCurrentValue">
  <ap>
     Four clauses of a SQL SELECT statement (see the example):<br/>
	- SELECT clause: designates the column or columns to be checked.<br/>
	- FROM clause:  identifies the source table within the previously opened database.<br/>
	- WHERE clause: specifies the matching criteria.<br/>
	- AND clause (optional): limits the statement's scope.<br/><br/><b>Note:</b>If the action is looking for values in an ORACLE database, 
    the parameters must be in UPPER CASE.
  </ap>
  <h>
    Queries an open LookUp database to see if a Field object's captured value is also a 
    value in the database. Requires ODBC Type database connection.<br/><br/><e>
      OpenConnection("InvoiceLook")<br/><b>LookupCurrentValue("PONumber,Vendor,PONumber")</b><br/>
		  CloseConnection()<br/><br/>

		  This sequence looks in the Vendor table of the InvoiceLook database to see if the captured 
      value of the current Field object is also a value in the database.<br/><br/>

	  	The LookupCurrentValue action uses its parameters to assemble a SQL SELECT statement 
      with these clauses:<br/><br/>

		  SELECT PONumber(column)<br/>
  		FROM Vendor(table)<br/>
		  WHERE PONumber(captured value)<br/><br/>

		  The action returns <b>True</b> if the PONumber column in the Vendor table
      contains a value equal to the captured value of the current Field object.

      NOTE: This action will be deprecated in a future release. It's functionality has been replaced by actions "ExecuteSQL" and "SmartSQL".
      
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>False</b> if the action is not applied at the Field level;
    if the database connection was not opened; or the captured value is not in the database.
    Otherwise, <b>True.</b></ret>
    <see><scr>LookUpReturnValue</scr>
    </see>
     </ref>
 -->
 <!-- NOTE: LookupReturnValue is DEPRECATED 6/3/2011  -->
 <!--
 <ref id="LookupReturnValue">
  <ap> 
    Four clauses of a SQL SELECT statement (see the example):<br/>
    - SELECT clause: designates the column or columns to be checked.<br/>
    - FROM clause:  identifies the source table within the previously opened database.<br/>
    - WHERE clause: specifies the matching criteria.<br/>
    - AND clause (optional): limits the statement's scope.<br/><br/><b>Note:</b>If the action is looking for values in an ORACLE database, 
    the parameters must be in UPPER CASE.
	</ap>
  <h>
    Uses the captured value associated with the current Field object to determine if a
    table in an open LookUp database contains a corresponding value. Requires ODBC Type database connection.<br/><br/>

    If there is a match (True), the <scr>PopulateWithResult</scr>
     action updates 
    the Data file of the current page with the value.<br/><br/><e>
      OpenConnection("@APPVAR(*/fingerprintconn:cs)")<br/>
      <b>LookupReturnValue("VendorName,Vendor,VendorID")</b><br/>
		  PopulateWithResult("1,FALSE")<br/>
		  CloseConnection()<br/><br/>

      This sequence looks in the Vendor table of the InvoiceLook database, for a VendorID 
      value that matches the captured value of the current VendorID  Field object.<br/><br/>

      If the search is successful (True), the follow-up PopulateWithResult
      action assigns the Vendor Name value to the Data file of the current page, as the
      VendorName field's captured value.

      NOTE: This action will be deprecated in a future release. It's functionality has been replaced by actions "ExecuteSQL" and "SmartSQL".
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>False</b> if the action is not applied at the Field level;
    the database connection was not opened; or the captured value is not in the database.
    Otherwise, <b>True.</b></ret>
    <see><scr>LookupCurrentValue, PopulateWithResult</scr>
    </see>
     </ref>
  -->
  
 <ref id="PopulateWithResult">
  <ap><b>1.</b> A number  indicating which value in a record retrieved by an
    earlier <scr>ExecuteSQLEx</scr>
     or <scr>SmartSQLEx</scr>
     action is to be assigned to the current
    Field object (and added to the Data file of the current page.)<br/><br/>

    "1" refers to the first column in a recordset, "2" refers to the second column, etc.<br/><br/><b>2.</b> True or False. True causes the action to fail if the action
    returns a recordset with multiple lines. False permits the action to accept a recordset with multiple
    lines but to use values in the first record of the recordset.
  </ap>
  <h>
    Populates a Field object with a database value retrieved by
    a <scr>ExecuteSQLEx</scr> or <scr>SmartSQLEx</scr> action.<br/><br/>

    This action allows multiple rules to populate multiple Field objects with data from a
    single database record (see the example below.)<br/><br/><e>
      (Field #1)<br/>
      OpenConnection("@APPVAR(*/lookupdb:cs)")<br/>
      ExecuteSQLEx(""Select * From Vendor Where VendorID = %s;",VendorID", "True", "")<br/>
      <b>PopulateWithResult("1,FALSE")</b><br/><br/>

      (Field #2)<br/><b>PopulateWithResult("2,FALSE")</b><br/><br/>

      In the example, the <scr>ExecuteSQLEx</scr>
     action of the RuleSet applied to Field #1
      retrieves the recordset (if it exists). The <scr>PopulateWithResult</scr>
     action places
      the value of the first record's first column into the field where the rule has been applied.<br/><br/>

      The <scr>PopulateWithResult</scr>
     action of a rule applied to Field #2 populates the field with
      the value of the first record's second column.<br/><br/><b>False</b> means that the action can accept a recordset with multiple records but will
      extract value(s) from the first record only.
    </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret><b>True</b> if the second parameter is "True" and a previous <scr>ExecuteSQLEx</scr> or <scr>SmartSQLEx</scr> action finds 
    a recordset with only one record.<br/><br/><b>True</b> if the second parameter is "False" and a previous ExecuteSQLEx (or SmartSQLEx) 
    action finds a recordset with one or more records.<br/><br/>

    Otherwise, <b>False.</b></ret>
    <see><scr>ExecuteSQLEx</scr>,<scr>SmartSQLEx</scr>
    </see>
     </ref>
  
 <ref id="ExecuteSQL" qi="This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by ExecuteSQLEx.">
  <ap><b>1.</b>The SQL expression you want to execute surrounded by quotation marks (" ")<br/>
    '%s' or %s can be substituted in the SQL expression to represent a field value. <br/>
    If %s represents a text field, it must be surrounded by ' '. <br/>
    If %s represents a numeric field, it appears without surrounding apostrophe characters.<br/><br/><b>2,3+</b>Field names whose captured values you want to use in the SQL expression (see the example).<br/></ap>
  <h>
    Executes the SQL statement you enter in the first parameter. Field values can be substituted
    for "%s" in the statement.<br/><br/><e>
      This sequence opens a connection to the InvoiceLook database.  Next, it inserts values
      into the CompanyCode and Type columns of the Vendor table:<br/><br/>
      OpenConnection("@APPVAR(*/lookupdb:cs)")<br/>
      <b>ExecuteSQL("INSERT INTO Vendor (CompanyCode,Type) VALUES ('MQSW','New')")</b><br/><br/>
      
      Here, dbVendorID is a numeric field while dbVendorname is a text field:<br/><br/>
      OpenConnection("@APPVAR(*/fingerprintconn:cs)")<br/>
      ExecuteSQL(""SELECT CompanyCode  FROM Vendor WHERE dbVendorID = %s AND dbVendorName = '%s';",VendorID,VendorName")
      <br/><br/></e>
    </h>
    <lvl>All.</lvl>
    <ret><b>True</b> if the SQL statement executes successfully, select statements must also
    return a value.<br/><b>False,</b> if it does not.
  </ret>
   <see>ExecuteSQLEx</see>
     </ref>
  
  <ref id="ExecuteSQLEx">
  <ap>
    <b>sStringIn</b> - 1. The SQL expression you want to execute surrounded by quotation marks (" ")<br/>
      '%s' or %s can be substituted in the SQL expression to represent a field value. <br/>
      If %s represents a text field, it must be surrounded by ' '. <br/>
      If %s represents a numeric field, it appears without surrounding apostrophe characters.<br/>
      <b>2,3+</b>. Field names whose captured values you want to use in the SQL expression (see the example).<br/><br/>
    <b>sPopulate</b> - True/False value to enable or suppress populating value of any record returned from the SQL expression.<br/><br/>
    <b>sTarget</b> - Smart Parameter destination for value population, leave blank for current object's Text property.<br/>
  </ap>
  <h>
    Executes the SQL statement you enter in the first parameter. Field values can be substituted
    for "%s" in the statement.<br/><br/><e>
      This sequence opens a connection to the InvoiceLook database.  Next, it inserts values
      into the CompanyCode and Type columns of the Vendor table:<br/><br/>
      OpenConnection("@APPVAR(*/lookupdb:cs)")<br/>
      <b>ExecuteSQLEx("INSERT INTO Vendor (CompanyCode,Type) VALUES ('MQSW','New')", "False", "")</b><br/><br/>
      
      Here, dbVendorID is a numeric field while dbVendorname is a text field:<br/><br/>
      OpenConnection("@APPVAR(*/fingerprintconn:cs)")<br/>
      <b>ExecuteSQLEx(""SELECT CompanyCode  FROM Vendor WHERE dbVendorID = %s AND dbVendorName = '%s';",VendorID,VendorName", "True", "@F.MyLookupResult")</b>
      <br/><br/></e>
    </h>
    <lvl>All.</lvl>
    <ret><b>True</b> if the SQL statement executes successfully, select statements must also
    return a value.<br/><b>False,</b> if it does not.
  </ret>
     </ref>
  
 <ref id="SmartSQL" qi="This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by SmartSQLEx.">
  <ap><b>1.</b>The SQL expression you want to execute.  Smart parameters are supported within the expression.<br/><b>2.</b>True/False value to enable or suppress populating value of any record returned from the SQL expression.<br/></ap>
  <h>
    Executes the SQL statement you enter in the first parameter.<br/><br/><e>
      This sequence opens a connection to the InvoiceLook database.  Next, it inserts values
      into the CompanyCode and Type columns of the Vendor table:<br/><br/>

      OpenConnection("@APPVAR(*/lookupdb:cs)")<br/>
      SmartSQL("INSERT INTO Vendor (CompanyCode,Type) VALUES ('MQSW','New')")
      <br/><br/>
      
      Here, dbVendorID is a numeric field while dbVendorname is the calling text field:<br/><br/>
      OpenConnection("@APPVAR(*/lookupdb:cs)")<br/>
      <b>SmartSQL("SELECT CompanyCode FROM Vendor WHERE dbVendorID =+@P\VendorID+ AND dbVendorName = '+@F+';",YES)</b><br/><br/></e>
    </h>
    <lvl>All.</lvl>
    <ret><b>True</b> if the SQL statement executes successfully, select statements must also
    return a value.<br/><b>False</b> if the SQL statement does not execute successfully.
  </ret>
   <see>SmartSQLEx</see>
     </ref>
  
  <ref id="SmartSQLEx">
  <ap>
    <b>sStringIn</b> - The SQL expression you want to execute.  Smart parameters are supported within the expression.<br/>
    <b>sPopulate</b> - True/False value to enable or suppress populating value of any record returned from the SQL expression.<br/>
    <b>sTarget</b> - Smart Parameter destination for value population, leave blank for current object's Text property.<br/>
  </ap>
  <h>
    Executes the SQL statement you enter in the first parameter.<br/><br/><e>
      This sequence opens a connection to the InvoiceLook database.  Next, it inserts values
      into the CompanyCode and Type columns of the Vendor table:<br/><br/>

      OpenConnection("@APPVAR(*/lookupdb:cs)")<br/>
      <b>SmartSQLEx("INSERT INTO Vendor (CompanyCode,Type) VALUES ('MQSW','New')", "False", "")</b><br/><br/>
      
      Here, dbVendorID is a numeric field while dbVendorname is the calling text field:<br/><br/>
      OpenConnection("@APPVAR(*/lookupdb:cs)")<br/>
      <b>SmartSQLEx(""SELECT CompanyCode FROM Vendor WHERE dbVendorID =+@P\VendorID+ AND dbVendorName = '+@F+';",YES", "True", "@F.MyLookupResult")</b><br/><br/></e>
    </h>
    <lvl>All.</lvl>
    <ret><b>True</b> if the SQL statement executes successfully, select statements must also
    return a value.<br/><b>False</b> if the SQL statement does not execute successfully.
  </ret>
     </ref>
  
 <ref id="ClearLookupResults">
  <ap>None.</ap>
  <h>
    This action clears the stored results returned from a previous Lookup action such as
    <b>PopulateWithResult.</b><br/><br/><e>
      OpenConnection("@APPVAR(*/lookupdb:cs)")<br/>
      ExecuteSQLEx("SELECT NAME, ADDRESS FROM Vendor;", "False", "")<br/>
      PopulateWithResult("1")<br/><b>ClearLookupResults()</b><br/><br/>

      Here, ClearLookupResults() clears the stored results of the Vendor Name and Address.
    </e>
    </h>
    <lvl>All.</lvl>
    <ret>Always <b>True.</b></ret>
     </ref>
 </help>
 </rrx>
<rrx namespace="MC_Identify" src="c:\datacap\RRS\MC_Identify.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="AutoField" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[ 'Identifies red HCFA-1500 or red UB04 forms.  The action must be placed after a rule's SetMaxTolerantDistance,]]>
<![CDATA[
]]>
<![CDATA[ '  SetFormType, ReadDCOSetup, and SetWritePosFile actions]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[  Dim sDataFileName]]>
<![CDATA[
]]>
<![CDATA[  Dim bDCORead]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  AutoField= False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType<>2) Then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("AutoField: object is not a page.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Autofield Analyzing '" & currentObj.Imagename & "'")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(g_oAutoField) then]]>
<![CDATA[
]]>
<![CDATA[    If Initialize_Autofield=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  AutoField = g_oAutoField.Analyze(CurrentObj.ImageName) ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Analyze returned:" & AutoField) ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number<>0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Failed to Analyze Image.")]]>
<![CDATA[
]]>
<![CDATA[    Err.Clear]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  sDataFileName=Replace(LCase(CurrentObj.Variable("IMAGEFILE")), ".tif", ".xml")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Setting DATAFILE to '" & sDataFileName & "'")]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("DATAFILE")=sDataFileName]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Reading DATAFILE...")]]>
<![CDATA[
]]>
<![CDATA[  bDCORead=CurrentObj.Read(CurrentObj.Variable("DATAFILE"))]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Read DATAFILE returned:" & bDCORead)]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindFields" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim bRead]]>
<![CDATA[
]]>
<![CDATA[  Dim sDatafile]]>
<![CDATA[
]]>
<![CDATA[  Dim bModifiedFields]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  FindFields = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType<>2) Then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("AutoField: Calling DCO must be a page. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(g_oAutoField) then]]>
<![CDATA[
]]>
<![CDATA[    If Initialize_Autofield=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("FindFields Analyzing file: '" & CurrentObj.Imagename & "'")]]>
<![CDATA[
]]>
<![CDATA[	FindFields = g_oAutoField.FindFields(CurrentObj.ImageName) ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("FindFields returns '" & FindFields & "'")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number<>0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("FindFields Err.")]]>
<![CDATA[
]]>
<![CDATA[    Err.Clear]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("DATAFILE")=Replace(LCase(CurrentObj.Variable("IMAGEFILE")), ".tif", ".xml")]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Read(CurrentObj.Variable("DATAFILE"))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetMaxTolerantDistance" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	  SetMaxTolerantDistance = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	  If Not IsNumeric(StrParam) Then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("The parameter:" & StrParam & " - is invalid. Expected integer 1 - 100.")]]>
<![CDATA[
]]>
<![CDATA[		  Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[		nDistance = CInt(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		If (nDistance<0 And nDistance>100) Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("The parameter:" & StrParam & " - is invalid. Expected integer 1 - 100.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If Not IsAlive(g_oAutoField) then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Autofld object is not available. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    g_oAutoField.MaxDistance = nDistance]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    If Err.Number<>0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Failed to SetMaxTolerantDistance.")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if  ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    SetMaxTolerantDistance = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFormType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  SetFormType = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(g_oAutoField) then]]>
<![CDATA[
]]>
<![CDATA[    If Initialize_Autofield=False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetFormType = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam=Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  Select Case UCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    Case "0","HCFA"]]>
<![CDATA[
]]>
<![CDATA[      g_oAutoField.FormType = 0]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Selected FormType HCFA 1500 05/08")]]>
<![CDATA[
]]>
<![CDATA[    Case "1","UB","UB92"]]>
<![CDATA[
]]>
<![CDATA[      g_oAutoField.FormType = 1]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Selected FormType UB92")]]>
<![CDATA[
]]>
<![CDATA[    Case "2","UB04"]]>
<![CDATA[
]]>
<![CDATA[      g_oAutoField.FormType = 2]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Selected FormType UB04")]]>
<![CDATA[
]]>
<![CDATA[    Case "3"]]>
<![CDATA[
]]>
<![CDATA[      g_oAutoField.FormType = 3]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Selected FormType CMS 1500 02/12")]]>
<![CDATA[
]]>
<![CDATA[    Case Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Invalid parameter '" & StrParam & "'.")]]>
<![CDATA[
]]>
<![CDATA[      SetFormType=False]]>
<![CDATA[
]]>
<![CDATA[  End Select]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number<>0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Failed to SetFormType.")]]>
<![CDATA[
]]>
<![CDATA[    Err.Clear]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ReadDCOSetup" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam, strDCOSetup, strPos]]>
<![CDATA[
]]>
<![CDATA[	Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ReadDCOSetup = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(g_oAutoField) then]]>
<![CDATA[
]]>
<![CDATA[    Call Initialize_Autofield()]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(g_oAutoField) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Autofield Object available. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Autofield Object available.")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & ", ", ",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	strDCOSetup = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	strPos = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters(1)]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strDCOSetup)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    strDCOSetup=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter(1) parsing. Using original parameter '" & strDCOSetup & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   'Check for valid path from parameter]]>
<![CDATA[
]]>
<![CDATA[  If IsAlive(FileMgr) Then]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    If Not FileMgr.FileExists(strDCOSetup) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("File not found:'" & strDCOSetup & "'")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("File '" & strDCOSetup & "' exists.")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Added support for Smart Parameters(2)]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(strPos)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    strPos=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter(1) parsing. Using original parameter '" & strPos & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	g_oAutoField.ReadDCOSetup strDCOSetup, strPos]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number<>0 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Failed to ReadDCOSetup.")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ReadDCOSetup = True]]>
<![CDATA[
]]>
	</g>
</af>
<f name="ReadPageSetup" access="public">
	<p name="DCOSetupPath">
	</p>
	<p name="FPPosition">
	</p>
	<p name="PageType">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ReadPageSetup = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(g_oAutoField) then]]>
<![CDATA[
]]>
<![CDATA[    call Initialize_Autofield()]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not IsAlive(g_oAutoField) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Autofield Object available. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Autofield Object available.")]]>
<![CDATA[
]]>
<![CDATA[  End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(DCOSetupPath)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    DCOSetupPath=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter(1) parsing. Using original parameter '" & DCOSetupPath & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   'Check for valid path from parameter]]>
<![CDATA[
]]>
<![CDATA[  If IsAlive(FileMgr) Then]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    If Not FileMgr.FileExists(DCOSetupPath) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("File not found:'" & DCOSetupPath & "'")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("File '" & DCOSetupPath & "' exists.")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  End if ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(FPPosition)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    FPPosition=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter(2) parsing. Using original parameter '" & FPPosition & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam=MetaWord(PageType)]]>
<![CDATA[
]]>
<![CDATA[  If sSmartParam<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[    PageType=sSmartParam  ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No result from Smart Parameter(3) parsing. Using original parameter '" & PageType & "'") ]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  g_oAutoField.ReadPageSetup DCOSetupPath, FPPosition, PageType]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ReadPageSetup = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<help>
  <![CDATA[
'************************************************************************
' MC_Identify help.xml
'-----------------------------------------------------------------------
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2013 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'------------------------------------------------------------------------
]]>
  
<ref id="AutoField">
  <ap>None.</ap>
  <h>
    This important action identifies red HCFA-1500 or red UB04 forms.<br/><br/>
    The action must be placed after a rule's <scr>SetMaxTolerantDistance, SetFormType, ReadDCOSetup,</scr> and <scr>SetWritePosFile</scr> actions (see the example below).
    <e>
      <scr>SetMaxTolerantDistance(60)</scr><br/>
      <scr>SetFormType(0)</scr><br/>
      <scr>ReadDCOSetup(HCFA.xml,POS 1052)</scr><br/>
      <b>AutoField()</b>      
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if the action is not applied at the Page level; otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="FindFields">
    <ap>None.</ap>
    <h>
      This action sets up a Data file (.xml) for the current page,
      and supplies the Data file with field position information.<br/><br/>

      Typically, this action is part of a Medical Claims <scr>ID_PageFix</scr> rule.
      <e>
        <scr>SetMaxTolerantDistance(60)</scr>
        <br/>
        <scr>SetFormType(0)</scr>
        <br/>
        <scr>ReadDCOSetup(HCFA.xml, POS1052)</scr>
        <br/>
        <b>FindFields()</b>
      </e>
    </h>
    <lvl>Page level only.</lvl>
    <ret>
      <b>False</b> if rule with this action is not bound to a Page object of the Document Hierarchy,
      or if a source page represented by the Page object is unavailable. Otherwise, returns <b>True.</b>
    </ret>
  </ref>

<ref id="SetMaxTolerantDistance">
    <ap>
      The Maximum Tolerant Distance - an <i>Integer</i>from 1 (Lowest Tolerance) to 100 (Highest Tolerance).
    </ap>
    <h>
      This action sets the tolerance level that <b>AutoField</b> will use to match HCFA-1500 or red UB04 forms
      (depending on the form specified using the <b>SetFormType</b>action).
      <e>
        <b>SetMaxTolerantDistance(60)</b>
        <br/>
        <scr>SetFormType(0)</scr>
        <br/>
        <scr>ReadDCOSetup(HCFA.xml, POS1052)</scr>
        <br/>
        <scr>AutoField()</scr>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if the parameter is not an <i>Integer</i>between 1 and 100. Otherwise, <b>True.</b>
    </ret>
  </ref>

<ref id="SetFormType">
  <ap>
    <i>String</i>value indicating the Form Type:<br/>
    For HCFA-1500 or CMS-1500 use: "0" or "hcfa" <br/>
    For UB-04 use: "2" or "ub04".
  </ap>  
  <h>
    This action sets the Form Type value that will be used by <b>Autofield.</b>
    <e>
      <scr>SetMaxTolerantDistance(60)</scr><br/>
      <b>SetFormType(0)</b><br/>
      <scr>ReadDCOSetup(HCFA.xml, POS1052)</scr><br/>
      <scr>SetWritePosFile(True)</scr><br/>
      <scr>AutoField()</scr>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter is invalid. Otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="ReadDCOSetup">
    <ap>
      A comma-separated <i>String</i> value made up a smart parameter that designates the Document Hierarchy's file
      name, followed by a Variable Name that indicates the position of the fingerprint. Typically, the file's name
      is the Application ID with an .xml extension; "HCFA.xml", for example, is the name of
      the <i>HCFA</i> application's Document Hierarchy file. "Pos1052" specifies a previously assembled
      HCFA-1500 fingerprint (in this case) with details of the form's Field IDs, locations and data types.
      For use with the Application Service the syntax of the first parameter changes to include the
      SmartParameter that will point to the setup dco, i.e. '@APPPATH(setupdco)' instead of 'HCFA.xml'.
    </ap>
    <h>
      <e>
        <b>ReadDCOSetup(HCFA.xml,Pos1052)</b><br/><br/>
        or for use with the Application Manager with the @APPPATH SmartParameter to locate the setup dco:<br/><br/>
        <b>ReadDCOSetup(@APPPATH(setupdco),Pos1052)</b><br/><br/>
        Note that this action is used with almost every other <b>MC_Identify</b> action.
      </e>
    </h>
    <lvl>All, but usually the Batch level.</lvl>
    <ret>
      <b>False</b> if the Document Hierarchy file is not found. Otherwise, <b>True.</b>
    </ret>
  </ref>
  <ref id="ReadPageSetup">
    <ap>
      1) A smart parameter enabled argument that designates the Document Hierarchy's file name and path.
      2) The fingerprint position variable name, usually "Pos" followed by the id of the fingerprint desired. 
      3) The Page type of the page to ID. Typically "PClaim" or "IClaim".
    </ap>
    <h>
      <e>
        <b>ReadPageSetup(@APPPATH(setupdco),Pos1059,PClaim)</b><br/><br/>
        Note that this action is used with almost every other <b>MC_Identify</b> action.
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if the Document Hierarchy file is not found. Otherwise, <b>True.</b>
    </ret>
  </ref>
</help>
</rrx>
<rrx namespace="MC_Validation" src="c:\datacap\RRS\MC_Validation.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<g>
</g>
<f name="UpdateCredentialList" access="public">
	<p name="sCredential">
	</p>
	<p name="AddRemove">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[       Dim bAdd]]>
<![CDATA[
]]>
<![CDATA[       Dim sSmartValue]]>
<![CDATA[
]]>
<![CDATA[       Dim sSmartAddRemove]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[       UpdateCredentialList=True]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[       On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[       'Determine if Add or Remove credentials]]>
<![CDATA[
]]>
<![CDATA[       sSmartAddRemove = MetaWord(AddRemove)]]>
<![CDATA[
]]>
<![CDATA[       If len(trim(sSmartAddRemove))=0 then]]>
<![CDATA[
]]>
<![CDATA[          sSmartAddRemove=sCredential]]>
<![CDATA[
]]>
<![CDATA[       End if]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[       Select Case ucase(trim(sSmartAddRemove))]]>
<![CDATA[
]]>
<![CDATA[          Case "OFF","REMOVE","0","FALSE","-1","NO","DELETE"]]>
<![CDATA[
]]>
<![CDATA[             bAdd=False        ]]>
<![CDATA[
]]>
<![CDATA[          Case Else]]>
<![CDATA[
]]>
<![CDATA[             bAdd=True]]>
<![CDATA[
]]>
<![CDATA[       End Select]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[       'Check for smart parameter value]]>
<![CDATA[
]]>
<![CDATA[       sSmartValue = MetaWord(sCredential)]]>
<![CDATA[
]]>
<![CDATA[       If len(trim(sSmartValue))=0 then]]>
<![CDATA[
]]>
<![CDATA[          sSmartValue=sCredential]]>
<![CDATA[
]]>
<![CDATA[       End if]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[       'Make an array of the credentials]]>
<![CDATA[
]]>
<![CDATA[       aCreds = Split(sSmartValue & ",",",")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[       'Add or Remove from list ]]>
<![CDATA[
]]>
<![CDATA[       For i = 0 to ubound(aCreds)]]>
<![CDATA[
]]>
<![CDATA[          If len(Trim(aCreds(i)))>0 then]]>
<![CDATA[
]]>
<![CDATA[             If g_dictCredentials.Exists(aCreds(i)) then]]>
<![CDATA[
]]>
<![CDATA[   		            If bAdd=False then]]>
<![CDATA[
]]>
<![CDATA[                     Writelog("Removing Credential '" & aCreds(i) & "' from credential dictionary.")]]>
<![CDATA[
]]>
<![CDATA[                     Call g_dictCredentials.Remove(aCreds(i)) ]]>
<![CDATA[
]]>
<![CDATA[                  Else]]>
<![CDATA[
]]>
<![CDATA[                     Writelog("Credential '" & aCreds(i) & "' already exists in credential dictionary and will not be added.")]]>
<![CDATA[
]]>
<![CDATA[                  End if]]>
<![CDATA[
]]>
<![CDATA[             Else]]>
<![CDATA[
]]>
<![CDATA[                  If bAdd=True then]]>
<![CDATA[
]]>
<![CDATA[                     Writelog("Adding Credential '" & aCreds(i) & "' to credential dictionary.")]]>
<![CDATA[
]]>
<![CDATA[                     Call g_dictCredentials.Add(aCreds(i),aCreds(i)) ]]>
<![CDATA[
]]>
<![CDATA[                  End if]]>
<![CDATA[
]]>
<![CDATA[             End if]]>
<![CDATA[
]]>
<![CDATA[          End if]]>
<![CDATA[
]]>
<![CDATA[       Next 'i]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[       'Log Current list of Credentials]]>
<![CDATA[
]]>
<![CDATA[       aKeys=g_dictCredentials.Keys]]>
<![CDATA[
]]>
<![CDATA[       Writelog("New list of Credentials:" & join(aKeys,","))]]>
<![CDATA[
]]>
<![CDATA[                          ]]>
<![CDATA[
]]>
<![CDATA[       If Err.Number=0 then UpdateCredentialList=True ]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[       Call ErrorHandler("UpdateCredentialList") ]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<g>
</g>
<af name="InheritSnippets" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    if trim(StrParam="") Then]]>
<![CDATA[
]]>
<![CDATA[	writelog("InheritSnippets has wrong empty argument")]]>
<![CDATA[
]]>
<![CDATA[        InheritSnippets = false]]>
<![CDATA[
]]>
<![CDATA[	exit function]]>
<![CDATA[
]]>
<![CDATA[    end if ]]>
<![CDATA[
]]>
<![CDATA[    if(CurrentObj.ObjectType = DCO_FIELD) Then]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        if( CurrentObj.GetPosition(lleft,ltop,lright,lbottom)) Then ]]>
<![CDATA[
]]>
<![CDATA[            writelog("position of current field " & CurrentObj.ID & " is:" &_]]>
<![CDATA[
]]>
<![CDATA[    		 lleft & "," & ltop & "," & lright & "," & lbottom)]]>
<![CDATA[
]]>
<![CDATA[	    arParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[            for i=0 to uBound(arParam) 'loop for all inherited fields]]>
<![CDATA[
]]>
<![CDATA[                lInheritedIndex = CurrentObj.parent.FindChildIndex(arParam(i))]]>
<![CDATA[
]]>
<![CDATA[                if(lInheritedIndex <= 0 ) then]]>
<![CDATA[
]]>
<![CDATA[                    writelog("no entry found for field " & arParam(i))]]>
<![CDATA[
]]>
<![CDATA[                    exit for]]>
<![CDATA[
]]>
<![CDATA[                end if ]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[                Set lInherited = CurrentObj.parent.GetChild(lInheritedIndex)]]>
<![CDATA[
]]>
<![CDATA[                if( lInherited.SetPosition(lleft, ltop, lright, lbottom) ) Then]]>
<![CDATA[
]]>
<![CDATA[                    writelog("position for " & lInherited.ID & " has been set to " &_]]>
<![CDATA[
]]>
<![CDATA[        			 lleft &","& ltop & "," & lright & "," & lbottom)]]>
<![CDATA[
]]>
<![CDATA[                end if]]>
<![CDATA[
]]>
<![CDATA[            next 'i - loop for all inherited fields]]>
<![CDATA[
]]>
<![CDATA[	else]]>
<![CDATA[
]]>
<![CDATA[	    writelog("unable to find out position of current field " & CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        InheritSnippets = true]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        WriteLog("Unproper place of action " & CurrentObj.ObjectType & ". Must be at FIELD level")]]>
<![CDATA[
]]>
<![CDATA[        InheritSnippets = false]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="ValProcedureCode" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sPCCode]]>
<![CDATA[
]]>
<![CDATA[	Dim oPCCodeField]]>
<![CDATA[
]]>
<![CDATA[	Dim sPCCodeValue]]>
<![CDATA[
]]>
<![CDATA[	Dim sTableName]]>
<![CDATA[
]]>
<![CDATA[	Dim sCodeName]]>
<![CDATA[
]]>
<![CDATA[	Dim strCodeFieldName]]>
<![CDATA[
]]>
<![CDATA[	Dim strCodeFieldValue]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ValProcedureCode=FALSE]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Check for DCO field object]]>
<![CDATA[
]]>
<![CDATA[    If Not (CurrentObj.ObjectType = DCO_FIELD) Then ]]>
<![CDATA[
]]>
<![CDATA[        WriteLog("Action must be called from a DCO Field.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog(vbCrLf & "-------- Starting Procedure Code Validation --------")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'Code for UB92 Claims]]>
<![CDATA[
]]>
<![CDATA[	sPCCode="79pc"]]>
<![CDATA[
]]>
<![CDATA[	Set oPCCodeField=CurrentObj.parent.FindChild("79pc")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsAlive(oPCCodeField) Then]]>
<![CDATA[
]]>
<![CDATA[		sPCCodeValue = trim(oPCCodeField.text)]]>
<![CDATA[
]]>
<![CDATA[		writelog("PCCode='" & sPCCodeValue & "'")]]>
<![CDATA[
]]>
<![CDATA[		Select Case sPCCodeValue]]>
<![CDATA[
]]>
<![CDATA[			Case "5"]]>
<![CDATA[
]]>
<![CDATA[				sTableName="Procedures"]]>
<![CDATA[
]]>
<![CDATA[				sCodeName="ProcCode"]]>
<![CDATA[
]]>
<![CDATA[			Case "9"]]>
<![CDATA[
]]>
<![CDATA[				sTableName="Diagnosis"]]>
<![CDATA[
]]>
<![CDATA[				sCodeName="DiagCode"]]>
<![CDATA[
]]>
<![CDATA[			Case Else]]>
<![CDATA[
]]>
<![CDATA[				WriteLog("PC Code value is unknown and *INVALID*. Unable to check procedure code.")]]>
<![CDATA[
]]>
<![CDATA[				oPCCodeField.Status=nFail]]>
<![CDATA[
]]>
<![CDATA[                Set oPCCodeField = Nothing]]>
<![CDATA[
]]>
<![CDATA[				Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End Select]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		'This is default for UB92 and the only Setting for HCFA]]>
<![CDATA[
]]>
<![CDATA[		sTableName="Procedures" ]]>
<![CDATA[
]]>
<![CDATA[		sCodeName="ProcCode"]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	strCodeFieldName = CurrentObj.ID]]>
<![CDATA[
]]>
<![CDATA[	strCodeFieldValue=Trim(CurrentObj.text)]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(strCode & " = " & strCodeFieldName &"    Value = " &strCodeFieldValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Len(Trim(strCodeFieldValue))=0 Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(Space(6) & "Empty - see required fields validation")]]>
<![CDATA[
]]>
<![CDATA[        ValProcedureCode=TRUE]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Elseif Not LookUp(strCodeFieldValue, sTableName, sCodeName) Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(Space(6)& "*INVALID*")        ]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(Space(6)& "VALID")]]>
<![CDATA[
]]>
<![CDATA[        ValProcedureCode=TRUE]]>
<![CDATA[
]]>
<![CDATA[	End If			]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("-------- End Procedure Code Validation --------")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="ValRequiredGroup" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ValRequiredGroup = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If Not(CurrentObj.ObjectType = DCO_FIELD) Then]]>
<![CDATA[
]]>
<![CDATA[        WriteLog("Action must be called from a DCO Field.")]]>
<![CDATA[
]]>
<![CDATA[        ValRequiredGroup = False]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("" & vbCrLf & "-------- Starting Required Group Validation --------")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim sRequiredGroup]]>
<![CDATA[
]]>
<![CDATA[  Dim sFieldName]]>
<![CDATA[
]]>
<![CDATA[  Dim sFieldValue]]>
<![CDATA[
]]>
<![CDATA[  Dim sTestValue]]>
<![CDATA[
]]>
<![CDATA[  Dim iNumFields]]>
<![CDATA[
]]>
<![CDATA[  Dim bIsFull]]>
<![CDATA[
]]>
<![CDATA[  Dim bErrorFound]]>
<![CDATA[
]]>
<![CDATA[  Dim k,L]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    bIsFull=True            ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        sFieldName=Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[        iNumFields=UBound(sFieldName)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        sRequiredGroup = sFieldName(0)]]>
<![CDATA[
]]>
<![CDATA[        WriteLog("Required Group = '" & sRequiredGroup & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        WriteLog("Found " & iNumFields & " Fields to check (" & StrParam & ").")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        sFieldValue = Trim(lGetFieldValue(sFieldName(0))) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        'Remove Zero's and Decimal chars (tests for '0' and '0.00')]]>
<![CDATA[
]]>
<![CDATA[        sFieldValue = Replace(sFieldValue,"0","")]]>
<![CDATA[
]]>
<![CDATA[        sFieldValue = Replace(sFieldValue,".","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        'Fieldvalue is empty or zero]]>
<![CDATA[
]]>
<![CDATA[        If Trim(sFieldValue)="" Then ]]>
<![CDATA[
]]>
<![CDATA[            bIsFull=False           ]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        For k=0 To iNumFields]]>
<![CDATA[
]]>
<![CDATA[            sFieldValue=Trim(lGetFieldValue(sFieldName(k)))]]>
<![CDATA[
]]>
<![CDATA[            sTestValue = sFieldValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            'Remove Zero's and Decimal chars (tests for '0' and '0.00')]]>
<![CDATA[
]]>
<![CDATA[            sTestValue = Replace(sTestValue,"0","")]]>
<![CDATA[
]]>
<![CDATA[            sTestValue = Replace(sTestValue,".","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            If (Trim(sTestValue="") And bIsFull=True) Or (Not(Trim(sTestValue)="") And bIsFull=False) Then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[               WriteLog("Field '" & sFieldName(k) & "' = Blank - Group field verificaton failed")]]>
<![CDATA[
]]>
<![CDATA[               ValRequiredGroup = False]]>
<![CDATA[
]]>
<![CDATA[               ]]>
<![CDATA[
]]>
<![CDATA[            Else]]>
<![CDATA[
]]>
<![CDATA[               If Not Trim(sTestValue)="" Then]]>
<![CDATA[
]]>
<![CDATA[                   WriteLog("Field '" & sFieldName(k) & "' = '" & sFieldValue & "'.")]]>
<![CDATA[
]]>
<![CDATA[               Else    ]]>
<![CDATA[
]]>
<![CDATA[                   WriteLog("Field '" & sFieldName(k) & "' is Empty.")]]>
<![CDATA[
]]>
<![CDATA[               End If]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[        Next 'k]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If ValRequiredGroup = False Then]]>
<![CDATA[
]]>
<![CDATA[            For k=0 To iNumFields]]>
<![CDATA[
]]>
<![CDATA[    		    Call SetFieldStatus(sFieldName(k),1)]]>
<![CDATA[
]]>
<![CDATA[            Next ]]>
<![CDATA[
]]>
<![CDATA[        Else]]>
<![CDATA[
]]>
<![CDATA[            WriteLog("      Group " & CurrentObj.ID & " -Valid-")]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	    WriteLog("-------- End Required Groups Validation Function --------")]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="CommonValAddress" access="public" bInter="bInter" bDebug="bDebug" strParam="strString">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim arParam]]>
<![CDATA[
]]>
<![CDATA[  Dim sDescription]]>
<![CDATA[
]]>
<![CDATA[  Dim sFNameField]]>
<![CDATA[
]]>
<![CDATA[  Dim sLNameField]]>
<![CDATA[
]]>
<![CDATA[  Dim sStreet1Field]]>
<![CDATA[
]]>
<![CDATA[  Dim sStreet2Field]]>
<![CDATA[
]]>
<![CDATA[  Dim sCityField]]>
<![CDATA[
]]>
<![CDATA[  Dim sStateField]]>
<![CDATA[
]]>
<![CDATA[  Dim sZipCodeField]]>
<![CDATA[
]]>
<![CDATA[  Dim sPhoneField ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    CommonValAddress = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If Not(CurrentObj.ObjectType = DCO_PAGE) Then]]>
<![CDATA[
]]>
<![CDATA[        WriteLog("Action must be called from a DCO Page. Exiting")]]>
<![CDATA[
]]>
<![CDATA[        CommonValAddress = False]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    arParam = Split(strString,",") ]]>
<![CDATA[
]]>
<![CDATA[    sDescription  = arParam(0)]]>
<![CDATA[
]]>
<![CDATA[    sFNameField   = arParam(1)]]>
<![CDATA[
]]>
<![CDATA[    sLNameField   = arParam(2)]]>
<![CDATA[
]]>
<![CDATA[    sStreet1Field = arParam(3)]]>
<![CDATA[
]]>
<![CDATA[    sStreet2Field = arParam(4)]]>
<![CDATA[
]]>
<![CDATA[    sCityField    = arParam(5)]]>
<![CDATA[
]]>
<![CDATA[    sStateField   = arParam(6)]]>
<![CDATA[
]]>
<![CDATA[    sZipCodeField = arParam(7) ]]>
<![CDATA[
]]>
<![CDATA[    sPhoneField   = arParam(8) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	    WriteLog(Space(0) & vbCrLf & "-------- Starting "& sDescription &" Address Validation --------")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        writelog(sDescription & " address validation has parameters:")]]>
<![CDATA[
]]>
<![CDATA[        writelog("First name " & sFNameField & ": " & CurrentObj.FindChild(sFNameField).text)]]>
<![CDATA[
]]>
<![CDATA[        writelog("Last name " & sLNameField & ": " & CurrentObj.FindChild( sLNameField).text)]]>
<![CDATA[
]]>
<![CDATA[        writelog("Street1 " & sStreet1Field & ": " & CurrentObj.FindChild(sStreet1Field).text)]]>
<![CDATA[
]]>
<![CDATA[        writelog("Street2 " & sStreet2Field & ": " & CurrentObj.FindChild(sStreet2Field).text)]]>
<![CDATA[
]]>
<![CDATA[        writelog("City " & sCityField & ": " & CurrentObj.FindChild(sCityField).text)]]>
<![CDATA[
]]>
<![CDATA[        writelog("State " & sStateField & ": " & CurrentObj.FindChild(sStateField).text)]]>
<![CDATA[
]]>
<![CDATA[        writelog("ZipCode " & sZipCodeField & ": " & CurrentObj.FindChild(sZipCodeField).text)]]>
<![CDATA[
]]>
<![CDATA[        writelog("Phone " & sPhoneField & ": " & CurrentObj.FindChild(sPhoneField).text) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	    ValInsuredAddressHCFA=ValAddress(sFNameField,sLNameField,sStreet1Field,sStreet2Field,sCityField,sStateField,sZipCodeField,sPhoneField)]]>
<![CDATA[
]]>
<![CDATA[								 ]]>
<![CDATA[
]]>
<![CDATA[	    WriteLog("-------- End "& sDescription &" Address Validation --------")	]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="CommonParseAddress" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	       ]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next   ]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[        CommonParseAddress = False   ]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[    	If Not (CurrentObj.ObjectType = DCO_PAGE) Then ]]>
<![CDATA[
]]>
<![CDATA[        	WriteLog("Action must be called from a DCO Page.")]]>
<![CDATA[
]]>
<![CDATA[  	    	Exit Function	]]>
<![CDATA[
]]>
<![CDATA[	    End if]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Select Case StrParam]]>
<![CDATA[
]]>
<![CDATA[			Case "HCField32Object"]]>
<![CDATA[
]]>
<![CDATA[				Call mc_ParseAddress("HCField32Object","32FacAdd","32FacNam","32F1Addr","32F2Addr","32FacCit","32FacSta","32FacZip","","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Case "HCField33Object"	]]>
<![CDATA[
]]>
<![CDATA[				Call mc_ParseAddress("HCField33Object","33DocAdd","33PhBNam","33Ph1Add","33Ph2Add","33PhCity","33PhStat","33PhyZip","33PhyPhn","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Case "UBField13Object"]]>
<![CDATA[
]]>
<![CDATA[				Call mc_ParseAddress("UBField13Object","13paddr","","13paddr1", "13paddr2","13padcit","13padsta","13padzip","","")]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[			Case "UBField1Object"]]>
<![CDATA[
]]>
<![CDATA[				Call mc_ParseAddress("UBField1Object","1fcynmad","1provnam","1provadd","","1provcit","1provsta","1provzip","1provphn","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Case "UBField2Object"]]>
<![CDATA[
]]>
<![CDATA[				Call mc_ParseAddress("UBField1Object","2payto","2paytnm","2paytadd","","2paytcty","2paytst","2paytzip","","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Case "UBField38Object"]]>
<![CDATA[
]]>
<![CDATA[				Call mc_ParseAddress("UBField38Object","38inmadb","38name","38add1","38add2","38city","38state","38zip","","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Case Else]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Invalid Action Parameter. Expected Values are: 'HCField32Object','HCField33Object','UBField1Object','UBField13Object','UBField38Object'.")]]>
<![CDATA[
]]>
<![CDATA[				Exit function]]>
<![CDATA[
]]>
<![CDATA[         End Select]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        CommonParseAddress = True]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="ConvertHyphen" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    Dim sPointerValue]]>
<![CDATA[
]]>
<![CDATA[    Dim strPointerFieldConf]]>
<![CDATA[
]]>
<![CDATA[    Dim NewPointerStr]]>
<![CDATA[
]]>
<![CDATA[    Dim NewPointerConf]]>
<![CDATA[
]]>
<![CDATA[    Dim From]]>
<![CDATA[
]]>
<![CDATA[    Dim Thru]]>
<![CDATA[
]]>
<![CDATA[    Dim CharValue]]>
<![CDATA[
]]>
<![CDATA[    Dim bSetLC]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If Not(CurrentObj.ObjectType = DCO_FIELD) Then]]>
<![CDATA[
]]>
<![CDATA[        WriteLog("Action must be called from a DCO Field.")]]>
<![CDATA[
]]>
<![CDATA[        ConvertHyphen = False]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if        ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    bSetLC=False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        sPointerValue = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[        strPointerFieldConf = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Hyphen conversion is ON. Current Value: " & sPointerValue & " Confidence String:" & strPointerFieldConf)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[        NewPointerStr = ""]]>
<![CDATA[
]]>
<![CDATA[        NewPointerConf = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If len(Trim(sPointerValue))=0 then]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Field is Empty.")]]>
<![CDATA[
]]>
<![CDATA[            ConvertHyphen = TRUE]]>
<![CDATA[
]]>
<![CDATA[            Exit Function]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        For k = 1 To Len(sPointerValue)]]>
<![CDATA[
]]>
<![CDATA[            CharValue = Mid(sPointerValue,k,1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            Select Case Charvalue]]>
<![CDATA[
]]>
<![CDATA[                Case "-" 'Hyphen Found]]>
<![CDATA[
]]>
<![CDATA[                    WriteLog("  Hyphen Found at position: " & k)]]>
<![CDATA[
]]>
<![CDATA[                    If (k > 1) Then]]>
<![CDATA[
]]>
<![CDATA[                      If(Len(sPointerValue) >= (k + 1)) Then]]>
<![CDATA[
]]>
<![CDATA[			                  'hyphen is not a last char]]>
<![CDATA[
]]>
<![CDATA[                        From = Mid(sPointerValue,k-1,1)]]>
<![CDATA[
]]>
<![CDATA[                        Thru = Mid(sPointerValue,k+1,1)]]>
<![CDATA[
]]>
<![CDATA[                        If(IsNumeric(From) And IsNumeric(Thru)) Then]]>
<![CDATA[
]]>
<![CDATA[                          If (From <> Thru) And (1 <= From And From <= 4) And (1<= Thru And Thru <= 4) Then Stepval = Clng(From) + Clng(Thru)]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[                            Select Case Stepval]]>
<![CDATA[
]]>
<![CDATA[                              Case 4]]>
<![CDATA[
]]>
<![CDATA[                                Writelog("  Hyphen Found. Value 1-3 or 3-1, value 2 added.")]]>
<![CDATA[
]]>
<![CDATA[                                NewPointerStr = NewPointerStr & "2"]]>
<![CDATA[
]]>
<![CDATA[                                NewPointerConf = NewPointerConf & "9"]]>
<![CDATA[
]]>
<![CDATA[                              Case 5]]>
<![CDATA[
]]>
<![CDATA[                                Writelog("  Hyphen Found. Value 1-4 or 4-1, values 2 and 3 added.")]]>
<![CDATA[
]]>
<![CDATA[                                NewPointerStr = NewPointerStr & "23"]]>
<![CDATA[
]]>
<![CDATA[                                NewPointerConf = NewPointerConf & "99"]]>
<![CDATA[
]]>
<![CDATA[                              Case 6]]>
<![CDATA[
]]>
<![CDATA[                                Writelog("  Hyphen Found. Value 2-4 or 4-2, value 3 added.")]]>
<![CDATA[
]]>
<![CDATA[                                NewPointerStr = NewPointerStr & "3"]]>
<![CDATA[
]]>
<![CDATA[                                NewPointerConf = NewPointerConf & "9"]]>
<![CDATA[
]]>
<![CDATA[                              Case Else]]>
<![CDATA[
]]>
<![CDATA[                                Writelog("  Hyphen Found. 1 Step conversion, removing Hyphen.") ]]>
<![CDATA[
]]>
<![CDATA[                                Stepval = 0    ]]>
<![CDATA[
]]>
<![CDATA[                            End Select 'Case Stepval]]>
<![CDATA[
]]>
<![CDATA[			                    else]]>
<![CDATA[
]]>
<![CDATA[ 				                    Writelog("A Hyphen was found between Non-Numeric characters. Hyphen ingored.")]]>
<![CDATA[
]]>
<![CDATA[			                  End if]]>
<![CDATA[
]]>
<![CDATA[			                else]]>
<![CDATA[
]]>
<![CDATA[			                  Writelog("  Hyphen Found in the last position: removing Hyphen.") ]]>
<![CDATA[
]]>
<![CDATA[			              end if]]>
<![CDATA[
]]>
<![CDATA[		              Else]]>
<![CDATA[
]]>
<![CDATA[			              Writelog("  Hyphen Found in the first position: removing Hyphen.") 			]]>
<![CDATA[
]]>
<![CDATA[                  End If]]>
<![CDATA[
]]>
<![CDATA[                Case Else ]]>
<![CDATA[
]]>
<![CDATA[                  'Valid Character found?]]>
<![CDATA[
]]>
<![CDATA[		              If(IsNumeric(CharValue)) Then]]>
<![CDATA[
]]>
<![CDATA[		                If(1<=CharValue And CharValue<=4) Then]]>
<![CDATA[
]]>
<![CDATA[                      NewPointerStr = NewPointerStr & CharValue]]>
<![CDATA[
]]>
<![CDATA[                      NewPointerConf = NewPointerConf & Mid(strPointerFieldConf,k,1)]]>
<![CDATA[
]]>
<![CDATA[		                 Else]]>
<![CDATA[
]]>
<![CDATA[			                Writelog("Character is not {1,2,3,4} : Setting field to Low Confidence, Skipping character.")]]>
<![CDATA[
]]>
<![CDATA[                      bSetLC=TRUE]]>
<![CDATA[
]]>
<![CDATA[		                 End if]]>
<![CDATA[
]]>
<![CDATA[		              Else]]>
<![CDATA[
]]>
<![CDATA[		                writelog("Character is non-numeric: skipping character.")]]>
<![CDATA[
]]>
<![CDATA[                    'If not a comma, period or space then set field to LC]]>
<![CDATA[
]]>
<![CDATA[                    If Not(CharValue=CHRw(44) or CharValue=CHRw(46) or CharValue=Space(1)) Then bSetLC=TRUE]]>
<![CDATA[
]]>
<![CDATA[		              End if]]>
<![CDATA[
]]>
<![CDATA[              End Select]]>
<![CDATA[
]]>
<![CDATA[        Next 'k]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.Text = NewPointerStr]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.ConfidenceString = NewPointerConf]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If bSetLC=True Then]]>
<![CDATA[
]]>
<![CDATA[          CurrentObj.ConfidenceString = String(len(CurrentObj.Text),"1")  ]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        ConvertHyphen = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="ParseLastFirstIniNames" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	ParseLastFirstIniNames = mc_ParseName(CurrentObj,StrParam)]]>
<![CDATA[
]]>
<![CDATA[		 ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="AddCenturyTo2DigitYear" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim InitialDateTime]]>
<![CDATA[
]]>
<![CDATA[	InitialDateTime = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[	if(Len(InitialDateTime) = 6) Then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		if( IsNumeric(InitialDateTime) ) Then]]>
<![CDATA[
]]>
<![CDATA[		' we will treat two digit year inside time interval ]]>
<![CDATA[
]]>
<![CDATA[		'  [current - 100, current]]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			strDate = Mid(InitialDateTime,1,2) & "/" &_]]>
<![CDATA[
]]>
<![CDATA[				         Mid(InitialDateTime,3,2) & "/" &_]]>
<![CDATA[
]]>
<![CDATA[				  "19" & Mid(InitialDateTime,5,2) ]]>
<![CDATA[
]]>
<![CDATA[			on Error Resume next]]>
<![CDATA[
]]>
<![CDATA[			    SuggestedDate = CDate(strDate)]]>
<![CDATA[
]]>
<![CDATA[			    if(Err.Number <> 0 ) Then]]>
<![CDATA[
]]>
<![CDATA[			       Writelog("got error from create date from string: " &strDate)]]>
<![CDATA[
]]>
<![CDATA[			       Err.Clear]]>
<![CDATA[
]]>
<![CDATA[			       AddCenturyTo2DigitYear = false]]>
<![CDATA[
]]>
<![CDATA[			       On Error Goto 0]]>
<![CDATA[
]]>
<![CDATA[			       exit Function]]>
<![CDATA[
]]>
<![CDATA[			    end if]]>
<![CDATA[
]]>
<![CDATA[			on Error Goto 0]]>
<![CDATA[
]]>
<![CDATA[			NowDate = Date]]>
<![CDATA[
]]>
<![CDATA['			StartIntervalDate = DateAdd("yyyy",-100,Date)]]>
<![CDATA[
]]>
<![CDATA[			timeDiff = DateDiff("yyyy",SuggestedDate,NowDate)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			if(timeDiff >= 100) Then]]>
<![CDATA[
]]>
<![CDATA[			    strRightAdd = "20"]]>
<![CDATA[
]]>
<![CDATA[			end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			if(timeDiff < 100 And timeDiff >= 0 ) Then]]>
<![CDATA[
]]>
<![CDATA[			    strRightAdd = "19"]]>
<![CDATA[
]]>
<![CDATA[			end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[			if( timeDiff<0 ) Then]]>
<![CDATA[
]]>
<![CDATA[			   writelog("date refers to a later point in time then now")]]>
<![CDATA[
]]>
<![CDATA[			end if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			call CurrentObj.AddChild(4,"",4)]]>
<![CDATA[
]]>
<![CDATA[			call CurrentObj.AddChild(4,"",4)]]>
<![CDATA[
]]>
<![CDATA[			if( strRightAdd = "20" ) then]]>
<![CDATA[
]]>
<![CDATA[				call CurrentObj.GetChild(4).AddValue(50,10) '2]]>
<![CDATA[
]]>
<![CDATA[				call CurrentObj.GetChild(5).AddValue(48,10) '0]]>
<![CDATA[
]]>
<![CDATA[			else]]>
<![CDATA[
]]>
<![CDATA[				call CurrentObj.GetChild(4).AddValue(49,10) '1]]>
<![CDATA[
]]>
<![CDATA[				call CurrentObj.GetChild(5).AddValue(57,10) '9]]>
<![CDATA[
]]>
<![CDATA[			end if]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			writelog("supposed datetime has not digit character(s)")]]>
<![CDATA[
]]>
<![CDATA[		AddCenturyTo2DigitYear = false]]>
<![CDATA[
]]>
<![CDATA[		exit function]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("supposed datetime has not 6 characters")]]>
<![CDATA[
]]>
<![CDATA[		AddCenturyTo2DigitYear = false]]>
<![CDATA[
]]>
<![CDATA[		exit function]]>
<![CDATA[
]]>
<![CDATA[	End if		]]>
<![CDATA[
]]>
<![CDATA[	AddCenturyTo2DigitYear = true  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="Parse58ainsnm" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[    Dim StrParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Parse58ainsnm = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    StrParam = "58alname,58afname,58aminit,58aCred,58aSufx"]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[	Parse58ainsnm = mc_ParseName(CurrentObj,StrParam) ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="Parse58binsnm" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[    Dim StrParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Parse58binsnm = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    StrParam = "58blname,58bfname,58bminit,58bCred,58bSufx"]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[	Parse58binsnm = mc_ParseName(CurrentObj,StrParam) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="Parse58cinsnm" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[    Dim StrParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Parse58cinsnm = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    StrParam = "58clname,58cfname,58cminit,58cCred,58cSufx"]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[	Parse58cinsnm = mc_ParseName(CurrentObj,StrParam) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="Parse31aPhSig" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    Dim StrParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Parse31aPhSig = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    StrParam = "31aPhLNm,31aPhFNm,31aPhIni,31crdntl,31aPhSfx"]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[	Parse31aPhSig = mc_ParseName(CurrentObj,StrParam) ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="PopulateFromField" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[        Set SourceObj = CurrentObj.parent.FindChild(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	if(Not SourceObj is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[           CurrentObj.text = SourceObj.text]]>
<![CDATA[
]]>
<![CDATA[           CurrentObj.ConfidenceString = SourceObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[           writelog("populate this field with values from " & StrParam)    ]]>
<![CDATA[
]]>
<![CDATA[           PopulateFromField= true]]>
<![CDATA[
]]>
<![CDATA[        else]]>
<![CDATA[
]]>
<![CDATA[           writelog("unable to find out " & StrParam)    ]]>
<![CDATA[
]]>
<![CDATA[           PopulateFromField= false]]>
<![CDATA[
]]>
<![CDATA[        end if ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="MC_ReadZones" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Dim sName	]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosName]]>
<![CDATA[
]]>
<![CDATA[	Dim sOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim aOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim nXoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim nYoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim oCurPage]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	MC_ReadZones=True]]>
<![CDATA[
]]>
<![CDATA[	sOffSet = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCurPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sOffSet=oCurPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	While oCurPage.ObjectType<>2 AND oCurPage.ObjectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oCurPage = oCurPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[		If len(sOffSet)=0 then sOffSet=oCurPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If len(sOffSet)=0 then ]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = oCurPage.FindChild("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[		If Not(oChild is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[			sOffset = trim(oChild.Text)]]>
<![CDATA[
]]>
<![CDATA[			sOffset = replace(sOffset,";","")			]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sName=oCurPage.Variable("TemplateID")	]]>
<![CDATA[
]]>
<![CDATA[	sPosName = "Pos" & sName]]>
<![CDATA[
]]>
<![CDATA[	Writelog("MC_ReadZones for " & sPosName)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aOffSet = Split(sOffSet & ",0" , ",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nXoffset = (-1*aOffSet(0))]]>
<![CDATA[
]]>
<![CDATA[	nYoffset = (-1*aOffSet(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nXoffSet)) or len(trim(nXoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nXoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("X offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nYoffSet)) or len(trim(nYoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nYoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("Y offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Offsets : " & nXoffset & "," & nYoffset)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call mc_ZoneChildren(CurrentObj, sPosName, 0, clng(nXoffSet), clng(nYoffSet))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCurPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="StripTrailingAlpha" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    StripTrailingAlpha = true]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Dim strText,strConf]]>
<![CDATA[
]]>
<![CDATA[    Dim strTextRes,strConfRes]]>
<![CDATA[
]]>
<![CDATA[    strTextRes = ""]]>
<![CDATA[
]]>
<![CDATA[    strConfRes = ""]]>
<![CDATA[
]]>
<![CDATA[    Dim checkedChar]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    strText = CurrentObj.text]]>
<![CDATA[
]]>
<![CDATA[    strConf = CurrentObj.confidenceString]]>
<![CDATA[
]]>
<![CDATA[    if(strText="") Then exit function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    bAlphaFound = false]]>
<![CDATA[
]]>
<![CDATA[    for i=1 to Len(strText)]]>
<![CDATA[
]]>
<![CDATA[    checkedChar = Mid(strText,i,1)    ]]>
<![CDATA[
]]>
<![CDATA[       if(IsNumeric(checkedChar) or IsAlpha_(checkedChar)) Then]]>
<![CDATA[
]]>
<![CDATA[          if IsNumeric(checkedChar) Then]]>
<![CDATA[
]]>
<![CDATA[             strTextRes = strTextRes & checkedChar]]>
<![CDATA[
]]>
<![CDATA[             strConfRes = strConfRes & Mid(strConf,i,1)]]>
<![CDATA[
]]>
<![CDATA[             bAlphaFound = true]]>
<![CDATA[
]]>
<![CDATA[          elseif IsAlpha_(checkedChar) and Not bAlphaFound Then]]>
<![CDATA[
]]>
<![CDATA[             strTextRes = strTextRes & checkedChar]]>
<![CDATA[
]]>
<![CDATA[             strConfRes = strConfRes & Mid(strConf,i,1)]]>
<![CDATA[
]]>
<![CDATA[             bAlphaFound = true   ]]>
<![CDATA[
]]>
<![CDATA[          end if]]>
<![CDATA[
]]>
<![CDATA[       end if]]>
<![CDATA[
]]>
<![CDATA[    next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    if(strTextRes = "" ) Then]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.text = ""]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.confidenceString = ""]]>
<![CDATA[
]]>
<![CDATA[       exit function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    if IsAlpha_(Mid(strTextRes,1,1)) Then]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.text = Mid(strTextRes,1,5)]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.confidenceString = Mid(strConfRes,1,5)]]>
<![CDATA[
]]>
<![CDATA['    else]]>
<![CDATA[
]]>
<![CDATA['       CurrentObj.text = Mid(strTextRes,1,4)]]>
<![CDATA[
]]>
<![CDATA['       CurrentObj.confidenceString = Mid(strConfRes,1,4)]]>
<![CDATA[
]]>
<![CDATA['    end if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="ValidateNPI" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim sum]]>
<![CDATA[
]]>
<![CDATA[  Dim nDigits]]>
<![CDATA[
]]>
<![CDATA[  Dim Parity]]>
<![CDATA[
]]>
<![CDATA[  Dim i,j]]>
<![CDATA[
]]>
<![CDATA[  Dim Digit]]>
<![CDATA[
]]>
<![CDATA[  Dim sLuhnString]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim	sRootNumber]]>
<![CDATA[
]]>
<![CDATA[	Dim sRootChkDgt]]>
<![CDATA[
]]>
<![CDATA[	Dim sCompChkDgt]]>
<![CDATA[
]]>
<![CDATA[  Dim nChar]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ValidateNPI=False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sValue = trim(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    For j = 1 to len(sValue)]]>
<![CDATA[
]]>
<![CDATA[        nChar=mid(sValue,j,1)]]>
<![CDATA[
]]>
<![CDATA[    	If Not(IsNumeric(nChar)) then]]>
<![CDATA[
]]>
<![CDATA[	    	Writelog("NPI must be Numeric")]]>
<![CDATA[
]]>
<![CDATA[	    	DCOMessage("NPI must be Numeric")]]>
<![CDATA[
]]>
<![CDATA[	    	Exit Function]]>
<![CDATA[
]]>
<![CDATA[	    End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'j]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If len(sValue)<>10 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("NPI must be 10 digits in length.")]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage("NPI must be 10 digits in length.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sRootNumber = Left(sValue,9)]]>
<![CDATA[
]]>
<![CDATA[	sRootChkDgt = Right(sValue,1)]]>
<![CDATA[
]]>
<![CDATA[		     ]]>
<![CDATA[
]]>
<![CDATA[    sum = cint(24)]]>
<![CDATA[
]]>
<![CDATA[    sLuhnString = "'24+"]]>
<![CDATA[
]]>
<![CDATA[    nDigits = len(sRootNumber)]]>
<![CDATA[
]]>
<![CDATA[    parity = nDigits mod 2]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[    For i = 1 to nDigits ]]>
<![CDATA[
]]>
<![CDATA[		digit = cint(mid(sRootNumber,i,1))]]>
<![CDATA[
]]>
<![CDATA[                  ]]>
<![CDATA[
]]>
<![CDATA[        If i mod 2 = parity then]]>
<![CDATA[
]]>
<![CDATA[			digit = digit * 2]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[        If digit > 9 then]]>
<![CDATA[
]]>
<![CDATA[			digit = digit - 9 ]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[        sum = sum + digit]]>
<![CDATA[
]]>
<![CDATA[		sluhnString = sLuhnString & cstr(digit) & "+"]]>
<![CDATA[
]]>
<![CDATA[    Next 'i]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    sCompChkDgt = right(10 - (sum mod 10),1)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Calculated CheckDigit:'" & sCompChkDgt & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If cint(sCompChkDgt)=cint(sRootChkDgt) Then		]]>
<![CDATA[
]]>
<![CDATA[		ValidateNPI=True]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Calculated CheckDigit matches Field value CheckDigit.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Calculated CheckDigit does not match Field value CheckDigit.")]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage("Calculated CheckDigit does not match Field value CheckDigit.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="TransformLI" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    Dim sType    ]]>
<![CDATA[
]]>
<![CDATA[    Dim oPage]]>
<![CDATA[
]]>
<![CDATA[    Dim oDoc]]>
<![CDATA[
]]>
<![CDATA[    Dim oDETAILS]]>
<![CDATA[
]]>
<![CDATA[    Dim i]]>
<![CDATA[
]]>
<![CDATA[    Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    TransformLI=FALSE]]>
<![CDATA[
]]>
<![CDATA[    Set oDETAILS =Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.ObjectType = 2 Then]]>
<![CDATA[
]]>
<![CDATA[        Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[        Set oDoc = oPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[        Select Case UCase(oPage.Type)]]>
<![CDATA[
]]>
<![CDATA[          Case "HCFA 1500","PCLAIM"]]>
<![CDATA[
]]>
<![CDATA[            Set oDETAILS = tli_GetDETAILS(oPage)]]>
<![CDATA[
]]>
<![CDATA[            Call tli_TransformHCFA(oDETAILS, oPage)]]>
<![CDATA[
]]>
<![CDATA[            TransformLI=True ]]>
<![CDATA[
]]>
<![CDATA[          Case "UB92","UB04_PAGE","ICLAIM"]]>
<![CDATA[
]]>
<![CDATA[            Set oDETAILS = tli_GetDETAILS(oPage)]]>
<![CDATA[
]]>
<![CDATA[            Call tli_TransformUB92(oDETAILS, oPage)]]>
<![CDATA[
]]>
<![CDATA[            TransformLI=True]]>
<![CDATA[
]]>
<![CDATA[          Case Else]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Unknown Page type '" & oPage.Type & "'")]]>
<![CDATA[
]]>
<![CDATA[        End Select                       ]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Elseif CurrentObj.ObjectType = 1 then]]>
<![CDATA[
]]>
<![CDATA[        Set oDoc = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[        'Loop through pages in doc]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        nChildren = oDoc.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[        For i = 1 to nChildren]]>
<![CDATA[
]]>
<![CDATA[            Set oPage = oDoc.GetChild(i-1)]]>
<![CDATA[
]]>
<![CDATA[            If oPage.ObjectType=2 Then]]>
<![CDATA[
]]>
<![CDATA[                If oPage.Type = "HCFA 1500" then]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[                Select Case UCase(oPage.Type)]]>
<![CDATA[
]]>
<![CDATA[                  Case "HCFA 1500","HCFA_1500","PCLAIM"]]>
<![CDATA[
]]>
<![CDATA[                    If oDETAILS is Nothing Then ]]>
<![CDATA[
]]>
<![CDATA[                        Set oDETAILS = tli_GetDETAILS(oPage)]]>
<![CDATA[
]]>
<![CDATA[                    Else]]>
<![CDATA[
]]>
<![CDATA[                        oPage.Type = Trim(oPage.Type) & Space(1) & "Trailing"]]>
<![CDATA[
]]>
<![CDATA[                    End if]]>
<![CDATA[
]]>
<![CDATA[                    Call tli_TransformHCFA(oDETAILS, oPage)]]>
<![CDATA[
]]>
<![CDATA[                    TransformLI=True]]>
<![CDATA[
]]>
<![CDATA[                    ]]>
<![CDATA[
]]>
<![CDATA[                  Case "UB92","UB04_PAGE","ICLAIM"]]>
<![CDATA[
]]>
<![CDATA[                    If oDETAILS is Nothing Then ]]>
<![CDATA[
]]>
<![CDATA[                        Set oDETAILS = tli_GetDETAILS(oPage)]]>
<![CDATA[
]]>
<![CDATA[                    Else]]>
<![CDATA[
]]>
<![CDATA[                        oPage.Type = Trim(oPage.Type) & Space(1) & "Trailing"]]>
<![CDATA[
]]>
<![CDATA[                    end if]]>
<![CDATA[
]]>
<![CDATA[                    Call tli_TransformUB92(oDETAILS, oPage)]]>
<![CDATA[
]]>
<![CDATA[                    TransformLI=True]]>
<![CDATA[
]]>
<![CDATA[                  ]]>
<![CDATA[
]]>
<![CDATA[                  End Select]]>
<![CDATA[
]]>
<![CDATA[                  ]]>
<![CDATA[
]]>
<![CDATA[                End if]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[        Next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Else    ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Action must be called by a Page or Document object.")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oDETAILS = Nothing	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="CheckDocID" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim sDocID]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CheckDocID = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sDocID = CurrentObj.ID]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog "DocID: " & sDocID]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Len(sDocID) <= 3 Then]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.ID = Pilot.BatchID & "." & Right("000" & sDocID, 2)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog "DocID: " & CurrentObj.ID]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CheckDocID = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="CalculateUBLineCharges" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim oDetail, oLitem, oField]]>
<![CDATA[
]]>
<![CDATA[	Dim iTotal,iSumTotal, iFieldCharge]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CalculateUBLineCharges = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	iSumTotal = 0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	writelog("CurrentObj.ObjectType: " & CurrentObj.ObjectType)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oDetail = ReturnNamedComponent("DETAILS")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("oDetail.NumOfChildren - 1: " & oDetail.NumOfChildren - 1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	iTotal =  Trim(CurrentObj.TEXT)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("iTotal")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(iTotal) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Invalid total charge.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		For k = 0 to oDetail.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[			Set oLitem = oDetail.GetChild(k)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If Not(oLitem is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[				For l = 0 to oLitem.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[					Set oField = oLitem.GetChild(l)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[					If oField.ID = "RevCode" And Right(oField.TEXT,3) = "001" Then]]>
<![CDATA[
]]>
<![CDATA[						Exit For]]>
<![CDATA[
]]>
<![CDATA[					ElseIf oField.ID = "Charges" Then]]>
<![CDATA[
]]>
<![CDATA[						iFieldCharge = Trim(oField.TEXT)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[						If Len(iFieldCharge) > 0 Then]]>
<![CDATA[
]]>
<![CDATA[							oField.Status = 1]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							oField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[				Next]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Next		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Set oField = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Set oLitem = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Set oDetail = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For i = 0 to oDetail.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[		Set oLitem = oDetail.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("oLitem: " & oLitem.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If Not(oLitem is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			For j = 0 to oLitem.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[				Set oField = oLitem.GetChild(j)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[				If oField.ID = "RevCode" And Right(oField.TEXT,3) = "001" Then]]>
<![CDATA[
]]>
<![CDATA[					Exit For]]>
<![CDATA[
]]>
<![CDATA[				ElseIf oField.ID = "RevCode" Then]]>
<![CDATA[
]]>
<![CDATA[					Writelog("oField: " & oField.ID & " :: " & oField.TEXT)]]>
<![CDATA[
]]>
<![CDATA[				ElseIf oField.ID = "Charges" Then]]>
<![CDATA[
]]>
<![CDATA['					Writelog("oField: " & oField.ID & " :: " & oField.TEXT)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					iFieldCharge = Trim(oField.TEXT)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA['					Writelog("iFieldCharge: " & iFieldCharge)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					If IsNumeric(iFieldCharge) Then 'And (iTotal - iFieldCharge) > 0 Then]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Field: " & oField.ID & " :: " & iFieldCharge)]]>
<![CDATA[
]]>
<![CDATA[						iSumTotal = (iSumTotal + iFieldCharge)]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			Next]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Line items not found.")]]>
<![CDATA[
]]>
<![CDATA[			Set oDetail = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (iSumTotal - iTotal) = 0 Then]]>
<![CDATA[
]]>
<![CDATA[		CalculateUBLineCharges = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For k = 0 to oDetail.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[		Set oLitem = oDetail.GetChild(k)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If Not(oLitem is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			For l = 0 to oLitem.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[				Set oField = oLitem.GetChild(l)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[				If oField.ID = "RevCode" And Right(oField.TEXT,3) = "001" Then]]>
<![CDATA[
]]>
<![CDATA[					Exit For]]>
<![CDATA[
]]>
<![CDATA[				ElseIf oField.ID = "Charges" Then]]>
<![CDATA[
]]>
<![CDATA[					iFieldCharge = Trim(oField.TEXT)]]>
<![CDATA[
]]>
<![CDATA['Writelog("SETTING STATUS")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[					'If Len(iFieldCharge) > 0 And CalculateUBLineCharges = False Then]]>
<![CDATA[
]]>
<![CDATA[					If CalculateUBLineCharges = False Then]]>
<![CDATA[
]]>
<![CDATA[						oField.Status = 1]]>
<![CDATA[
]]>
<![CDATA[					Else]]>
<![CDATA[
]]>
<![CDATA[						oField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA['Writelog(oField.id & " STATUS:" & oField.Status)]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			Next]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("                 ------------")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("       iSumTotal: " & iSumTotal)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("          iTotal:[" & iTotal & "]")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oField = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oLitem = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oDetail = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="CalculateHCFALineCharges" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim oDetail, oLitem, oField]]>
<![CDATA[
]]>
<![CDATA[	Dim iTotal,iSumTotal, iFieldCharge]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CalculateHCFALineCharges = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	iSumTotal = 0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	writelog("CurrentObj.ObjectType: " & CurrentObj.ObjectType)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oDetail = ReturnNamedComponent("DETAILS")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Found '" & oDetail.NumOfChildren - 1 & "' Lineitem lines.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	iTotal =  CurrentObj.TEXT]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Check Value of Total Charges - fail all charges if invalid.]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(iTotal) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Non numeric total charge value.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'find and fail all 'Charges' fields]]>
<![CDATA[
]]>
<![CDATA[		For k = 0 to oDetail.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[			Set oLitem = oDetail.GetChild(k)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If Not(oLitem is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[				For l = 0 to oLitem.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[					Set oField = oLitem.GetChild(l)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[					If oField.ID = "Charges" Then]]>
<![CDATA[
]]>
<![CDATA[						iFieldCharge = Trim(oField.TEXT)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						If Len(iFieldCharge) > 0 Then]]>
<![CDATA[
]]>
<![CDATA[							oField.Status = 1]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							oField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[							oField.ConfidenceString = 9]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[				Next 'l]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Next 'k		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Set oField = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Set oLitem = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Set oDetail = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Check sum of charges vs total charges]]>
<![CDATA[
]]>
<![CDATA[	For i = 0 to oDetail.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[		Set oLitem = oDetail.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("oLitem: " & oLitem.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If Not(oLitem is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			For j = 0 to oLitem.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[				Set oField = oLitem.GetChild(j)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[				If oField.ID = "Charges" Then]]>
<![CDATA[
]]>
<![CDATA[					iFieldCharge = Trim(oField.TEXT)]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					If len(iFieldCharge)=0 then iFieldCharge=0]]>
<![CDATA[
]]>
<![CDATA[          If Not IsNumeric(iFieldCharge) then iFieldCharge=0]]>
<![CDATA[
]]>
<![CDATA[          	]]>
<![CDATA[
]]>
<![CDATA[					If IsNumeric(iFieldCharge) Then ]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Field: " & oField.ID & " :: " & iFieldCharge)]]>
<![CDATA[
]]>
<![CDATA[						iSumTotal = (iSumTotal + iFieldCharge)]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			Next 'j]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Line items not found.")]]>
<![CDATA[
]]>
<![CDATA[			Set oDetail = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (iSumTotal - iTotal) = 0 Then]]>
<![CDATA[
]]>
<![CDATA[		CalculateHCFALineCharges = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For k = 0 to oDetail.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[		Set oLitem = oDetail.GetChild(k)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If Not(oLitem is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			For l = 0 to oLitem.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[				Set oField = oLitem.GetChild(l)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[				If oField.ID = "Charges" Then]]>
<![CDATA[
]]>
<![CDATA[					iFieldCharge = Trim(oField.TEXT)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA['					If Len(iFieldCharge) > 0 And CalculateHCFALineCharges = False Then]]>
<![CDATA[
]]>
<![CDATA[					If CalculateHCFALineCharges = False Then]]>
<![CDATA[
]]>
<![CDATA[						oField.Status = 1]]>
<![CDATA[
]]>
<![CDATA[					Else]]>
<![CDATA[
]]>
<![CDATA[						oField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[						oField.ConfidenceString = 9]]>
<![CDATA[
]]>
<![CDATA[						CurrentObj.ConfidenceString = 9]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			Next]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("                 ------------")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("       iSumTotal: " & iSumTotal)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("          iTotal:[" & iTotal & "]")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oField = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oLitem = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oDetail = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="SetOriginalTIF" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim sWorkingImage, sNewWorkingImage, sOriginalImage]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetOriginalTIF = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sWorkingImage = UCase(CurrentObj.Variable("IMAGEFILE"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("sWorkingImage:" & sWorkingImage)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sOriginalImage = Replace(sWorkingImage,"TIF",StrParam)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("sOriginalImage:" & sOriginalImage)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not FileMgr.FileExists(sOriginalImage) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("sOriginalImage does not exist.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sNewWorkingImage = Replace(sOriginalImage,"TM","TMO_")]]>
<![CDATA[
]]>
<![CDATA[	sNewWorkingImage = Replace(sNewWorkingImage,StrParam,"TIF")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("sNewWorkingImage:" & sNewWorkingImage)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FileMgr.CopyFile sOriginalImage,sNewWorkingImage]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("IMAGEFILE") = sNewWorkingImage]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetOriginalTIF = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="FormatFieldLengths" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Dim i]]>
<![CDATA[
]]>
<![CDATA[	Dim sOConfidence, sNConfidence, iLen]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FormatFieldLengths = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For i = 0 to CurrentObj.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[		Set oField = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(">>>> Start Field.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Field.ID:" & oField.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		sLength = Trim(oField.Variable("Length"))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If sLength = "" Then sLength = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("sLength: " & sLength)]]>
<![CDATA[
]]>
<![CDATA[            Value = oField.Text]]>
<![CDATA[
]]>
<![CDATA[            CurCount = Len(Value)]]>
<![CDATA[
]]>
<![CDATA[            nChilds = oField.Numofchildren - CurCount	]]>
<![CDATA[
]]>
<![CDATA[            Tcnt = 0	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            Writelog(Space(4) & "Start Value'" & Value & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	     'Trim the field value - remove leading and trailing spaces]]>
<![CDATA[
]]>
<![CDATA[	      If oField.ObjectType=3 then 'must be a dco field obj]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		     CharValue = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		     If len(oField.Text) > 0 then CharValue = oField.Getchild(nChilds).CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		     While clng(CharValue)= clng(32)]]>
<![CDATA[
]]>
<![CDATA[			   bRes = oField.DeleteChild(nChilds)]]>
<![CDATA[
]]>
<![CDATA[			   CharValue = 0  		]]>
<![CDATA[
]]>
<![CDATA[			   If len(oField.Text) > 0 then CharValue = oField.Getchild(nChilds).CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[			   Tcnt = Tcnt + 1]]>
<![CDATA[
]]>
<![CDATA[		     Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		     If len(oField.Text) > 0 then CharValue = oField.Getchild(oField.Numofchildren-1).CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		     While clng(CharValue)= clng(32)]]>
<![CDATA[
]]>
<![CDATA[			   bRes = oField.DeleteChild(oField.Numofchildren-1)]]>
<![CDATA[
]]>
<![CDATA[			   CharValue = 0  		]]>
<![CDATA[
]]>
<![CDATA[			   If len(oField.Text) > 0 then CharValue = oField.Getchild(oField.Numofchildren-1).CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[			   Tcnt = Tcnt + 1]]>
<![CDATA[
]]>
<![CDATA[		    Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	      End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If oField.ID = "DETAILS" Then]]>
<![CDATA[
]]>
<![CDATA[			For j = 0 to oField.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[				Set oSubField = oField.GetChild(j)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[				WriteLog("SubField.ID:" & oSubField.ID)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[				For k = 0 to oSubField.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[					Set oSubFields = oSubField.GetChild(k)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[					WriteLog("SubFields.ID:" & oSubFields.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					sLengthSub = Trim(oSubFields.Variable("Length"))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					If sLengthSub = "" Then]]>
<![CDATA[
]]>
<![CDATA[						sLengthSub = 0]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					WriteLog("DCO length of field " & oSubFields.ID & "=" & sLengthSub)]]>
<![CDATA[
]]>
<![CDATA[					WriteLog("Actual length of field " & oSubFields.ID & "= "& Len(oSubFields.Text))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					If Clng(sLengthSub) = 0 Then]]>
<![CDATA[
]]>
<![CDATA[						WriteLog("0 length value found: " & oSubFields.ID & " Length = " & sLengthSub)]]>
<![CDATA[
]]>
<![CDATA[					'ElseIf oSubFields.Variable("RecogType") = 4 Then]]>
<![CDATA[
]]>
<![CDATA[					'	WriteLog("OMR field found: " & oSubFields.ID & " Skipping")]]>
<![CDATA[
]]>
<![CDATA[					ElseIf Clng(Len(oSubFields.Text)) > Clng(sLengthSub) Then]]>
<![CDATA[
]]>
<![CDATA[						WriteLog("Truncating field: "& oSubFields.ID)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[						WriteLog("O Confidence: " & oSubFields.ConfidenceString)]]>
<![CDATA[
]]>
<![CDATA[						sOConfidenceSub = oSubFields.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[						oSubFields.Text = Left(oSubFields.Text,sLengthSub)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						sNConfidenceSub = Left(sOConfidenceSub,sLengthSub)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						iLenSub = Len(sNConfidenceSub)-1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						sNConfidenceSub = Mid(sNConfidenceSub,1,iLenSub) & "0"]]>
<![CDATA[
]]>
<![CDATA[						WriteLog("sNConfidenceSub: " & sNConfidenceSub)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[						oSubFields.ConfidenceString = sNConfidenceSub]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				Next	]]>
<![CDATA[
]]>
<![CDATA[			Next	]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("DCO length of field " & oField.ID & "= " & sLength)]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Actual length of field " & oField.ID & "= "& Len(oField.Text))]]>
<![CDATA[
]]>
<![CDATA['		WriteLog("oField.Variable(STATUS) = " & oField.Variable("STATUS") )]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If oField.ID = "1InsType" or oField.ID = "3aPatSex" or oField.ID = "6PatRela" or oField.ID = "8aPStatM" or oField.ID = "8bPStatE" _]]>
<![CDATA[
]]>
<![CDATA[		  or oField.ID = "10aPCREm" or oField.ID = "10bPCRAA" or oField.ID = "10cPCROA" or oField.ID = "11aInSex" or oField.ID = "11dPlOth" _]]>
<![CDATA[
]]>
<![CDATA[		  or oField.ID = "20aOutLb" or oField.ID = "25bSSEIN" or oField.ID = "27AccAss" Then]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("OMR field found: " & oField.ID & " Skipping")]]>
<![CDATA[
]]>
<![CDATA[		ElseIf Clng(sLength) = 0 Then]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("0 length value found: " & oField.ID & " Length = " & sLength)]]>
<![CDATA[
]]>
<![CDATA[		ElseIf Clng(Len(oField.Text)) > Clng(sLength) Then]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Truncating field: "& oField.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("O Confidence: " & oField.ConfidenceString)]]>
<![CDATA[
]]>
<![CDATA[			sOConfidence = oField.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			oField.Text = Left(oField.Text,sLength)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			sNConfidence = Left(sOConfidence,sLength)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			iLen = Len(sNConfidence)-1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			sNConfidence = Mid(sNConfidence,1,iLen) & "0"]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("sNConfidence: " & sNConfidence)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			oField.ConfidenceString = sNConfidence]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(">>>> End Field.")]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA['	WriteLog(">> End length check.")]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	Set oField = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oSubFields = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FormatFieldLengths = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="SetConf" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim i, j]]>
<![CDATA[
]]>
<![CDATA[	Dim sOConfidence, sNConfidence, iLen, sChar]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetConf = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sOConfidence = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[	Writelog("sOConfidence: " & sOConfidence)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	iLen = Len(sOConfidence)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("iLen: " & iLen)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For j = 1 to iLen]]>
<![CDATA[
]]>
<![CDATA[		sNConfidence = sNConfidence & StrParam]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("sNConfidence: " & sNConfidence)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.ConfidenceString = sNConfidence]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SetConf = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="FilterPID" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue, sFilterValue, sNewValue, sConfStr, iLen]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	FilterPID = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType<> 3 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Not a field object. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sValue = Trim(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("sValue: " & sValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sConfStr = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sFilterValue = Left(Trim(oFld.Text),2)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("sFilterValue: " & sFilterValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sNewValue = Trim(Replace(sValue,sFilterValue,""))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("sNewValue: " & sNewValue)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	iLen = Len(sNewValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sConfStr = Left(sConfStr, iLen)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("sConfStr: " & sConfStr)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text = sNewValue]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.ConfidenceString = sConfStr]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FilterPID = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="ClearErrorMsg" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   ClearErrorMsg = TRUE]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Variable("ErrorMessage") = ""]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Current Error Message: " & CurrentObj.Variable("ErrorMessage"))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="AddToErrorMsg" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  Dim oPage]]>
<![CDATA[
]]>
<![CDATA[  Dim iParam, arParam]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[  Dim sLastParam]]>
<![CDATA[
]]>
<![CDATA[  Dim nLast]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  AddToErrorMsg = FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    arParam = Split(StrParam, ",")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Dmessage: " & UBound(arParam))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    nLast = Ubound(arParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    sLastParam = ucase(arParam(nLast))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If trim(sLastParam) ="TRUE" and nLast>0 Then]]>
<![CDATA[
]]>
<![CDATA[	      AddToErrorMsg = TRUE]]>
<![CDATA[
]]>
<![CDATA[        ReDim Preserve arParam(nLast-1)]]>
<![CDATA[
]]>
<![CDATA[    End If  ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    sMsgStr = Join(arParam,",")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.ObjectType <> 3 then  ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("This action must be on a field object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    While oPage.ObjectType > 2]]>
<![CDATA[
]]>
<![CDATA[        Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[    wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Current Page is: " & oPage.ID)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    sSmartParam = MetaWord(sMsgStr)]]>
<![CDATA[
]]>
<![CDATA[    If len(sSmartParam)="" then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Smart Parameter parsing did not return a value. Defaulting message to the Action argument.")]]>
<![CDATA[
]]>
<![CDATA[        sSmartParam = sMsgStr]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   oPage.Variable("ErrorMessage") = oPage.Variable("ErrorMessage") & sSmartParam & VbCr]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Error message currently set to: " & oPage.Variable("ErrorMessage"))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="AddToDetailErrorMsg" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[Dim oPage]]>
<![CDATA[
]]>
<![CDATA[Dim iParam, arParam]]>
<![CDATA[
]]>
<![CDATA[Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   arParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Dmessage: " & UBound(arParam))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   If UBound(arParam) = 0 Then]]>
<![CDATA[
]]>
<![CDATA[	   AddToDetailErrorMsg = FALSE]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[	   AddToDetailErrorMsg = TRUE]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("This action must be on a field object.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   While oPage.ObjectType > 2]]>
<![CDATA[
]]>
<![CDATA[      Set oPage = oPage.Parent]]>
<![CDATA[
]]>
<![CDATA[   wend]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Current Page is: " & oPage.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   sSmartParam = MetaWord(arParam(0))]]>
<![CDATA[
]]>
<![CDATA[   If len(sSmartParam)="" then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Smart Parameter parsing did not return a value. Defaulting message to the Action argument.")]]>
<![CDATA[
]]>
<![CDATA[      sSmartParam =arParam(0)]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   oPage.Variable("ErrorMessage") = oPage.Variable("ErrorMessage") & "Lineitem " & cStr(CurrentObj.Parent.Parent.FindChildIndex(CurrentObj.Parent.ID) + 1) & "-" & sSmartParam & VbCr]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Error message currently set to: " & oPage.Variable("ErrorMessage"))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<f name="ParseNDC" access="public" qi="An action that detects and parses NDC data elemets from the calling field value.">
	<p name="NDCField">
	</p>
	<p name="TypeField">
	</p>
	<p name="QuantityField">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  	]]>
<![CDATA[
]]>
<![CDATA[      On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ParseNDC=True	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Dim regEx ]]>
<![CDATA[
]]>
<![CDATA[      Dim Pattern_NDC]]>
<![CDATA[
]]>
<![CDATA[      Dim Pattern_Units  ]]>
<![CDATA[
]]>
<![CDATA[      Dim sFieldValue]]>
<![CDATA[
]]>
<![CDATA[      Dim Index]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Set regEx = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[      regEx.IgnoreCase = False]]>
<![CDATA[
]]>
<![CDATA[      regEx.Global = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      'N4 followed by space(s) or not then 11 digits]]>
<![CDATA[
]]>
<![CDATA[      Pattern_NDC = "N4\ *[\dOIlS]{11}"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      'F2,GR,ML or UN followed by 9 digits]]>
<![CDATA[
]]>
<![CDATA[      Pattern_Units = "(F2|GR|ML|UN)[\dOIlS\.]{1,9}"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[      'Get the Field value]]>
<![CDATA[
]]>
<![CDATA[      sFieldValue = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      '---------------------------------]]>
<![CDATA[
]]>
<![CDATA[      'NDC Pattern Test]]>
<![CDATA[
]]>
<![CDATA[      regEx.Pattern = Pattern_NDC]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Checking for NDC Pattern in: '" & Cstr(sFieldValue) & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set Matches = regEx.Execute(sFieldValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[      If cstr(Matches.Count)=cstr(0) then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("No NDC value matched.")]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        For Each Match In Matches]]>
<![CDATA[
]]>
<![CDATA[           WriteLog("Matched Value: '" & CStr(Match.value) & "' ")]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[           Index = Match.FirstIndex 'First character position of match]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[           'Copy field value and positions to NDC field 	]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[           'Get DCO object using smart parameter syntax]]>
<![CDATA[
]]>
<![CDATA[           Set oChild = DCONav(NDCField) ]]>
<![CDATA[
]]>
<![CDATA[           If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[           If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[              Writelog("Did not find the NDC target Field")]]>
<![CDATA[
]]>
<![CDATA[           Else]]>
<![CDATA[
]]>
<![CDATA[              Index=Index+3 '+1 for zero offset in regex, +2 to skip 'N4' leading ID characters. ]]>
<![CDATA[
]]>
<![CDATA[  			]]>
<![CDATA[
]]>
<![CDATA[              oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[              oChild.Variable("Position")="0,0,0,0"				]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[              'These are utility calls in rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[              Call RRCopyChars(CurrentObj, oChild, Index, 11)]]>
<![CDATA[
]]>
<![CDATA[              Call RRCopyPos(CurrentObj, oChild, Index, 11)]]>
<![CDATA[
]]>
<![CDATA[              Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[              Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & oChild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[           End If]]>
<![CDATA[
]]>
<![CDATA[           Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[  	   ]]>
<![CDATA[
]]>
<![CDATA[           Exit For 'Only for first Match (should only be one)]]>
<![CDATA[
]]>
<![CDATA[        Next 'Match]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[	'---------------------------------]]>
<![CDATA[
]]>
<![CDATA[      'Units Pattern Test]]>
<![CDATA[
]]>
<![CDATA[	regEx.Pattern = Pattern_Units]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Checking for Units Pattern in: '" & Cstr(sFieldValue) & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set Matches = regEx.Execute(sFieldValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[      If Matches.Count=0 then Writelog("No Units value matched.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      For Each Match In Matches]]>
<![CDATA[
]]>
<![CDATA[         WriteLog("Matched Value: '" & CStr(Match.value) & "' ")]]>
<![CDATA[
]]>
<![CDATA[	       ParseNDC = True]]>
<![CDATA[
]]>
<![CDATA[         Index = Match.FirstIndex 'First character position of match]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	       'Copy field values and positions to Units(type) and Quantity field 	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	       'Get DCO object using smart parameter syntax	]]>
<![CDATA[
]]>
<![CDATA[	       Set oChild = DCONav(TypeField)]]>
<![CDATA[
]]>
<![CDATA[         If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[         If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[	          Writelog("Did not find the Type target Field")]]>
<![CDATA[
]]>
<![CDATA[         Else]]>
<![CDATA[
]]>
<![CDATA[            Index=Index+1 '+1 for zero offset in regex ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[            oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[            oChild.Variable("Position")="0,0,0,0"				]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            'These are utility calls in rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[            Call RRCopyChars(CurrentObj, oChild, Index, 2)]]>
<![CDATA[
]]>
<![CDATA[            Call RRCopyPos(CurrentObj, oChild, Index, 2)]]>
<![CDATA[
]]>
<![CDATA[            Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[            Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & oChild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[         End If]]>
<![CDATA[
]]>
<![CDATA[         Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[         'Get DCO object using smart parameter syntax]]>
<![CDATA[
]]>
<![CDATA[         Set oChild = DCONav(QuantityField)]]>
<![CDATA[
]]>
<![CDATA[         If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[         If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Did not find the Quantity target Field")]]>
<![CDATA[
]]>
<![CDATA[         Else]]>
<![CDATA[
]]>
<![CDATA[            Index=Index+2 '+2 to skip 2 Type ID characters. ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[            oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[            oChild.Variable("Position")="0,0,0,0"				]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            'These are utility calls in rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[            Call RRCopyChars(CurrentObj, oChild, Index, len(Match.value)-2)]]>
<![CDATA[
]]>
<![CDATA[            Call RRCopyPos(CurrentObj, oChild, Index, len(Match.value)-2)]]>
<![CDATA[
]]>
<![CDATA[            Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[            Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & oChild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[         End If]]>
<![CDATA[
]]>
<![CDATA[         Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	    ]]>
<![CDATA[
]]>
<![CDATA[         Exit For]]>
<![CDATA[
]]>
<![CDATA[      Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      'Cleanup]]>
<![CDATA[
]]>
<![CDATA[      Set Match = Nothing]]>
<![CDATA[
]]>
<![CDATA[      Set Matches = Nothing]]>
<![CDATA[
]]>
<![CDATA[      Set regEx=Nothing]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
	</g>
</f>
<f name="ParseConditionCodes" access="public">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  	]]>
<![CDATA[
]]>
<![CDATA[      On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ParseConditionCodes=True	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Dim regEx ]]>
<![CDATA[
]]>
<![CDATA[      Dim Pattern_CC]]>
<![CDATA[
]]>
<![CDATA[      Dim sFieldValue]]>
<![CDATA[
]]>
<![CDATA[      Dim Index]]>
<![CDATA[
]]>
<![CDATA[      Dim nExpected]]>
<![CDATA[
]]>
<![CDATA[      Dim nMatch]]>
<![CDATA[
]]>
<![CDATA[      Dim sRemainder]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[      Set regEx = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[      regEx.IgnoreCase = False]]>
<![CDATA[
]]>
<![CDATA[      regEx.Global = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Pattern_CC = "A[A-I]|W[2-5]"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[      'Get the Field value]]>
<![CDATA[
]]>
<![CDATA[      sFieldValue = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[      sRemainder = sFieldValue]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      'Calc expected num of matches]]>
<![CDATA[
]]>
<![CDATA[      nExpected = len(replace(sFieldValue,Space(1),""))/2]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Expecting " & nExpected & " condition codes based on field length.")      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      '---------------------------------]]>
<![CDATA[
]]>
<![CDATA[      'CC Pattern Test]]>
<![CDATA[
]]>
<![CDATA[      regEx.Pattern = Pattern_CC]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    	Writelog("Checking for CC Pattern in: '" & Cstr(sFieldValue) & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	    Set Matches = regEx.Execute(sFieldValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[      nMatch=0]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[      If cstr(Matches.Count)=cstr(0) then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("No Condition Code values matched.")]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        For Each Match In Matches]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[           nMatch = nMatch + 1]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[           WriteLog("Matched Value: '" & CStr(Match.value) & "' ")]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[           Index = Match.FirstIndex 'First character position of match]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[           'Copy field value and positions to Target field 	]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[           'Get DCO object using smart parameter syntax]]>
<![CDATA[
]]>
<![CDATA[           Set oChild = DCONav("@P\CCode" & cstr(nMatch)) ]]>
<![CDATA[
]]>
<![CDATA[           If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[           If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[              Writelog("Did not find the Condition code target Field")]]>
<![CDATA[
]]>
<![CDATA[           Else]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[              Index=Index+1 '+1 for zero offset in regex]]>
<![CDATA[
]]>
<![CDATA[  			]]>
<![CDATA[
]]>
<![CDATA[              oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[              oChild.Variable("Position")="0,0,0,0"				]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[              'These are utility calls in rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[              Call RRCopyChars(CurrentObj, oChild, Index, len(Match.value))]]>
<![CDATA[
]]>
<![CDATA[              Call RRCopyPos(CurrentObj, oChild, Index, len(Match.value))]]>
<![CDATA[
]]>
<![CDATA[              Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[              Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & oChild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[              sRemainder = Replace(sRemainder,Match.value,"",1,1)]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[           End If]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[           Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[  	          ]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[        Next 'Match]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[	   ]]>
<![CDATA[
]]>
<![CDATA[    if nMatch<>nExpected then]]>
<![CDATA[
]]>
<![CDATA[      sMsg = "Expected " & nExpected & " matches, only found " & nMatch & "."]]>
<![CDATA[
]]>
<![CDATA[      Writelog(sMsg)]]>
<![CDATA[
]]>
<![CDATA[      DCOMessage(sMsg)]]>
<![CDATA[
]]>
<![CDATA[      ParseConditionCodes=False]]>
<![CDATA[
]]>
<![CDATA[    end if  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    if len(replace(sRemainder,Space(1),""))>0 then]]>
<![CDATA[
]]>
<![CDATA[      sMsg = "Invalid value '" & sRemainder & "' found."]]>
<![CDATA[
]]>
<![CDATA[      Writelog(sMsg)]]>
<![CDATA[
]]>
<![CDATA[      DCOMessage(sMsg)]]>
<![CDATA[
]]>
<![CDATA[      ParseConditionCodes=False]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   'Cleanup]]>
<![CDATA[
]]>
<![CDATA[   Set Match = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set Matches = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set regEx=Nothing]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="ParseEPSDT" access="public">
	<p name="EPSDTCode">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  	]]>
<![CDATA[
]]>
<![CDATA[      On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ParseEPSDT=True	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Dim regEx ]]>
<![CDATA[
]]>
<![CDATA[      Dim Pattern_NDC]]>
<![CDATA[
]]>
<![CDATA[      Dim Pattern_Units  ]]>
<![CDATA[
]]>
<![CDATA[      Dim sFieldValue]]>
<![CDATA[
]]>
<![CDATA[      Dim Index]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Set regEx = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[      regEx.IgnoreCase = False]]>
<![CDATA[
]]>
<![CDATA[      regEx.Global = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Pattern_Code = "\s?(AV|S2|ST|NU)\s?$"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[      'Get the Field value]]>
<![CDATA[
]]>
<![CDATA[      sFieldValue = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      '---------------------------------]]>
<![CDATA[
]]>
<![CDATA[      'Reason Code Pattern Test]]>
<![CDATA[
]]>
<![CDATA[      regEx.Pattern = Pattern_Code]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Checking for Reason Code Pattern in: '" & Cstr(sFieldValue) & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Set Matches = regEx.Execute(sFieldValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[      If cstr(Matches.Count)=cstr(0) then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("No matched values.")]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        For Each Match In Matches]]>
<![CDATA[
]]>
<![CDATA[           WriteLog("Matched Value: '" & CStr(Match.value) & "' ")]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[           Index = Match.FirstIndex 'First character position of match]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[           'Copy field value and positions to Target field 	]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[           'Get DCO object using smart parameter syntax]]>
<![CDATA[
]]>
<![CDATA[           Set oChild = DCONav(EPSDTCode) ]]>
<![CDATA[
]]>
<![CDATA[           If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[           If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[              Writelog("Did not find the Reason Code target Field")]]>
<![CDATA[
]]>
<![CDATA[           Else]]>
<![CDATA[
]]>
<![CDATA[              Index=Index+1 '+1 for zero offset]]>
<![CDATA[
]]>
<![CDATA[  			]]>
<![CDATA[
]]>
<![CDATA[              oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[              oChild.Variable("Position")="0,0,0,0"				]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[              'These are utility calls in rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[              Call RRCopyChars(CurrentObj, oChild, Index, 11)]]>
<![CDATA[
]]>
<![CDATA[              Call RRCopyPos(CurrentObj, oChild, Index, 11)]]>
<![CDATA[
]]>
<![CDATA[              Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[              Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & oChild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[           End If]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[           Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[  	   ]]>
<![CDATA[
]]>
<![CDATA[           Exit For 'Only for first Match (should only be one)]]>
<![CDATA[
]]>
<![CDATA[        Next 'Match]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[   'Cleanup]]>
<![CDATA[
]]>
<![CDATA[    Set Match = Nothing]]>
<![CDATA[
]]>
<![CDATA[    Set Matches = Nothing]]>
<![CDATA[
]]>
<![CDATA[    Set regEx=Nothing]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ParseEPSDT=False]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<help>
  <g>
    <![CDATA[
'******************************************************************************************
' MC_Validation help.xml  
'-----------------------------------------------------------------------
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2013 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'------------------------------------------------------------------------

]]>
  </g>
  
  <ref id="UpdateCredentialList">
    <p name="sCredential"/>
    <p name="AddRemove"/>
    <ap>
      A two parameter specification of a list of credential abbreviations and a Add or Remove from list indicator.<br/>

      The List of credentials is a comma separated list of credential abbreviations - smartparameter enabled.<br/>
      The Indicator is a Add or Remove Condition from the list command. Defaults to Add, keywords for setting the remove
      from list mode are: "OFF","REMOVE","0","FALSE","-1","NO" and "DELETE".
    </ap>
    <h>
      An action that updates the default list of abbreviations that the following name parsing actions use to extract credentail strings from names:
      ParseLastFirstIniNames(), Parse58ainsnm(), Parse58binsnm(), Parse58cinsnm(), Parse82name(), Parse83aname(), Parse83bname(), Parse31aPhSig()
      <e>
        <b>UpdateCredentialList(MD,Add)</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if the action generates an error. Otherwise, <b>True.</b>
    </ret>

    
  </ref>

  <ref id="InheritSnippets">
    <ap>
      Names of the fields that will inherit the same snippet information as the current Field object.<br/><br/>

      For example: 2paLname, 2PaFname, 2PaMInit.
    </ap>
    <h>
      Assigns the snippet position information of the current Field object to the
      Field objects specified in the parameter.
      <e>
        <b>InheritSnippets(2paLname, 2PaFname,2PaMInit)</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the action is not applied at the Field level,
      or if a parameter is incorrect.  Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="ValProcedureCode">
    <ap>None.</ap>
    <h>
      Validates the Procedure Code fields of a HCFA-1500 form.
      <e>
        <scr>ValProcedureCode()</scr>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if not applied at the Field level, or if the procedure code is invalid.  Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="ValRequiredGroup">
    <ap>Names of the fields in the group.</ap>
    <h>
      Checks that all fields in a designated group are filled with data.<br/><br/>

      This action is used for HCFA-1500 forms only.
      <e>
        <b>ValRequiredGroup(24aDtFr1,24aDtTo1, 24adCPT_1,24fChg1,24gdays1)</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the parameters are invalid, or if any of the parameter fields does not contain data.  Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="CommonValAddress">
    <ap>
      Comma-delimited <i>String</i>with a list of field names with address values to be validated.
    </ap>
    <h>
      Validates address values: <br/><br/>

      <b>1.</b> First Name: value can start with "Ms","Mr","Miss", "Dr" (Salutations). The remaining values have to be alphanumeric with no special characters. Punctuation is allowed only after the salutation.<br/>
      <b>2.</b> Last name: same requirements as for first name <br/>
      <b>3.</b> Street:  alphanumeric, upper or lower case.  Can include punctuation and the # character. <br/>
      <b>4.</b> City:  characters from A to Z, upper or lower case, comma, period, space, and ampersand character.<br/>
      <b>5.</b> State:  must be two alphanumeric characters.<br/>
      <b>6.</b> Zip Code: must be between five and nine numeric characters.  This value is checked against the State value (above).<br/>
      <b>7.</b> Phone Number: The Area Code is checked against State and Zip Code values (above).<br/>
      <e>
        <b>CommonValAddress(Insured,4InsFNam,4InsLNam, 7IAddStr,,7IAddCty,7IAddSta,7IAddZip)</b><br/>
        or<br/>
        <b>CommonValAddress(Description,12plname,12pfname, 13paddr1,13paddr2,13padcit,13padsta,13padzip)</b>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>False</b> if not placed at the Page level. Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="CommonParseAddress">
    <ap>
      For Professional Claim, String value of:<br/>
      <b>1.</b> HCField32Object: for parsing Facility Address field (field 32).<br/>
      <b>2.</b> HCField33Object: for parsing Physician Address field (field 33).<br/><br/>

      For Institutional Claim, String value of:<br/>
      <b>1.</b> UBField1Object: for parsing Provider Address field (field 1).<br/>
      <b>2.</b> UBField2Object: for parsing Pay-To Address field (field 2).<br/>
      <b>3.</b> UBField38Object: for parsing responsible party Name and Address field (field 38).
    </ap>
    <h>
      Parses addresses in the following fields into appropriate subfields:<br/>
      Professional Claims - Facility Address (Field 32), or Physician Address (Field 33)<br/>
      Institutional Claims - Provider Address (Field 1), Pay-To Address (Field 2), or Responsible Party Name and Address (Field 38).
      <e>
        <b>CommonParseAddress(HCField32Object)</b>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>False</b> if the parameter is invalid, or if the action is not at the Page level.  Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="ConvertHyphen">
    <ap>None.</ap>
    <h>
      Removes spaces, commas, hyphens and invalid characters.<br/><br/>

      "1,2,3,4" becomes "1234"; "1-2-3" becomes "123".

      Valid characters for this field are {1,2,3,4}.
      Characters other than 1,2,3,4, space, commas, decimal or hyphens will lower the field confidence.
      <e>
        <scr>ConvertHyphen()</scr>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if not called at the Field level. Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="ParseLastFirstIniNames">
    <ap>
      Three comma separated parameters:<br/>
      <b>1.</b> The name of the Last Name Field object.<br/>
      <b>2.</b> The name of the First Name Field object.<br/>
      <b>3.</b> The name of the Middle Name or Middle Initial Field object.<br/>
      <b>4.</b> The name of the Credential Field object.<br/>
      <b>5.</b> The name of the Suffix Field object<br/>
    </ap>
    <h>
      Parses the name information in the first line of an address superfield. <br/><br/>

      The action will parse the full name's value into the Last, First, and Middle Name/Initial fields specified by the parameter.
      In the absence of any explicit pattern, such as punctuation or a middle initial, parsing is defaults to First Middle Last.
      A Parameter value of '-1' in the argument changes this default in the absence of any explicit pattern to Last First.

      <e>
        For form fields where the instructions specify First Middle Last:
        <b>ParseLastFirstIniNames(8plname,8pfname,8pminit)</b>
        or
        For form fields where the instruction specify Last First Middle:
        <b>ParseLastFirstIniNames(17ReLNam,17ReFNam,17ReMIni,17ReCred,17ReSufx,-1)</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the parameter values are invalid; Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="AddCenturyTo2DigitYear">
    <ap>None.</ap>
    <h>
      Converts two-digit Year values to four-digit Year values.<br/><br/>

      All dates are assumed to be before today's date, with a format of mmddyy.
      If today is 150507, and this action is applied to a field with a value of 221095, the date is assumed to be 22101995.
      <e>
        <b>AddCenturyTo2DigitYear()</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if value is not a valid date in the mmddyy format, or if the action is not applied at the Field level.  Otherwise, <b>True.</b>
    </ret>
  </ref>  

  <ref id="Parse58ainsnm">
    <ap>None.</ap>
    <h>
      This action parses field 58ainsnm of the UB04 application.
      <e>
        <b>Parse58ainsnm()</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

  <ref id="Parse58binsnm">
    <ap>None.</ap>
    <h>
      This action parses field 58binsnm of the UB04 application.
      <e>
        <b>Parse58binsnm()</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

  <ref id="Parse58cinsnm">
    <ap>None.</ap>
    <h>
      This action parses field 58cinsnm of the UB04 application.
      <e>
        <b>Parse58cinsnm()</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

  

  <ref id="Parse31aPhSig">
    <ap>None.</ap>
    <h>
      Parses field 31aPhSig of the HCFA application.
      <e>
        <b>Parse31aPhSig()</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

  <ref id="PopulateFromField">
    <ap>The name of the field whose value is to be assigned to the current field.</ap>
    <h>
      Copies the value from the field specified by the parameter into the current field.
      <e>
        <b>PopulateFromField(24aDtFr1)</b>
      </e>
    </h>
    <lvl>Field level only.</lvl>
    <ret>
      <b>False</b> if the parameter is invalid, or if the action is not applied at the Field level.  Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="MC_ReadZones">
    <ap>None.</ap>
    <h>
      Adjusts autofield based OMR field zone positions on the calling page.<br/><br/>

      <b>Alert!</b> This action handles Autofield-based OMR zone detection for a Medical Claims application.
      The action is not compatible with standard rules-based OMR zone detection procedures.
      <e>
        <scr>MC_ReadZones()</scr>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>False</b> if not applied at the Page level. Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="StripTrailingAlpha">
    <ap>None.</ap>
    <h>
      Removes all alpha characters from the captured value, except any in the first character position.
      <e>
        <b>StripTrailingAlpha()</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

  <ref id="ValidateNPI" >
    <ap>None.</ap>
    <h>
      Validates the NPI value by evaluating the 10 digits in the value
      uses a modified LUHN checkdigit algorithm.
      <e></e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>True</b> if the field contains a valid NPI value.  Otherwise, <b>False.</b>
    </ret>
  </ref>

  <ref id="TransformLI" >
    <ap>None.</ap>
    <h>
      Each line in the table is remapped into a repeating set of fields. These fields have
      a parent field with a unique ID. All data in a source field is retained in the new target field,
      with the exception of the new fields type and ID. The linear field structure is replaced with
      a structure based on a parent field within the claim page called DETAILS.<br/><br/>

      Each set of fields in the row of table data is then placed within a LINEITEM type field, the ID
      of the field is patterned on the index of its insertion in the DETAILS field. The first Line Item
      field will be called LINEITEM1, the second LINEITEM2, etc. Each Line Item field contains an
      identical set of Field Type and ID as outlined in the values list below.<br/><br/>

      As an example, the HCFA Line Item Table has twelve 24nDtfr fields. During processing, the
      <b>TransformLI</b> action assigns recognized values for these fields to a DateFrom <b>Field</b> object
      that is a child of the Line Item Tables Details new parent <b>Field</b> object.
      Ultimately, 12 recognized values can be assigned to the DateFrom <b>Field</b> object.<br/><br/>

      Values associated with rows of the HCFA-1500 table will be assigned to these Field types: (<b>n</b> is a value from 1 to 12)<br/><br/>

      24aDtf<b>n</b> = DateFrom<br/>
      24aDtTo<b>n</b> = DateThru<br/>
      24bPlac<b>n</b> = PlaceOfService<br/>
      24cType<b>n</b> = TypeOfService<br/>
      24cEMG_<b>n</b> = EMG_C<br/>
      24dCPT_<b>n</b> = CPT_Code<br/>
      24dModi<b>n</b> = Modifiers<br/>
      24eDiag<b>n</b> = DiagPointer<br/>
      24fChgs<b>n</b> = Charges<br/>
      24gDays<b>n</b> = Days_Units<br/>
      24hEPSD<b>n</b> = EPSD<br/>
      24iQual<b>n</b> = Qualifier<br/>
      24jRefID<b>n</b> =  ReferenceId<br/>
      24iEMG_<b>n</b> = EMG_I<br/>
      24jCOB<b>n</b> = COB<br/>
      24kLoc<b>n</b> = LocalUse<br/>
      24Info<b>n</b> = Info<br/><br/>

      Values associated with rows of the UB92/UB04 table will be assigned to these child <b>Field</b> objects: (n is a value from a to z):<br/><br/>
      42<b>n</b>revcd = RevCode<br/>
      43<b>n</b>dscrt = Description<br/>
      44<b>n</b>hcpcs = HCPCS<br/>
      44<b>n</b>Mod = Modifiers<br/>
      45<b>n</b>srvdt = ServiceDate<br/>
      46<b>n</b>srvun = Units<br/>
      47<b>n</b>ttchg = Charges<br/>
      48<b>n</b>ncchg = NonCovered<br/>
      49<b>n</b> = LocalUse<br/><br/>

      <b>Note:</b> This action will convert all pages in a document if called from a <b>Document</b> object.
      The expected page types are <b>HCFA 1500, UB92,</b> and <b>UB04_Page.</b>
    </h>
    <lvl>Document or Page level.</lvl>
    <ret>
      <b>True</b> if the assignment of values for all fields in all lines of the Line Item Table was successful.<br/>
      <b>False</b> if the transfer of values for one or more fields fails.
    </ret>
  </ref>

  <ref id="CheckDocID" >
    <ap>None.</ap>
    <h>
      Checks document ids and updates them to the proper format.
      <e>
        <b>CheckDocID()</b>
      </e>
    </h>
    <lvl>Document level.</lvl>
    <ret>
      <b>True</b> if docid is formatted without an error.<br/>
      <b>False</b> if docid is formatted with an error.
    </ret>
  </ref>

  <ref id="CalculateUBLineCharges" >
    <ap>None.</ap>
    <h>
      Calculates charges for UB service lines.
      <e>
        <b>CalculateUBLineCharges()</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>True</b> if line charges equal total charges field.  Otherwise, <b>False.</b>
    </ret>
  </ref>

  <ref id="CalculateHCFALineCharges" >
    <ap>None.</ap>
    <h>
      Calculates charges for HCFA service lines.
      <e>
        <b>CalculateHCFALineCharges()</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>True</b> if line charges equal total charges field.  Otherwise, <b>False.</b>
    </ret>
  </ref>


  <ref id="SetOriginalTIF">
    <ap>The extension of the original image file.</ap>
    <h>
      Replaces current working tif file with the original image file.  It is assumed that the original file name
      has been copied to a file name that uses a different extention for safe keeping.
      <e>
        <b>SetOriginalTIF(TI1)</b><br/>
        This example replaces the current TIF file with the original TIF image that was previously renamed with a TI1 extension.
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>False</b> if the original image file does not exist.  Otherwise <b>True.</b>
    </ret>
  </ref>

  <ref id="FormatFieldLengths">
    <ap>None.</ap>
    <h>
      Truncates length and sets the last character to low confidence of the field.
      <e>
        <b>FormatFieldLengths()</b>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

  <ref id="SetConf" >
    <ap>The value of the new confidence for each character in the field, 0 to 9.</ap>
    <h>
      Sets cofidence string for a field.
      <e>
        <b>SetConf(9)</b><br/>
        This example sets the confidence for each character in the field to 9, the highest confidence.
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>
  
  <ref id="FilterPID">
    <ap>The name of the field to filter.</ap>
    <h>
      Filters qualifier from attending physician field for UB04 claims.
      <e>
        <b>FilterPID(76apqual)</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if not called at the field level.  Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="ClearErrorMsg" >
    <ap>None.</ap>
    <h>
      Clears the value of the page variable 'ErrorMessage'.
      <e>
        ClearErrorMsg()
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>

  <ref id="AddToErrorMsg">
    <ap>
      1) A smart parameter or regular string to add to the error message variable.<br/>
      2) Optional comma separated second parameter with argument string 'TRUE' to trigger action to return true.
    </ap>
    <lvl>Field level.</lvl>
    <h>
      Adds the value to the existing value for the Page Variable 'ErrorMessage' and returns false.
      <e>
        <b>AddToErrorMsg("Invoice Number must be 60 percent numeric with a minimum length of 2.")</b>
        <br/>
        <br/>
        Adds the value to the existing value for the Page Variable 'ErrorMessage' and returns True.
        <b>AddToErrorMsg("Invoice Number must be 60 percent numeric with a minimum length of 2.","TRUE")</b>
      </e>
    </h>
    <ret>
      <b>True</b> if optional second comma separated parameter is used. Otherwise always <b>False</b> 
    </ret>
  </ref>

  <ref id="AddToDetailErrorMsg">
    <ap>
      1) A smart parameter or regular string to add to the error message variable.<br/>
      2) Optional comma separated second parameter to trigger action to return true.
    </ap>
    <h>
      Adds the value to the existing value for the Page Variable ErrorMessage.
      <e>
        AddToDetailErrorMsg("Description cannot be blank")
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>True</b> if optional second comma separated parameter is used. Otherwise always <b>False</b>
    </ret>
  </ref>
  
  <ref id="ParseNDC" >
    <ap>
      Three Smart Parameters representing the target path from the calling object to the field's parsed data is to be saved.<br/>
      1) Field for the parsed NDC value.<br/>
      2) Field for the parsed Type value.<br/>
      3) Field for the parsed Quantity value.<br/>
    </ap>
    <h>
      An action that detects and parses NDC data elemets from the calling field value.
      NDC value parsing looks for "N4" followed by 11 numeric digits.
      NDC Type and Quantity Parsing looks for "F2","GR","ML" or "UN" followed by 1 to 9 numeric digits.
      <e>
        <b>ParseNDC("..\NDC","..\NDCType","..\NDCQty")</b>
      </e>
    </h>
    <lvl>Field containing NDC data to detect and parse.</lvl>
    <ret>
      <b>False</b> if the action generates an error. Otherwise, <b>True.</b>
    </ret>
  </ref>
  <ref id="ParseConditionCodes">
    <h>
      An action that detects and parses Condition Code data elemets from the calling field value.
      Valid codes are AA, AB, AC, AD, AE, AF, AG, AH, AI, W2, W3, W4 or W5.
      <e>
        <b>ParseConditionCodes()</b>
      </e>
    </h>
    <lvl>Field containing Condition Code data to detect and parse to fields CCode1 through CCode4.</lvl>
    <ret>
      <b>False</b> if the action generates an error or an invalid code is detected. Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="ParseEPSDT">
    <ap>
      A Smart Parameter enabled value representing the target field where parsed data is to be saved.<br/>
    </ap>
    <h>
      An action that detects and parses a EPSDT Reason Code from the calling field value.
      Parsing looks for "AV","S2","ST" or "NU" as a single word at the end of the field value.
      <e>
        <b>ParseEPSDT("..\EPSDTCode")</b>
      </e>
    </h>
    <lvl>Field containing Reason Code data.</lvl>
    <ret>
      <b>False</b> if the action generates an error. Otherwise, <b>True.</b>
    </ret>
  </ref>
  
 </help>
</rrx>
<rrx namespace="ocr_a" src="c:\datacap\RRS\ocr_a.dll">

<i ref="rrunner">
</i>
<i ref="recog_shared">
</i>
<g>
</g>
<g>
</g>
<af name="EnableEngineLogsOCR_A" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	EnableEngineLogsOCR_A = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	EnableEngineLogsOCR_A = oABBYYRecognition.EnableLogs]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="SetConfCalculationParamsOCR_A" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[    SetConfCalculationParamsOCR_A = FALSE]]>
<![CDATA[
]]>
<![CDATA[    Dim sParams]]>
<![CDATA[
]]>
<![CDATA[    sParams = Split(strParam,",")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If UBound(sParams) < 1 Then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog "This action requires two parameters. Exiting"]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If Not IsNumeric(sParams(0)) Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Both parameters have to be numeric. Exiting"]]>
<![CDATA[
]]>
<![CDATA[      ElseIf Not IsNumeric(sParams(1)) Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Both parameters have to be numeric. Exiting"]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        m_ConfM = CInt(sParams(0))]]>
<![CDATA[
]]>
<![CDATA[        m_confC = CInt(sParams(1))]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Confidence mapping formula is MAX(10, (M/100) * (ABBYY Confidence + C))"]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Where M is " & m_ConfM]]>
<![CDATA[
]]>
<![CDATA[        Writelog "And C is " & m_ConfC]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        SetConfCalculationParamsOCR_A = TRUE]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="Recognize" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	Recognize = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType <> 2 And CurrentObj.ObjectType <> 1) Then WriteLog("Only page and document levels are supported. Exiting...") : Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[	Recognize = oABBYYRecognition.Recognize(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="RecognizePageOCR_A" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	RecognizePageOCR_A = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then WriteLog("This action must be called at the page level. Exiting...") : Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	RecognizePageOCR_A = oABBYYRecognition.RecognizePage(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If UpdateCCO Then]]>
<![CDATA[
]]>
<![CDATA[      If CurrentObj.Variable("v_ccoNormOFF") <> "1" Then]]>
<![CDATA[
]]>
<![CDATA[          NormalizeCCO false,false]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="RecognizePageFieldsOCR_A" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	RecognizePageFieldsOCR_A = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then WriteLog("This action must be called at the page level. Exiting...") : Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[	RecognizePageFieldsOCR_A =  oABBYYRecognition.RecognizePageFields(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="RecognizeFieldOCR_A" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	RecognizeFieldOCR_A = False]]>
<![CDATA[
]]>
<![CDATA[	'On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType<>3) Then WriteLog("This action must be called at the field level. Exiting...") : Exit Function	'must be a field]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	RecognizeFieldOCR_A = oABBYYRecognition.RecognizeField(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="RecognizeBarcodeOCR_A" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  'On Error Resume Next      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	RecognizeBarcodeOCR_A = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType=3) Then]]>
<![CDATA[
]]>
<![CDATA[     InitABBYY]]>
<![CDATA[
]]>
<![CDATA[     CurrentObj.Variable("y_fType") = "3" ]]>
<![CDATA[
]]>
<![CDATA[     RecognizeBarcodeOCR_A = oABBYYRecognition.RecognizeField(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[  ElseIf (CurrentObj.ObjectType=2) Then]]>
<![CDATA[
]]>
<![CDATA[     InitABBYY]]>
<![CDATA[
]]>
<![CDATA[     RecognizeBarcodeOCR_A = oABBYYRecognition.GetBarcodes(CurrentObj) ]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("This action must be called at the field or page level. Exiting...")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	RecognizeBarcodeOCR_A = True ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="RecognizeFieldVoteOCR_A" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	RecognizeFieldVoteOCR_A = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>3) Then WriteLog("This action must be called at the field level. Exiting...") : Exit Function	'must be a field]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[	RecognizeFieldVoteOCR_A = oABBYYRecognition.RecognizeFieldVote(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="RotateImageOCR_A" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  RotateImageOCR_A = True]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType<>2) Then Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Image rotation is skipped: image file does not exist.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  writelog "Rotating image " & CurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[  oABBYYRecognition.RotateImage(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="SetAutoRotationOCR_A" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	SetAutoRotationOCR_A = True]]>
<![CDATA[
]]>
<![CDATA[	StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("y_AutoRotate") = StrParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="RecognizeToPDFOCR_A" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	RecognizeToPDFOCR_A = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType <> 2 And CurrentObj.ObjectType <> 1) Then Writelog("This action must be called at the document or page level. Exiting...") : Exit Function	'must be at least a page ]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[  'Writelog "pdf recognition"]]>
<![CDATA[
]]>
<![CDATA[	RecognizeToPDFOCR_A = oABBYYRecognition.RecognizeToPDF(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="RecognizeToALTOOCR_A" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	RecognizeToAltoOCR_A = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType <> 2 And CurrentObj.ObjectType <> 1) Then Writelog("This action must be called at the document or page level. Exiting...") : Exit Function	'must be at least a page ]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[  'Writelog "RecognizeToAlto recognition"]]>
<![CDATA[
]]>
<![CDATA[	RecognizeToAltoOCR_A = oABBYYRecognition.RecognizeToAlto(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oABBYYRecognition.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="SetFastModeOCR_A" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	SetFastModeOCR_A = True]]>
<![CDATA[
]]>
<![CDATA[	StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("y_FastMode") = strParam]]>
<![CDATA[
]]>
<![CDATA[	SetFastModeOCR_A = True ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="ReleaseEngineOCR_A" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	ReleaseEngineOCR_A = True]]>
<![CDATA[
]]>
<![CDATA[  If IsAlive(oABBYYRecognition) Then Set oABBYYRecognition = Nothing]]>
<![CDATA[
]]>
<![CDATA[	ReleaseEngineOCR_A = True ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="OCRA_ConvertImage2BW" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	OCRA_ConvertImage2BW = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType <> 2 Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog "This action can only be called at the page level. Exiting."]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  InitABBYY]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sFiltered = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	sResult = ""]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For n = 1 To Len(sFiltered)]]>
<![CDATA[
]]>
<![CDATA[		char = Mid(sFiltered,n,1)]]>
<![CDATA[
]]>
<![CDATA[		If (AscW(char)>=48 And AscW(char)<=57) Or (AscW(char)>=65 And AscW(char)<=90) Or (AscW(char) = 46) Or (AscW(char)>=97 And AscW(char)<=122) Then]]>
<![CDATA[
]]>
<![CDATA[			sResult = sResult & Mid(sFiltered,n,1)]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next 'char]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'If len(sResult)<3 or len(sResult)>4 then ]]>
<![CDATA[
]]>
<![CDATA[		'writelog("Parameter must be 3 or 4 alphanumeric characters.")]]>
<![CDATA[
]]>
<![CDATA[		'Exit Function]]>
<![CDATA[
]]>
<![CDATA[	'Else]]>
<![CDATA[
]]>
<![CDATA[		writelog("Save original file with extension: '" & sResult & "' ")	]]>
<![CDATA[
]]>
<![CDATA[    OCRA_ConvertImage2BW = oABBYYRecognition.ConvertToBW( CurrentObj.ImageName, sResult)]]>
<![CDATA[
]]>
<![CDATA[	'End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'OCRA_ConvertImage2BW = True ]]>
<![CDATA[
]]>
<![CDATA[  oABBYYRecognition.CatchError("") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<help>
  <![CDATA[
'****************************************************
' ocr_a.rrx - a description of the library

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2017 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.

'****************************************************

]]>

  <ref id="EnableEngineLogsOCR_A" qi="Enables ABBYY Engine logging.">
    <ap>None.</ap>
    <h>
      This action enables OCR/A Engine logging. The log file is created in the batch folder with the name "engine.log".
      Engine logging should only be enabled when directed by support.<br/><br/>
      <e>
        <b>EnableEngineLogsOCR_A()</b><br/>
        RecognizePageOCR_A()<br/><br/>
        This sequence creates a log file in the batch folder with the name "engine.log"
      </e>
    </h>
    <lvl>Any level.</lvl>
    <ret>
      <b>True,</b> if logging is successfully enabled.  Otherwise, <b>False.</b>
    </ret> 
  </ref>

  <ref id="SetConfCalculationParamsOCR_A" qi="Specifies the values to use for ABBYY->Datacap confidence mapping.">
    <ap>
      The M and C values for the following formula <br/>
      <b>Datacap Confidence = MAX(10, (M/100) * (ABBYY Confidence + C))</b><br/>
      The default values for M is 10. The default value for C is 60.
    </ap>
    <h>
      Specifies the values to use for ABBYY->Datacap confidence mapping.
      Typically it is unnecessary to use this action when performing recognition with OCR/A 
      because the default settings are appropriate for most applications.<br/><br/>

      Note: The calculation of confidence for spaces may not be changed by these settings.<br/><br/>
      <e>
        <b>SetConfCalculationParamsOCR_A(0.1,70)</b>
        <br/>
      </e>
    </h>
    <lvl>Any level.</lvl>
    <ret>
      <b>False</b> if both parameters are not passed or are not numeric.  Otherwise, <b>True.</b>
    </ret> 
  </ref>

  <ref id="Recognize" qi="Refers to settings in the OCR/A tab of the Recognition Options Setup dialog to recognize all characters on a page, and populates the page's Fingerprint file (.cco) with the recognition results.">
    <ap>None.</ap>
    <h>
      The <b>Recognize</b> action performs document layout analysis and OCR, generating a layout XML file such as TM000001_layout.xml. <br/><br/>
      The layout file groups text into blocks as a person would looking at the document. 
      Each block may have the default type of block or a specific type such as title or table. 
      There are locate actions available in the <b>DocumentAnalytics</b> action library to navigate the 
      block structure such as <b>GoSiblingBlockNext</b>. This is in contrast to the CCO file produced by other actions 
      that groups text into lines that span the width of the page. <br/><br/>
      
      The layout XML file also retains font and color attributes, saved in CSS format, for the text 
      which is used for extracting data and reconstructing the document in a new format. <br/><br/>
      
      To use the Locate actions and perform click ‘n’ key during verification, use the action 
      <b>CreateCcoFromLayout</b> action in the <b>SharedRecognitionTools</b> action library. 
      This action will create a CCO file for the page after producing the layout XML file.<br/><br/>
      
      Following are the types of elements that may be present in the layout XML file:<br/><br/>

      <b>Block Type/XML Node</b><br/><br/>

      <i>
        Block/Block<br/>
        Header/Header<br/>
        Footer/Footer<br/>
        Title/Title<br/>
        Heading1/H1<br/>
        Heading2/H2<br/>
        Heading3/H3<br/>
        Picture/Picture<br/>
        Barcode/Barcode<br/>
        Space/S<br/>
        Tab/Tab<br/>
        Table/Table<br/>
        Row/Row<br/>
        Cell/Cell<br/>
        Paragraph/Para<br/>
        Line/L<br/>
        Sentence/Sent<br/>
        Word/W<br/>
        Character/C<br/><br/>
      </i>

      <b>Supported File Formats</b><br/><br/>

      The Recognize action can process color images and PDF files. When processing PDF documents, the action will extract embedded text within the PDF document, and perform recognition only on those areas that contain data but do not contain embedded text. This improves the processing speed and overall performance of the processing of PDF documents.<br/><br/>

      Tip: It is also possible to process Microsoft Excel, Microsoft Word, Html, Rtf, and Txt documents by first converting those documents to searchable PDFs via the Convert library. For example, a Microsoft Excel document can be converted to PDF by calling the action ExcelWorkbookToPdf. Once the PDF document is created, then it can be processed through the Recognize action.<br/><br/>

      <b>Language Detection</b><br/><br/>

      Language detection helps improve recognition results. Instead of using the default English setting, it detects the language and results in more accurate OCR results. When the OCR process is complete, a report on the number of languages detected (and total number of words detected for each language) is generated. This report is stored in the runtime DCO as variables, and can also be found in the layout XML file. <br/><br/>

      To enable automatic language detection:<br/><br/>

      - Use <b>rrSet</b> or similar action to set the variable <b>"y_lg"</b> to a list of comma separated of <b>at least </b>three languages from the "Supported Languages by Auto Detection" section below.<br/>
      - After specifying the list of languages, call the Recognize action.<br/><br/>

      Note: It is recommended that the list of languages be minimized to the languages expected to be processed by the application. This is because the more languages are specified, the slower the processing. 
      However, if an application will only be processing two languages, the application developer is still required to provide at least three languages to enable automatic language detection.
      <br/><br/>

      <b>Languages Supported by Auto Detection</b><br/><br/>
      <i>
        <b>Important!</b> When setting the comma separated list of languages, 
        make sure that the language are spelled as written below and without spaces. An invalid language name will cause the action to abort. 
        The information following the colon : is informational and should not be included.<br/><br/>

        Arabic : Arabic (Saudi Arabia)<br/>
        ArmenianWestern : Armenian (Western)<br/>
        AzeriLatin : Azerbaijani (Latin)<br/>
        Bashkir<br/>
        Bulgarian<br/>
        Catalan<br/>
        ChinesePRC : Chinese Simplified<br/>
        ChinesePRC+English : Chinese Simplified and English<br/>
        ChineseTaiwan : Chinese Traditional<br/>
        ChineseTaiwan+English : Chinese Traditional and English<br/>
        Croatian<br/>
        Czech<br/>
        Danish<br/>
        Dutch<br/>
        English<br/>
        Estonian<br/>
        Finnish<br/>
        French<br/>
        German<br/>
        GermanNewSpelling : German (new spelling)<br/>
        GermanLuxembourg : German (Luxembourg)<br/>
        Greek<br/>
        Hebrew<br/>
        Hungarian<br/>
        Hungarian<br/>
        Indonesian<br/>
        Italian<br/>
        Japanese<br/>
        Korean<br/>
        Korean+English : Korean and English<br/>
        KoreanHangul : Korean (Hangul)<br/>
        Latin<br/>
        Latvian<br/>
        Lithuanian<br/>
        Mixed : Russian and English<br/>
        Norwegian : NorwegianNynorsk and NorwegianBokmal<br/>
        NorwegianBokmal : Norwegian (Bokmal)<br/>
        NorwegianNynorsk : Norwegian (Nynorsk)<br/>
        OldEnglish<br/>
        OldFrench<br/>
        OldGerman<br/>
        OldItalian<br/>
        OldSpanish<br/>
        Polish<br/>
        PortugueseBrazilian<br/>
        PortugueseStandard<br/>
        Romanian<br/>
        RussianOldSpelling<br/>
        Russian<br/>
        RussianWithAccent<br/>
        Slovak<br/>
        Slovenian<br/>
        Spanish<br/>
        Swedish<br/>
        Tatar<br/>
        Thai<br/>
        Turkish<br/>
        Ukrainian<br/>
        Vietnamese<br/>
        <br/>
      </i><br/>

      The language can be bound to the DCO object by selecting it in the OCR_A tab in the zones tab of Datacap Studio.
      When selected in the OCR_A tab the variable <b>y_lg</b> is set to the language.
      The language also can be set within rules using the <b>rrSet</b> action to set
      the <b>y_lg</b> variable to the desired language.<br/><br/>

      For example: <b>rrSet("Italian", "@X.y_lg")</b> will set the language to Italian.<br/><br/>

      If the <b>s_lg</b> variable is not set for the current DCO object, the recognized
      language is determined by the current locale set with the <b>hr_locale</b> variable.
      For example, if the locale is set for Germany, <b>rrSet("de-DE", "@X.hr_locale")</b>, then the text will be recognized as German.<br/><br/>

      If both the hr_locale and y_lg variables are set, the value in <b>y_lg</b> takes precedence over the locale setting.
      If <b>y_lg</b> is set but the engine should use the value set for <b>hr_locale</b> instead,
      setting the variable <b>dco_uselocale</b> to "1" will give precedence to <b>hr_locale.</b><br/><br/>
      
      If the page you are recognizing is formatted for right-to-left text, such as Arabic or Hebrew,
      then the variable "hr_bidi" should be set to "rtl" to indicate the page is right to left.<br/><br/>

      <b>Examples of Use:</b><br/>
      rrSet("English,French,German", @P.y_lg") - Auto detection of English, French or German<br/>
      rrSet("English,German,GermanNewSpelling,Norwegian", @P.y_lg") - Auto detection of English, French, German or Norwegian<br/>      
      rrSet("ChinesePRC+@CHR(43)+English", "@P.y_lg") - An exception for specification of Simplified Chinese and English.<br/>
      <br/><br/>           
      
      <b>Custom Parameters</b><br><br/>      
      The following variables can be used to set custom parameters for recognition:
      </br>
      <br/><br/>
      <b>y_DetectFontFormatting</b><br/>
      y_DetectFontFormatting specifies whether font formatting detection should be performed
      by the recognition engine at the document level.
      This can have an effect on the styles listed in the
      layout XML for the recognized page.  In some cases, font sizes may be recognized more
      accurately if this setting is disabled by setting the value to "0" in the
      DCO and the setting y_DetectFontFormattingAtPageLevel is enabled.
      If not defined, this setting is enabled by default.<br/><br/>


      <b>y_DetectFontFormattingAtPageLevel</b><br/>
      If y_DetectFontFormattingAtPageLevel is enabled by setting the value to "1" in the DCO,
      the engine attempts to detect font parameters,
      enabling detailed processing of subscripts, superscripts, italic-face type,
      small capital letters for the page.  In some cases, enabling this this setting and disabling
      the y_DetectFontFormatting setting can improve
      detection of font sizes as specified in the layout XML.
      If not defined, this setting is disabled by default.<br/><br/>

      <b>Aggressive Text Recognition</b><br/>
      An optional setting instructs the engine to perform aggressive text recognition.
      Setting the variable y_EnableAggressiveTextExtraction to "1" will enable the aggressive mode.
      It is recommended that you test with this setting on and off to see which mode works better for your documents.<br/><br/>

      <b>y_userProfile</b>: Reserved for Internal use only.<br/>
      <br/>
      <b>y_predefinedProfile</b>: Set this variable to the name of a predefined to use during recognition. Valid values are:
      <br/>
      <br/><i>
        DocumentConversion_Accuracy<br/>
        DocumentConversion_Speed<br/>
        DocumentArchiving_Accuracy<br/>
        DocumentArchiving_Speed<br/>
        BookArchiving_Accuracy<br/>
        BookArchiving_Speed<br/>
        TextExtraction_Accuracy<br/>
        TextExtraction_Speed<br/>
        EngineeringDrawingsProcessing<br/>
        BusinessCardsProcessing<br/>
      </i>
      <br/><br/>

      <b>Text Extraction versus Text Recognition</b><br/>      
      When a PDF is recognized, by default, the text included in the recognition results is obtained from a combination of automatic recognition 
      that is run on the PDF and from searchable text that is embedded within the PDF.<br/><br/>
      
      Any images that are embedded on the page have the text recognized by the engine.
      If areas of the page contain both an image and searchable text associated with the image, 
      the engine decides whether the engine must use the searchable text or recognize the text from the matching image.<br/><br/>

      Because the engine performs recognition, the confidence of the text might vary even if the same searchable text is embedded in the PDF.<br/><br/>

      The variable y_contentReuseMode can be used to force the engine only to use the recognized 
      text on the page or only to use the embedded text on the page. One reason why you might decide 
      only to use the embedded text is to prevent recognition and produce high confidence results.<br/><br/>

      A drawback of only to using the embedded text is that if the embedded text is wrong or incomplete, 
      recognition is not performed to capture that missing data that results in a layout XML that is incomplete 
      compared to what the user sees when the user views the PDF.  Do not use this setting if the source PDF 
      file is of the image-on-text type, because in this case, the text layer is not extracted.<br/><br/>

      If a text line contains characters that are not included in the alphabet of the selected recognition languages,
      this text is not written to the result and mode 0 or 1 must be used.<br/><br/>

      These settings of y_contentReuseMode can be set on the DCO node that is being converted:<br/>
      rrSet("0", "@X.y_contentReuseMode") - The default auto mode that uses a combination of recognition and embedded text.<br/>
      rrSet("1", "@X.y_contentReuseMode") - Only recognition is used to create the layout XML.<br/>
      rrSet("2", "@X.y_contentReuseMode") - Only embedded text is used to create the layout XML.<br/><br/>

      <br/>
      <b>Table Identification</b><br/>
      Some recognition engines can identify a table on a document when performing full page recognition when using layout files
      produced by the Recognize action. 
      When text is recognized as a table, it means that additional metadata is internally stored about the words that have been recognized.  
      This extra metadata stores the cell information, row and column position, for the text. 
      This table metadata can be used by subsequent actions that support table functionality. This is an alternative approach to using
      the "line items" feature that processes recognized data as tables without a table being identified by the recognition engine.<br/><br/>
      
      The recognize action attempts to detect tables on a page, identifying the rows and columns. If a table is detected, then the table structure can be
      used by subsequent actions that manipulate recognized tables. As with character recognition, 100% accuracy of a table's
      rows and columns is not guaranteed. If this feature is needed, it is best to test on a variety of tables
      that you expect to be processing in your application and determine if the accuracy is good enough to
      provide the functionality that you need. If table recognition accuracy is not good enough for your desired approach,
      it is recommended that you change your approach.<br/><br/>

      It is possible that parts of a table may not be recognized as expected even if they visually look good
      to the human eye. For example parts of your table may be left outside of the table structure or
      rows and columns may be combined in ways that may not be expected from visually looking at the table.
      If the tables in your documents are not being identified well by the engine, 
      then you should consider a different approach, such as using line items, to process tabular data within your documents.<br/><br/>

      The following tips can help improve the recognition of your table:<br/><br/>

      * Tables should be well defined with grid lines that identify the rows and columns of the table.<br/>
      * Do not perform line removal if you are attempting to detect table structures.<br/>
      * Cells cannot intersect each other.<br/>
      * All cells must have a rectangular shape.<br/><br/>

      <b>Forcing Single Lines Per Table Cell</b><br/>
      If your table contains only a single rows but the engine is recognizing multiple rows per table cell,
      the engine can be instructed to recognize rows as a single row by setting the DCO variable
      y_SingleLinePerCell to "1".  For example: rrSet("1","@X.y_SingleLinePerCell").<br/><br/>

      <b>Split Table By Separators</b><br/>
      When identifying a table layout, the engine will use grid lines and its own heuristics to
      determine the rows and columns for the table.  Sometimes this can cause the cells created by the engine
      to be different from what is defined by grid lines on the page.  For example, your table may have grid lines
      that show multiple lines in a cell but instead those lines are interpreted as single line cells.
      The DCO variable y_SplitOnlyBySeparators can be set to "1" which will tell the engine to only use grid lines
      when identifying the layout of a table.  For example: rrSet("1","@X.y_SplitOnlyBySeparators").
      When enabled, the setting will tell the engine to use the grid lines to guide
      the identification, providing a table layout that should more closely match the visible grid lines.
      This setting is off by default.<br/><br/>

      If y_SplitOnlyBySeparators is enabled, the engine will not attempt to recognize a table without grid lines.<br/><br/>      

      <b>Disable Table Detection</b><br/>
      Table detection is enabled by default and can be disabled by setting the page level
      variable y_DetectTables to "0". For example: rrSet("0","@X.y_DetectTables").
      Typically, it is not necessary to disable table detection, but the setting
      is provided in cause you find it gives better results for your document types.<br/><br/>

      <b>Zoning The Table Location</b><br/>
      In some cases table identification can be improved by identifying the table location / zone.
      This can improve table identification when the engine is not detecting the table boundaries
      well or when the table does not have gridlines to identify the table boundaries.
      <br/><br/>
      
      If the page can be fingerprinted so
      the location of the table is always known, then the table area can be zoned to identify the table
      boundaries. To identify the table zone to the recognition engine, specify the name of the field
      that contains the table zone using the variable y_TableZone.  For example, if the current
      page has a field called "MyTable"and the zone for that field identifies the table location on the page
      then the action rrSet("MyTable", "@X.y_TableZone") will allow the engine to use
      the zone to identify the table.<br/><br/>      

      If a table is recognized using the user provided zone,
      sub-fields will be created off of the y_TableZone specified field with the table contents.
      If there are multiple tables on the page,
      only one table can be identified using this method.<br/><br/>

      If you need to identify multiple tables on a page, then
      you must use auto detection, process the page multiple times with different zones for each table
      or take a different approach.  If the location of the table cannot be predicted or identified prior to
      recognition, then you would need to use auto detection or take a different approach.<br/><br/>

      Telling the engine the table zone can provide better results in situations where
      table auto detect is making mistakes, as in the case when there are no gridlines.
      Be aware that this technique still cannot guarantee 100% accuracy and you may need to
      take additional custom steps to massage the recognized data for your needs. It is a similar situation
      as to the need to correct standard character recognition.<br/><br/>

      <e>
        rrSet("English,French,Japanese", "@P.y_lg")<br/>
        <b>Recognize()</b><br/>
        CreateCcoFromLayout()<br/>
        <br/>
        This sequence creates layout xml file and subsequently a CCO file for the current page. Auto detection is enabled for English, French, and Japanese documents. The CCO file produced is ready for use by navigation and pattern match actions.
      </e>
    </h>
    <lvl>Page only.</lvl>
    <ret>
      <b>False</b> if the ruleset with this action is not bound to a <b>Page</b>object of the Document Hierarchy.
      Otherwise, <b>True.</b>
    </ret> 
  </ref>

  <ref id="RecognizePageOCR_A" qi="Refers to settings in the OCR/A tab of the Recognition Options Setup dialog to recognize all characters on a page, and populates the page's Fingerprint file (.cco) with the recognition results.">
    <ap>None.</ap>
    <h>
      This action responds to settings in the OCR/A tab of the Recognition Options Setup dialog to recognize
      all characters on a page, and populates the page's CCO file with the recognition results.
      If a CCO file does not exist at the time this action is called, the action will create one.<br/><br/>

      Information regarding the supported languages and how to configure them is provided in the help for the OCR/A <b>Recognize</b> action.<br/><br/>

      <e>
        AnalyzeImage()<br/>
        RotateImage()<br/>
        <b>RecognizePageOCR_A()</b><br/><br/>
        This sequence creates a CCO file for the current page, and checks to see if rotation of
        the image is needed.  Full-page recognition then takes place in response to settings in
        the OCR/A tab of the Recognition Options Setup dialog.
        The recognition results are stored in the CCO file.
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>False</b> if the ruleset with this action is not bound to a
      <b>Page</b>object of the Document Hierarchy. Otherwise, <b>True.</b>
    </ret> 
  </ref>

  <ref id="RecognizePageFieldsOCR_A" qi="A page-level action that recognizes all fields on the page that have been configured for OCR/A recognition (see the OCR/A tab of the Recognition Options Setup dialog.) ">
    <ap>None.</ap>
    <h>
      This page-level action recognizes all fields on the page that have been configured for OCR/A
      recognition (see the OCR/A tab of the Recognition Options Setup dialog.) <br/>
      <b>Note:</b>Individual field-level recognition actions will overwrite the results from this
      page-level action.<br/><br/>
      The action will not recognize a zoned field if the Skip Recognition checkbox in the OCR/A
      tab of the Recognition Options Setup dialog has been selected.<br/><br/>

      Information regarding the supported languages and how to configure them is provided in the help for the OCR/A <b>Recognize</b> action.<br/><br/>
      <e>
        ReadZones()<br/>
        <b>RecognizePageFieldsOCR_A()</b>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>False</b> if the ruleset with this action is not bound to a <b>Page</b>object of the Document Hierarchy.
      Otherwise, <b>True.</b>
    </ret> 
  </ref>

  <ref id="RecognizeFieldOCR_A" qi="A field-level action that retrieves a zoned field's settings from the OCR/A tab of the Recognition Options Setup dialog, and uses these settings to recognize the field's value.">
    <ap>None.</ap>
    <h>
      This field-level action retrieves a zoned field's settings from the OCR/A tab of the
      Recognition Options Setup dialog, and uses these settings to recognize the field's value.<br/><br/>

      Information regarding the supported languages and how to configure them is provided in the help for the OCR/A <b>Recognize</b> action.<br/><br/>
      <e>
        <b>RecognizeFieldOCR_A()</b><br/><br/>

        In the example, the rule uses
        the action to retrieve and apply settings in the OCR/A tab of the Recognition Options
        Setup dialog, settings that have been previously assigned to a Document Hierarchy's zoned field.
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the ruleset with this action is not bound to a <b>Field</b>object of the Document Hierarchy.
      Otherwise, <b>True.</b>
    </ret> 
  </ref>

  <ref id="RecognizeBarcodeOCR_A" qi="A field/page level action that retrieves barcodes.">
    <ap>None.</ap>
    <h>
      This action uses the OCR/A engine to recognize a barcode on the page or in a field.<br/><br/>
      <e>
        <b>RecognizeBarcodeOCR_A</b><br/><br/>
      </e>
    </h>
    <lvl>Field and Page levels.</lvl>
    <ret>
      <b>False</b> if the ruleset with this action is not bound to a <b>Field</b>object or <b>Page</b> object of the Document Hierarchy.
      Otherwise, <b>True.</b>
    </ret> 
  </ref>


  <ref id="RecognizeFieldVoteOCR_A" qi="A field-level action that initiates a voting procedure that first uses specifications in the OCR/A tab of the Recognition Options Setup dialog to recognize the field's characters.">
    <ap>None.</ap>
    <h>
      This field-level action initiates a voting procedure that first uses specifications in the OCR/A tab
      of the Recognition Options Setup dialog to recognize the field's characters. <br/><br/>
      When this action stores the results of recognition, it first determines if the corresponding
      Field object of the Document Hierarchy contains a value. If a value is present, the action
      compares the field's existing value with the recognition results - character by character.<br/><br/>
      If a particular character's values match, the Confidence Rating for the character is raised to the maximum
      level.  If the values do not match, the Confidence Rating for the character is lowered to the minimum.<br/><br/>
      Note that when using this voting procedure, the second Recognition engine is secondary and
      its results are never assigned.  Instead, the action changes the Confidence Ratings on the basis of
      results provided by the first Recognition engine. If there are no recognition results previous to
      this action, it will act just like the <b>RecognizeFieldOCR_A</b> action.<br/><br/>
      <e>
        RecognizeFieldICR_C()<br/>
        <b>RecognizeFieldVoteOCR_A()</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the ruleset with this action is not bound to a <b>Field</b>object of the Document Hierarchy.
      Otherwise, <b>True.</b>
    </ret> 
  </ref>


  <ref id="RotateImageOCR_A" qi="">
    <ap>None.</ap>
    <h>
      For best recognition results, the text in the image should be in a 0 rotation, meaning it is readable and not upside down or rotated sideways.
      This action checks if the scanned Image file needs to be rotated by 90, 180, or 270 degrees to be in the upright position.
      If rotation is necessary, the action saves the Image file in the new, correct position.
      If ingested images might be rotated incorrectly, use this action prior to calling the recognition action.
      This action will rotate the image immediately and can be more efficient than using auto rotation in the recognition action.<br/><br/>

      This action useful to separate the rotation step from the recognition step.  For example, if you are performing fingerprinting,
      calling this action prior to AnalyzeImage will ensure the image is properly rotated,
      allowing for proper fingerprinting and the image will already be properly rotated once the image reaches the recognition step.<br/><br/>
      
      When using automatic rotation, the language should be set for the page to help insure the rotation is performed
      correctly.  Refer to the Recognize action for information regarding the recognition language.<br/><br/>

      If automatic rotation is performed, the action saves the image file
      in the new, correct position, and the variable "AutoRotationAngle" is populated with applied rotation angle.
      It is possible to force the action to rotate an image by either 90, 180, or 270 by setting the 
      variable "ManualRotationAngle" in the DCO object prior to calling this action.<br/><br/>

      If you are using this action, or if your documents are guaranteed to be in the correct orientation,
      it is recommended to also call the action SetAutoRotationOCR_A(False)
      to prevent the recognition action from reanalyzing the image to see if rotation is necessary.<br/><br/>
      <e>
        <b>RotateImageOCR_A()</b><br/>
        AnalyzeImage()<br/><br/>

      </e>
    </h>
    <lvl>Page only.</lvl>
    <ret>
      <b>False</b> if the ruleset with this action is not bound to a <b>Page</b> object of the
      Document Hierarchy, or if the action cannot locate the Image file representing the current page.
      Otherwise, <b>True.</b>
    </ret>
    <see>Recognize</see>
  </ref>
 
 
  <ref id="SetAutoRotationOCR_A" qi="This action set to False turns off automatic image orientation detection and rotation.">
    <ap>
      <b>True:</b> Forces image orientation detection and rotation during recognition.  This is the default value.<br/>
      <b>False:</b> Image orientation and rotation will not be performed.
    </ap>
    <h>      
      When this action is called with the parameter True, it forces image orientation detection and rotation in all of the OCR/A recognition actions. 
      If this action is not called, the value will default to True so rotation will be automatically performed.<br/><br/>

      If used, this action must be called prior to recognition and both actions must be called at the same level.
      If RotateImageOCR_A has already been used on an image or if your documents are guaranteed to be in the correct orientation, it is recommended to call
      SetAutoRotationOCR_A(False) prior to recognition so recognition will not reanalyze the image to see if it needs rotation."<br/><br/>
      <e>
        <b>SetAutoRotationOCR_A("True")</b><br/>
        RecognizePageOCR_A
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      Always <b>True.</b>
    </ret> 
  </ref>

  <ref id="RecognizeToPDFOCR_A" qi="Converts a scanned Images (.tif) to an Adobe Portable Document Format (PDF) file.">
    <ap>
      None.
    </ap>
    <h>
      Converts one or more scanned Images (.tif) to an Adobe Portable Document Format (PDF) file.  The PDF is searchable as it also
      includes the text as read directly by the recognition engine.<br/><br/>

      When placed at page level, the action recognizes and converts the current tif page to a pdf file.<br/><br/>

      When placed at document level, the action recognizes and converts all tif pages in the existing doc into one
      pdf file.  If the pages are PDF files, this will build a new PDF that combines the page level PDFs
      into to a single PDF.<br/><br/>

      <b>Document Format</b> <br/><br/>

      To create PDF/A1A documents, set the y_pdfA variable to "1" prior to calling RecognizeToPDFOCR_A.<br/><br/>
      To create PDF/A1B documents, set the y_pdfA variable to "1" AND y_pdfA1B variable to "1" prior to calling RecognizeToPDFOCR_A.<br/><br/>
      To set the MRC (mixed Raster Content) Mode for conversion to PDF/A, set the y_pdfMRCMode to one of the following values: <br/><br/>
      0 - Engine decides if MRC is to be used. Default.<br/>
      1 - MRC is always used.<br/>
      2 - MRC is never used. MRC technology uses a lossy compression algorithm. This means that some unimportant information from the source image (background texture, garbage, etc.) can be lost. Disable MRC if even insignificant information from the source image cannot be lost.<br/>
      Using parameter of 2 can help with issues where the text in the PDF document is too dark. <br/>
      <br/>

      <b>Document Contents</b><br/><br/>

      To exclude specific page types, set the variable "typesToExclude" to a comma delimited list of page types to exclude from the pdf. <br/><br/>
      To include specific page types, set the variable "typesToInclude" to a comma delimited list of page types to include from the pdf. <br/><br/>
      To exclude specific page status, set the variable "statusToExclude" to a comma delimited list of page status to exclude from the pdf. <br/><br/>
      When more than one filter is specified, the following order of precedence takes place: <br/>
      - "statusToExclude" overrides "typesToInclude" <br/>
      - "typesToInclude" overrides "typesToExclude" <br/><br/>

      If calling the action at the document level, the types and status filters apply to both the documents and child pages. <br/>
      If calling the action at the page level, the types and status filters apply to the page only. <br/><br/>

      By default, recognition is performed on images creating searchable text in the PDF. 
      To prevent recognition, creating an image only PDF, set the variable y_PDFImageOnly to 1 in the current DCO object.<br/><br/>

      If creating a searchable PDF, 
      information regarding the supported languages and how to configure them is provided in the help for the OCR/A <b>Recognize</b> action.<br/><br/>
      
      <b>Document Attributes</b><br/><br/>

      The following variables can be used to set the correspoding pdf document attributes: <br/><br/>

      y_PDFKeys<br/>
      y_PDFAuthor<br/>
      y_PDFTitle<br/>
      y_PDFSubject<br/>
      y_PDFProducer<br/>
      y_pdfCreator<br/>
      y_PDFQuality<br/>
      y_pdfDelTmp<br/><br/>

      <b>Memory or Disk Processing</b><br/><br/>
      
      By default the conversion is performed in memory.  If you are creating PDF with many pages, 
      it is possible for the conversion to run out of memory.  The disk can be used for 
      processing by setting the DCO variable y_maxPagesForInMemoryProcessing to the maximum number of pages
      for in-memory processing.  If the document contains more pages than this value, the disk will be
      used instead of memory.<br/><br/>

      The variables in the above sections must be set before calling the action "RecognizeToPDFOCR_A"
      <br/><br/>
      
      <b>Including PDF Annotations</b><br/>
      By default, when converting PDF to PDF, annotations in the source PDF file will not be included in the output PDF.
      "Free Text" annotations in source PDF can be included in the output PDF by setting the page DCO variable y_IncludeAnnotation to "1".      
      Other types of PDF annotations are not supported, such as popup and ink annotations.
      This feature will not cause the text of a "Sticky note" to be displayed on the image and a
      sticky note icon may display on the final image regardless of this setting.<br/><br/>
      <br/><br/>

      <b>PDF Export Optimization</b>
      The variable y_pdfExportScenario can be used to set the scenario of export to PDF (PDF/A) format, which optimizes export for some parameters.
      This will impact the size and quality of the output PDF.<br/><br/>
      
      It takes following values:<br/>
      
      0 - Optimize the PDF (PDF/A) export in order to receive the best quality of the resulting file.(This is default)<br/>
      1 - The PDF (PDF/A) export will be balanced between the quality of the resulting file, its size and the time of processing.<br/>
      2 - Optimize the PDF (PDF/A) export in order to receive the minimum size of the resulting file.<br/>
      3 - Optimize the PDF (PDF/A) export in order to receive the highest speed of processing.<br/>
      
      <br/><br/>
      <e>
        rrSet("IBM", "@D.y_PDFProducer")<br/>
        rrSet("75","@D.statusToExclude) <br/>
        rrSet("Blank","@D.typesToExclude) <br/>
        <b>RecognizeToPDFOCR_A()</b><br/><br/>

        The above example creates a PDF document with all pages contained in the dco document object , except those with type "Blank" and status of "75". <br/>
      </e>
    </h>
    <lvl>Document or Page Level.</lvl>
    <ret>
      <b>False,</b> if called at an invalid level.  Otherwise, <b>True.</b>
    </ret> 
  </ref>

  <ref id="RecognizeToALTOOCR_A" qi="Converts a scanned Images (.tif) to an ALTO electronic Document Format (XML) file.">
    <ap>
      None.
    </ap>
    <h>
      Converts a scanned Images (.tif) to an ALTO Document Format (XML) file.  <br/><br/>

      When placed at page level, the action recognizes and converts the current tif page to an ALTO file.<br/><br/>

      When placed at document level, the action recognizes and converts all tif pages in the existing doc into one
      ALTO file.<br/><br/>

      <b>Document Format</b> <br/><br/>

      The following variables can be used to set the properties of the ALTO xml file: <br/><br/>

      <b></b>


      <b>y_AltoFontFormattingMode</b><br/><br/>

      Specifies which character attributes are saved to the ALTO xml file. Valid values are:<br/><br/>

      <b>0</b> - The only saved attribute is whether characters are subscript or superscript. <b>This is the default.</b><br/>
      <b>1</b> - The following attributes are saved: whether characters are subscript, superscript, bold, italic, underlined, strikeout. Font size and font name are not saved.<br/>
      <b>2</b> - All font attributes are saved.<br/><br/>

      <b>y_AltoWriteNondeskewedCoordinates</b><br/>

      <p>
        Specifies whether character, word, block coordinates written into files in ALTO format should be defined on an original image or on an image used for recognition (to which different modifications, e.g. deskewing, were applied).
        <b>This property is TRUE by default, which means that the coordinates are defined on an original image.</b>
      </p>

      <p>
        Notes:<br/><br/>

        If you set this property to FALSE, export to ALTO format is performed faster. This is due to the fact that in this case there is no need in conversion of coordinates between modified and original image, which takes quite a long time.
        If this property is set to default TRUE value, the base line position is not written during export. If it is FALSE, the base line position is written into the result XML file.
        This is because ALTO format requires the base line position to be described by only one number. In the original coordinates the base line may not be strictly horizontal/vertical, in which case it is impossible to define its position by a single number.
      </p>

      <b>Document Contents</b><br/><br/>

      To exclude specific page types, set the variable "typesToExclude" to a comma delimited list of page types to exclude from the ALTO xml file. <br/><br/>
      To include specific page types, set the variable "typesToInclude" to a comma delimited list of page types to include from the ALTO xml file. <br/><br/>
      To exclude specific page status, set the variable "statusToExclude" to a comma delimited list of page status to exclude from the ALTO xml file. <br/><br/>
      When more than one filter is specified, the following order of precedence takes place: <br/>
      - "statusToExclude" overrides "typesToInclude" <br/>
      - "typesToInclude" overrides "typesToExclude" <br/><br/>

      If calling the action at the document level, the types and status filters apply to both the documents and child pages. <br/>
      If calling the action at the page level, the types and status filters apply to the page only. <br/><br/>

      Information regarding the supported languages and how to configure them is provided in the help for the OCR/A <b>Recognize</b> action.<br/><br/>

      The variables in the above sections must be set before calling the action "RecognizeToALTOOCR_A"
      <br/><br/>
      <e>
        rrSet("TRUE", "@P.y_AltoWriteNondeskewedCoordinates")<br/>
        rrSet("0","@P.y_AltoFontFormattingMode) <br/>
        <b>RecognizeToALTOOCR_A()</b><br/><br/>

        The above example creates a PDF document with all pages contained in the dco document object , except those with type "Blank" and status of "75". <br/>
      </e>
    </h>
    <lvl>Document or Page Level.</lvl>
    <ret>
      <b>False,</b> if called at an invalid level.  Otherwise, <b>True.</b>
    </ret> 
  </ref>
 

  <ref id="SetFastModeOCR_A" qi="This action set to TRUE provides 2-2.5 times faster recognition speed at the cost of a moderately increased error rate (1.5-2 times more errors).">
    <ap>
      <b>True:</b> Enables "Fast Mode" which sacrifices recognition quality over speed.<br/>
      <b>False:</b> Disables "Fast Mode" causing the recognition to run slower, but provides more accurate results.<br/><br/>
      If no parameter is specified, the value defaults to False.
    </ap>
    <h>
      This action set to TRUE provides 2-2.5 times faster recognition speed at the cost of a moderately
      increased error rate (1.5-2 times more errors).<br/><br/>
      It is recommended to disable fast mode if you are performing field level recognition because
      you will sacrifice quality yet see negligible speed increase at the field level.<br/><br/>
      If you use this action, it must be called prior to recognition.<br/><br/>
      <e>
        <b>SetFastModeOCR_A("True")</b><br/>
        RecognizePageOCR_A<br/>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      Always <b>True.</b>
    </ret> 
  </ref>

  <ref id="ReleaseEngineOCR_A" qi="This action releases the ABBYY engine.">

    <h>
      This action releases the OCR/A engine.
      It is an optional cleanup step when you have used the OCR/A engine for recognition.
      Typically this action would be placed in a ruleset attached to a close event,
      such as a batch level close event in the recognition ruleset, to be run once after all recognition is completed in the ruleset.
      If large documents are being created, such as creating large multi-page PDF files, then release can be called immediately after
      RecognizeToPDFOCR_A to release memory sooner instead of waiting for the batch close event.
      It is suggested to place it where it works best for your specific needs.<br/><br/>
      <e>
        <b>ReleaseEngineOCR_A()</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      Always <b>True.</b>
    </ret> 
  </ref>

  <ref id="OCRA_ConvertImage2BW"  qi="This action converts a Color or Grayscale image to Black and White.">
    <ap>
      The file extension that the action is to assign to the backup of the original Image file.
      For example: tio<br/><br/>
      The extension should be 3 or 4 alphanumeric characters.
    </ap>
    <h>
      This action converts a Color or Grayscale image to black and white. The resolution of the resulting black and white image will be determined automatically by the engine. <br/><br/>
      To turn off automatic resolution overwride, and keep the original resolution, set the page variable "AutoOverwriteResolution" to "0". <br/><br/>
      To manually overwrite the original resolution set the following variables at the page level (both are required): <br/><br/>

      <b>XResolutionToOverwrite</b><br/>
      <b>XResolutionToOverwrite</b><br/><br/>

      <b>Note</b>: All variables must be set before calling the action OCRA_ConvertImage2BW <br/><Br/>

      <e>
        rrSet("300", "@P.XResolutionToOverwrite") <br/>
        rrSet("300", "@P.YResolutionToOverwrite") <br/>
        <b>OCRA_ConvertImage2BW()</b>

        <br/>
        <br/>
        This example converts the source image to black and white, setting the horizontal and vertical resolution of the black and white image to 300 DPI.
      </e>
      <br/>
    </h>
    <lvl>Page.</lvl>
    <ret>
      <b>False </b> if called at a level other than the Page.
      <b>False</b> if the parameter is not 3 or 4 alphanumeric characters.  Otherwise, <b>True.</b>
    </ret> 
  </ref>
   
</help>

</rrx>
<rrx namespace="PatternMatch" src="c:\datacap\RRS\PatternMatch.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<af name="MatchPattern" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim l_HBitMap	]]>
<![CDATA[
]]>
<![CDATA[	Dim nL, nT, nR, nB]]>
<![CDATA[
]]>
<![CDATA[	Dim mL, mT, mR, mB]]>
<![CDATA[
]]>
<![CDATA[	Dim nX, nY, nC]]>
<![CDATA[
]]>
<![CDATA[	Dim vAnchor, nBH, nSub ]]>
<![CDATA[
]]>
<![CDATA[	Dim aAnchor, aMetric	]]>
<![CDATA[
]]>
<![CDATA[	Dim nTID]]>
<![CDATA[
]]>
<![CDATA[	Dim sTIDFileName]]>
<![CDATA[
]]>
<![CDATA[	Dim aResult]]>
<![CDATA[
]]>
<![CDATA[	Dim nWidth, nHeight, nResolution, nResult]]>
<![CDATA[
]]>
<![CDATA[	Dim nConf]]>
<![CDATA[
]]>
<![CDATA[	Dim oSA]]>
<![CDATA[
]]>
<![CDATA[	Dim g_oPM]]>
<![CDATA[
]]>
<![CDATA[	Dim oCurPage		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	MatchPattern = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType<>3 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action must be called from a DCO field.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCurPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	While oCurPage.ObjectType<>2 AND oCurPage.ObjectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oCurPage = oCurPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nTID = oCurPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'vANCHOR is the Position of the AREA on the Permanent Fingerprint to Match to.]]>
<![CDATA[
]]>
<![CDATA[	'vMETRIC is the area to search beyond the center of the source area: vANCHOR. Pattern is (Horizonal,Vertical) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(CurrentObj.Variable("ANCHOR"))>0 then]]>
<![CDATA[
]]>
<![CDATA[		vANCHOR = CurrentObj.Variable("ANCHOR")]]>
<![CDATA[
]]>
<![CDATA[		Writelog("'ANCHOR' variable found. ANCHOR ZONE='" & vANCHOR & "' ")]]>
<![CDATA[
]]>
<![CDATA[	Elseif len(CurrentObj.Variable("Pos" & nTID))>0 then]]>
<![CDATA[
]]>
<![CDATA[		vANCHOR = CurrentObj.Variable("Pos" & nTID) ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("'Pos" & nTID & "' variable found. ANCHOR ZONE='" & vANCHOR & "' ")]]>
<![CDATA[
]]>
<![CDATA[	Else ]]>
<![CDATA[
]]>
<![CDATA[		vANCHOR = CurrentObj.Variable("Position")	]]>
<![CDATA[
]]>
<![CDATA[		Writelog("'Position' variable found. ANCHOR ZONE='" & vANCHOR & "' ")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  vMETRIC=""]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.FindVariable("METRIC")>0 then]]>
<![CDATA[
]]>
<![CDATA[  	vMETRIC = CurrentObj.Variable("METRIC")]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Run Time METRIC variable found. METRIC='" & vMETRIC & "'")]]>
<![CDATA[
]]>
<![CDATA[  Elseif CurrentObj.Variable("METRIC")<>"" then]]>
<![CDATA[
]]>
<![CDATA[    vMETRIC = CurrentObj.Variable("METRIC")]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Setup XML METRIC variable found. METRIC='" & vMETRIC & "'")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		vMETRIC = "500,500"]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Default Metric used. METRIC='" & vMETRIC & "'")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aAnchor=Split(vAnchor, ",")]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To UBound(aAnchor)]]>
<![CDATA[
]]>
<![CDATA[		If IsNumeric(aAnchor(i)) then ]]>
<![CDATA[
]]>
<![CDATA[			aAnchor(i)=CLng(aAnchor(i))]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			writelog("Invalid Anchor Position info. A non-numeric value was found.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Set PATTERN AREA]]>
<![CDATA[
]]>
<![CDATA[	nL = aAnchor(0)]]>
<![CDATA[
]]>
<![CDATA[	nT = aAnchor(1)]]>
<![CDATA[
]]>
<![CDATA[	nR = aAnchor(2)]]>
<![CDATA[
]]>
<![CDATA[	nB = aAnchor(3)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aMetric = Split(vMetric, ",")]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To UBound(aMetric )]]>
<![CDATA[
]]>
<![CDATA[		If IsNumeric(aMetric (i)) then ]]>
<![CDATA[
]]>
<![CDATA[			aMetric(i)=CLng(aMetric (i))]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			writelog("Invalid METRIC Position information. A non-numeric value was found.")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  pm_GetLock()                                    ' Get Pattern Match object lock]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'Calculate Search Area based on METRIC, Note: must be recalculated using image area to reflect image bounds]]>
<![CDATA[
]]>
<![CDATA[	mL = aAnchor(0)-aMetric(0)]]>
<![CDATA[
]]>
<![CDATA[	If mL<0 then mL = Clng(0)]]>
<![CDATA[
]]>
<![CDATA[	mT = aAnchor(1)-aMetric(1)]]>
<![CDATA[
]]>
<![CDATA[	if mT<0 then mT = Clng(0)]]>
<![CDATA[
]]>
<![CDATA[	mR = aAnchor(2)+aMetric(0)]]>
<![CDATA[
]]>
<![CDATA[	mB = aAnchor(3)+aMetric(1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(nTID)>0 and IsNumeric(nTID) then]]>
<![CDATA[
]]>
<![CDATA[		aResult = GetDataArray("SELECT tp_ImagePath FROM Template WHERE tp_TemplateID =" & nTID & "; ")	]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		aResult = GetDataArray("SELECT tp_ImagePath FROM Template WHERE tp_Status =" & chr(39) & "<Global>" & chr(39) & "; ")]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If isArray(aResult) then]]>
<![CDATA[
]]>
<![CDATA[		sTIDFileName  = g_DCI.FileName ]]>
<![CDATA[
]]>
<![CDATA[		sTIDFileName = aResult(0,0)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Anchor Image: '" & sTIDFileName & "' ")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Anchor Image Path found.")]]>
<![CDATA[
]]>
<![CDATA[    pm_ReleaseLock()                                               ' Release Pattern Match lock	]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	g_DCI.FileName = sTIDFileName]]>
<![CDATA[
]]>
<![CDATA[	g_DCI.Invert]]>
<![CDATA[
]]>
<![CDATA[	lHBitMap = g_DCI.GetHBITMAP]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If g_dictAnchors.Exists(sTIDFileName & vAnchor) then ]]>
<![CDATA[
]]>
<![CDATA[		Set g_oPM = g_dictAnchors.Item(sTIDFileName & vAnchor)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Set g_oPM = CreateObject("Datacap.PatternMatch")]]>
<![CDATA[
]]>
<![CDATA[		MatchPattern = g_oPM.CreateAnchor(nL,nT,nR,nB,lHBitMap)]]>
<![CDATA[
]]>
<![CDATA[		Set g_dictAnchors(sTIDFileName & vAnchor) = g_oPM]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	g_DCI.FileName = oCurPage.ImageName]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Search Image: '" & g_DCI.FileName & "' ")]]>
<![CDATA[
]]>
<![CDATA[	ImageCtrl.filename = g_DCI.FileName ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call g_DCI.Invert]]>
<![CDATA[
]]>
<![CDATA[	lHBitMap = g_DCI.GetHBITMAP]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nResult = g_DCI.GetImageInfo(nWidth, nHeight, nResolution)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If clng(mR) > clng(nWidth) then mR = clng(nWidth)]]>
<![CDATA[
]]>
<![CDATA[	If clng(mB) > clng(nHeight) then mB = clng(nHeight)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Search Area: " & mL & "," & mT & "," & mR & "," & mB)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	MatchPattern = g_oPM.SearchForAnchor(mL, mT, mR, mB, lHBitMap)', nBH, nSub ,nX, nY, nC)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	Set oSA = g_oPM.StatUP]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Writelog("X:" & oSA.X & ", Y:" & oSA.Y & " diff:" & oSA.Diff & " white:" & oSA.White & " black:" & oSA.Black & "  w_diff:" & oSA.w_diff & " w_white:" & oSA.w_White & " w_black:" & oSA.w_black)                                                                       ]]>
<![CDATA[
]]>
<![CDATA[	'nRectIndex = ImageCtrl.DrawRect(nL,nT,nR,nB,3,RGB(0,0,255),RGB(255,0,0),"")]]>
<![CDATA[
]]>
<![CDATA[	'nRectIndex = ImageCtrl.DrawRect(oSA.X ,oSA.Y ,oSA.X + (nR-nL),oSA.Y + (nB-nT),3,RGB(255,0,0),RGB(255,0,0),"")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nConf = g_oPM.Confidence]]>
<![CDATA[
]]>
<![CDATA[	writelog("Match Confidence: " & nConf)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_DCI.FileName = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	if clng(nConf)<clng(g_MatchConf) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Confidence too low - match requires conf " & clng(g_MatchConf))]]>
<![CDATA[
]]>
<![CDATA[		MatchPattern = False	]]>
<![CDATA[
]]>
<![CDATA[		Set oSA = Nothing]]>
<![CDATA[
]]>
<![CDATA[    pm_ReleaseLock()                                               ' Release Pattern Match lock	]]>
<![CDATA[
]]>
<![CDATA[		If CurrentObj.Variable("Req"&nTID) = "1" Or CurrentObj.Variable("Required") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[    	CurrentObj.Variable("STATUS") = 1]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Calculate Offset for found Pattern]]>
<![CDATA[
]]>
<![CDATA[	Dim xOffset, yOffset]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	xOffset = abs(clng(aAnchor(0)) - clng(mL+oSA.X))]]>
<![CDATA[
]]>
<![CDATA[	yOffset = abs(clng(aAnchor(1)) - clng(mT+oSA.Y))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If clng(aAnchor(0))>clng(mL+oSA.X) then xOffset = (xOffset * -1)]]>
<![CDATA[
]]>
<![CDATA[	If clng(aAnchor(1))>clng(mT+oSA.Y) then yOffset = (yOffset * -1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Calculated offset is: (" & xOffset & "," & yOffset & ")") ]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("Image_Offset") = xOffset & "," & yOffset ]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("Zone_Offset") = xOffset & "," & yOffset ]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("Position") = CStr(nL+xOffset) & "," & CStr(nT+yOffset) & "," & CStr(nR+xOffset) & "," & CStr(nB+yOffset)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oSA = Nothing ]]>
<![CDATA[
]]>
<![CDATA[  pm_ReleaseLock()                                               ' Release Pattern Match lock	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PatternMatch_Identify" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim bMatch	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	On error resume next	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	PatternMatch_Identify = False]]>
<![CDATA[
]]>
<![CDATA[	bMatch = False]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType<>2 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Current DCO is not a Page.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  pm_GetLock()]]>
<![CDATA[
]]>
<![CDATA[  If g_dictPMID.Count = 0 then Call pm_LoadDict("*")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = g_dictPMID.Keys]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	PatternMatch_Identify = pm_Match(aStrParam)	]]>
<![CDATA[
]]>
<![CDATA[  pm_ReleaseLock()]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PatternMatch_Fingerprint" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  Dim k]]>
<![CDATA[
]]>
<![CDATA[  Dim nTID]]>
<![CDATA[
]]>
<![CDATA[	Dim aResult	]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[	Dim bMatch	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	PatternMatch_Fingerprint = False]]>
<![CDATA[
]]>
<![CDATA[	bMatch = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'StrParam is a Comma delineated list of Fingerprint ID's. A Match to a listed ]]>
<![CDATA[
]]>
<![CDATA[	'Fingerprint id for the current obj's image returns true.]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType<>2 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Current DCO is not a Page.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if  ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,Chr(32),"")]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam,",")	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Ubound(aStrParam) = -1 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Invalid Parameter")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  pm_GetLock()                                     ' Now get the lock for PatternMatch]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Unload fingerprints not found in the parameter  ]]>
<![CDATA[
]]>
<![CDATA[  Call pm_UnloadDict(StrParam)  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	'Check if Dictionary has loaded	templates]]>
<![CDATA[
]]>
<![CDATA[	bFound = TRUE]]>
<![CDATA[
]]>
<![CDATA[	For k = 0 to ubound(aStrParam)]]>
<![CDATA[
]]>
<![CDATA[		nTID = aStrParam(k)]]>
<![CDATA[
]]>
<![CDATA[		If Not(g_dictPMID.Exists(nTID)) and Trim(nTID)<>"" Then bFound = False 	]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If bFound=False or g_dictPMID.Count = 0 then]]>
<![CDATA[
]]>
<![CDATA[    Call pm_LoadDict(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  		]]>
<![CDATA[
]]>
<![CDATA[	PatternMatch_Fingerprint = pm_Match(aStrParam) ]]>
<![CDATA[
]]>
<![CDATA[  pm_ReleaseLock()                                 ' Done with PatternMatch]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PatternMatch_PageType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sTID]]>
<![CDATA[
]]>
<![CDATA[	Dim DCOsetup]]>
<![CDATA[
]]>
<![CDATA[	Dim ChildNode]]>
<![CDATA[
]]>
<![CDATA[	Dim i,j]]>
<![CDATA[
]]>
<![CDATA[	Dim nTID	]]>
<![CDATA[
]]>
<![CDATA[	Dim aResult	]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam()]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[	Dim lHBitMap	]]>
<![CDATA[
]]>
<![CDATA[	Dim iBitMapObj]]>
<![CDATA[
]]>
<![CDATA[	Dim bMatch	]]>
<![CDATA[
]]>
<![CDATA[	Dim aPageTypes]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	PatternMatch_PageType = False]]>
<![CDATA[
]]>
<![CDATA[	bMatch = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'StrParam is a comma-separated list of PageTypes. A Match to any PageType associated ]]>
<![CDATA[
]]>
<![CDATA[	'Fingerprint id for the current obj's image returns true.]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType<>2 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Current DCO is not a Page.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if  ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,Chr(32),"")]]>
<![CDATA[
]]>
<![CDATA[	aPageTypes = Split(StrParam,",")	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Ubound(aPageTypes) = -1 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Invalid Parameter")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  pm_GetLock()                                                  ' Now get the PM Lock ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	'Get FingerPrints associated with specified pagetypes from RulesDB	]]>
<![CDATA[
]]>
<![CDATA[	sSQL = "SELECT tp_TemplateID FROM TEMPLATE, PAGETYPE WHERE TP_PAGETYPE=PT_PAGETYPEID AND PT_PAGETYPE IN ('" & Join(aPageTypes,"','") & "'); "]]>
<![CDATA[
]]>
<![CDATA[	'sSQL = "SELECT tp_TemplateID FROM TEMPLATE, PAGETYPE WHERE TP_PAGETYPE=PT_PAGETYPEID AND PT_PAGETYPE='" & TRIM(StrParam) & "'; "]]>
<![CDATA[
]]>
<![CDATA[	Writelog("SQL:>> " & sSQL & " <<")]]>
<![CDATA[
]]>
<![CDATA[	aResult = GetDataArray(sSQL) ]]>
<![CDATA[
]]>
<![CDATA[	If Not(IsArray(aResult)) Then	]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No FingerPrint ID's Found.")]]>
<![CDATA[
]]>
<![CDATA[    pm_ReleaseLock()                                             ' No results, release the PM Lock.]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	ReDim aStrParam(uBound(aResult,1))		]]>
<![CDATA[
]]>
<![CDATA[	For k = 0 to ubound(aResult,1)	]]>
<![CDATA[
]]>
<![CDATA[		aStrParam(k) = cstr(aResult(k,0))]]>
<![CDATA[
]]>
<![CDATA[	Next 'k	]]>
<![CDATA[
]]>
<![CDATA[	'aStrParam now is an array of FingerPrint IDs associated with specified pagetypes]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[  'Remove fingerprint ID number not in Search array    ]]>
<![CDATA[
]]>
<![CDATA[  Call pm_UnloadDict(join(aStrparam,","))]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	'Check if Dictionary has loaded	fingerprint ID numbers]]>
<![CDATA[
]]>
<![CDATA[	bFound = TRUE]]>
<![CDATA[
]]>
<![CDATA[	For k = 0 to ubound(aStrParam)]]>
<![CDATA[
]]>
<![CDATA[		nTID = aStrParam(k)]]>
<![CDATA[
]]>
<![CDATA[		If Not(g_dictPMID.Exists(nTID)) and Trim(nTID)<>"" Then bFound = False ]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'bFound is True only if ALL specified PageTypes with associated Templates have loaded PatternMatch dictionary]]>
<![CDATA[
]]>
<![CDATA[	If bFound=False or g_dictPMID.Count = 0 then]]>
<![CDATA[
]]>
<![CDATA[    Call pm_LoadDict(join(aStrparam,","))]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  		]]>
<![CDATA[
]]>
<![CDATA[	PatternMatch_PageType = pm_Match(aStrParam) ]]>
<![CDATA[
]]>
<![CDATA[  pm_ReleaseLock()                                                ' Remove the PM lock.]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetMatchConfidence" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	SetMatchConfidence = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(StrParam) then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	StrParam = clng(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If StrParam < 0 or StrParam > 9 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Match Confidence Must be a value between 0 and 9.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetMatchConfidence = True]]>
<![CDATA[
]]>
<![CDATA[	g_MatchConf = StrParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<g>
</g>
<af name="pat_RegisterZones" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Dim oPg]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	pat_RegisterZones = False]]>
<![CDATA[
]]>
<![CDATA[	counter = 0]]>
<![CDATA[
]]>
<![CDATA[	xScale = 1]]>
<![CDATA[
]]>
<![CDATA[	yScale = 1]]>
<![CDATA[
]]>
<![CDATA[	xOff = 0]]>
<![CDATA[
]]>
<![CDATA[	yOff = 0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	set oPg = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	if (CurrentObj.ObjectType <> 2) then Exit Function ' must be a page]]>
<![CDATA[
]]>
<![CDATA[	If (oPg.NumOfChildren <= 0) Then]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("No fields in current page, RegisterPageAnchors fails")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  pm_GetLock()                                          ' Get pattern match object lock]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	sName = ""	]]>
<![CDATA[
]]>
<![CDATA[	sName = oPg.Variable("TemplateID") ' needed to find expected positions?]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	if (sName = "") then]]>
<![CDATA[
]]>
<![CDATA[		sPosName = "Position"]]>
<![CDATA[
]]>
<![CDATA[	else]]>
<![CDATA[
]]>
<![CDATA[		sPosName = "Pos" & sName]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	' make a list of all found anchors]]>
<![CDATA[
]]>
<![CDATA[	For i = 0 To oPg.NumOfChildren -1]]>
<![CDATA[
]]>
<![CDATA[		Set oAnc = oPg.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		If Not oAnc Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[			If oAnc.Variable("PatternMatch") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[				AnchorsFound = False]]>
<![CDATA[
]]>
<![CDATA[				WriteLog("Anchor " & oAnc.Type & " found. Looking for offset...")]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				Set oSetupNode = oAnc.SetupNode()]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[				' get expected loc]]>
<![CDATA[
]]>
<![CDATA[				sExp = oSetupNode.Variable(sPosName)]]>
<![CDATA[
]]>
<![CDATA[				If (len(sExp) <= 1) Then sExp = oSetupNode.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[				If (len(sExp) > 1) then]]>
<![CDATA[
]]>
<![CDATA[					WriteLog("Expected " & sExp)]]>
<![CDATA[
]]>
<![CDATA[					arExp = split(sExp, ",", -1, 1)]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					WriteLog("Image_Offset " & oAnc.Variable("Image_Offset"))]]>
<![CDATA[
]]>
<![CDATA[					sOff = oAnc.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[					If Len(sOff) < 1 Then]]>
<![CDATA[
]]>
<![CDATA[						WriteLog("Zone_Offset " & oAnc.Variable("Zone_Offset"))]]>
<![CDATA[
]]>
<![CDATA[						sOff = oAnc.Variable("Zone_Offset")]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[					' Anchor was found, we can tell because offset was set]]>
<![CDATA[
]]>
<![CDATA[					If Len(sOff) >= 1 Then]]>
<![CDATA[
]]>
<![CDATA[						arOff = split(sOff, ",", -1, 1)]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						sExp = CStr(CInt((CInt(arExp(0)) + CInt(arExp(2)) + .5)/2.)) & "," & CStr(CInt((CInt(arExp(1)) + CInt(arExp(3)) + .5)/2.))]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						Redim Preserve arAnchors(2, counter+1)]]>
<![CDATA[
]]>
<![CDATA[						sFnd = CStr(CInt(arOff(0) + (CInt(arExp(0)) + CInt(arExp(2)) + .5)/2.)) & "," & CStr(CInt(arOff(1) + (CInt(arExp(1)) + CInt(arExp(3)) + .5)/2.))]]>
<![CDATA[
]]>
<![CDATA[						arAnchors(0, counter) = CStr(sExp)]]>
<![CDATA[
]]>
<![CDATA[						arAnchors(1, counter) = CStr(sFnd)]]>
<![CDATA[
]]>
<![CDATA[						counter = counter + 1]]>
<![CDATA[
]]>
<![CDATA[					End If	' found an anchor that is set on this image]]>
<![CDATA[
]]>
<![CDATA[				End If		' found an anchor that has an expected location POSnnnn for this fingerprint]]>
<![CDATA[
]]>
<![CDATA[			End If			' found a pattern match (anchor) field]]>
<![CDATA[
]]>
<![CDATA[		End If				' found a field in this runtime DCO]]>
<![CDATA[
]]>
<![CDATA[	Next ' i				' loop through fields in this runtime DCO]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If counter = 3 Then]]>
<![CDATA[
]]>
<![CDATA[		' special case for 3 FOUND anchors - calculate linear scale and offset X & Y]]>
<![CDATA[
]]>
<![CDATA[		' use found anchor pair with biggest X difference, and pair with biggest Y difference]]>
<![CDATA[
]]>
<![CDATA[		'Writelog("Linear anchor calculate")]]>
<![CDATA[
]]>
<![CDATA[		xMax = 0]]>
<![CDATA[
]]>
<![CDATA[		yMax = 0]]>
<![CDATA[
]]>
<![CDATA[		' match up all anchor pairs to find the most distant pair in X and Y axes]]>
<![CDATA[
]]>
<![CDATA[		For i = 0 To counter-1]]>
<![CDATA[
]]>
<![CDATA[			For j = 0 To counter-1]]>
<![CDATA[
]]>
<![CDATA[				If i <> j Then]]>
<![CDATA[
]]>
<![CDATA[					arAnchExp1 = split(arAnchors(0, i), ",")]]>
<![CDATA[
]]>
<![CDATA[					arAnchFnd1 = split(arAnchors(1, i), ",")]]>
<![CDATA[
]]>
<![CDATA[					arAnchExp2 = split(arAnchors(0, j), ",")]]>
<![CDATA[
]]>
<![CDATA[					arAnchFnd2 = split(arAnchors(1, j), ",")]]>
<![CDATA[
]]>
<![CDATA[					xdiff = ABS(arAnchFnd1(0)-arAnchFnd2(0))]]>
<![CDATA[
]]>
<![CDATA[					ydiff = ABS(arAnchFnd1(1)-arAnchFnd2(1))]]>
<![CDATA[
]]>
<![CDATA[					if xdiff > xMax then]]>
<![CDATA[
]]>
<![CDATA[						xMax = xdiff]]>
<![CDATA[
]]>
<![CDATA[            denom = ABS(arAnchExp1(0)-arAnchExp2(0))]]>
<![CDATA[
]]>
<![CDATA[            If denom < 1 Then denom = 1]]>
<![CDATA[
]]>
<![CDATA[						xScale = xdiff / denom]]>
<![CDATA[
]]>
<![CDATA[					end if]]>
<![CDATA[
]]>
<![CDATA[					if ydiff > yMax then]]>
<![CDATA[
]]>
<![CDATA[						yMax = ydiff]]>
<![CDATA[
]]>
<![CDATA[            denom = ABS(arAnchExp1(1)-arAnchExp2(1))]]>
<![CDATA[
]]>
<![CDATA[            If denom < 1 Then denom = 1]]>
<![CDATA[
]]>
<![CDATA[						yScale = ydiff / denom]]>
<![CDATA[
]]>
<![CDATA[					end if]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			Next ' j]]>
<![CDATA[
]]>
<![CDATA[		Next ' i]]>
<![CDATA[
]]>
<![CDATA[		'WriteLog("X scale " + CStr(xScale) + " span " + CStr(xMax))]]>
<![CDATA[
]]>
<![CDATA[		'WriteLog("Y scale " + CStr(yScale) + " span " + CStr(yMax))]]>
<![CDATA[
]]>
<![CDATA[		' we have found the X and Y scale, now calculate offset]]>
<![CDATA[
]]>
<![CDATA[		' negative of average distance from expected to found]]>
<![CDATA[
]]>
<![CDATA[		For i = 0 To counter-1	]]>
<![CDATA[
]]>
<![CDATA[			arAnchExp1 = split(arAnchors(0, i), ",")]]>
<![CDATA[
]]>
<![CDATA[			arAnchExp1(0) = arAnchExp1(0)*xScale]]>
<![CDATA[
]]>
<![CDATA[			arAnchFnd1 = split(arAnchors(1, i), ",")]]>
<![CDATA[
]]>
<![CDATA[			arAnchExp1(1) = arAnchExp1(1)*yScale]]>
<![CDATA[
]]>
<![CDATA[			xOff = xOff + (arAnchFnd1(0)-arAnchExp1(0))]]>
<![CDATA[
]]>
<![CDATA[			yOff = yOff + (arAnchFnd1(1)-arAnchExp1(1))]]>
<![CDATA[
]]>
<![CDATA[		Next ' i]]>
<![CDATA[
]]>
<![CDATA[    If counter > 0 Then]]>
<![CDATA[
]]>
<![CDATA[		  xOff = xOff / counter]]>
<![CDATA[
]]>
<![CDATA[		  yOff = yOff / counter]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Linear scale ("+ CStr(xScale) + ","+ CStr(yScale) +") offset ("+ CStr(xOff) +","+ CStr(yOff) +")")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	' now adjust all the fields using the found anchors]]>
<![CDATA[
]]>
<![CDATA[	If counter > 0 Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Register using " & counter & " anchors")]]>
<![CDATA[
]]>
<![CDATA[		temp = AZoneChildren(CurrentObj, sPosName)]]>
<![CDATA[
]]>
<![CDATA[		pat_RegisterZones = temp]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("No anchors set on this page")]]>
<![CDATA[
]]>
<![CDATA[		pat_RegisterZones = True			' this is OK, not an error]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  pm_ReleaseLock()                                               ' Release Pattern Match lock	  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="pat_ReleasePageAnchors" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Redim arAnchors(2, 0)]]>
<![CDATA[
]]>
<![CDATA[	pat_ReleasePageAnchors = True]]>
<![CDATA[
]]>
	</g>
</af>
<g>
</g>
<af name="pat_RecogMatch_Id" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[	Dim sTID]]>
<![CDATA[
]]>
<![CDATA[	Dim DCOsetup]]>
<![CDATA[
]]>
<![CDATA[	Dim ChildNode]]>
<![CDATA[
]]>
<![CDATA[	Dim i,j]]>
<![CDATA[
]]>
<![CDATA[	Dim nTID	]]>
<![CDATA[
]]>
<![CDATA[	Dim aResult	]]>
<![CDATA[
]]>
<![CDATA[	Dim lHBitMap]]>
<![CDATA[
]]>
<![CDATA[	Dim oSA ]]>
<![CDATA[
]]>
<![CDATA[	Dim iCCOobj]]>
<![CDATA[
]]>
<![CDATA[	Dim oCCOCreator]]>
<![CDATA[
]]>
<![CDATA[	Dim bMatch]]>
<![CDATA[
]]>
<![CDATA[	Dim aAnchor]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	On error resume next	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	pat_RecogMatch_Id = False]]>
<![CDATA[
]]>
<![CDATA[	bMatch = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType<>2 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Current DCO is not a Page.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  pm_GetLock()                                      ' Get Pattern Match object lock]]>
<![CDATA[
]]>
<![CDATA[	Set oSA = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCCOCreator	= CreateObject("CCO._CCOCreator")]]>
<![CDATA[
]]>
<![CDATA[	Set iCCOobj = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Check if Dictionary is already loaded	]]>
<![CDATA[
]]>
<![CDATA[	If g_dictRMID.Count = 0 then	]]>
<![CDATA[
]]>
<![CDATA[		'Read Setup DCO and a Create Dictionary of CCO Recognition Match Objects]]>
<![CDATA[
]]>
<![CDATA[		Set DCOsetup = DCO.SetupObject	]]>
<![CDATA[
]]>
<![CDATA[		If DCOsetup is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[       pm_ReleaseLock()                              ' Release Pattern Match lock	]]>
<![CDATA[
]]>
<![CDATA[       Exit Function       ]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		Set ChildNode = Nothing]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		For i = 1 to DCOsetup.NumOfNodes(3)]]>
<![CDATA[
]]>
<![CDATA[			Set ChildNode = DCOsetup.GetNode(3,i-1)]]>
<![CDATA[
]]>
<![CDATA[			If Not(ChildNode is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[				If ChildNode.Variable("PatternMatch")="1" Then		]]>
<![CDATA[
]]>
<![CDATA[					For j = 0 to ChildNode.NumOfVariables]]>
<![CDATA[
]]>
<![CDATA[						If left(ChildNode.VariableName(j) & Space(3),3)="Pos" And isnumeric(replace(ChildNode.VariableName(j),"Pos","")) then	]]>
<![CDATA[
]]>
<![CDATA[							nTID = trim(replace(ChildNode.VariableName(j),"Pos",""))]]>
<![CDATA[
]]>
<![CDATA[							If isNumeric(nTID) and len(nTID)>=1 then ]]>
<![CDATA[
]]>
<![CDATA[																	]]>
<![CDATA[
]]>
<![CDATA[								'Add to Dictionary]]>
<![CDATA[
]]>
<![CDATA[								If Not(g_dictRMID.Exists(nTID)) then ]]>
<![CDATA[
]]>
<![CDATA[									Set g_dictRMID(nTID) = CreateObject("Scripting.Dictionary")]]>
<![CDATA[
]]>
<![CDATA[								End if	]]>
<![CDATA[
]]>
<![CDATA[									]]>
<![CDATA[
]]>
<![CDATA[								Set dictZone = g_dictRMID(nTID)]]>
<![CDATA[
]]>
<![CDATA[																	]]>
<![CDATA[
]]>
<![CDATA[								If Not(dictZone.Exists(ChildNode.Variable("Pos" & nTID))) then ]]>
<![CDATA[
]]>
<![CDATA[									Call dictZone.Add(ChildNode.Variable("Pos" & nTID),cstr(""))]]>
<![CDATA[
]]>
<![CDATA[								End if	]]>
<![CDATA[
]]>
<![CDATA[															]]>
<![CDATA[
]]>
<![CDATA[								Set g_dictRMID(nTID) = dictZone]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[					Next 'j					]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[				Set ChildNode = Nothing]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		Next 'i]]>
<![CDATA[
]]>
<![CDATA[		Set DCOsetup = Nothing]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If g_dictRMID.Count <> 0 then ]]>
<![CDATA[
]]>
<![CDATA[			'Load All Template records based on Key Values]]>
<![CDATA[
]]>
<![CDATA[			aKeys = g_dictRMID.Keys]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			sKeys = join(aKeys,",")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			sSQL = "SELECT tp_TemplateID, tp_CCOPath FROM Template WHERE tp_TemplateID IN (" & sKeys & "); "]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			aResult = GetDataArray(sSQL) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If isArray(aResult) then]]>
<![CDATA[
]]>
<![CDATA[				For k = 0 to ubound(aResult,1)]]>
<![CDATA[
]]>
<![CDATA[					Writelog("#" & aResult(k,0) & ", path:'" & aResult(k,1) & "' ")]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					'Ensure CCO file exists]]>
<![CDATA[
]]>
<![CDATA[					If FileMgr.FileExists(aResult(k,1)) Then ]]>
<![CDATA[
]]>
<![CDATA[																	]]>
<![CDATA[
]]>
<![CDATA[						'Load CCO file as Object into dictionary						]]>
<![CDATA[
]]>
<![CDATA[						Set iCCOobj = oCCOCreator.Load(aResult(k,1))				]]>
<![CDATA[
]]>
<![CDATA[													]]>
<![CDATA[
]]>
<![CDATA[						If g_dictRMID.Exists(cstr(aResult(k,0))) then ]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[							If Not(iCCOobj is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[								Set dictZone = g_dictRMID.item(cstr(aResult(k,0)))]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[								For Each zoneKey in dictZone.Keys]]>
<![CDATA[
]]>
<![CDATA[										]]>
<![CDATA[
]]>
<![CDATA[									aAnchor = pm_SplitNumber(zoneKey)]]>
<![CDATA[
]]>
<![CDATA[																					]]>
<![CDATA[
]]>
<![CDATA[									'***Find Recognition Text for FingerPrint CCO Area....]]>
<![CDATA[
]]>
<![CDATA[									AnchorText=Trim(rm_ZoneText(aAnchor,iCCOObj))]]>
<![CDATA[
]]>
<![CDATA[									If len(AnchorText)>0 Then]]>
<![CDATA[
]]>
<![CDATA[										Writelog(Space(5) & "FPZone:'" & zoneKey & "' TXTZone:'" & Join(aAnchor,",") & "' Value:'" & AnchorText & "'")]]>
<![CDATA[
]]>
<![CDATA[										Call dictZone.Remove(zoneKey)]]>
<![CDATA[
]]>
<![CDATA[										Call dictZone.Add(Join(aAnchor,","),cstr(AnchorText))]]>
<![CDATA[
]]>
<![CDATA[									Else	]]>
<![CDATA[
]]>
<![CDATA[										dictZone(zoneKey)=cstr(AnchorText) 			]]>
<![CDATA[
]]>
<![CDATA[									End if]]>
<![CDATA[
]]>
<![CDATA[								Next 'zoneKey]]>
<![CDATA[
]]>
<![CDATA[							Else]]>
<![CDATA[
]]>
<![CDATA[								Writelog("CCO file did not load!")		]]>
<![CDATA[
]]>
<![CDATA[								Call g_dictRMID.Remove(cstr(aResult(k,0)))	]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						End if			]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						Set iCCOobj = Nothing]]>
<![CDATA[
]]>
<![CDATA[					Else]]>
<![CDATA[
]]>
<![CDATA[						Writelog("File '" & aResult(k,1) & " not found. CCO File Missing while loading Patterns.")	]]>
<![CDATA[
]]>
<![CDATA[						If g_dictRMID.Exists(cstr(aResult(k,0))) then g_dictRMID.Remove(cstr(aResult(k,0)))]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[																	]]>
<![CDATA[
]]>
<![CDATA[				Next 'k]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[				Writelog("No results retrieved from Template Table Lookup.")]]>
<![CDATA[
]]>
<![CDATA[				set oCCOCreator = Nothing]]>
<![CDATA[
]]>
<![CDATA[        pm_ReleaseLock()                                          ' Release Pattern Match lock	]]>
<![CDATA[
]]>
<![CDATA[				Exit Function]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	set oCCOCreator = Nothing]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = g_dictRMID.Keys]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	pat_RecogMatch_Id = rm_Match(aStrParam)		]]>
<![CDATA[
]]>
<![CDATA[	pm_ReleaseLock()                                               ' Release Pattern Match lock	]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************************
' Licensed Materials - Property of IBM
' Restricted Materials of IBM
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2016 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'************************************************************************
]]>


<ref id="MatchPattern" access="public" bInter="bInter" bDebug="bDebug" qi="Align the image of this field on the current page with the fingerprint">
	<ap>None.</ap>	
	<h>
    Searches on the current image in a zone associated with the current field
    for a match to the pattern specified for this field in a fingerprint.
    The zoned area from the original fingerprint is matched against a larger
    zone in the current image. The search area is controlled by the METRIC variable.
    METRIC=200,100 means search from 200 pixels to the left and right, and 100 pixels
    above and below the expected location. If METRIC is not specified, the default is 500
    pixels horizontal and vertical. <br/><br/>

	  The fingerprint is determined by the current image's Fingerprint ID, or the 
    Global Fingerprint ID if the current image is not identified.<br/><br/>
    MatchPattern may be called on any field and if matched an offset variable will 
    be saved for that field.  If called prior to ReadZones then ReadZones will 
    use the offset for that field when setting its position.  
    Other fields will be unaffected.<br/><br/>

    If the field is matched to the fingerprint with a confidence equal to or greater than the required confidence,
    the position of the field is set to the found location.
    If the field is not matched, the function returns false.
    If not found and the field's Required variable is nonzero, the field status is set to 1 (Error or Validation failed).<br/><br/>
    
    This action operates on black and white images, grayscale or color images will cause the action to fail. The fingerprint image must have the same resolution (DPI) as the current page image. The geometric shape contained in the Anchor field should be bold and well defined with clear edges, with crisp black and white markings, producing a distinct shape. The shape should be thick and compact, not composed of long thin lines. To avoid false positive matches, the shape should not match other shapes or black areas that may exist nearby within the same image.
    <e>
      <b>MatchPattern()</b> 
		</e>	
	</h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if:<br/><br/>

    - The Anchor position returned is not Numeric; or<br/>
    - No image is found; or<br/>
    - The accuracy of the match is below the set Confidence Value; or<br/>
    - An Anchor match does not occur.<br/><br/>

    Otherwise, <b>True.</b>
  </ret>
</ref>
	
  
<ref id="PatternMatch_Identify" access="public" bInter="bInter" bDebug="bDebug" qi="Identifies a page using image pattern matching.">
	<ap>None.</ap>
  <h>
    PatternMatch_Identify identifies a page's type and fingerprint using geometric pattern matching. The locations of unique patterns are configured as Anchor Fields for each fingerprint in the Document Hierarchy. One or more Anchor fields can be used to match geometric shapes on a fingerprint to the current image. If one or more Anchor fields on the current page match a fingerprint, at or above the configured confidence level, the page is identified with that fingerprint. The action does not require all defined anchors to match - the first match is used.

    The action loads all Anchor field patterns from the fingerprint library, then searches on the current image for each of the patterns in the associated zones. The search area for each zone is increased by the dimensions specified in the page METRIC variable. If METRIC is not specified, the default is 500 pixels horizontal and vertical.

    When this action finds a match, it sets the matching Fingerprint ID and Page Type. It will also create page-level fields and update the Anchor fields with Anchor-specific pattern offset values in a field-level Image_Offset variable. The offset can be used subsequent to matching a fingerprint. The pat_RegisterZones action can be used to align the zones in the fingerprint to the current image, providing more accurately positioned text in each field.
<br/><br/>
    This action requires the current page image to be bitonal (black and white), grayscale or color images will cause the action to fail. The fingerprint image must have the same resolution (DPI) as the current page image. The geometric shape contained in each Anchor field should be bold and well defined with clear edges, with crisp black and white markings, producing a distinct shape. The shape should be thick and compact, not composed of long thin lines. To avoid false positive matches, the shape should not match other shapes or black areas that may exist nearby within the same image.
    <e>
      <b>PatternMatch_Identify()</b>
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    <lit>False</lit> if the rule containing this action was not applied to a Page object of the Document Hierarchy; if a pattern match is not found; or if fingerprints do not exist. Otherwise, <lit>True</lit>.
  </ret>
</ref>
  
	
<ref id="PatternMatch_Fingerprint" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Identifies a page from a specified list of fingerprints.">
  <ap>
    A comma-separated list of one or more Fingerprint ID's.<br/><br/>
  </ap>
  <h>
    PatternMatch_Fingerprint identifies a page's type and fingerprint using geometric pattern matching. The locations of unique patterns are configured as Anchor Fields for each fingerprint in the Document Hierarchy. One or more Anchor fields can be used to match geometric shapes on a fingerprint to the current image. If one or more Anchor fields on the current page match a fingerprint, at or above the configured confidence level, the page is identified with that fingerprint. The action does not require all defined anchors to match - the first match is used.

    The action loads all Anchor field patterns from the specified fingerprints, then searches on the current image for each of the patterns in the associated zones. The search area for each zone is increased by the dimensions specified in the page METRIC variable. If METRIC is not specified, the default is 500 pixels horizontal and vertical.

    When this action finds a match, it sets the matching Fingerprint ID and Page Type. It will also create page-level fields and update the Anchor fields with Anchor-specific pattern offset values in a field-level Image_Offset variable. The offset can be used subsequent to matching a fingerprint. The pat_RegisterZones action can be used to align the zones in the fingerprint to the current image, providing more accurately positioned text in each field.
<br/><br/>
    This action requires the current page image to be bitonal (black and white), grayscale or color images will cause the action to fail. The fingerprint image must have the same resolution (DPI) as the current page image. The geometric shape contained in each Anchor field should be bold and well defined with clear edges, with crisp black and white markings, producing a distinct shape. The shape should be thick and compact, not composed of long thin lines. To avoid false positive matches, the shape should not match other shapes or black areas that may exist nearby within the same image.
    <e>
      <b>PatternMatch_Fingerprint(1024,1034,1035,1036)</b><br/><br/>

      This example compares the current page to the four fingerprints specified by their IDs.
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the rule containing this action was not applied to a Page object of 
    the Document Hierarchy; if a parameter is invalid; if a match does not occur; 
    or if one or more of the specified fingerprints do not exist. Otherwise, <b>True.</b>
  </ret>
</ref>


  <ref id="PatternMatch_PageType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Identifies a page according to its Page Type. ">
  <ap>
    One or more Page Types defined in the Document Hierarchy
  </ap>
  <h>
    PatternMatch_PageType identifies a page's type and fingerprint using geometric pattern matching. The locations of unique patterns are configured as Anchor Fields for each fingerprint in the Document Hierarchy. One or more Anchor fields can be used to match geometric shapes on a fingerprint to the current image. If one or more Anchor fields on the current page match a fingerprint, at or above the configured confidence level, the page is identified with that fingerprint. The action does not require all defined anchors to match - the first match is used.

    The action loads all Anchor field patterns from fingerprints with the specified page types, then searches on the current image for each of the patterns in the associated zones. The search area for each zone is increased by the dimensions specified in the page METRIC variable. If METRIC is not specified, the default is 500 pixels horizontal and vertical.

    When this action finds a match, it sets the matching Fingerprint ID and Page Type. It will also create page-level fields and update the Anchor fields with Anchor-specific pattern offset values in a field-level Image_Offset variable. The offset can be used subsequent to matching a fingerprint. The pat_RegisterZones action can be used to align the zones in the fingerprint to the current image, providing more accurately positioned text in each field.
<br/><br/>
    This action requires the current page image to be bitonal (black and white), grayscale or color images will cause the action to fail. The fingerprint image must have the same resolution (DPI) as the current page image. The geometric shape contained in each Anchor field should be bold and well defined with clear edges, with crisp black and white markings, producing a distinct shape. The shape should be thick and compact, not composed of long thin lines. To avoid false positive matches, the shape should not match other shapes or black areas that may exist nearby within the same image.
    <e>
      <b>PatternMatch_PageType(HCFA 1500)</b><br/><br/>

      This action looks for a match among the inventory of fingerprints that have a 
      page type of "HCFA 1500".
    </e>
  </h>
  <lvl>Page level only.</lvl>
  <ret>
    <b>False</b> if the rule containing this action was not applied to a Page 
    object of the Document Hierarchy; if the parameter is invalid; if a match 
    does not occur; or if fingerprints do not yet exist. Otherwise, <b>True.</b>
  </ret>
 </ref>
	
  
<ref id="SetMatchConfidence" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the confidence threshold for pattern matching.">
	<ap>
    The value of the confidence threshold.<br/><br/>

  	The value must be between 0 (lowest confidence) and 9 (highest confidence).<br/><br/>

    Higher values require fewer differences between the compared areas to return a positive match value.
  </ap>
	
	<h>
     Sets the confidence threshold for pattern matching.
		<e>
      <b>SetMatchConfidence(9)</b> 
		</e>
	</h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter is not a number between 0 and 9.  Otherwise, <b>True.</b>
  </ret>
</ref>

<ref id="pat_RegisterZones" access="public" bInter="bInter" bDebug="bDebug" qi="Registers and adjusts the positions of all fields on the current source page, based on the positions of the page's designated Anchor field(s).">
  <ap>None.</ap>
  <h>
    pat_RegisterZones registers and adjusts the positions of all fields on the current page, based on the previously matched positions of the page's designated Anchor field(s). Anchor fields are determined by the Anchor Field setting in Datacap Studio, for each field.

    Prior to calling pat_RegisterZones, usually in a different task or ruleset, one of the PatternMatch actions that performs Anchor matching must be called. Then, when the pat_RegisterZones action is called, the expected positions of the Anchor fields on the image (taking into account the Fingerprint classification) are compared with the recognized positions of the fields identified as an Anchor field. The action ReadZones must be called prior to pat_RegisterZones. If any required Anchors are not matched, an operator may be required to update the Anchor position in a verify or fixup task.
<br/><br/>
    All matched or manually adjusted Anchor positions are used for adjustment, Anchors that are not matched are ignored.  <br/>
    <br/>
    If one Anchor is found, the field positions are all shifted by the same amount.
<br/>
    If two or more Anchors are found, the field positions are shifted by different amounts, depending on their distance from each Anchor. This process is called Interpolation.
<br/>
    The expected positions of the Anchor fields on the image (taking into
    account the Fingerprint classification) are compared with the recognized positions
    of those Anchor fields - or the Anchor positions set manually by a Fixup task's operator.<br/><br/>
    <e>
      <b>
        ReadZones()<br/>
        pat_RegisterZones()<br/>
        PrecognizePageFieldsOCR_S()<br/>
      </b>
    </e>
  </h>
  <lvl>Page only.</lvl>
  <ret>
    <b>True</b> if the ruleset with this action is bound to a Page object of the Document Hierarchy, 
    and if the action can find all designated Anchor fields. Otherwise, <b>False.</b>
  </ret> 
</ref>
	
<ref id="pat_ReleasePageAnchors" access="public" bInter="bInter" bDebug="bDebug" 
    qi="An action that can be called at the end of a batch to release information about the identity and location of a page's Anchor field(s).">
  <ap>None.</ap>
  <h>
    This action can be optionally called to release the small amount of Anchor memory that
    was allocated by the action pat_RegisterZones.  If pat_ReleasePageAnchors is not called,
    the memory will be released at the end of the batch or the next time pat_RegisterZones is called.
    <e>
      <b>pat_ReleasePageAnchors()</b>
    </e>
  </h>
  <lvl>Page only.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
 
  
<ref id="pat_RecogMatch_Id" access="public" bInter="bInter" bDebug="bDebug" qi="Identifies the current page type by matching OCR results in any fingerprint Anchor zone with OCR results for the corresponding zone on the current page.">
	<ap>None.</ap>	
	<h>
    pat_RecogMatch_Id identifies the page by matching text from any fingerprint Anchor field with the corresponding text on the current page.  Fuzzy matching is used. Full-page OCR or ICR must be performed prior to calling this action.
    <br/> <br/>
    If any Anchor field text in the current page matches the zonal text of any fingerprint, the page is identified by that fingerprint (first match).
    The Type of the current page is set to the fingerprint page type if a match is found.
    Full page OCR or ICR must be performed on both the fingerprints and the current image prior to calling this action.
    Text to be matched is extracted from each fingerprint's Anchor field, which should be defined tightly around the text in the fingerprint. The search area in the current image is the fingerprint-specific field zone in the Document Hierarchy, extended by any associated METRIC variable.
    <br/> <br/>
    Page identification using pat_RecogMatch_ID (text matching) is mutually exclusive with identification using graphical pattern matching actions (PatternMatch_Identify, etc.).  
    Anchor fields in the Document Hierarchy should be selected carefully so that false positive text matches do not occur.
    <br/> <br/>
		<e>
      <b>pat_RecogMatch_Id()</b>
    </e>
	</h>
  <lvl>Page only.</lvl>
  <ret>
    <b>True</b> if the ruleset is bound to a Page, and a fingerprint matching the text of at least one Anchor field is found. Otherwise, and in case of any errors, <b>False.</b>
In addition, the page variable TemplateID is set to the matching Fingerprint ID.
  </ret>
</ref>
</help>
</rrx>
<rrx namespace="Picture" src="c:\datacap\RRS\Picture.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<af name="PIC_FormatFields" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	PIC_FormatFields = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oPictureStringFormater.m_bFilter = False]]>
<![CDATA[
]]>
<![CDATA[	PIC_FormatFields = oPictureStringFormater.Process(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	oPictureStringFormater.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="PIC_FilterFields" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	PIC_FilterFields = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oPictureStringFormater.m_bFilter = True           ' Replace low confidence with a space.]]>
<![CDATA[
]]>
<![CDATA[	PIC_FilterFields = oPictureStringFormater.Process(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	oPictureStringFormater.CatchError("")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PIC_ValidateField" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[  Dim oSetupNode]]>
<![CDATA[
]]>
<![CDATA[  Dim nSetupStatus]]>
<![CDATA[
]]>
<![CDATA[  Dim bHiddenField]]>
<![CDATA[
]]>
<![CDATA[  Dim sMsg]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  PIC_ValidateField = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType<>3 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Object must be of Type Field. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    PIC_ValidateField = False]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  bHiddenField=False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	oPictureStringFormater.m_bFilter = False]]>
<![CDATA[
]]>
<![CDATA[  bReturn = oPictureStringFormater.Validate(CurrentObj)    ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  If bReturn = False Then ]]>
<![CDATA[
]]>
<![CDATA[		sMsg = RRState.LoadString("picture","CharOutOfScope","Field '{0}' value of '{1}' does not match the picture string format '{2}'.")]]>
<![CDATA[
]]>
<![CDATA[    sMsg = replace(sMsg,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMsg = replace(sMsg,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[    sMsg = replace(sMsg,"{2}",CurrentObj.Variable("PictureString"))]]>
<![CDATA[
]]>
<![CDATA[    DCOMessage(sMsg)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Set oSetupNode = CurrentObj.SetupNode]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If oSetupNode is nothing then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Unable to get setupNode for field " & CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    If Trim(cstr(oSetupNode.Variable("STATUS")))="-1" then bHiddenField=True]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Trim(cstr(CurrentObj.STATUS))="-1" then bHiddenField=True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If bHiddenField=False then PIC_ValidateField = bReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="PIC_SetPictureCharacter" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim PicCharNum]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  PIC_SetPictureCharacter = FALSE]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  PicCharNum = Left(StrParam,1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if Len(StrParam) < 3 then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("SetPicChar parameter must be a single digit numeric followed by a comma, followed by the allowable characters")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if Not IsNumeric(PicCharNum) then    'first character must be a digit]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("SetPicChar parameter must be a single digit numeric followed by a comma, followed by the allowable characters")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if mid(StrParam,2,1) <> "," then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("SetPicChar parameter must be a single digit numeric followed by a comma, followed by the allowable characters")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  CustomPicCharAr(PicCharNum) = Right(StrParam,Len(StrParam) - 2)  ]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("Picture Character " & cStr(PicCharNum) & " is set to: " &  CustomPicCharAr(PicCharNum))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  PIC_SetPictureCharacter = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PIC_ApplyPictureString" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim PicRepeatChar]]>
<![CDATA[
]]>
<![CDATA[  Dim i]]>
<![CDATA[
]]>
<![CDATA[  Dim CharaterSet]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  PIC_ApplyPictureString = FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if CurrentObj.ObjectType <> 3 then]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Action is for use on a field object only.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if Len(StrParam) > len(CurrentObj.Text) then]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("Picture String is longer than the detected field value.")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  PicRepeatChar = Right(StrParam,1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  While len(StrParam) < len(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[     StrParam = StrParam & PicRepeatChar   ]]>
<![CDATA[
]]>
<![CDATA[  wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Applying Picture String: " & StrParam & " to: " & CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  For i = 1 to Len(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Checking " & mid(CurrentObj.Text,i,1) & " against picture character " & mid(StrParam,i,1) ) ]]>
<![CDATA[
]]>
<![CDATA[     if Not oPictureStringFormater.IsCharValid(cStr(mid(CurrentObj.Text,i,1)), cStr(mid(StrParam,i,1))) then   ]]>
<![CDATA[
]]>
<![CDATA[       'didn't find the current character in the characterset]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Picture Validation failed at character position " & cStr(i))    ]]>
<![CDATA[
]]>
<![CDATA[       Exit Function ]]>
<![CDATA[
]]>
<![CDATA[     end if  ]]>
<![CDATA[
]]>
<![CDATA[  next 'i]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  PIC_ApplyPictureString = TRUE]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PIC_ReplaceBlankField" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim TrimValue ' The current field value with spaces trimmed at front and end.]]>
<![CDATA[
]]>
<![CDATA[  Dim numChars  ' Number of characters in the new field, if changed.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  PIC_ReplaceBlankField = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  call Writelog("PIC_ReplaceBlankField Input: " & strParam)   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (strParam = "") Then]]>
<![CDATA[
]]>
<![CDATA[    Call Writelog("PIC_ReplaceBlankField requires a parameter. Exiting.")    ]]>
<![CDATA[
]]>
<![CDATA[    Call ErrorHandler("PIC_ReplaceBlankField")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (CurrentObj.ObjectType <> 3) Then]]>
<![CDATA[
]]>
<![CDATA[    Call Writelog("PIC_ReplaceBlankField Object must be of Type Field. Exiting.")    ]]>
<![CDATA[
]]>
<![CDATA[    Call ErrorHandler("PIC_ReplaceBlankField")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  PIC_ReplaceBlankField = True]]>
<![CDATA[
]]>
<![CDATA[  TrimValue = trim(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[  If (TrimValue = "") Then]]>
<![CDATA[
]]>
<![CDATA[    Call Writelog("Replacing empty field " & CurrentObj.Text & " with: " & strParam)    ]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Text = strParam        ]]>
<![CDATA[
]]>
<![CDATA[    numChars = len(strParam)]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.ConfidenceString = String(clng(numChars), "1") ' Set new confidence value to low]]>
<![CDATA[
]]>
<![CDATA[  Else  ]]>
<![CDATA[
]]>
<![CDATA[    Call Writelog("Field is not empty: " & CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("PIC_ReplaceBlankField")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<help>
  <![CDATA[
'----------------------------------------------------------------------
' Help.xml for picture.rrx
'----------------------------------------------------------------------
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2013 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'----------------------------------------------------------------------
 ]]>
	<ref id="PIC_FormatFields">
		<ap>None.</ap>
    <h>
      Lowers the Confidence Rating of any character in a field that does not satisfy the <i>PictureString</i> criteria.<br/><br/>
      This action adjusts the character confidence of a field, and optionally replaces characters, based on the picture string
      that has been set for the field.  It is very similar to the <b>FilterFields</b> action.<br/><br/>

      This action has two roles.  If a character in the field does not match the picture string format defined
      for that field:<br/><br/>

      1. It replaces any "problem" characters with an alternative character from a
      secondary recognition engine if one exists.  If an alternative recognition character does
      not exist, then the original character is left unchanged.<br/><br/>

      Note: There must be an equal number of alternative characters as the field length, and
      the alternative character must also be valid within the field's picture string for 
      substitution to occur. If the alternative recognition character is also not a valid
      picture string character, then no substitution will occur.<br/><br/>

      2. It lowers the Confidence Rating of any character in a field that does not
      satisfy the picture string's criteria.<br/><br/>

      3. Alternative recognition characters are removed from the field after execution.<br/><br/>
      
      Note: This Action is recursive and will affect all child fields of the calling node.<br/><br/>

      <b>Picture Strings:</b><br/>
      This action works with picture strings that are defined for a field.  The picture string
      must be stored in a field variable called '<i>PictureString</i>'.  Picture strings improve and filter recognition
      results, and are used to limit characters typed into that field during verify. The <b>PIC_FormatFields</b>
      and <b>PIC_FilterFields</b>  actions can be called to “enforce” the
      PictureString after recognition rules are invoked. The PIC_ApplyPictureString action
      is an exception that does not use the PictureString variable.<br/><br/>

      Recognition actions do not pay attention to this property, individual recognition engines have their own
      parameters to help guide the recognition.  The Web Verify task always enforces PictureString.
      Thick client Verify panels constructed by
      Batch Pilot Autoform also enforces PictureString specifications.<br/><br/>

      <b>PIC_FilterFields</b> replaces non-matching characters with low confidence spaces, <b>PIC_FormatFields</b>
      just lowers the confidence. The DCEdit control enforces them during verify.<br/><br/>

      There are two typical ways that the picture values can be set in PictureString.<br/><br/>
      <b>1.</b> Use the rrunner action rrSet in a ruleset.  With this action, you can specify the PictureString
      variable and set it to the desired value.<br/>
      <b>2.</b> In the Zones tab of Datacap Studio, right click on the desired field and choose "Manage Variables".
      Enter the new variable PictureString and set its value to the desired picture string characters.<br/><br/>

      While not direct input to this action as a standard parameter, here are the valid picture string characters
      that can be set in the PictureString field variable which are then used by this action.<br/><br/>

      A: Alphabetic characters only or a space. Numeric and/or punctuation characters are not valid.<br/>
      a: Alphabetic, space and punctuation characters.<br/>
      D: Dates. The dates must be expressed with numeric characters. You can delimit months, dates, and years with hyphens, periods, and forward slashes.<br/>
      F: Float numbers, which are fractional numbers. To accommodate fractional values, this picture string allows you to
      include both numbers and a period (for the decimal separator). The F character also allows minus signs to represent negative numbers.<br/>
      f: Numeric and punctuation characters.<br/>
      L: Lower-case alphabetic and space characters.<br/>
      l: Lower-case alphabetic, space and punctuation characters.<br/>
      N: Numeric characters only.<br/>
      n: Uppercase alphabetic, numeric or space characters.
      P: Punctuation and space characters.<br/>
      T: Time values. These values are expressed in numbers with a colon. In addition, the characters P, M, and A are allowed to distinguish between morning and afternoon times, and colon characters are allowed to delimit hours, minutes, and seconds.<br/>
      U: Upper-case alphabetic and space characters.<br/>
      u: Upper-case alphabetic, space and punctuation characters.<br/>
      X: Alphabetic, space and numeric characters.<br/>
      x: Alphabetic, space, numeric and punctuation characters.<br/>
      Z: Any character.<br/>
      #: Numeric characters and the minus sign.<br/><br/>

      PIC_SetPictureCharacter can be used to define up to 10 additional application specific picture strings
      at runtime, identified as 0 through 9.
      <e>
        rrSet("AN,@F.PictureString")<br/>
        <b>PIC_FormatFields()</b><br/><br/>

        This example expects the current field to contain a single alphabetic character followed by an
        unlimited number of digits.  Here the <i>PictureString</i> variable is set at runtime, but
        it can instead be configured at design time in the setup DCO in Datacap Studio.
      </e>
    </h>
		<lvl>All levels.</lvl>
		<ret>
			Always <b>True.</b>
		</ret>
		<see>PIC_FilterFields, PIC_ValidateField, PIC_SetPictureCharacter</see>
	</ref>
	<ref id="PIC_ValidateField">
		<ap>None.</ap>
		<h>
			Checks the value of all characters in a field against that field's <i>PictureString</i> criteria.<br/><br/>
			If a character in the field does not match the picture string format defined
			for that field, it lowers the Confidence Rating of any character in a field that does not
			satisfy the Picture String's criteria.  The criteria is stored in the <i>PictureString</i>
			variable that is bound to the field.<br/><br/>

			Note: Fields with a status of '-1' (Hidden) are checked but this action will not return false if
			the value does not match the picture string criteria.<br/><br/>

			While not direct input parameters to this action, this action works with picture strings
			that are defined for a field.  See the <b>PIC_FormatFields</b>
			action for a list of all available picture string codes and information about the PictureString variable.<br/><br/>
			<e>
				<b>PIC_ValidateField()</b>
			</e>
		</h>
		<lvl>Field level only.</lvl>
		<ret>
			<b>False</b> if the field value does not satisfy the field's Picture String criteria.
			Otherwise <b>True.</b>
		</ret>
		<see>PIC_FormatFields, PIC_FilterFields, PIC_SetPictureCharacter</see>
	</ref>
	<ref id="PIC_SetPictureCharacter">
		<ap>
			Two comma separated parameters:<br/>
			1. The picture string identifier.  This must be a value between 0 through 9.<br/>
			2. A string of characters to associate with the picture string identifier (the first parameter).
		</ap>
		<h>
			Configures application specific picture strings.<br/><br/>
			In addition to the predefined character strings, custom picture strings can be configured.  The picture string
			values 0 through 9 can be configured to allow validations that are not covered by the predefined settings.<br/><br/>

			It is possible to configure your verify panel edit control to restrict keyboard entry based on picture strings
			when you use the '<i>PictureString</i>' field variable.  Note that only predefined picture strings work with
			the edit control.  Any custom picture strings created by PIC_SetPictureCharacater action will not cause the edit control
			to restrict user input.
			<e>
				<b>PIC_SetPictureCharacter("0,01")</b><br/>
				<b>PIC_SetPictureCharacter("1,0123")</b><br/>
				<b>PIC_SetPictureCharacter("2,-./")</b><br/>
				PIC_ApplyPictureString("0N21N2NN")<br/><br/>

				This example creates custom picture strings for 0, 1 and 2.  They are then used here to provide
				tighter control on the allowed input.  "0N21N2NN" format matches a typical 6 digit date specification
				like "01/07/67".<br/><br/>

				<b>PIC_SetPictureCharacter("0,01")</b><br/>
				<b>PIC_SetPictureCharacter("1,0123")</b><br/>
				<b>PIC_SetPictureCharacter("2,-./")</b><br/>
				PIC_ValidateField()<br/><br/>

				This example is the same as the one above it, the difference is that the picture string has
				been setup in the PictureString variable in Datacap Studio, so it is not seen here.
			</e>
		</h>
		<lvl>Any level.</lvl>
		<ret>
			<b>False,</b> if the parameter input is invalid.  Otherwise, <b>True.</b>
		</ret>
		<see>PIC_FormatFields, PIC_FilterFields, PIC_ApplyPictureString</see>
	</ref>
	<ref id="PIC_ReplaceBlankField">
		<ap>
			A character or string that will be placed into the field if it is blank.<br/>
		</ap>
		<h>
			If a field is blank, it replaces it with a single character.<br/><br/>
			If a field is empty or only contains spaces, it is replaced with the character or string that is passed in as a parameter.
			If the field is replaced with the input parameter, the confidence is changed to a low confidence of 1.
			<e>
				<b>PIC_ReplaceBlankField("~")</b>
			</e>
		</h>
		<lvl>
			Field level.
		</lvl>
		<ret>
			<b>False</b> if it is called at the wrong level or if the parameter is missing, otherwise <b>True.</b>
		</ret>
	</ref>
	<ref id="PIC_FilterFields">
		<ap>None.</ap>
		<h>
			Replaces a character and adjusts the confidence based on the <i>PictureString</i> defined for the field.<br/><br/>
			Lowers the Confidence Rating of any character in a field that does not satisfy the Picture String's criteria
			and replaces the problem character with a low confidence space. It is very similar to the FormatFields action but
      does not use alternative recognition characters.<br/><br/>

			This action has two roles.  If a character in the field does not match the picture string format defined
			for that field:<br/><br/>

			1. It replaces any "problem" characters with a space character and marked as low confidence.<br/><br/>

			2. It lowers the Confidence Rating of any character in a field that does not
			satisfy the Picture String's criteria.<br/><br/>

      3. Any alternative recognition characters are removed from the field after execution.<br/><br/>

			Note: This Action is recursive and will affect all child fields of the calling node.<br/><br/>

			While not direct input to this action, this action works with picture strings
			that are defined for a field.  See the <b>PIC_FormatFields</b>
			action for a list of all available picture string codes and information about the <i>PictureString</i> variable.<br/><br/>
			<e>
				rrSet("XxN,@F.PictureString")<br/>
				<b>PIC_FilterFields()</b><br/><br/>
				This example expects the current field to have the first character be either a alphabetic character or a digit,
				the second character can be an alphabetic character, digit or punctuation character and the remaining characters
				must only be digits.
			</e>
		</h>
		<lvl>All levels.</lvl>
		<ret>
			Always <b>True.</b>
		</ret>
		<see>PIC_FormatFields, PIC_ValidateField</see>
	</ref>
	<ref id="PIC_ApplyPictureString">
		<ap>
			The picture string to validate the field.
		</ap>
		<h>
			Validates the current field using a runtime <i>PictureString</i> as an argument.<br/><br/>
			Using the provided picture string, this action will test that each of the characters in the current field
			are allowed.  The provided picture string must be the same length or shorter than the data
			on the field.  If the picture string is shorter, then the last character of the picture
			string will be used to validate all remaining characters in the field.<br/><br/>

			See the help for action PIC_FormatFields for an overview of picture strings.
			Unlike PIC_FormatFields which uses the PictureString variable, PIC_ApplyPictureString
			accepts the picture string as a variable only.
			<e>
				PIC_SetPictureCharacter("0,01")<br/>
				PIC_SetPictureCharacter("1,0123")<br/>
				PIC_SetPictureCharacter("2,-./")<br/>
				<b>PIC_ApplyPictureString("0N21N2NN")</b><br/><br/>

				This example creates custom picture strings for 0, 1 and 2.  They are then used here to provide
				tighter control on the allowed input.  "0N21N2NN" format matches a typical 6 digit date specification
				like "01/07/67".
			</e>
		</h>
		<lvl>Field level.</lvl>
		<ret>
			<b>False,</b> if called at the wrong level, if the picture string is longer than the field value
			or if the field fails the picture string validation.  Otherwise, <b>True.</b>
		</ret>
	</ref>
</help></rrx>
<rrx namespace="POLR" src="c:\datacap\RRS\POLR.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="CallPOLR" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<br>
	</br>
	<br>
	</br>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[Dim SettingsFile ]]>
<![CDATA[
]]>
<![CDATA[Dim oObj]]>
<![CDATA[
]]>
<![CDATA[Dim oConn]]>
<![CDATA[
]]>
<![CDATA[Dim oCmd]]>
<![CDATA[
]]>
<![CDATA[Dim oRS]]>
<![CDATA[
]]>
<![CDATA[Dim oParam]]>
<![CDATA[
]]>
<![CDATA[Dim oPage]]>
<![CDATA[
]]>
<![CDATA[Dim bQuantityMatch]]>
<![CDATA[
]]>
<![CDATA[Dim bItemIDMatch]]>
<![CDATA[
]]>
<![CDATA[Dim bPriceMatch]]>
<![CDATA[
]]>
<![CDATA[Dim bWriteUnusedPOLines]]>
<![CDATA[
]]>
<![CDATA[Dim retn]]>
<![CDATA[
]]>
<![CDATA[Dim strConnection]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  Dim ParamAr]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   CallPOLR = TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ParamAr = SPLIT(strParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   if uBound(ParamAr) <> 1 then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Wrong number of parameters, expecting(ShowPOLR as TRUE or FALSE, ADODB PONum constant value).  Exiting")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   SettingsFile = DCO.Variable("Settings File")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Settings file:" & SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    retn = Pilot.GetProfileString("POLR","Qty","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[    If retn = "*" Then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Error 73 reading settings file.  Contact Administrator")]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("POLRresult") = "Error 73 reading settings file."]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[       If Retn = "1" Then]]>
<![CDATA[
]]>
<![CDATA[          bQuantityMatch = True]]>
<![CDATA[
]]>
<![CDATA[       Else]]>
<![CDATA[
]]>
<![CDATA[          bQuantityMatch = False]]>
<![CDATA[
]]>
<![CDATA[       End If         ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    retn = Pilot.GetProfileString("POLR","ItemID","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[    If retn = "*" Then]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("POLRresult") = "Error 74 reading settings file"]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Error 74 reading settings file.  Contact Administrator")]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[       If Retn = "1" Then]]>
<![CDATA[
]]>
<![CDATA[          bItemIDMatch = True]]>
<![CDATA[
]]>
<![CDATA[       Else]]>
<![CDATA[
]]>
<![CDATA[          bItemIDMatch = False]]>
<![CDATA[
]]>
<![CDATA[       End If         ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    retn = Pilot.GetProfileString("POLR","Price","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[    If retn = "*" Then]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("POLRresult") = "Error 75 reading settings file"]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Error 75 reading settings file.  Contact Administrator")]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[       If Retn = "1" Then]]>
<![CDATA[
]]>
<![CDATA[          bPriceMatch = True]]>
<![CDATA[
]]>
<![CDATA[       Else]]>
<![CDATA[
]]>
<![CDATA[          bPriceMatch = False]]>
<![CDATA[
]]>
<![CDATA[       End If         ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    retn = Pilot.GetProfileString("POLR","WriteUnusedPOLInes","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[    If retn = "*" Then]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("POLRresult") = "Error 76 reading settings file"]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Error 76 reading settings file.  Contact Administrator")]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[       If Retn = "1" Then]]>
<![CDATA[
]]>
<![CDATA[          bWriteUnusedPOLines = True]]>
<![CDATA[
]]>
<![CDATA[       Else]]>
<![CDATA[
]]>
<![CDATA[          bWriteUnusedPOLines = False]]>
<![CDATA[
]]>
<![CDATA[       End If         ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If Right(Pilot.Station,5) = "-Test" Then    'please do not edit the two lines below]]>
<![CDATA[
]]>
<![CDATA[       strConnection = Pilot.GetProfileString("Database","TestPODSN","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[       sSQL = Pilot.GetProfileString("Database","TestPOLookup","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[	  Else]]>
<![CDATA[
]]>
<![CDATA[       strConnection = Pilot.GetProfileString("Database","PODSN","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[       sSQL = Pilot.GetProfileString("Database","POLookup","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[	  End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    Writelog("PODSN:" & strConnection)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    'Smart Parameter]]>
<![CDATA[
]]>
<![CDATA[    sSmartParam=MetaWord(strConnection)]]>
<![CDATA[
]]>
<![CDATA[    If sSmartParam<>"" Then]]>
<![CDATA[
]]>
<![CDATA[      strConnection=sSmartParam]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    'FIPS decryption]]>
<![CDATA[
]]>
<![CDATA[    strIN=strConnection]]>
<![CDATA[
]]>
<![CDATA[    bRes = [securecall]strIN,strConnection[/securecall]   ]]>
<![CDATA[
]]>
<![CDATA[    If bRes=False Then Writelog("Value was not decrypted.")]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[    strConnection = FormatADOConn(strConnection)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Set oConn = CreateObject("ADODB.Connection")]]>
<![CDATA[
]]>
<![CDATA[    oConn.CursorLocation = 3   'added 11/26/2012 by Tom Stuart]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ 	  oConn.Open(strConnection)]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[ 	  If oConn.State <> 1 Then]]>
<![CDATA[
]]>
<![CDATA[ 	    Writelog("Unable to open connection to PO database.  Contact administrator.")]]>
<![CDATA[
]]>
<![CDATA[            CurrentObj.Variable("POLRresult") = "Unable to open PO Database."]]>
<![CDATA[
]]>
<![CDATA[ 	    Exit Function]]>
<![CDATA[
]]>
<![CDATA[ 	  End If   	 ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    Set oCmd = CreateObject("ADODB.Command")]]>
<![CDATA[
]]>
<![CDATA[   	Set oParam = oCmd.CreateParameter("PONum",cLng(ParamAr(1)),1,50)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    oCmd.CommandText = sSQL]]>
<![CDATA[
]]>
<![CDATA[    oCMD.CommandType = 1]]>
<![CDATA[
]]>
<![CDATA[    oCmd.ActiveConnection = oConn]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    oCmd.Parameters.Append(oParam)]]>
<![CDATA[
]]>
<![CDATA[    Dim oField]]>
<![CDATA[
]]>
<![CDATA[    Set oField=Nothing]]>
<![CDATA[
]]>
<![CDATA[    Set oField = CurrentObj.FindChild("PO_Number")]]>
<![CDATA[
]]>
<![CDATA[    if oField Is Nothing then]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("POLRresult") = "PO_Number field not found."]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Could not find PO_Number field.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[    if Trim(CurrentObj.FindChild("PO_Number").Text) = "" then]]>
<![CDATA[
]]>
<![CDATA[         CurrentObj.Variable("POLRresult") = "Missing PO Number"]]>
<![CDATA[
]]>
<![CDATA[         Writelog("PO number was blank.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[         Exit Function]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    oCmd(0).Value = CurrentObj.FindChild("PO_Number").Text]]>
<![CDATA[
]]>
<![CDATA[	    ]]>
<![CDATA[
]]>
<![CDATA[    Set oRS = oCmd.Execute]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If oRS.BOF Or oRS.EOF Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("PO was not found.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[          CurrentObj.Variable("POLRresult") = "PO was not found"]]>
<![CDATA[
]]>
<![CDATA[	  Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End If   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   Set oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Pilot.SaveData(oPage)]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If InStr(uCase(Pilot.DCOFile), uCase(Pilot.BatchDir)) > 0 Then]]>
<![CDATA[
]]>
<![CDATA[      DCO.Write(Pilot.DCOFile)]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      DCO.Write(Pilot.BatchDir & "\" & Pilot.DCOFile)]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[   Set oObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[   Set oObj = CreateObject("POLR.POLRClass")]]>
<![CDATA[
]]>
<![CDATA[   Writelog("POLR class instantiated")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If InStr(uCase(Pilot.DCOFile), uCase(Pilot.BatchDir)) > 0 Then]]>
<![CDATA[
]]>
<![CDATA[      oObj.Init(Pilot.DCOFile)]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[      oObj.Init(Pilot.BatchDir & "\" & Pilot.DCOFile)]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Init Done")   ]]>
<![CDATA[
]]>
<![CDATA[   oObj.SendPage(oPage.ID)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Sent pageID: " & oPage.ID)]]>
<![CDATA[
]]>
<![CDATA[   oObj.ClearPOLRVariables()]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Cleared POLR variables")]]>
<![CDATA[
]]>
<![CDATA[   oObj.WriteUnusedPOLines(bWriteUnusedPOLines)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Setting WriteUnusedPOLines: " & cStr(bWriteUnusedPOLines) )]]>
<![CDATA[
]]>
<![CDATA[   Call oObj.SetMatchCriteria(bQuantityMatch,bItemIDMatch,bPriceMatch)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Initial input done")]]>
<![CDATA[
]]>
<![CDATA[   retn = Pilot.GetProfileString("POLR","PriceTolerance","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[   If retn = "*" Then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Error 78 reading settings file.  Contact Administrator")]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("POLRresult") = "Error 78 reading settings file"]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[       If IsNumeric(retn) Then]]>
<![CDATA[
]]>
<![CDATA[          oObj.SetPriceTolerance(cDbl(retn))]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Set tolerance")]]>
<![CDATA[
]]>
<![CDATA[   oObj.SendRecordset(oRS)]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Sent Recordset")]]>
<![CDATA[
]]>
<![CDATA[   retn = Pilot.GetProfileString("POLR","SeparatorCharacter","*",SettingsFile)]]>
<![CDATA[
]]>
<![CDATA[   If retn = "*" Then]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Error 77 reading settings file.  Contact Administrator")]]>
<![CDATA[
]]>
<![CDATA[       CurrentObj.Variable("POLRresult") = "Error 77 reading settings file"]]>
<![CDATA[
]]>
<![CDATA[       Exit Function]]>
<![CDATA[
]]>
<![CDATA[   Else]]>
<![CDATA[
]]>
<![CDATA[       oObj.SetSeparatorCharacter(retn)  ]]>
<![CDATA[
]]>
<![CDATA[   End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Set separator char")]]>
<![CDATA[
]]>
<![CDATA[   if uCASE(ParamAr(0)) = "TRUE" then]]>
<![CDATA[
]]>
<![CDATA[     writelog("Ready to show form")]]>
<![CDATA[
]]>
<![CDATA[     oObj.ShowForm()]]>
<![CDATA[
]]>
<![CDATA[     writelog("Form done")]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   oObj.SavePOLRData()]]>
<![CDATA[
]]>
<![CDATA[   Writelog("Setting POLRresult: " & cStr(oObj.GEtUnmatchedNum))  ]]>
<![CDATA[
]]>
<![CDATA[   CurrentObj.Variable("POLRresult") = cStr(oOBj.GetUnmatchedNum) & " unmatched line item(s)."]]>
<![CDATA[
]]>
<![CDATA[   Writelog("POLRresult: " & CurrentObj.Variable("POLRresult"))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   Writelog("POLR done")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   bResult = oPage.Read(oPage.variable("DATAFILE"))]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[   oConn.Close]]>
<![CDATA[
]]>
<![CDATA[   Set oObj = Nothing ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'*****************************************************************************
' help.xml for POLR
'-----------------------------------------------------------------------------
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'*****************************************************************************
'
' Version 8.1.0.06 PHOFLE 05/25/2012
'  * New help xml 
'
'*****************************************************************************

]]>

<ref id="CallPOLR">
    <ap>
      The ADOBDB constant number for the PO number field.  When using bind variables, the data type
      of the PO Number is specified with this action.
    </ap>
    <h>
      This action is used to pre-match invoice line items with the PO prior to verify operator verification.
      The record set for the PO is retrieved using the information in the settings.ini.
      This calls the record set according to the DSN in the settings INI.
      PODSN and POLookup indicate how to obtain the record set.
      The record set is expected to be the line items for the PO for the current document and
      is keyed off of the PO number.  It then uses the POLR logic to perform the automatic matching.<br/><br/>
      
      NOTE: The TestPODSN and PODSN ini entries support smart parameters to allow for secure connection strings.
      <br/><br/>

      The settings ini file must contain values for these keys:<br/>
      [POLR]<br/>
      Qty=<br/>
      ItemID=<br/>
      Price=<br/>
      WriteUnusedPOLInes=<br/>
      PriceTolerance=<br/>
      SeparatorCharacter=<br/><br/>

      If the station name has a suffix of "-Test" then this key must exist:<br/>
      [Database]<br/>
      TestPODSN=<br/>
      TestPOLookup=<br/><br/>

      If the station name does not have a suffix of "-Test" then this key must exist:<br/>
      [Database]<br/>
      PODSN=<br/>
      POLookup=
      <e>
        <b>CallPOLR("200")</b>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>

  </ref>
  
  
</help>
</rrx>
<rrx namespace="ReArrangePages" src="c:\datacap\RRS\ReArrangePages.dll">

<net ref="ReArrangePages.SampleAction">
	<method name="RearrangePages">
		<p name="p1" type="PageTypes" qi="This is a example string type.  Smart parameters are supported.">
		</p>
		<ap>
<![CDATA[
]]>
<![CDATA[      Any additional parameter information can be placed here.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Put your action description here.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      More description here.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[MyAction("123")]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        This is the action example.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True,]]>
			</b>
<![CDATA[ if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
</net>
</rrx>
<rrx namespace="Recog_Shared" src="c:\datacap\RRS\Recog_Shared.dll">

<i ref="rrunner">
</i>
<i ref="cco2cco">
</i>
<g>
</g>
<af name="AnalyzeImage" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	AnalyzeImage = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then WriteLog("Skipping analysis. Object is not a page.") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim CCOFileName]]>
<![CDATA[
]]>
<![CDATA[  Dim ImageName]]>
<![CDATA[
]]>
<![CDATA[	ImageName = CurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	  If Not(FileMgr.FileExists(ImageName)) Then WriteLog("Skipping analysis. Image file doesn't exist") : Exit Function]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA['RTC 173458 - Logic added to get the extension of a file and then calculate the length of extension to get the corresponding cco file name.]]>
<![CDATA[
]]>
<![CDATA[ Dim aPath]]>
<![CDATA[
]]>
<![CDATA[ Dim realExt]]>
<![CDATA[
]]>
<![CDATA[ aPath =Split(ImageName,".")]]>
<![CDATA[
]]>
<![CDATA[ Dim l]]>
<![CDATA[
]]>
<![CDATA[ l=UBound(aPath)]]>
<![CDATA[
]]>
<![CDATA[ 'Get the last item of an array which will be the real extenstion of an image.]]>
<![CDATA[
]]>
<![CDATA[ realExt = aPath(l)]]>
<![CDATA[
]]>
<![CDATA[ WriteLog("extension for current object image name is:  " + realExt)]]>
<![CDATA[
]]>
<![CDATA[  'Initially it was hardcoded to 3 considering image extension to be always 3 characters. ]]>
<![CDATA[
]]>
<![CDATA[  'Modified it with realExt which will work for any number of characters in extension.]]>
<![CDATA[
]]>
<![CDATA[  CCOFileName = Left(ImageName, Len(ImageName)-Len(realExt))&"cco"]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("----- Analysis of: "& ImageName & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim theTime, oCCO, bSaved]]>
<![CDATA[
]]>
<![CDATA[	theTime = Timer]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If g_bUseDCOPRocessor Then]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If Not IsAlive(goDCOProcessor) Then ]]>
<![CDATA[
]]>
<![CDATA[            UseOutOfProcessRecog FALSE,FALSE,"TRUE"]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If goDCOProcessor is nothing then ]]>
<![CDATA[
]]>
<![CDATA[			    writelog "DCOProcessor object is not initialized"]]>
<![CDATA[
]]>
<![CDATA[			    nTaskStatus=retAbort]]>
<![CDATA[
]]>
<![CDATA[	    Else]]>
<![CDATA[
]]>
<![CDATA[			    Set oCCO = goDCOProcessor.Process("CCO._CCOCreator", "Analyze", ImageName)]]>
<![CDATA[
]]>
<![CDATA[			    bSaved = oCCO.Save(CCOFileName)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			    If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[				    Writelog("n: " & Err.Number & " ; m:" & Err.Message) ]]>
<![CDATA[
]]>
<![CDATA[			    End if]]>
<![CDATA[
]]>
<![CDATA[		  End If]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		  Set oCCO = CCOCreator.Analyze(ImageName)]]>
<![CDATA[
]]>
<![CDATA[		  bSaved = oCCO.Save(CCOFileName)]]>
<![CDATA[
]]>
<![CDATA[		  Set oCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("CCOFILE")=FileMgr.GetFileName(CCOFileName)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Analysis time: " & CCur(Timer - theTime))]]>
<![CDATA[
]]>
<![CDATA[	AnalyzeImage = True 	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetOutOfProcessRecogTimeout" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    SetOutOfProcessRecogTimeout = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[        g_lOutOfProcessTimeout = CLng(StrParam) * 1000]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.Variable("OutOfProcessTimeout") = g_lOutOfProcessTimeout]]>
<![CDATA[
]]>
<![CDATA[        Writelog("OutOfProcessTimeout set to '" & g_lOutOfProcessTimeout & "' Using SetOutOfProcessRecogTimeout disables automatic retry mode.")]]>
<![CDATA[
]]>
<![CDATA[        g_UseLegacyRetryMode = true]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Invalid parameter type passed. This action expects a numeric value."]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="RecogContinueOnFailure" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    RecogContinueOnFailure = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If lcase(StrParam) = "true" OR lcase(StrParam) = "false" Then]]>
<![CDATA[
]]>
<![CDATA[        g_bContinueOnFailure = cbool(strParam)]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Invalid parameter type passed. This action expects a boolean value."]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetRecogFailureRetryDelay" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    SetRecogFailureRetryDelay = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If IsNumeric(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[        g_iRecogFailureRetryDelay = CInt(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Invalid parameter type passed. This action expects a numeric value."]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<f name="SetupAutomaticRetry" access="public">
	<p name="retryCount">
	</p>
	<p name="timeout">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  retryCount = Trim(MetaWord(retryCount))]]>
<![CDATA[
]]>
<![CDATA[  timeout = Trim(MetaWord(timeout))]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  If IsNumeric(retryCount) Then        ]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.Variable("hr_EngineRetry") = retryCount]]>
<![CDATA[
]]>
<![CDATA[        Writelog("hr_EngineRetry set to " & retryCount)]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Invalid parameter type passed. The retryCount '" & retryCount & "' is not numeric.")]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If IsNumeric(timeout) Then        ]]>
<![CDATA[
]]>
<![CDATA[        CurrentObj.Variable("hr_EngineTimeout") = timeout]]>
<![CDATA[
]]>
<![CDATA[        Writelog("hr_EngineTimeout set to " & timeout)]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Invalid parameter type passed. The timeout '" & timeout & "' is not numeric.")]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SetupAutomaticRetry = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<af name="SetFullPageRecogArea" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	SetFullPageRecogArea = False]]>
<![CDATA[
]]>
<![CDATA[	If StrParam = "" Or Not IsNumeric(StrParam) Or Cdbl(StrParam)< 0 Or Cdbl(StrParam) > 1 Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("SetFullPageRecogArea: Parameter is invalid.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("sr_FullPageRecogArea") = Cdbl(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	Err.Clear]]>
<![CDATA[
]]>
<![CDATA[	SetFullPageRecogArea = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CCONormalization_OFF" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[ CCONormalization_OFF = true]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ If CurrentObj.ObjectType <> 2 Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Warning! This action is set to run only at the page level."]]>
<![CDATA[
]]>
<![CDATA[ Else]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable("v_ccoNormOFF") = 1 ]]>
<![CDATA[
]]>
<![CDATA[ End If]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFingerprintRecogPriority" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	If (StrParam = "true" Or StrParam = "1") Then]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("s_srCreateCCO") = "1"]]>
<![CDATA[
]]>
<![CDATA[		goSnapper.m_bRecogCreateCCO = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("s_srCreateCCO") = "0"]]>
<![CDATA[
]]>
<![CDATA[		goSnapper.m_bRecogCreateCCO = False]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Err.Clear]]>
<![CDATA[
]]>
<![CDATA[	SetFingerprintRecogPriority = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsBlankPage" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	IsBlankPage = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[	If StrParam = "" Or Not IsNumeric(StrParam) Then WriteLog("Skipping. Parameter isn't an integer"): Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = CLng(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog "Invalid parameter entered, value must be between 0 and 2,147,483,647. Exiting."]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("IsBlankPage : Exiting. Image file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- IsBlankPage of: "&CurrentObj.ImageName&" -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim strCCOFile]]>
<![CDATA[
]]>
<![CDATA[	strCCOFile = Left(CurrentObj.ImageName, Len(CurrentObj.ImageName)-3)&"cco"]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(strCCOFile)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("IsBlankPage skipping. CCO file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	Dim oCCO]]>
<![CDATA[
]]>
<![CDATA[	Set oCCO = CCOCreator.Load(strCCOFile )]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Count words]]>
<![CDATA[
]]>
<![CDATA[	Dim i, nWord]]>
<![CDATA[
]]>
<![CDATA[	For i=1 To oCCO.count]]>
<![CDATA[
]]>
<![CDATA[		nWord = nWord + oCCO.item(i).count ]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (nWord<=StrParam) Then IsBlankPage = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCCO = Nothing ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="RotateTio" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	RotateTio = False]]>
<![CDATA[
]]>
<![CDATA[	StrParam = LCase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If (StrParam = "true") Then]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("s_srRotateTIO") = CInt(True)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("s_srRotateTIO") = CInt(False)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	RotateTio = True ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CreateTextFile" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[		CreateTextFile = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim oFile]]>
<![CDATA[
]]>
<![CDATA[	Dim oCCO]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(CurrentObj.ImageName)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("CreateTextFile skipping. Image file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- CreateTextFile for: "&CurrentObj.ImageName&" -----")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'RTC 172685 - Logic added to get the extension of a file and then calculate the length of extension to get the corresponding cco file name.]]>
<![CDATA[
]]>
<![CDATA[	 Dim aPath]]>
<![CDATA[
]]>
<![CDATA[	 Dim realExt]]>
<![CDATA[
]]>
<![CDATA[	 aPath =Split(CurrentObj.ImageName,".")]]>
<![CDATA[
]]>
<![CDATA[	 Dim l]]>
<![CDATA[
]]>
<![CDATA[	 l=UBound(aPath)]]>
<![CDATA[
]]>
<![CDATA[	 'Get the last item of an array which will be the real extenstion of an image.]]>
<![CDATA[
]]>
<![CDATA[	 realExt = aPath(l)]]>
<![CDATA[
]]>
<![CDATA[	 WriteLog("extension for current object image name is:  " + realExt)]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[	Dim strCCOFile]]>
<![CDATA[
]]>
<![CDATA[  'Initially it was hardcoded to 3 considering image extension to be always 3 characters. ]]>
<![CDATA[
]]>
<![CDATA[  'Modified it with realExt which will work for any number of characters in extension.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	strCCOFile = Left(CurrentObj.ImageName, Len(CurrentObj.ImageName)-Len(realExt))&"cco"]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("strCCOFile :" +strCCOFile)]]>
<![CDATA[
]]>
<![CDATA[	If Not(FileMgr.FileExists(strCCOFile)) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("CreateTextFile skipping. CCO file doesn't exist")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCCO = CCOCreator.Load(strCCOFile )]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set l_sStreamUTF8 = CreateObject("ADODB.Stream")]]>
<![CDATA[
]]>
<![CDATA[	With l_sStreamUTF8]]>
<![CDATA[
]]>
<![CDATA[    .Open        ]]>
<![CDATA[
]]>
<![CDATA[		.Type = 2 'text]]>
<![CDATA[
]]>
<![CDATA[    .LineSeparator = -1 'crlf]]>
<![CDATA[
]]>
<![CDATA[		.CharSet = "UTF-8"        ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	  'Recog results	]]>
<![CDATA[
]]>
<![CDATA[	  Dim Line, i, j]]>
<![CDATA[
]]>
<![CDATA[	  For i=1 To oCCO.count]]>
<![CDATA[
]]>
<![CDATA[		  For j=1 To oCCO.item(i).count]]>
<![CDATA[
]]>
<![CDATA[			  Line = Line & oCCO.item(i).item(j).value & " " ]]>
<![CDATA[
]]>
<![CDATA[		  Next]]>
<![CDATA[
]]>
<![CDATA[		  .WriteText Line,1 'append line separator at end of string]]>
<![CDATA[
]]>
<![CDATA[		  Line = ""]]>
<![CDATA[
]]>
<![CDATA[	  Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	  .SaveToFile Left(CurrentObj.ImageName, Len(CurrentObj.ImageName)-Len(realExt)) & "txt", 2 ' save to file create/overwrite existing]]>
<![CDATA[
]]>
<![CDATA[	  .Close  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	End With]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set l_sStreamUTF8 = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CreateTextFile = True  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SnapCCOtoDCO" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	SnapCCOtoDCO = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType <> 2 And CurrentObj.ObjectType <> 3) Then Exit Function	'must be a page or a field]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim oCCO]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- SnapCCO2DCO for: " & CurrentObj.ID & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim theTime]]>
<![CDATA[
]]>
<![CDATA[	theTime = Timer]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	goSnapper.SnapCCOtoDCO CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Snapping Time: " & CCur(Timer - theTime))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[	SnapCCOtoDCO = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetAdjustFieldToChars" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim bStrParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetAdjustFieldToChars = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam=replace(StrParam," ","")]]>
<![CDATA[
]]>
<![CDATA[  StrParam=ucase(trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  bStrParam = cbool(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[    Err.Clear]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Invalid Parameter '" & StrParam & "' Must be 'True' or 'False'")]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    goSnapper.m_bDoPostProcessSnap=bStrParam]]>
<![CDATA[
]]>
<![CDATA[    Writelog("SetAdjustFieldToChars is set to '" & cstr(goSnapper.m_bDoPostProcessSnap) & "'")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SnapDCOtoCCO" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	SnapDCOtoCCO = False]]>
<![CDATA[
]]>
<![CDATA[	If (CurrentObj.ObjectType<>2) Then WriteLog("SnapDCOtoCCO: Object is not a page.") : Exit Function	'must be a page]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("----- SnapDCOtoCCO for: " & CurrentObj.ImageName & " -----")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	goSnapper.SnapDCOtoCCO CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SnapDCOtoCCO = True]]>
<![CDATA[
]]>
	</g>
</af>
<f name="SnapFieldtoChars" access="public">
	<p name="Smartparam" type="string">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[	Dim oField]]>
<![CDATA[
]]>
<![CDATA[	Dim RemSet]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SnapFieldtoChars = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oField = DcoNav(Smartparam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(oField) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Valid DCO not found.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If oField.ObjectType<>3 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("DCO must a field")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	RemSet = goSnapper.m_bDoPostProcessSnap ]]>
<![CDATA[
]]>
<![CDATA[	goSnapper.m_bDoPostProcessSnap = True ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SnapFieldtoChars = goSnapper.CorrectFieldPosition(oField)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oField = Nothing	]]>
<![CDATA[
]]>
<![CDATA[      goSnapper.m_bDoPostProcessSnap = RemSet]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</f>
<f name="RecogOMRThreshold" access="public">
	<p name="threshold">
	</p>
	<p name="background">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Dim i]]>
<![CDATA[
]]>
<![CDATA[	Dim oChar]]>
<![CDATA[
]]>
<![CDATA[	Dim ImageCtrl]]>
<![CDATA[
]]>
<![CDATA[	Dim ImageFile]]>
<![CDATA[
]]>
<![CDATA[	Dim nLeft]]>
<![CDATA[
]]>
<![CDATA[	Dim nTop]]>
<![CDATA[
]]>
<![CDATA[	Dim nRight]]>
<![CDATA[
]]>
<![CDATA[	Dim nBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim area]]>
<![CDATA[
]]>
<![CDATA[	Dim PixelCount]]>
<![CDATA[
]]>
<![CDATA[	Dim BlackPercent]]>
<![CDATA[
]]>
<![CDATA[	Dim Bl]]>
<![CDATA[
]]>
<![CDATA[	Dim nRet]]>
<![CDATA[
]]>
<![CDATA[	Dim HCMarkVal]]>
<![CDATA[
]]>
<![CDATA[	Dim TextVal]]>
<![CDATA[
]]>
<![CDATA[	Dim ConfVal]]>
<![CDATA[
]]>
<![CDATA[	Dim WhiteCount]]>
<![CDATA[
]]>
<![CDATA[	Dim DensityString]]>
<![CDATA[
]]>
<![CDATA[	Dim BoxCoordinates]]>
<![CDATA[
]]>
<![CDATA[	Dim fThreshPct]]>
<![CDATA[
]]>
<![CDATA[	Dim fBkgndPct]]>
<![CDATA[
]]>
<![CDATA[	Dim darkestPct]]>
<![CDATA[
]]>
<![CDATA[	Dim darkestBox]]>
<![CDATA[
]]>
<![CDATA[	Dim nchecked]]>
<![CDATA[
]]>
<![CDATA[	Dim bCorrected]]>
<![CDATA[
]]>
<![CDATA[  Dim slocale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	RecogOMRThreshold = False]]>
<![CDATA[
]]>
<![CDATA[	bCorrected = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType <> 3 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("This action must operate on a field.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.Variable("d_sr") = "1" Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog ( "Field '" & CurrentObj.ID & "' OMR recognition is skipped by the settings.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  slocale = DetermineLocale ' in rrunner]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  threshold = Trim(threshold)]]>
<![CDATA[
]]>
<![CDATA[  background = Trim(background)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  threshold = DCGlobalCurrency.NormalizeNumber(threshold,slocale)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(threshold) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("First argument threshold must be numeric, representing the percentage of black to call the box marked.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		fThreshPct = Cdbl(threshold)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  background = DCGlobalCurrency.NormalizeNumber(background,slocale)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Not IsNumeric(background) Then]]>
<![CDATA[
]]>
<![CDATA[		' should also check 0 <= bkgnd <= thresh <= 100)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Second Argument background must be numeric, representing the Background percentage to ignore. Exiting")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		fBkgndPct = Cdbl(background)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If fThreshPct < 0 Or fThreshPct > 100 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Threshold must be between 0 and 100. Exiting")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If fBkgndPct < 0 Or fBkgndPct > fThreshPct Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Background percentage must be between 0 and threshold.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.NumOfChildren = 0 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("This field has no OMR Boxes defined.  Exiting")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set ImageCtrl = CreateObject("DCImage.DCImageCtrl.1")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	imagefile = CurrentObj.Parent.Variable("IMAGEFILE")]]>
<![CDATA[
]]>
<![CDATA[	ImageCtrl.FileName = imagefile]]>
<![CDATA[
]]>
<![CDATA[	If ImageCtrl.Filename = "" Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Cannot load image: " & imagefile)]]>
<![CDATA[
]]>
<![CDATA[		nTaskStatus=retAbort ''Set the task to abort]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	bl = Space(28)]]>
<![CDATA[
]]>
<![CDATA[  b2 = Space(4)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	HCMarkVal = fThreshPct + fThreshPct - fBkgndPct]]>
<![CDATA[
]]>
<![CDATA['	Writelog("High Confidence mark set to: " & CStr(HCMarkVal))]]>
<![CDATA[
]]>
<![CDATA['	Writelog("OMR Results: " & CurrentObj.Parent.ID & "-" & CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA['	Writelog("Checkbox    Adjusted Coordinates              Area   Count        Density")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	darkestPct = 0]]>
<![CDATA[
]]>
<![CDATA[	nchecked = 0]]>
<![CDATA[
]]>
<![CDATA[	ImageCtrl.GetImageInfo Width, Height, DPI]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Field ID: '" &  CurrentObj.ID & "' Page ID: '" & CurrentObj.Parent.ID  & "'")  ]]>
<![CDATA[
]]>
<![CDATA[	Writelog("OMR Zone       Coordinates          Area   PixelCount   Percent Blk") ]]>
<![CDATA[
]]>
<![CDATA[	Writelog("--------   -------------------      ----   ----------   -----------")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For i = 0 To CurrentObj.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[		Set oChar = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		nRet= oChar.GetPosition(nLeft,nTop,nRight,nBottom)]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Raw coordinates: Left=" & nLeft & " Top=" & nTop & " Right=" & nRight & " Bottom=" & nBottom)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If (nLeft < 0) Then nLeft = 0 : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[		If (nTop < 0) Then nLeft = 0 : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[		If (nRight < nLeft) Then nRight = nLeft : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[		If (nBottom < nTop) Then nBottom = nTop : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If (nLeft > Width) Then nLeft = Width : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[		If (nTop > Height) Then nLeft = Height : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[		If (nRight > Width) Then nRight = Width : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[		If (nBottom > Height) Then nBottom = Height : bCorrected = True]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[		area = (nRight - nLeft) * (nBottom - nTop)]]>
<![CDATA[
]]>
<![CDATA[		If (area <= 0) Then]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Invalid field bounds: Left=" & nLeft & " Top=" & nTop & " Right=" & nRight & " Bottom=" & nBottom)]]>
<![CDATA[
]]>
<![CDATA[			Set ImageCtrl = Nothing]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		PixelCount = ImageCtrl.NumOfPixels(nLeft,nTop,nRight,nBottom,1)]]>
<![CDATA[
]]>
<![CDATA[		BoxCoordinates = left(CStr(nLeft)+b2,4) & "," & left(CStr(nTop)+b2,4) & "," & left(CStr(nRight)+b2,4) & "," & CStr(nBottom)]]>
<![CDATA[
]]>
<![CDATA[		BlackPercent = PixelCount/Area * 100  		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Left(b2 & CStr(i+1) & bl,12) & Left(BoxCoordinates & bl,20) & Right(bl & CStr(Area),8) & Right(bl & CStr(PixelCount),10) & Left(bl,10) & CStr(BlackPercent)) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If BlackPercent >= fThreshPct Then ]]>
<![CDATA[
]]>
<![CDATA[			TextVal = TextVal & "1"]]>
<![CDATA[
]]>
<![CDATA[			nchecked = nchecked + 1]]>
<![CDATA[
]]>
<![CDATA[			If BlackPercent > darkestPct Then]]>
<![CDATA[
]]>
<![CDATA[				darkestPct = BlackPercent]]>
<![CDATA[
]]>
<![CDATA[				darkestBox = i]]>
<![CDATA[
]]>
<![CDATA[			End If		]]>
<![CDATA[
]]>
<![CDATA[		Else ]]>
<![CDATA[
]]>
<![CDATA[			TextVal = TextVal & "0"]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		DensityString=DensityString & Chr(CInt(BlackPercent) + 48)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If bCorrected Then]]>
<![CDATA[
]]>
<![CDATA[			Confval = ConfVal & "0"]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			If BlackPercent > fBkgndPct And BlackPercent < HcMarkVal Then]]>
<![CDATA[
]]>
<![CDATA[				Confval = ConfVal &  "4"]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[				ConfVal = ConfVal & "9"]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Next 'i]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.Variable("MultiPunch") <> "1" And nchecked > 1 Then]]>
<![CDATA[
]]>
<![CDATA[		TextVal = ""]]>
<![CDATA[
]]>
<![CDATA[		ConfVal = ""]]>
<![CDATA[
]]>
<![CDATA[		' multiple marks in single punch field - choose darkest and lower confidence]]>
<![CDATA[
]]>
<![CDATA[		For i = 0 To CurrentObj.NumOfChildren - 1]]>
<![CDATA[
]]>
<![CDATA[			If i = darkestBox Then]]>
<![CDATA[
]]>
<![CDATA[				TextVal = TextVal & "1"]]>
<![CDATA[
]]>
<![CDATA[				Confval = ConfVal & "1"]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[				TextVal = TextVal & "0"]]>
<![CDATA[
]]>
<![CDATA[				Confval = ConfVal & "1"]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Next 'i]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text = TextVal]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.ConfidenceString = ConfVal]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("DensityString") = DensityString  ]]>
<![CDATA[
]]>
<![CDATA[	Writelog("  ") ]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Field Value:       " & CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ConfidenceString:  " & CurrentObj.ConfidenceString)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("DensityString:     " & DensityString)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("  ")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Set ImageCtrl = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	RecogOMRThreshold = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<af name="UseOutOfProcessRecog" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  UseOutOfProcessRecog = false]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog "Current DCOProcessor state: " & g_bUseDCOPRocessor]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If LCase(Trim(strParam)) <> "true" And LCase(strParam) <> "false" Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Invalid parameter passed: '" & strParam & "'."]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.Variable("UseOutOfProcessRecog") = strParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    g_bUseDCOPRocessor = strParam]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If g_bUseDCOPRocessor then]]>
<![CDATA[
]]>
<![CDATA[        On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        If Not IsAlive(goDCOProcessor) Then ]]>
<![CDATA[
]]>
<![CDATA[	          Set goDCOProcessor = CreateObject("Datacap.DCOProcessor")]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            If g_lOutOfProcessTimeout = 0 Then]]>
<![CDATA[
]]>
<![CDATA[                goDCOProcessor.RunTimeout = g_lDefaultOutOfProcessTimeout 'default to 185 seconds ]]>
<![CDATA[
]]>
<![CDATA[            Else]]>
<![CDATA[
]]>
<![CDATA[                goDCOProcessor.RunTimeout = g_lOutOfProcessTimeout]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            goDCOProcessor.StartTimeout = g_DCOProcessorStartTimeout]]>
<![CDATA[
]]>
<![CDATA[            goDCOProcessor.NewObjectTimeout =  g_DCOProcessorNewObjectTimeout]]>
<![CDATA[
]]>
<![CDATA[            goDCOProcessor.FinalizersTimeout = g_DCOProcessorFinalizersTimeout]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[            If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[                Writelog "DCOProcessor could not be initialized: " & Err.Description]]>
<![CDATA[
]]>
<![CDATA[                g_bUseDCOPRocessor = False]]>
<![CDATA[
]]>
<![CDATA[                Err.Clear]]>
<![CDATA[
]]>
<![CDATA[            Else]]>
<![CDATA[
]]>
<![CDATA[                Writelog "DCOProcessor has been initialized."]]>
<![CDATA[
]]>
<![CDATA[            End If]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        If IsALive(goDCOProcessor) Then            ]]>
<![CDATA[
]]>
<![CDATA[            Call StopDCOProcessor            ]]>
<![CDATA[
]]>
<![CDATA[        End If]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog "Updated DCOProcessor state: " & g_bUseDCOPRocessor]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	UseOutOfProcessRecog=true]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<help>
  <![CDATA[
'****************************************************
' recog_shared.rrx - a description of the library

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2016 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.

'****************************************************

]]>

<ref id="action_name" >
  <ap>None.</ap>  
  <h>
    Help description
    <e>
      <b>action_name()</b>
    </e>
  </h>
  <lvl>DCO level.</lvl>
  <ret>
    <b>False</b> if it fails some condition.  Otherwise, <b>True.</b>
  </ret>
</ref>

 


  <ref id="AnalyzeImage" qi="Converts the Image file (.tif) that represents the current page to a Fingerprint file (.cco) file for the page.">
    <ap>None.</ap>
    <h>
      This action converts the Image file (.tif) that represents the current
      page to a CCO file for the page.<br/><br/>

      A ruleset with this action should be bound to a <b>Page</b>object that represents an
      application's source page. <br/><br/>

      The action is not required if full-page recognition takes place using actions such as
      <b>RecognizePageOCR_S</b>or<b>RecognizePageICR_C</b>.
      <e>
        <b>AnalyzeImage()</b><br/>
        RotateImage()<br/>
        SetProblemValue(0.5)<br/>
        SetSearchArea(0.5)<br/>
        FindFingerprint(True)<br/><br/>

        This sequence generates a CCO file for the current page, then checks to see if rotation of the
        image is needed. Finally, the sequence attempts to match the current page with a fingerprint.
        (For more about the matching process, see the descriptions of the <b>AutoDoc</b>actions.)
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>False</b> if the ruleset with this action is not bound to a <b>Page</b>object of the
      Document Hierarchy. Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="SetOutOfProcessRecogTimeout" qi="Sets the number of seconds to wait before determining that a recognition action is no longer running properly.">
    <ap>
      <i>Numeric</i>value indicating the number of seconds to wait to determine that a
      recognition action has stalled or exited.
    </ap>
    <h>
      Engines ICR/C and OCR/SR have an automatic retry feature which will automatically retry a failed recognition
      operation.  If SetOutOfProcessRecogTimeout is called the automatic retry feature will be disabled,
      and any retry of actions must then be handled with rulesets setup to retry operations under the appropriate conditions.
      It is recommended to use use the automatic retry feature, which can be controlled with the
      action SetupAutomaticRetry making special rules handling unnecessary.<br/><br/>

      SetOutOfProcessRecogTimeout sets the number of seconds to wait before assuming a recognition action is no longer
      running correctly.  When the timeout is reached, the recognition process is removed from memory.
      The <b>SetOutOfProcessRecogTimeout</b>action only has an effect if out-of-process recognition is
      enabled by the use of a<b>UseOutOfProcessRecog</b>action.<br/><br/>

      If a recognition action does not complete within the specified number of seconds indicated by
      a <b>SetOutOfProcessRecogTimeout</b>action or a <b>SetEngineTimeout</b>action, it is assumed
      that the recognition engine has encountered a severe error, is removed from memory, and
      recognition will automatically be re-started one more time.  If the recognition action completes
      successfully within the specified time on either the first or second attempt, that recognition
      action will be successful.  If the recognition action does not complete by the specified time
      on the second attempt, the recognition action will be set to abort
      if <b>RecogContinueOnFailure(False)</b>was used.<br/><br/>

      If <b>SetOutOfProcessRecogTimeout</b>is not called, the default value of 300 seconds will be
      used.  In normal conditions, the default value will be sufficient and does not need to be
      changed.  This value will need to be increased only if a single page consistently takes more
      than 5 minutes to complete, which is a very atypical situation.  The programmer can choose
      to shorten this time to reduce the time to detect failures earlier, provided there is time
      left to perform recognition in "worst case" scenarios.  For best results, this timeout should
      be set the same or longer than the value specified in a <b>SetEngineTimeout</b>action.<br/><br/>

      When a <b>SetOutOfProcessRecogTimeout</b>action is called, the setting will be in effect for the
      entire batch, allowing you to set the value once, then call as many recognition actions as
      necessary.<br/><br/>

      This is a legacy action for action libraries that do not support automatic retry.
      Action libraries that support the automatic retry feature will automatically configure the
      out-of-process recognition timeout setting so the action SetOutOfProcessRecogTimeout
      will not need to be called.
      <e>
        <b>SetOutOfProcessRecogTimeout(300)</b><br/>
        UseOutOfProcessRecog(True)<br/>
        RecognizePageOCR_S()<br/>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>SetupAutomaticRetry</see>
  </ref>

  <ref id="RecogContinueOnFailure" access="public" qi="Determines if a batch will abort if page or field recognition fails.">
    <ap>
      <i>String</i>value: True or False.<br/><br/>
      <b>1.</b> True: a recognition failure will not be automatically re-tried if recognition fails. The batch will continue and the application can use the value assigned to the <b>RecogStatus</b>variable to decide how to proceed on success or failure of recognition. (For more about the <b>RecogStatus</b>variable, access Information about the <b>RecogContinueOnFailure</b>action.) <br/>
      <b>2.</b> False: causes the batch to abort if a full-page or field-level recognition action fails. If <b>UseOutOfProcessRecog</b>is enabled, the batch will abort only if the second recognition attempt fails.
    </ap>
    <h>
      This action determines if a batch will abort if page or field recognition failed.<br/><br/>

      Please note: If <b>RecogContinueOnFailure</b>is not specifically called, the default <b>True</b> value
      is used. When the value is false, this means that batches will abort if recognition fails.
      When the value is True, the batch will not abort when recognition fails.<br/><br/>

      After a recognition operation is complete, the variable <b>RecogStatus</b>is set to indicate the
      success or failure of recognition. If page-level recognition is being performed, RecogStatus values of 0, 1 or 2 are considered successful.
      The full list of values includes:<br/><br/>

      0 - Success<br/>
      1 - Recognition was successful but there are no results...the page was empty.<br/>
      2 - Recognition was successful and additional processing such as "RotateImage" was performed.<br/>
      4 - Failure: the recognition engine cannot be instantiated.<br/>
      5 - Failure: the recognition engine timed out (the time specified by the <b>SetEngineTimeout</b>action has expired.<br/>
      6 - Failure: could not load image to engine.<br/>
      7 - Failure: could not load image to engine (path not found).<br/>
      8 - Failure: image could not be rotated.<br/>
      10 - Failure: general failure occurred and recognition was not completed.<br/>
      <br/>
      It is not necessary to call this action for libraries that have the automatic retry feature.
      Action libraries that use the automatic retry feature default this setting to <b>true.</b><br/><br/>
      <e>
        <b>RecogContinueOnFailure(True)</b><br/>
        RecognizePageOCR_S()<br/>
        <br/>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>SetupAutomaticRetry</see>
  </ref>


  <ref id="SetRecogFailureRetryDelay" qi="Sets the number of seconds to wait before restarting a failed recognition action.">
    <ap>
      <i>Numeric </i> value indicating the number of seconds to wait before restarting a failed recognition
      action, and automatically re-activating recognition one more time.
    </ap>
    <h>
      This action sets the number of seconds to wait after the time specified in either a <b>SetOutOfProcessRecogTimeOut</b>action
      or a <b>SetEngineTimeout</b>action has expired. Once either timeout has occurred, the recognition engine
      will be removed from memory: the action will then wait the additional time specified by the <b>SetRecogFailureRetryDelay</b>action
      to be sure that the engine has exited before restarting recognition. <b>SetRecogFailureRetryDelay</b>only
      has an effect if out-of-process recognition has been enabled by a <b>UseOutOfProcessRecog</b>action.
      <br/><br/>
      If a recognition action does not complete within the number of seconds specified by
      a <b>SetOutOfProcessRecog</b>action or a <b>SetEngineTimeout</b>action, it is assumed that the
      recognition engine has encountered a severe error - and that recognition will automatically be
      restarted one more time. If the recognition action completes successfully within the specified
      time on either the first or second attempt, that recognition action will be successful. If the
      recognition action does not complete by the specified time on the second attempt, the
      recognition action will be set to abort if <b>RecogContinueOnFailure(False)</b>has been
      used.<br/><br/>

      If <b>SetRecogFailureRetryDelay</b>is not specifically called, the default value of 10
      seconds is used. Under normal conditions, the default value will be sufficient and does
      not need to be changed. This value needs to be increased only if a log indicates that errors
      are occurring when attempting to re-start a failed recognition action, and the problem can be
      diagnosed by setting the RecogStatus to "4".<br/><br/>

      When <b>SetRecogFailureRetryDelayDelay</b>is called, its setting will be in effect for the
      entire batch. This allows you to set the value once, and call as many recognition actions
      as necessary.
      <e>
        <b>SetRecogFailureRetryDelay(10)</b><br/>
        UseOutOfProcessRecog(True)<br/>
        RecognizePageOCR_S()<br/>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>


  <ref id="SetupAutomaticRetry" qi="Changes the default values for actions that support automatic retry.">
    <p id="retryCount"/>
    <p id="timeout"/>
    <ap>
      1. <b>retryCount:</b> The number of times a failed action should be retried.  If this action is not called,
      the default retryCount is 1.<br/><br/>

      2. <b>timeout:</b> The number of seconds to wait for an action to complete before retrying.  If this action
      is not called, the default timeout is 180 seconds.  Note that this is the minimum time that will be used.
      Depending on the specific nature of the failure, it may be several seconds longer before the
      current operation is stopped and retried.<br/><br/>

      Smart parameters are supported.
    </ap>
    <h>
      This action changes the default values for the number of retries and the time to wait for an action to complete, for
      actions and action libraries that support automatic retry. Actions that support automatic retry use these
      values to control the retry logic.  To see if an action library supports automatic retry, check
      the help for the library.<br/><br/>

      The intent of the automatic retry is to provide transparent recovery for the rare situation where an action
      may not terminate.  For example, if an image is being recognized and something about the image is peculiar or invalid and
      causes the recognition engine to never terminate the recognition step.  Sometimes, retrying these failures
      will work successfully on the second attempt.<br/><br/>

      The automatic retry mechanism will wait
      for the number of seconds specified, and if the action does not complete, will stop the current operation and
      retry it.  If the action is successful after the automatic retry, the action will complete and
      operation will continue as normal.  If the action is not successful,
      failure will be conveyed using the method as documented in the help for the action that failed.<br/><br/>

      While the default time is long enough in most situations, it is possible that there may be times when
      the default timeout should be changed.  For example, if an application is processing atypical documents
      that complete successfully but in a time longer than the default time.  In this kind of situation,
      it makes sense to use this action to increase the expected length of time for an operation to complete.<br/><br/>

      Automatic retry is enabled by default for action libraries that support it.  However, certain legacy actions
      can disable the automatic retry feature, as noted in the action help.
      Calling SetupAutomaticRetry overrides legacy mode and will enable automatic retry.<br/><br/>

      The OCR/SR and ICR/C action libraries support the automatic retry feature.<br/><br/>
      <e>
        setFingerpritntRecogPriorty("TRUE")<br/>
        <b>SetupAutomaticRetry(1, 240)</b><br/>
        RecognizePageOCR_S()<br/>
        CreateTextFile()<br/><br/>

        In this example, the default value for the timeout is changed just prior to the page being recognized.
      </e>
    </h>
    <lvl>
      Any level.<br/><br/>

      The configuration values are hierarchical.  That means once they are set, they take effect
      on all DCO objects below the from where they were set.  For example, if SetupAutomaticRetry
      is called at the batch level, then the settings will take effect for all objects in the batch (document, page and field).
      If the action is called on a specific page, then the settings will take effect for that page object
      and all fields attached to that page.  If called at the batch and page level, then the page and fields on that page will use the page
      level setting while other objects use the batch level setting.
      This allows the action to be called from the appropriate spot, minimizing
      the number of times it needs to be used.
    </lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>OCR/SR Action Library.</see>
  </ref>



  <ref id="SetFullPageRecogArea" qi="An optional action that sets the area of the current page that is to be the target of recognition procedures, when full-page recognition action is invoked.">
    <ap>
      A decimal value indicating the percent of the page to be recognized in response to this action.<br/><br/>
      For example: "0.1" designates the first 10% of the page, while "1.0" calls for recognition
      of the entire page.<br/><br/>

      This action is helpful if you know that a page's values will always be in a particular location
      on the page, but recognition of the entire page is not necessary.
    </ap>
    <h>
      This optional action sets the area of the current page that will be the target of
      recognition procedures when full-page recognition action is called. For example: "0.1" indicates
      that the first 10% of the page is to be recognized; "1.00" indicates that the entire
      page is to be recognized.<br/>
      <e>
        <b>SetFullPageRecogArea(0.5)</b>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>False</b> if the ruleset with this action is not bound to a <b>Page</b> object of the
      Document Hierarchy, or if the action's parameter is not a decimal value. Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="CCONormalization_OFF">
    <ap>None.</ap>
    <h>
      Prevents the automatic running of NormalizeCCO procedures after a full-page recognition action has run.<br/>

      A full-page recognition action such as <b>RecognizePageICR_C</b>automatically calls the
      thorough but time-consuming <b>NormalizeCCO</b>action after recognition is complete
      (this action is part of the <b>cco2cco.rrx</b>file.)<br/><br/>

      To by-pass this procedure, place <b>CCONormalization_OFF</b>right before the recognition action.
      <e>
        <b>CCONormalization_OFF()</b><br/>
        RecognizePageICR_C()<br/>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>False</b> if the action does not run at the Page level. Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="SetFingerprintRecogPriority" qi="Sets the option that controls whether a full-page recognition action is to create a Fingerprint file(.cco) - aka a CCO file - for the current page.">
    <ap>
      String value: <i>True</i>or <i>False</i> to control the creation of the CCO. <br/><br/>

      <b>True:</b> If a CCO already exists prior to recognition, it is replaced with a brand new one with
      recognition results.<br/>
      <b>False:</b> If SetFingerprintRecogPriority is not called (or is set to false) and a CCO already
      exists prior to recognition, the recognition results will be added to that CCO.
    </ap>
    <h>
      This action sets the option that controls whether a full-page recognition action is to create
      a CCO file for the current page. When the option is On, processing is faster because the call
      to the <b>AnalyzeImage</b>action is eliminated. <br/><br/>

      The difference between creating a CCO from scratch with recognition results and adding the recognition
      results to the existing CCO created by AnalyzeImage is that in the "adding" case,
      the recognized characters are put into the CCO in a manner that uses a different fingerprinting technique.
      <br/><br/>
      <b>Note:</b>Be sure to place this action before a full-page recognition action.
      <e>
        <b>SetFingerprintRecogPriority(True)</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
</ref>


  <ref id="IsBlankPage" qi="Counts the number of words in the Fingerprint file(.cco) file of the current page and returns True if the count is less than or equal to the number you enter as the parameter.">
    <ap>
      Long value indicating the maximum number of words in the Fingerprint file(.cco) of a
      "blank" source page. "50", for example, tells the action that if a CCO file has 50 words or less,
      its page is <i>blank.</i> Valid values are 0 to 2,147,483,647.
    </ap>
    <h>
      This action counts the number of words in the CCO file of the current page and returns True if
      the count is less than or equal to the number you enter as the parameter. <br/><br/>

      A rule containing this action should apply to a <b>Page</b>object; within the rule, this
      action should come after one of the actions that creates a fingerprint, such as
      <b>AnalyzeImage</b>, <b>RecognizePageOCR_S</b>, or <b>RecognizePageICR_C</b>.
      <e>
        AnalyzeImage()<br/>
        <b>IsBlankPage(5)</b><br/>
        SetPageType(Separator)<br/><br/>

        This sequence uses <b>AnalyzeImage</b>to create a CCO file, then checks to see
        if the file contains less than six words. If so, the <b>IsBlankPage(5)</b>action
        returns True. The final action, a DCO action, establishes the page as a Separator page.
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>False</b> if the action parameter is invalid or if the action is unable to locate the Image file for the
      current page or its CCO file. Otherwise, <b>True.</b>
    </ret>
  </ref>



  <ref id="RotateTio" access="public" qi="Checks if an Image file processed by the ImageFix action that assigns a .tio extension to the file needs to be rotated by 90, 180, or 270 degrees.  If so, the action rotates and then saves the Image file with the same .tio extension. ">
    <ap>
      A <i>String</i>value to initiate rotation (True) or prevent rotation (False.)
    </ap>
    <h>
      This action checks if an Image file processed by the <b>ImageFix</b>action that assigns
      the .tio extension needs to be rotated by 90, 180, or 270 degrees.  If rotation is necessary,
      the action saves the Image file with the same .tio extension.
      <e>
        AnalyzeImage()<br/>
        <b>RotateTio(True)</b><br/>
        RotateImage()<br/>
        RecognizePageICR_C()
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>



  <ref id="CreateTextFile" qi="Creates a Text file(.txt) for the current page; adds the page's recognized values to the file; and places the file in the current batch, in your application's Batches directory.">
    <ap>None.</ap>
    <h>
      This action creates a UTF-8 encoded Text file (.txt) for the current page; adds the page's recognized values to the file;
      and places the file in the current batch, in your application's <b>Batches</b> directory. <br/><br/>
      <b>Alert!</b> The Text file generated by this action is handy for debugging purposes - to
      see what recognition is placing into the page's Fingerprint file(.cco) file. The action should
      follow a full-page recognition action such as <b>RecognizePageOCR_S</b>, in a rule applied
      to a <b>Page</b>object of the Document Hierarchy.
      <e>
        RecognizePageOCR_S()<br/>
        <b>CreateTextFile()</b><br/>
        SetProblemValue(0.7)<br/>
        SetSearchArea(0.5)<br/>
        FindFingerprint(True)<br/><br/>

        After the full-page recognition action (<b>RecognizePageOCR_S</b>), the <b>CreateTextFile()</b>
        action places the recognized values into a Text file that it has set up for the page, and
        adds the file to the current batch, in the application's <b>Batches</b> directory.  <br/><br/>

        The text file that is created has the same filename as the image, but is assigned a .txt
        filename extension.
      </e>
    </h>
    <lvl>Page only.</lvl>
    <ret>
      <b>False</b> if the ruleset with this action is not bound to a <b>Page</b>object of
      the Document Hierarchy, or if an Image file for the current page is not available. Otherwise, <b>True.</b>
    </ret>
</ref>

  <ref id="SnapCCOtoDCO" qi="Transfers the recognition results in the current page's CCO file - its Fingerprint file - to the appropriate Field objects of the Document Hierarchy...its setup DCO.">
    <ap>None.</ap>
    <h>
      This action transfers the recognition results of the current page's CCO file to the
      appropriate <b>Field</b> objects of the Document Hierarchy (DCO). Note that the action only
      transfers values to <b>Field</b> objects.<br/><br/>

      SnapCCOToDCO will only clear / update field text when all of the following conditions are met:<br/>
      - Field is not an OMR field (i.e. var RecogType=4).<br/>
      - Field has positions assigned.<br/>
      - Field does not have the variable "v_skipsnap" set to 1.<br/>
      - Field has data mapping to the CCO (at least one character).<br/>
      - Fixes issue that would affect processing of reserved fields (i.e. fields that are used for anchor finding followed by snapping of data).<br/>
      <e>
        <b>SnapCCOtoDCO()</b>
      </e>
    </h>
    <lvl>Page or Field level.</lvl>
    <ret>
      <b>False</b> if a ruleset with this action is not bound to a <b>Page</b> object or
      <b>Field</b> object of the Document Hierarchy. Otherwise, <b>True.</b>
    </ret>
  </ref>

  <ref id="SetAdjustFieldToChars" qi="Optional setting for SnapCCOToDCO to adjust the field position the its character positions.">
    <ap>
      A <i>String</i>value to snap character positions (True) or disable snapping (False).
    </ap>
    <h>
      This action has SnapCCOtoDCO adjust the field position (parameter True) to the character positions results after snapping the charater values to the field.
      Off by Default
      <e>
        <b>SetAdjustFieldToChars(TRUE)</b>
        <br/>
        <b>SnapCCOtoDCO()</b>
      </e>
    </h>
    <lvl>Page or Field level.</lvl>
    <ret>
      <b>True.</b>
    </ret>
  </ref>

  <ref id="SnapDCOtoCCO" qi="Transfers the recognition results assigned to Field objects of the Document Hierarchy (aka the setup DCO) to the current page's CCO file...also known as its Fingerprint file.">
    <ap>None.</ap>
    <h>
      This action transfers the recognition results assigned to <b>Field</b>objects of the
      Document Hierarchy(DCO) to the current page's CCO file. <br/><br/>

      If zonal recognition is used instead of full-page recognition, the action will populate
      the current page's CCO file with the results of zonal recognition.  Then, when the Verify
      task runs, a user can use the ClickNKey option to populate fields.
      <e>
        <b>SnapDCOtoCCO()</b>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>False</b> if a rule with this action is not applied to a page. Otherwise, <b>True.</b>
    </ret>
  </ref>
  
  <ref id="SnapFieldtoChars" qi="Adjusts the zone position of the passed dco field to the field's character positions.">
    <p id="Smartparam" type="string"/>
    <ap>A SmartParamter value representing a valid Field location.</ap>
    <h>
      This action adjusts the field position of the passed DCO to the DCO's character positions. <br/><br/>
      If the field does not have a text value, no adjustment to the field zone is performed.
      <e>
        <b>SnapFieldtoChars(@F)</b>
      </e>
    </h>
    <lvl>Any level.</lvl>
    <ret>
      <b>False</b> if a valid DCO field is not returned from the Smart parameter value. Otherwise, <b>True.</b>
    </ret>
  </ref>


  <ref id="RecogOMRThreshold" qi="Performs OMR checkbox recognition by counting black pixels within each OMR box area in a Field with one or more OMR boxes.">
    <p id="threshold"/>
    <p id="background"/>
    <ap>
      <i>Floating Point</i> or <i>Integer</i>values that specify the count of black
      pixels in OMR boxes:  <br/><br/>

      1. <b>Threshold:</b>the percentage of pixels in the zone - the field zone not the printed box
      that should be considered "checked", i.e. the lightest box that is not just noise, but should
      be considered a check mark.  <br/><br/>

      2. <b>Background:</b> the percentage of pixels in the zone that might be due to scanner noise
      and/or the border of the printed box. This value also controls the range on either side of the
      Threshold value that is “low confidence”.<br/><br/>

      Please note: The action also accepts parameters that are fractional percentages which are needed
      to detect marks in very large zones.<br/><br/>

      The parameters should be experimentally adjusted on real-world scanned forms.
      First, determine the Threshold value that correctly identifies a light mark as “checked”, and
      correctly identifies noisy zones as “unchecked”.
      Second, adjust the Background parameter’s value to achieve an acceptable confidence interval.
    </ap>
    <h>
      This action performs OMR checkbox recognition by counting black pixels within each OMR box area in a
      Field with one or more OMR boxes. <br/><br/>

      <b>Text Boxes</b><br/>The action sets the text value of the field to a string of 0's and 1's
      (one digit per OMR box); and assigns a Confidence String to the string of digits: '4' for Low Confidence up to '9' for High Confidence.<br/><br/>

      <b>Density String and Confidence Value</b><br/>The action also establishes a "DensityString"
      variable for the Character String, indicating percentage-filled, from ASCII 48 ('0') through 148. <br/><br/>
      For each possible OMR box, there will be a character. The character's ASCII value minus 48 is the percentage-filled.
      If the Density String=0X, the first OMR field was blank, and the second was 40% filled. The ASCII value for X is 88. 88 minus 48 = 40.<br/><br/>

      <b>MultiPunch and Confidence Values</b><br/><br/>
      If the MultiPunch setting is set to 1 and multiple OMR's were filled beyond the threshold, the one that was filled the most will be marked and set to Low Confidence.<br/><br/>

      If the percentage-filled is below the second parameter, the OMR box will not be selected and the confidence will be high.<br/><br/>

      If the percentage-filled is between the two parameters, the OMR box will not be selected and the confidence will be low.<br/><br/>

      If the percentage-filled is above the first parameter and below double the first parameter minus the second parameter, the OMR box will be selected and the confidence will be low.<br/><br/>

      If the percentage-filled is above double the first parameter minus the second parameter, the OMR box will be selected and the confidence will be high.<br/><br/>

      Note: The <b>RecogOMRThreshold</b>action works best on dropout boxes, but with an appropriate background value can work effectively with boxes that
      are visible in the scanned image.<br/><br/>

      If you are using small visible boxes on your image, it is best to zone the area by surrounding the entire
      visible box with room for alignment movement, then factor out the black from the box using the parameters.
      If you attempt to zone inside the borders of a visible box, you can get a false positive if the page
      does not align exactly.<br/><br/>

      The page image must be a 1 bit black and white image.  If the image is not 1 bit, the action C2BW_Convert in
      the ColorToBW library can be used to convert the image to a black and white 1 bit image.<br/><br/>
      
      <e>
        RecogOMRThreshold("10","5")<br/><br/>
        For a small to medium size zone, “10% filled” may be considered a deliberate mark. Anything below 5% (Background) is definitely <b>
          <i>not</i>
        </b>a mark. Anything above 15% (Threshold + (Threshold – Background)) is a high confidence mark.
        This would work with a non-dropout OMR field where the box’s printed outline takes up less than 5% of the zone area. It would also work for dropout forms.<br/><br/>

        RecogOMRThreshold("2","0")<br/><br/>
        This is for a signature line, or a large zone where the percentage-filled is usually much lower than for a small zone. This assumes very little background or noise.
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>C2BW_Convert</see>
  </ref>


  <ref id="UseOutOfProcessRecog" qi="Causes recognition to be performed in a process that is separate from the process that is running the recognition actions. ">
    <ap>
      <b>True:</b> Recognition actions should run in a separate process.<br/>
      <b>False:</b> Recognition should run in the same process as the recognition actions.
    </ap>
    <h>
      This action determines in which process recognition will be performed. Using a separate process
      for recognition provides an additional stability and automatic recovery ability as it will automatically
      retry a recognition action that runs into trouble, such as recognition that has stalled or unexpectedly
      terminated. The action must be placed before a full-page or field-level recognition action such as
      <b>RecognizePageOCR_S.</b> <br/><br/>

      The action is also directly tied to the <b>SetRecogFailureRetryDelay</b>action, which determines how
      long (in seconds) the <b>UseOutOfProcessRecog</b>action waits to determine that recognition has stopped
      responding and must be retried.<br/><br/>

      If the <b>UseOutOfProcessRecog</b>action is not specifically called, its default True setting will be
      used. If the action is called specifically, the True or False setting will be in effect for the entire
      batch. This allows you to set the value once, and call as many recognition actions as necessary.<br/><br/>

      It is not necessary to call this action for action libraries that support automatic retry.  In event
      of a retry, the out of process engine will be automatically restarted.<br/><br/>
      <e>
        <b>UseOutOfProcessRecog(True)</b><br/>
        SetRecogFailureRetryDelay(10)<br/>
        RecognizePageOCR_S()<br/><br/>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>SetupAutomaticRetry</see>
  </ref>

</help>

</rrx>
<rrx namespace="Redact" src="c:\datacap\RRS\Redact.dll">

<net ref="Redact.Actions">
	<h>
<![CDATA[
]]>
<![CDATA[    ]]>
		<ul style="list-style-type:none">
<![CDATA[
]]>
<![CDATA[      ]]>
			<li>
<![CDATA[The RedactFields action creates rectangular redaction fields to cover sensitive or restricted information in the document.  ]]>
<![CDATA[
]]>
<![CDATA[      These redactions and an audit trail can be exported along with captured documents, to a FileNet P8 document repository with "Role Based Redaction" feature enabled.]]>
			</li>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ul>
<![CDATA[
]]>
<![CDATA[  ]]>
	</h>
	<method name="RedactFields" ditaname="newAction">
		<p name="FieldType" type="string" qi="The type of field to redact, or the pattern id for text located using FindPatterns">
		</p>
		<p name="Redaction Reason" type="string" qi="The redaction field template (Setup DCO field) containing the redaction reason">
		</p>
		<p name="InflateRect" type="string" qi="How far to extend the redaction around the redacted field's rectangle (Left, Top, Bottom, Right)">
		</p>
		<p name="CopyField" type="bool" qi="If True, create new redaction fields and preserve the original sensitive fields. If False, replace each sensitive field with a redaction field. The new field is added to the page, Field Type is the template field name.">
		</p>
		<h>
<![CDATA[
]]>
<![CDATA[      Create a redaction for each field of the specified type on this page.]]>
<![CDATA[
]]>
<![CDATA[      If InflateRect is specified, the redaction rectangle is extended by the specified distance (in pixels) to the Left, Top, Left, Bottom, and Right.]]>
<![CDATA[
]]>
<![CDATA[      If CopyField is false, the sensitive fields are marked as redactions. If CopyField is true, sensitive fields are copied and renamed after the redaction field template, is created.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<ul style="list-style-type:none">
<![CDATA[
]]>
<![CDATA[      ]]>
				<li>
<![CDATA[Prerequisites:]]>
				</li>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ul>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<ul>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA[Configure one or more redaction template field(s) in the Document Hierarchy using Datacap Navigator, or see note below.]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA[Idenfify sensitive information on each page using DocumentAnalytics, Locate, or other actions. Create or populate fields to be redacted, containing only the sensitive item(s).]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA[Call the RedactFields action on each page, once for each Field Type to be redacted]]>
				</li>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ul>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<ul style="list-style-type:none">
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA[Note: Alternnatively use Datacap Studio to add redaction template fields to the Document Hierarchy Batch. Set the following variables: IsRedaction=1, IsOcrRedaction=1, STATUS=-1, and ReasonCode=(GUID)]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA[[optional] Use the Datacap Navigator client to view or modify redactions. Datacap Navigator displays redaction fields on the page image view, and allows an operator to add, delete, move, and assign reasons.]]>
<![CDATA[
]]>
<![CDATA[          Datacap clients other than Navigator may not display redacted fields correctly.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA[
]]>
<![CDATA[          [optional] Export the documents, redactions, and audit trail to a FileNet P8 repository with the "role based redactions" feature enabled, using FilenetP8 actions.]]>
<![CDATA[
]]>
<![CDATA[          IBM Content Navigator hides the redacted parts of the image, or displays redactions as semi-transparent, in FileNet P8 repositories with role based redaction enabled, depending on user roles and repository policies.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA[Redaction fields are identified by field variable IsRedaction = 1. Redactions created by rules have field variable IsOcrRedaction = 1.]]>
				</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				<li>
<![CDATA[
]]>
<![CDATA[          The audit trail is represented as XML in the page variable RedactionAudit. ]]>
<![CDATA[
]]>
<![CDATA[          The audit data includes a list of all new or changed redactions, as well as the redaction types (template field names) and reason codes that were configured at the time.]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				</li>
<![CDATA[
]]>
<![CDATA[      ]]>
			</ul>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<ul style="list-style-type:none">
<![CDATA[
]]>
<![CDATA[          ]]>
					<li>
<![CDATA[Recognize()]]>
					</li>
<![CDATA[
]]>
<![CDATA[          ]]>
					<li>
<![CDATA[AnalyzeLayout()]]>
					</li>
<![CDATA[
]]>
<![CDATA[          ]]>
					<li>
					</li>
<![CDATA[
]]>
<![CDATA[          ]]>
					<li>
<![CDATA[FindPatterns(@APPPATH(setupdco)+.+DocAnalyticsPatterns.xml)]]>
					</li>
<![CDATA[
]]>
<![CDATA[          ]]>
					<li>
						<b>
<![CDATA[RedactFields("phonePattern", "Redact_Phone", "", true)]]>
						</b>
					</li>
<![CDATA[
]]>
<![CDATA[          ]]>
					<li>
<![CDATA[(Redact_Phone template field must be present in batch level of document hierarchy)]]>
					</li>
<![CDATA[
]]>
<![CDATA[          ]]>
					<li>
					</li>
<![CDATA[
]]>
<![CDATA[          ]]>
					<li>
<![CDATA[ExtractText("Address.Address")]]>
					</li>
<![CDATA[
]]>
<![CDATA[          ]]>
					<li>
<![CDATA[FindExtractedText("@P/MemberAddress", "First", "Address.Address", "address", "", "")]]>
					</li>
<![CDATA[
]]>
<![CDATA[          ]]>
					<li>
						<b>
<![CDATA[RedactFields("MemberAddress", "Redact_Address", "", true)]]>
						</b>
					</li>
<![CDATA[
]]>
<![CDATA[          ]]>
					<li>
<![CDATA[(Redact_Address template field must be present in batch level of document hierarchy)]]>
					</li>
<![CDATA[
]]>
<![CDATA[          ]]>
					<li>
					</li>
<![CDATA[
]]>
<![CDATA[          ]]>
					<li>
<![CDATA[ExtractTextAlchemyLanguage("docSentiment,DateTime.DateTime,EmailAddress.EmailAddress")]]>
					</li>
<![CDATA[
]]>
<![CDATA[          ]]>
					<li>
<![CDATA[FindExtractedText("@P/EmailAddress", "First", "entity", "text", "type", "Person")]]>
					</li>
<![CDATA[
]]>
<![CDATA[          ]]>
					<li>
						<b>
<![CDATA[RedactFields("EmailAddress", "Redact_EmailAddress", "1,3,1,3", true)]]>
						</b>
<![CDATA[
]]>
<![CDATA[          ]]>
					</li>
<![CDATA[
]]>
<![CDATA[        ]]>
				</ul>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
</net>
</rrx>
<rrx namespace="rrunner" src="c:\datacap\RRS\rrunner.dll">

<g>
</g>
<ifrrx>
</ifrrx>
<ifrra>
</ifrra>
<g>
</g>
<ifrrx>
</ifrrx>
<g>
</g>
<f name="MessageID" access="public">
	<p name="Message">
	</p>
	<p name="Identifier">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("MESSAGE") = Message]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Identifier = Trim(Identifier)]]>
<![CDATA[
]]>
<![CDATA[  If len(Identifier)>0 then]]>
<![CDATA[
]]>
<![CDATA[  		  CurrentObj.Variable("MessageID") = Identifier]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="MessageIDParameter" access="public">
	<p name="Value">
	</p>
	<p name="ValueType">
	</p>
	<p name="Index" type="int">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  MessageIDParameter=True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sParamName]]>
<![CDATA[
]]>
<![CDATA[  Dim sParamType]]>
<![CDATA[
]]>
<![CDATA[  sParamText = "MessageParamText_" & cstr(Index)]]>
<![CDATA[
]]>
<![CDATA[  sParamType = "MessageParamType_" & cstr(Index)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim ResolvedValue]]>
<![CDATA[
]]>
<![CDATA[  Dim RX]]>
<![CDATA[
]]>
<![CDATA[  Dim sMessage]]>
<![CDATA[
]]>
<![CDATA[  Dim bTypes]]>
<![CDATA[
]]>
<![CDATA[  bTypes=False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'permitted 'Type' values:]]>
<![CDATA[
]]>
<![CDATA[  Dim Types]]>
<![CDATA[
]]>
<![CDATA[  Types = Array("job", "task", "shortcut", "field", "workflow", "appname", "pagetype", "doctype", "text", "variable")    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'check Type is a an allowed value ]]>
<![CDATA[
]]>
<![CDATA[  For t = 0 to (ubound(Types)-1)]]>
<![CDATA[
]]>
<![CDATA[    If lcase(ValueType)=Types(t) Then]]>
<![CDATA[
]]>
<![CDATA[      bTypes=True]]>
<![CDATA[
]]>
<![CDATA[      Exit For]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[  Next 't]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (BTypes=False) Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Type '" & ValueType & "' is not a member of the allowed types:'" & Join(Types,",") & ".")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'check for duplicate Parameter index     ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.FindVariable(sParamText)>=0 or CurrentObj.FindVariable(sParamType)>=0 Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Reusing Parameter index. Existing value '" & CurrentObj.Variable(sParamText) & "' and type '" &  CurrentObj.Variable(sParamType) & "' will be replaced.")]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'save MessageParamType variable & value to DCO node]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable(sParamText) = Value]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable(sParamType) = ValueType]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[  'resolve values as allowed; eg SmartParameter]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Resolving Value '" & Value & "'...")]]>
<![CDATA[
]]>
<![CDATA[  ResolvedValue = MetaWord(Value)]]>
<![CDATA[
]]>
<![CDATA[  If Len(ResolvedValue) = 0 Then ResolvedValue = Value ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Perform Message Substitution]]>
<![CDATA[
]]>
<![CDATA[  sMessage = CurrentObj.Variable("MESSAGE")]]>
<![CDATA[
]]>
<![CDATA[  If Len(sMessage)=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("The 'MESSAGE' variable is empty. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Current 'MESSAGE' value:'" & sMessage & "'.")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sPattern]]>
<![CDATA[
]]>
<![CDATA[  sPattern = "{" & cstr(Index) & "}"]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  writelog("pattern:'" &  sPattern & "'.")]]>
<![CDATA[
]]>
<![CDATA[  'sResult = DCGlobalStrings.RemoveReplace(sMessage,cint(nStartIndex-1),sInsertString,cint(nMaxMatches), CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	sNewMessage = Replace(sMessage, sPattern, ResolvedValue)]]>
<![CDATA[
]]>
<![CDATA[  writelog("replace:" & sNewMessage)  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  If Trim(sMessage) <> Trim(sNewMessage) then]]>
<![CDATA[
]]>
<![CDATA[    sMessage = sNewMessage]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Substitution successful. New 'MESSAGE' value: '" & sMessage & "'.")]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("A Substitution was not successfull. Please check your settings if a substitution was supposed to occur.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'save MessageParamText variable & value to DCO node]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable("MESSAGE") = sMessage]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Variable(sParamText) = ResolvedValue]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<g>
</g>
<g>
</g>
<g>
</g>
<af name="Status_Preserve_ON" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[    RRState.OnRuleFailure="Call StatCounter():Call OnRuleEnd()"]]>
<![CDATA[
]]>
<![CDATA[    RRState.OnRuleSuccess="Call StatCounter():Call OnRuleEnd()"  ]]>
<![CDATA[
]]>
<![CDATA[    RRState.OnRulesetStart="Call OnRuleSetStart()"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Status_Preserve_ON = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Status_Preserve_OFF" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    RRState.OnRuleStart="Call OnRuleStart():If CurrentObj.Status=nFail then CurrentObj.Status=nPass:CurrentObj.DeleteVariable(""MESSAGE""):nDefaultRtn = nRtn_Over"]]>
<![CDATA[
]]>
<![CDATA[    RRState.OnRuleSuccess="Call StatCounter():Call OnRuleEnd()" ]]>
<![CDATA[
]]>
<![CDATA[    RRState.OnRuleFailure="Call StatCounter():Call OnRuleFailure():Call OnRuleEnd()"]]>
<![CDATA[
]]>
<![CDATA[    RRState.OnRuleSetStart="Call OnRuleSetStart():RRState.OnRuleFailure="""":RRState.OnRuleStart=""Call OnRuleStart()"""]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Status_Preserve_OFF = True]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Initializing Calling Object to status " & nPass)]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Status = nPass]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.DeleteVariable("MESSAGE")	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DebugMode_ON" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  bDebug = True]]>
<![CDATA[
]]>
<![CDATA[	DebugLog("DebugMode ON")]]>
<![CDATA[
]]>
<![CDATA[	DebugMode_ON = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DebugMode_OFF" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Debuglog("DebugMode OFF")]]>
<![CDATA[
]]>
<![CDATA[	bDebug = False]]>
<![CDATA[
]]>
<![CDATA[	DebugMode_OFF = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CheckAllIntegrity" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim LastChecked]]>
<![CDATA[
]]>
<![CDATA[	Dim rtn]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CheckAllIntegrity = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	rtn = DCO.CheckIntegrity(LastChecked)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If rtn <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[		If Not LastChecked Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("CheckIntegrity returned : " & rtn & vbCrLf & Space(5) & "ID of last checked: " & LastChecked.ID) ]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		CheckAllIntegrity = False]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CheckDocCount" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim nD]]>
<![CDATA[
]]>
<![CDATA[	Dim nDD]]>
<![CDATA[
]]>
<![CDATA[	Dim ED]]>
<![CDATA[
]]>
<![CDATA[	Dim aD]]>
<![CDATA[
]]>
<![CDATA[	Dim vD		]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	nD = Trim(Pilot.ExpectedDocs)]]>
<![CDATA[
]]>
<![CDATA[	If nD="" or Not(isnumeric(nD)) then nD=0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ED = Trim(DCO.Variable("ED"))]]>
<![CDATA[
]]>
<![CDATA[	If ED="" or Not(isnumeric(ED)) then ED=0]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If cint(nD)<=cint(1) and cint(ED)>0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("DCO variable ED value found. Setting Pilot.ExpectedDocs to " & cstr(ED))]]>
<![CDATA[
]]>
<![CDATA[		nD = ED		]]>
<![CDATA[
]]>
<![CDATA[		Pilot.ExpectedDocs = clng(nD)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aD = Trim(Pilot.AdjustedDocs)]]>
<![CDATA[
]]>
<![CDATA[	If aD="" or Not(isnumeric(aD)) then aD=0]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	vD = Trim(DCO.Variable("AD"))]]>
<![CDATA[
]]>
<![CDATA[	If vD="" or Not(isnumeric(vD)) then vD=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If cint(aD)=cint(0) and cint(vD)>0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("DCO variable AD value found. Setting Pilot.AdjustedDocs to " & cstr(vD))]]>
<![CDATA[
]]>
<![CDATA[		aD = vD		]]>
<![CDATA[
]]>
<![CDATA[		Pilot.AdjustedDocs = clng(aD)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Expected documents:" & nD & ".")]]>
<![CDATA[
]]>
<![CDATA[	If aD>0 then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Adjusted documents:" & aD & ".")]]>
<![CDATA[
]]>
<![CDATA[		nD=aD]]>
<![CDATA[
]]>
<![CDATA[	End if ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	nDD = ObjectCount(DCO, 1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Found " & cstr(nDD) & " documents")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If cint(nDD) <> cint(nD) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Expected documents count does not match actual documents count!")]]>
<![CDATA[
]]>
<![CDATA[		CheckDocCount = False]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		CheckDocCount = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CheckPageCount" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim nP]]>
<![CDATA[
]]>
<![CDATA[	Dim nPP]]>
<![CDATA[
]]>
<![CDATA[	Dim aP]]>
<![CDATA[
]]>
<![CDATA[	Dim vP]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	nP = Trim(Pilot.ExpectedPages)]]>
<![CDATA[
]]>
<![CDATA[	If nP="" or Not(isnumeric(nP)) then nP=0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nP = Trim(DCO.Variable("EP"))]]>
<![CDATA[
]]>
<![CDATA[	If nP="" or Not(isnumeric(nP)) then nP=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If cint(nP)=cint(0) and Len(EP)>0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("DCO variable EP value found. Setting Pilot.ExpectedDocs to " & cstr(EP))]]>
<![CDATA[
]]>
<![CDATA[		nP = EP]]>
<![CDATA[
]]>
<![CDATA[		Pilot.ExpectedPages = clng(nP)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aP = Trim(Pilot.AdjustedPages)]]>
<![CDATA[
]]>
<![CDATA[	If aP="" or Not(isnumeric(aP)) then aP=0]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	vP = Trim(DCO.Variable("AP"))]]>
<![CDATA[
]]>
<![CDATA[	If vP="" or Not(isnumeric(vP)) then vP=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If cint(aP)=cint(0) and Len(vP)>0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("DCO variable AP value found. Setting Pilot.AdjustedPages to " & cstr(vP))]]>
<![CDATA[
]]>
<![CDATA[		aP = vP		]]>
<![CDATA[
]]>
<![CDATA[		Pilot.AdjustedPages = clng(aP)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Expected Pages:" & nP & ".")]]>
<![CDATA[
]]>
<![CDATA[	If aP>0 then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Adjusted pages:" & aP & ".")]]>
<![CDATA[
]]>
<![CDATA[		nP=aP]]>
<![CDATA[
]]>
<![CDATA[	End if ]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	nPP = ObjectCount(DCO, 2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Found " & cstr(nPP) & " pages")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If cint(nPP) <> cint(nP) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Expected pages count does not match actual pages count!")]]>
<![CDATA[
]]>
<![CDATA[		CheckPageCount = False]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		CheckPageCount = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Task_RaiseCondition" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[' Strparam is a CSV value]]>
<![CDATA[
]]>
<![CDATA[' 1) is the childindex]]>
<![CDATA[
]]>
<![CDATA[' 2) is the Condition to set the child to.			]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrparam]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildIndex]]>
<![CDATA[
]]>
<![CDATA[	Dim nConditionIndex]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Task_RaiseCondition= False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[	nChildIndex = aStrParam(0)	]]>
<![CDATA[
]]>
<![CDATA[	nConditionIndex = aStrParam(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(nChildIndex) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(nConditionIndex) Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nConditionIndex = CLng(nConditionIndex)]]>
<![CDATA[
]]>
<![CDATA[	nChildIndex= CLng(nChildIndex)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Pilot.ChildCondition(nChildIndex) = nConditionIndex]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Task_RaiseCondition= True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Task_NumberOfSplits" access="public" bInter="bInter" bDebug="bDebug" strParam="nNumOfSplits">
	<g>
<![CDATA[
]]>
<![CDATA[	Task_NumberOfSplits= False]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(nNumOfSplits) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("NumOfSplits Value is not Numeric.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	pilot.ChildrenQuantity=(CLng(nNumOfSplits))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Setting Task Number Of Splits to : " & nNumOfSplits)]]>
<![CDATA[
]]>
<![CDATA[	Task_NumberOfSplits= True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetTaskStatus" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ 'use global variable nTaskStatus to send status to RuleRunner]]>
<![CDATA[
]]>
<![CDATA[ Const RetAbort = 0]]>
<![CDATA[
]]>
<![CDATA[ Const RetFinished = 2]]>
<![CDATA[
]]>
<![CDATA[ Const RetPending = 8]]>
<![CDATA[
]]>
<![CDATA[ Const RetHold = 4]]>
<![CDATA[
]]>
<![CDATA[   if(isNumeric(StrParam)) then]]>
<![CDATA[
]]>
<![CDATA[      nTaskStatus = cint(StrParam)]]>
<![CDATA[
]]>
<![CDATA[        RRState.Data("nTaskStatus")=StrParam]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Set status of task to " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[      SetTaskStatus = true]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Action's parameter is not numeric")]]>
<![CDATA[
]]>
<![CDATA[     SetTaskStatus = false ]]>
<![CDATA[
]]>
<![CDATA[   end if]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SkipChildren" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    RRState.SkipChildren=True]]>
<![CDATA[
]]>
<![CDATA[	SkipChildren = True]]>
<![CDATA[
]]>
<![CDATA[	bprocesschildren = False]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AbortOnError" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	AbortOnError = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Select Case ucase(strparam)]]>
<![CDATA[
]]>
<![CDATA[		Case "TRUE"]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Setting Task to Abort On Errors")]]>
<![CDATA[
]]>
<![CDATA[			g_bAbortOnError = True]]>
<![CDATA[
]]>
<![CDATA[		Case "FALSE"]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Setting Task to Continue On Errors")]]>
<![CDATA[
]]>
<![CDATA[			g_bAbortOnError = False]]>
<![CDATA[
]]>
<![CDATA[		Case Else]]>
<![CDATA[
]]>
<![CDATA[			AbortOnError = False]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Invalid Parameter. Expecting 'True' or 'False', received '" & StrParam & "'.")]]>
<![CDATA[
]]>
<![CDATA[	End Select		]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="PilotMessage_Set" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sSmartParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If len(sSmartParam)="" then ]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Smart Parameter parsing did not return a value. Defaulting message to the Action argument.")]]>
<![CDATA[
]]>
<![CDATA[     sSmartParam =StrParam]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("MESSAGE")= Trim(sSmartParam)	]]>
<![CDATA[
]]>
<![CDATA[	PilotMessage_Set=True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PilotMessage_Clear" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.DeleteVariable("MESSAGE")	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.DeleteVariable("MessageID")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'TODO:  somehow CurrentObj.GetVariableName(index) sometimes return empty string and miss the MessageParam variable names, so use for loop for 20 message variables]]>
<![CDATA[
]]>
<![CDATA[	For index = 0 To 20]]>
<![CDATA[
]]>
<![CDATA[		rc = CurrentObj.DeleteVariable("MessageParamType_"&index)]]>
<![CDATA[
]]>
<![CDATA[		if rc = false then]]>
<![CDATA[
]]>
<![CDATA[			Exit For]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		rc = CurrentObj.DeleteVariable("MessageParamText_"&index)]]>
<![CDATA[
]]>
<![CDATA[		if rc = false then]]>
<![CDATA[
]]>
<![CDATA[			Exit For]]>
<![CDATA[
]]>
<![CDATA[		End if		]]>
<![CDATA[
]]>
<![CDATA[	Next	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	PilotMessage_Clear=True]]>
<![CDATA[
]]>
	</g>
</af>
<g>
</g>
<f name="rrSet" access="public">
	<p name="varSource">
	</p>
	<p name="varTarget">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' rr_Set was replaced by rrSet so we could use the "f" tag with unique parameters.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sSource]]>
<![CDATA[
]]>
<![CDATA[	Dim sDestination]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	rrSet = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sSource = Trim(varSource)]]>
<![CDATA[
]]>
<![CDATA[	sDestination = Trim(varTarget)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(sSource) = 0 Then sSource = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	If len(sDestination) = 0 Then sDestination = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' If sSource = sDestination Then we don't care, perform the copy anyway.		]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sValue = MetaWord(sSource)    ]]>
<![CDATA[
]]>
<![CDATA[	rrSet = DCONavSetValue(sDestination,sValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrSet") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<f name="rrSet_ID" access="public">
	<p name="SourceValue">
	</p>
	<p name="TargetDCO">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sSource]]>
<![CDATA[
]]>
<![CDATA[	Dim sDestination]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	rrSet_ID = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sSource = Trim(SourceValue)]]>
<![CDATA[
]]>
<![CDATA[	sDestination = Trim(TargetDCO)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(sSource) = 0 Then sSource = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	If len(sDestination) = 0 Then sDestination = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sValue = MetaWord(sSource)    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Set oTarget = DCONav(sDestination)]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(oTarget) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Copy to node not found.")]]>
<![CDATA[
]]>
<![CDATA[		rrSet_ID=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	oTarget.ID = sValue]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If Err=0 then rrSet_ID=True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrSet_ID") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<af name="rr_Get" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim sSource]]>
<![CDATA[
]]>
<![CDATA[	Dim sDestination]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	rr_Get = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sSource = StrParam]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If len(sSource) = 0 Then sSource = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	If len(sDestination) = 0 Then sDestination = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ' This condition will occur only if no parameter is supplied.]]>
<![CDATA[
]]>
<![CDATA[	If sSource = sDestination Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("A parameter is required for rr_Get(). Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sValue = MetaWord(sSource)]]>
<![CDATA[
]]>
<![CDATA[	rr_Get = DCONavSetValue(sDestination, sValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rr_Get") ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<f name="rrContains" access="public">
	<p name="SearchForValue">
	</p>
	<p name="SearchInValue">
	</p>
	<p name="caseSensitive">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  'Text that the action is looking for in the current field.]]>
<![CDATA[
]]>
<![CDATA[  'This action determines if a field represented by the bound object of the ]]>
<![CDATA[
]]>
<![CDATA[  'Document Hierarchy contains some or all of the parameter's text value, without additional unspecified text. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	rrContains = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sSearchFor = Trim(SearchForValue)]]>
<![CDATA[
]]>
<![CDATA[	sSearchIn = Trim(SearchInValue)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  caseSensitive = Trim(caseSensitive)]]>
<![CDATA[
]]>
<![CDATA[  If len(caseSensitive) = 0 then caseSensitive="FALSE"]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If len(sSearchFor) = 0 Then sSearchFor = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	If len(sSearchIn) = 0 Then sSearchIn = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If sSearchFor = sSearchIn Then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Search For and Search In reference the same component. Returning True.")]]>
<![CDATA[
]]>
<![CDATA[    rrContains = True]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sValueSearchFor = MetaWord(sSearchFor)]]>
<![CDATA[
]]>
<![CDATA[	sValueSearchIn = MetaWord(sSearchIn)]]>
<![CDATA[
]]>
<![CDATA[  	]]>
<![CDATA[
]]>
<![CDATA[  Writelog("'Checking if: '" & sValueSearchFor & "' is in '" & sValueSearchIn & "'.")    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if (UCase(caseSensitive) = "FALSE") Then ]]>
<![CDATA[
]]>
<![CDATA[     writelog("Case insensitive comparison")]]>
<![CDATA[
]]>
<![CDATA[     sValueSearchIn = ucase(sValueSearchIn)]]>
<![CDATA[
]]>
<![CDATA[     sValueSearchFor = ucase(sValueSearchFor)]]>
<![CDATA[
]]>
<![CDATA[  End if	]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  If instr(sValueSearchIn, sValueSearchFor)>0 Then]]>
<![CDATA[
]]>
<![CDATA[		rrContains = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("rrContains") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="rrCompareCase" access="public">
	<p name="object1">
	</p>
	<p name="object2">
	</p>
	<p name="caseSensitive">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sSourceA]]>
<![CDATA[
]]>
<![CDATA[	Dim sSourceB]]>
<![CDATA[
]]>
<![CDATA[	Dim sValueA]]>
<![CDATA[
]]>
<![CDATA[	Dim sValueB]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	rrCompareCase = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sSourceA = Trim(object1)]]>
<![CDATA[
]]>
<![CDATA[	sSourceB = Trim(object2)]]>
<![CDATA[
]]>
<![CDATA[  caseSensitive = Trim(caseSensitive)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(sSourceA) = 0 Then sSourceA = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	If len(sSourceB) = 0 Then sSourceB = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If sSourceA = sSourceB Then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Source A and B reference the same component. Returning True.")]]>
<![CDATA[
]]>
<![CDATA[    rrCompareCase = True]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sValueA = MetaWord(sSourceA)]]>
<![CDATA[
]]>
<![CDATA[	sValueB = MetaWord(sSourceB)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Case Sensitive = '" & UCase(caseSensitive) & "' Comparing: '" & sValueA & "' = '" & sValueB & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  dim compareType  ]]>
<![CDATA[
]]>
<![CDATA[  compareType = 0]]>
<![CDATA[
]]>
<![CDATA[  if (UCase(caseSensitive) = "FALSE") Then ]]>
<![CDATA[
]]>
<![CDATA[     writelog("Case insensitive comparison")]]>
<![CDATA[
]]>
<![CDATA[     compareType = 1]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If StrComp(sValueA, sValueB, compareType) = 0 Then]]>
<![CDATA[
]]>
<![CDATA[    rrCompareCase = True]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'If sValueA = sValueB Then]]>
<![CDATA[
]]>
<![CDATA[	'	rrCompare = True]]>
<![CDATA[
]]>
<![CDATA[	'End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrCompareCase") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="rrCompare" access="public">
	<p name="object1">
	</p>
	<p name="object2">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' rr_Compare was replaced by rrCompare so we could use the "f" tag with unique parameters.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	rrCompare = rrCompareCase(object1, object2, "TRUE")  ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrCompare") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<f name="rrCompareNotCase" access="public">
	<p name="object1">
	</p>
	<p name="object2">
	</p>
	<p name="caseSensitive">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	if rrCompareCase(object1, object2, caseSensitive) Then]]>
<![CDATA[
]]>
<![CDATA[     rrCompareNotCase = False]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[     rrCompareNotCase = True]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrCompareNot") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="rrCompareNot" access="public">
	<p name="object1">
	</p>
	<p name="object2">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' rr_Copy was replaced by rrCopy so we could use the "f" tag with unique parameters.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	if rrCompare(object1, object2) Then]]>
<![CDATA[
]]>
<![CDATA[     rrCompareNot = False]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[     rrCompareNot = True]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrCompareNot") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<f name="rrCompareCaseLength" access="public">
	<p name="object1">
	</p>
	<p name="object2">
	</p>
	<p name="caseSensitive">
	</p>
	<p name="length">
	</p>
	<p name="fromStart">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  Dim nLen]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  rrCompareCaseLength = false]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  if (Not (isNumeric(StrParam))) then]]>
<![CDATA[
]]>
<![CDATA[     writelog("length parameter '" & length & "' is not numeric.  Returning false")]]>
<![CDATA[
]]>
<![CDATA[     Exit Function   ]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  nLen = cint(length)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if (nLen <= 0) Then]]>
<![CDATA[
]]>
<![CDATA[     writelog("length parameter is 0.  Comparing entire string.")]]>
<![CDATA[
]]>
<![CDATA[     rrCompareCaseLength = rrCompareCase(object1, object2, caseSensitive)  ]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim sObj1]]>
<![CDATA[
]]>
<![CDATA[  Dim sObj2]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  sObj1 = MetaWord(object1)]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Object1 = " & sObj1)]]>
<![CDATA[
]]>
<![CDATA[  sObj2 = MetaWord(object2)]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Object2 = " & sObj2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  if (UCASE(fromStart) = "TRUE") Then]]>
<![CDATA[
]]>
<![CDATA[     sObj1 = Left(sObj1, nLen)]]>
<![CDATA[
]]>
<![CDATA[     sObj2 = Left(sObj2, nLen)]]>
<![CDATA[
]]>
<![CDATA[     writelog("Comparing From Start: '" & sObj1 & "' and '" & sObj2 & "'.")]]>
<![CDATA[
]]>
<![CDATA[  else]]>
<![CDATA[
]]>
<![CDATA[     sObj1 = Right(sObj1, nLen)]]>
<![CDATA[
]]>
<![CDATA[     sObj2 = Right(sObj2, nLen)]]>
<![CDATA[
]]>
<![CDATA[     writelog("Comparing From End: '" & sObj1 & "' and '" & sObj2 & "'.")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	rrCompareCaseLength = rrCompareCase(sObj1, sObj2, caseSensitive)  ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrCompare") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="rrCompareNotCaseLength" access="public">
	<p name="object1">
	</p>
	<p name="object2">
	</p>
	<p name="caseSensitive">
	</p>
	<p name="length">
	</p>
	<p name="fromStart">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If (rrCompareCaseLength(object1, object2, caseSensitive, length, fromStart)) Then]]>
<![CDATA[
]]>
<![CDATA[     rrCompareNotCaseLength = False]]>
<![CDATA[
]]>
<![CDATA[  else]]>
<![CDATA[
]]>
<![CDATA[     rrCompareNotCaseLength = True]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrCompareNotCaseLength") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="rrCopy" access="public">
	<p name="varSource">
	</p>
	<p name="varTarget">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' rr_Copy was replaced by rrCopy so we could use the "f" tag with unique parameters.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim sSource]]>
<![CDATA[
]]>
<![CDATA[	Dim sTarget]]>
<![CDATA[
]]>
<![CDATA[	Dim oSource]]>
<![CDATA[
]]>
<![CDATA[	Dim oTarget]]>
<![CDATA[
]]>
<![CDATA[	Dim sOrigImageN]]>
<![CDATA[
]]>
<![CDATA[	Dim sOrigImageH]]>
<![CDATA[
]]>
<![CDATA[	Dim oChild]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	rrCopy = True]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sSource = Trim(varSource)]]>
<![CDATA[
]]>
<![CDATA[	sTarget = Trim(varTarget)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(sSource) = 0 Then sSource = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	If len(sTarget) = 0 Then sTarget = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If sSource = sTarget Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Source and Target are to the same component. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oSource = DCONav(sSource)]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(oSource) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Copy from node not found.")]]>
<![CDATA[
]]>
<![CDATA[		rrCopy=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oTarget = DCONav(sTarget)]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(oTarget) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Copy to node not found.")]]>
<![CDATA[
]]>
<![CDATA[		rrCopy=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Get Target original]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Target original values]]>
<![CDATA[
]]>
<![CDATA[	oTarget.Text=""]]>
<![CDATA[
]]>
<![CDATA[	oTarget.Variable("Position")="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Check Source has value]]>
<![CDATA[
]]>
<![CDATA[	If oSource.Text="" then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Source field has no value.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Copying Node: '" & oSource.ID & "' value:'" & oSource.Text & "' image:'" & oSource.Variable("IMAGEFILE") & "' to '" & oTarget.ID & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call RRCopyChars(oSource,oTarget,1,len(oSource.Text))]]>
<![CDATA[
]]>
<![CDATA[	Call RRCopyPos(oSource,oTarget,1,len(oSource.Text))]]>
<![CDATA[
]]>
<![CDATA[	Call RRCopyImage(oSource,oTarget)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("New Target Value:'" & oTarget.Text & "'  Position:'" & oTarget.Variable("Position") & "' image:'" & oTarget.Variable("IMAGEFILE") & "'")		]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrCopy")   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<f name="rrAppend" access="public">
	<p name="varSource">
	</p>
	<p name="varTarget">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' rr_Append was replaced by rrAppend so we could use the "f" tag with unique parameters.]]>
<![CDATA[
]]>
<![CDATA[  Dim sSource]]>
<![CDATA[
]]>
<![CDATA[  Dim sTarget]]>
<![CDATA[
]]>
<![CDATA[  Dim oSource]]>
<![CDATA[
]]>
<![CDATA[  Dim oTarget]]>
<![CDATA[
]]>
<![CDATA[  Dim sOrigImageN]]>
<![CDATA[
]]>
<![CDATA[  Dim sOrigImageH]]>
<![CDATA[
]]>
<![CDATA[  Dim oChild]]>
<![CDATA[
]]>
<![CDATA[  Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[  Dim oChar]]>
<![CDATA[
]]>
<![CDATA[  Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	rrAppend = True]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sSource = Trim(varSource)]]>
<![CDATA[
]]>
<![CDATA[	sTarget = Trim(varTarget)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(sSource) = 0 Then sSource = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	If len(sTarget) = 0 Then sTarget = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If sSource = sTarget Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Source and Target are to the same component. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sValue = MetaWord(sSource)]]>
<![CDATA[
]]>
<![CDATA[	If Len(sValue)=0 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Source argument or object does not have a value. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[		rrAppend=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oTarget = DCONav(sTarget)]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(oTarget) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Append to node not found.")]]>
<![CDATA[
]]>
<![CDATA[		rrAppend=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Start Value of Target:'" & oTarget.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For i = 1 to Len(sValue)]]>
<![CDATA[
]]>
<![CDATA[		Set oChar = oTarget.AddChild(4,"",-1)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Not oChar is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[			oChar.CharValue(0)= Clng(ASCW(Mid(sValue,i,1)))]]>
<![CDATA[
]]>
<![CDATA[			oChar.CharConfidence(0) = Clng(9)]]>
<![CDATA[
]]>
<![CDATA[			bRes = oChar.SetPosition(clng(0),clng(0),clng(0),clng(0))]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'x]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[  Writelog("End Value of Target:'" & oTarget.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrAppend")   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<f name="rrPrepend" access="public">
	<p name="varSource">
	</p>
	<p name="varTarget">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' rr_Append was replaced by rrAppend so we could use the "f" tag with unique parameters.  ]]>
<![CDATA[
]]>
<![CDATA[	Dim sSource]]>
<![CDATA[
]]>
<![CDATA[	Dim sTarget]]>
<![CDATA[
]]>
<![CDATA[	Dim oSource]]>
<![CDATA[
]]>
<![CDATA[	Dim oTarget]]>
<![CDATA[
]]>
<![CDATA[	Dim sOrigImageN]]>
<![CDATA[
]]>
<![CDATA[	Dim sOrigImageH]]>
<![CDATA[
]]>
<![CDATA[	Dim oChild]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[	Dim oChar]]>
<![CDATA[
]]>
<![CDATA[  Dim i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	rrPrepend = True]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sSource = Trim(varSource)]]>
<![CDATA[
]]>
<![CDATA[	sTarget = Trim(varTarget)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(sSource) = 0 Then sSource = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	If len(sTarget) = 0 Then sTarget = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If sSource = sTarget Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Source and Target are to the same component. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sValue = MetaWord(sSource)]]>
<![CDATA[
]]>
<![CDATA[	If Len(sValue)=0 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Source argument or object does not have a value. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[		rrPrepend=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oTarget = DCONav(sTarget)]]>
<![CDATA[
]]>
<![CDATA[	If Not IsAlive(oTarget) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Append to node not found.")]]>
<![CDATA[
]]>
<![CDATA[		rrPrepend=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Start Value of Target:'" & oTarget.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For i = 1 to Len(sValue)]]>
<![CDATA[
]]>
<![CDATA[		Set oChar = oTarget.AddChild(4,"",i-1)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Not oChar is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[			oChar.CharValue(0)= Clng(ASCW(Mid(sValue,i,1)))]]>
<![CDATA[
]]>
<![CDATA[			oChar.CharConfidence(0) = Clng(9)]]>
<![CDATA[
]]>
<![CDATA[			bRes = oChar.SetPosition(clng(0),clng(0),clng(0),clng(0))]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'x]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[  Writelog("End Value of Target:'" & oTarget.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("rrPrepend") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<g>
</g>
<af name="rr_WriteNode" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Dim sNodeFileName	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	rr_WriteNode=True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sNodeFileName=Pilot.BatchDir & "\" & CurrentObj.ID & ".xml"]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("DATAFILE")=sNodeFileName]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="rr_AbortBatch" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  	rr_AbortBatch = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Call AbortBatch()  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<f name="GoToNextFunction" access="public">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GoToNextFunction = False]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("GoToNextFunction returning " & GoToNextFunction & " so next function in the RuleSet will run.") ]]>
<![CDATA[
]]>
<![CDATA[	'Call ErrorHandler("Function GoToNextFunction") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</f>
<af name="SetReturnValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	on error resume next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetReturnValue = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Trim(StrParam)  ]]>
<![CDATA[
]]>
<![CDATA[  if (ucase(StrParam) = "TRUE") then]]>
<![CDATA[
]]>
<![CDATA[    SetReturnValue = True]]>
<![CDATA[
]]>
<![CDATA[  end if      ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("SetReturnValue returns: " & SetReturnValue)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="ProcessChildren" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ProcessChildren = FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  aStrParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If uBound(aStrParam) <> 1 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Expecting comma separated arguments (Condition,Command). Wrong number of parameters. Exiting")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call u_RecurseObject(CurrentObj,aStrParam(0),aStrParam(1),cint(0))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ProcessChildren = TRUE]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<f name="SetBatchPriority" access="public">
	<p name="Priority">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[' Sets the Batch priority for the current Batch]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim SmartVal]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetBatchPriority=False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SmartVal=MetaWord(Priority)]]>
<![CDATA[
]]>
<![CDATA[  If Len(SmartVal)>0 then Priority=SmartVal]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not Isnumeric(Priority) Then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Parameter must be numeric.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Priority=cInt(Priority)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Priority<0 Then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Parameter must be a non negative integer.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Pilot.Priority=Priority ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number=0 then]]>
<![CDATA[
]]>
<![CDATA[    SetBatchPriority=True]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Batch Priority set to '" & cStr(Priority) & "'")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="SetOperatorID" access="public">
	<p name="OperatorID">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[' Sets the Batch OperatorID for the current Batch]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartVal]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetOperatorID=False]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  SmartVal=MetaWord(OperatorID)]]>
<![CDATA[
]]>
<![CDATA[  If Len(SmartVal)>0 then OperatorID=SmartVal]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Pilot.Operator=cstr(OperatorID) ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number=0 then]]>
<![CDATA[
]]>
<![CDATA[    SetOperatorID=True]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Operator set to '" & OperatorID & "'")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="SetStationID" access="public">
	<p name="StationID">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[' Sets the Batch StationID for the current Batch]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartVal]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetStationID=False]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  SmartVal=MetaWord(StationID)]]>
<![CDATA[
]]>
<![CDATA[  If Len(SmartVal)>0 then StationID=SmartVal]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Pilot.Station=cStr(StationID) ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number=0 then]]>
<![CDATA[
]]>
<![CDATA[    SetStationID=True]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Station set to '" & StationID & "'")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="rrCompareNumeric" access="public">
	<p name="object1">
	</p>
	<p name="operator">
	</p>
	<p name="object2">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Dim sSourceA]]>
<![CDATA[
]]>
<![CDATA[	  Dim sSourceB]]>
<![CDATA[
]]>
<![CDATA[      Dim sSourceOperator]]>
<![CDATA[
]]>
<![CDATA[      Dim sValueA]]>
<![CDATA[
]]>
<![CDATA[      Dim sValueB]]>
<![CDATA[
]]>
<![CDATA[      Dim lValueA]]>
<![CDATA[
]]>
<![CDATA[      Dim lValueB]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      'Can be extend to other logical operators like <>, <= or >= if needed in future]]>
<![CDATA[
]]>
<![CDATA[      Dim sValidOperators ]]>
<![CDATA[
]]>
<![CDATA[      sValidOperators= "<,>,="]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Calling rrCompareNumeric....")]]>
<![CDATA[
]]>
<![CDATA[      On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[            	]]>
<![CDATA[
]]>
<![CDATA[	    rrCompareNumeric = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[      sSourceA = Trim(object1)]]>
<![CDATA[
]]>
<![CDATA[    	sSourceB = Trim(object2)]]>
<![CDATA[
]]>
<![CDATA[      sSourceOperator=Trim(operator)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[      	If len(sSourceA) = 0 Then sSourceA = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[	      If len(sSourceB) = 0 Then sSourceB = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        'if operator is blank then returns false.]]>
<![CDATA[
]]>
<![CDATA[        If len(sSourceOperator) = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Logical operator is a mandatory parameter. Returning false")]]>
<![CDATA[
]]>
<![CDATA[          rrCompareNumeric = False   ]]>
<![CDATA[
]]>
<![CDATA[          Exit Function]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        sValueA = MetaWord(sSourceA)]]>
<![CDATA[
]]>
<![CDATA[        sValueB = MetaWord(sSourceB)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Object 1: "+sValueA + " Object 2: "+sValueB+" Operator: "+sSourceOperator)]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[         'Check for numeric values if passed]]>
<![CDATA[
]]>
<![CDATA[         If Not (IsNumeric(sValueA) and IsNumeric(sValueB)) Then]]>
<![CDATA[
]]>
<![CDATA[           Writelog("Parameters used for comparison should be numeric. Returning false")]]>
<![CDATA[
]]>
<![CDATA[           Exit Function]]>
<![CDATA[
]]>
<![CDATA[         End if]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[         'Check if correct operator passed, verify from the list of valid operators]]>
<![CDATA[
]]>
<![CDATA[         If Not ( (InStr(sValidOperators,sSourceOperator) > 0)) Then]]>
<![CDATA[
]]>
<![CDATA[          Writelog(" Operator: "+ sSourceOperator +" is not valid operator. Allowed operators are <, > , = only. Returning false")]]>
<![CDATA[
]]>
<![CDATA[          Exit Function]]>
<![CDATA[
]]>
<![CDATA[         End if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[     lValueA=CDbl(sValueA)]]>
<![CDATA[
]]>
<![CDATA[     lValueB=CDbl(sValueB)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Checking condition...   " + lValueA + " "+sSourceOperator+" "+lValueB)]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[        Select case sSourceOperator]]>
<![CDATA[
]]>
<![CDATA[            case "="]]>
<![CDATA[
]]>
<![CDATA[                If lValueA = lValueB Then ]]>
<![CDATA[
]]>
<![CDATA[                      Writelog("Source A and B reference the same component. Returning True.")]]>
<![CDATA[
]]>
<![CDATA[                      rrCompareNumeric = True                ]]>
<![CDATA[
]]>
<![CDATA[                  Else]]>
<![CDATA[
]]>
<![CDATA[                      Writelog("Source A and B reference the different component. Returning False.")]]>
<![CDATA[
]]>
<![CDATA[                      rrCompareNumeric = False               ]]>
<![CDATA[
]]>
<![CDATA[                 End if]]>
<![CDATA[
]]>
<![CDATA[                 Exit Function]]>
<![CDATA[
]]>
<![CDATA[           case ">"]]>
<![CDATA[
]]>
<![CDATA[                 If lValueA > lValueB Then ]]>
<![CDATA[
]]>
<![CDATA[                    Writelog("Source A is greater than Source B. Returning True.")]]>
<![CDATA[
]]>
<![CDATA[                    rrCompareNumeric = True               ]]>
<![CDATA[
]]>
<![CDATA[                Else]]>
<![CDATA[
]]>
<![CDATA[                    Writelog("Source A is not greater than Source B. Returning False.")]]>
<![CDATA[
]]>
<![CDATA[                    rrCompareNumeric = False                ]]>
<![CDATA[
]]>
<![CDATA[                 End if]]>
<![CDATA[
]]>
<![CDATA[                 Exit Function]]>
<![CDATA[
]]>
<![CDATA[           case "<"]]>
<![CDATA[
]]>
<![CDATA[                 If lValueA < lValueB Then ]]>
<![CDATA[
]]>
<![CDATA[                      Writelog("Source A is smaller than Source B. Returning True.")]]>
<![CDATA[
]]>
<![CDATA[                      rrCompareNumeric = True                ]]>
<![CDATA[
]]>
<![CDATA[                  Else]]>
<![CDATA[
]]>
<![CDATA[                      Writelog("Source A is not smaller than Source B. Returning False.")]]>
<![CDATA[
]]>
<![CDATA[                      rrCompareNumeric = False                  ]]>
<![CDATA[
]]>
<![CDATA[                 End if]]>
<![CDATA[
]]>
<![CDATA[                 Exit Function]]>
<![CDATA[
]]>
<![CDATA[           case else]]>
<![CDATA[
]]>
<![CDATA[                 Writelog("Incorrect operator. Returning false")]]>
<![CDATA[
]]>
<![CDATA[                 rrCompareNumeric = False         ]]>
<![CDATA[
]]>
<![CDATA[                 Exit Function]]>
<![CDATA[
]]>
<![CDATA[      End Select                  ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Call ErrorHandler("rrCompareNumeric")       ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<g>
</g>
<f name="rrIsValidTMGroup" access="public">
	<p name="GroupName" type="string">
	</p>
</f>
<f name="rrAddTMGroup2Batch" access="public">
	<p name="GroupName" type="string">
	</p>
	<p name="IgnoreFailure" type="bool">
	</p>
</f>
<help>
  <![CDATA[
'*****************************************************************************
' help.xml for rrunner
'-----------------------------------------------------------------------------
' Licensed Materials - Property of IBM
' â€œRestricted Materials of IBMâ€
' 5725-C15 5725-C69
'
' Â© Copyright IBM Corp. 1994, 2016 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'*****************************************************************************

]]>

<ref id="Status_Preserve_ON">
  <ap>None.</ap>
  <h>
    This action changes the <i>Status Preserve</i> condition of a <b>Page</b> object - and
    its <b>Field</b> objects - from <i>Off</i> to <i> On</i>.<br/><br/>

    The <i>On</i> condition prevents the status of an object from being changed based on the
    final return value of a rule run on the object.  See the help for Status_Preserve_OFF
    for details about how an object's status is automatically updated when this condition
    is set to <i>Off</i>.<br/><br/>

    Using Status_Preserve_ON has no affect on actions that manually update the status
    such as an action like <b>rrSet("1","@F.STATUS").</b>
    <e>
      <b>Status_Preserve_ON()</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    Status_Preserve_OFF
  </see>
</ref>
  
<ref id="Status_Preserve_OFF">
  <ap>None.</ap>
  <h>
    This action turns the <i>Status Preserve</i> condition of a page and its fields from <i>On</i> to <i>Off</i>. <br/>
    <br/>
    When this action is used, the <i>Status</i> of an object will be affected based on the final return
    value of the ruleset.  When <i>Status Preserve</i> is off, the status of an object will be set to 0,
    if the ruleset completes with the last action run returns a true result for the current object.  
    If the last action run on the object returns a false, then the status of the object will be set to 1.  
    When a field status is 1, the Verify task's Data Entry
    panel will then highlight the value with a colored background, alerting the operator to the problem.<br/><br/>

    Typically Status_Preserve_OFF is used in a validation ruleset.  The usual intent of a validation ruleset is
    to run actions that confirm that the data in a field is as expected or meets certain critera.
    It is also typical that Status_Preserve_OFF is called once at the page
    level at the beginning of a ruleset.  When called at the page level, it will also allow the status to
    be updated at the field level based on the return value of the rules.  <br/><br/>

    Typically a validation ruleset is the last ruleset run in a task and the
    validation ruleset will test required fields to set the status of each field.  When
    Status_Preserve_OFF is called, it is in effect for all of the subsequent objects run on the
    current ruleset.  If there is a need to have <i>Status Preserve</i> off in a subsequent
    ruleset, then it will need to be called again in the subsequent ruleset.<br/><br/>

    When Status_Preserve_OFF is called, the status of the current object is changed based on the the true or false
    return value of the last action run.  It is also possible to update an object's status manually, 
    such as using an action like <b>rrSet("1","@F.STATUS").</b>  If an object's status is updated manually
    like this with rrSet, then the status may not be automatically changed as expected by the return value 
    of the last action. 
    For example, if you manually set the status to 1 as shown, then the current ruleset returns with true,
    the status of the object may remain at 1.  These two methods of automatically and manually 
    changing the status should not be intermixed.  Use one method or the other.<br/>
    <e>
      <b>Status_Preserve_Off()</b><br/><br/>
      In this example, it assumes the action is called at the page level and then 
      the status of each object processed within this ruleset
      will be set based on the true/false return value of the last action called on an object.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>
    Status_Preserve_ON
  </see>
</ref>
  
<ref id="DebugMode_ON">
  <ap>None.</ap>
  <h>
    This action turns on <b><i>enhanced</i></b> logging.<br/><br/>

    Enhanced logging expands the scope and depth of a processing log's information, and of the logs
    that a rulerunner task generates when you are testing a rule and its actions.<br/><br/>

    When enabled, this feature also increases a Log file's size significantly, and should only be used when you are
    testing the impact of an action and rule on the application's workflow. Use DebugMode_ON to enable this feature.

    The example below shows enhanced logging enabled during the course of several actions, after which it is disabled.
    <e>
      <b>DebugMode_On()</b><br/>
      ExportOpenConnection(@APPVAR(values/dsn/exportdb:cs))<br/>
      SetTableName(Invoice)<br/>
      ExportFieldToColumn(Number, db_Number)<br/>
      AddRecord()<br/>
      DebugMode_Off()
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="DebugMode_OFF">
  <ap>None.</ap>
  <h>
    This action turns off the <b><i>enhanced</i></b> logging procedures turned on by an earlier <b>DebugMode_On</b> action.<br/><br/>

    Enhanced logging expands the scope and depth of a processing log's information, and of the logs
    that a rulerunner task generates when you are testing a rule and its actions.<br/><br/>

    When enabled, this feature also increases a Log file's size significantly, and should only be used when you are
    testing the impact of an action and rule on the application's workflow. Use DebugMode_Off to disable this feature.
    
    <e>
      <b>DebugMode_Off()</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="CheckAllIntegrity">
  <ap>None.</ap>
  <h>
    Checks that the documents in the batch contain the correct type and number of pages, 
    in line with the Document Integrity requirements of the Document Hierarchy.
    <e>
      CreateDocuments()<br/>
      CheckAllIntegrity()<br/><br/>

      These actions are part of a rule applied to the <b>Batch</b> object of the Document
      Hierarchy. The first assembles documents from the pages in the batch; the second ensures
      that the makeup of each document is valid.
    </e>
  </h>
  <lvl>Batch level.</lvl>
  <ret>
    <b>True</b> if the Document Integrity of the current batch meets the requirements as defined
    in the setup of the Document Hierarchy. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="CheckDocCount">
  <ap>None.</ap>
  <h>
    The number of expected documents is usually provided by the operator of a job's Scan task.
    This very handy action can compare the actual amount to the estimate at any time after a
    <b>CreateDocuments</b> action has assembled the documents in the batch.<br/>
    <e>
      <b>CheckDocCount()</b>
    </e>
  </h>
  <lvl>Batch level.</lvl>
  <ret>
    <b>True</b> if the <b><i>actual</i></b> count is the same as the <b><i>expected</i></b> count.
    Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="CheckPageCount">
  <ap>None.</ap>
  <h>
    This is the action that confirms that the number of <b><i>actual</i></b>
    images - pages - in the current task's Page file (.xml) matches the count of
    <b><i>expected</i></b> pages.
    <e>
      <b>CheckPageCount()</b>
    </e>
  </h>
  <lvl>Batch level.</lvl>
  <ret>
    <b>True</b> if the two counts are equal. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="Task_RaiseCondition">
  <ap>
    Two comma-separated <i>Integer</i> values:<br/><br/>
    1. The applicable value of the sub-batch index. 0 is the first sub-batch,
    1 is the second, etc. The <b>Task_NumberOfSplits</b> action determines how many
    sub-batches are created.<br/><br/>

    2. The value that designates the Child Job Condition that should be assigned
    to the specified sub-batch. 0 is the first Child Job Condition, 1 is the second, etc.
  </ap>
  <h>
    Assigns the correct Child Job Condition to the correct sub-batch entry created by the Task_NumberOfSplits action.
    <e>
      Task_NumberOfSplits(1)<br/>
      Task_RaiseCondition(0,0)<br/>
      <br/>
      In this example, User Application is alerted to create one sub-batch entry and
      to raise the first Child Job Condition for this sub-batch entry.<br/><br/>      
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if either parameter is not <i>Numeric</i>. Otherwise, <b>True.</b>
  </ret>
  <see>Task_NumberOfSplits</see>
</ref>
  
<ref id="Task_NumberOfSplits">
  <ap>
    <i>Integer</i> value of the number of splits. In most cases, you will want to use "1" as the parameter.
  </ap>
  <h>
    Specifies how many times sub-batches have been created from the current batch.<br/>
    Important! The action communicates but does not use the Number_of_Splits value you enter as a parameter.
    <e>
      Task_NumberOfSplits(1)<br/>
      Task_RaiseCondition(0,0)<br/>
      <br/>
      Above, User Application is alerted to create one sub-batch entry, and to raise the
      second <b>child job condition</b> for this sub-batch entry. 
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter you enter is not <i>Numeric</i>. Otherwise, <b>True.</b>
  </ret>
  <see>Task_RaiseCondition</see>
</ref>
  
<ref id="SetTaskStatus">
  <ap>
    <i>Numeric</i> value representing the status that the task is to return to User Application.
    The statuses include: <br/><br/>
    0 - Abort<br/>
    1 - Cancelled<br/>
    2 - Finished<br/>
    4 - Hold<br/>
    8 - Pending
  </ap>
  <h>
    Sets the Task Status value that is to be returned to User Application when the current task finishes processing.
    <e>
      <b>SetTaskStatus(4)</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter is not <i>Numeric.</i> Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="SkipChildren">
  <ap>None.</ap>
  <h>
    Prevents rules applied to child objects of the current parent object from being run. 
    The action can optimize the execution of rules by eliminating the need to visit 
    every field on every page.
    <e>
      <b>SkipChildren()</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
 
 
<ref id="AbortOnError">
  <ap>
    <b>True:</b> Abort the batch if an error occurs.<br/>
    <b>False:</b> Do not abort the batch if an error occurs.
  </ap>
  <h>
    Determines if tasks that encounter errors are to abort, or continue processing.
    <e>
      <b>AbortOnError("True")</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter is not "True" or "False". Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="PilotMessage_Set">
  <ap>
    The smart parameter message to be assigned to the <b>MESSAGE</b> variable. Be sure to
    surround the message in quotation marks.
  </ap>
  <h>
    Provides a runtime MESSAGE variable to the bound object of the Document Hierarchy, 
    and assigns the Action's parameter as the variable value. 
    <e>
      <b>PilotMessage_Set("Field +@F+ Value is not Valid")</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="PilotMessage_Clear">
  <ap>None.</ap>
  <h>
    Removes the runtime MESSAGE variable from the bound object of the Document Hierarchy.
    <e>
      <b>PilotMessage_Clear()</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="MessageID">
    <ap>
      Two parameters.<br/>
      <br/><br/>
      <b>1.</b>  The message with index substitution indicators to be assigned to the <b>MESSAGE</b> variable. Be sure to
      surround the message in quotation marks.<br/>
      <br/>
      <b>2.</b>  The ID to be assigned to the Message to enable client side translation.<br/>
      <br/><br/>
    </ap>
    <h>
      Adds a runtime MESSAGE and a MessageID variable to the bound object of the Document Hierarchy.
      <e>
        <b>MessageID("The field '{0}' has a value of '{1}'.", FieldValueMessage01)</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
 </ref>
  
  <ref id="MessageIDParameter">
    <ap>
      Three parameters. Smart parameters are supported:<br/>
      <br/><br/>
      <b>1.</b>  The runtime value to replace a substitution indicator with. Smart parameters are supported.<br/>
      <br/>
      <b>2.</b>  The value's 'Type' to enable client side translation lookup. Permitted Type values are:<br/>
      "job", "task", "shortcut", "field", "workflow", "appname", "pagetype", "doctype", "text", "variable".<br/>
      <br/>
      <b>2.</b>  The index of the substitution.<br/>
      <br/><br/>
    </ap>
    <h>
     Adds a runtime Value, Type, and Substitution index for use with a preconfigured MESSAGE and MessageID variable to the bound object of the Document Hierarchy.
      <e>
        MessageID("The field '{0}' has a value of '{1}'.", FieldValueMessage01)<br/>
        <b>MessageIDParameter("@F.Name",field,0)</b><br/>
        <b>MessageIDParameter("@F",Text,1)</b><br/>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>
  
  <ref id="rrSet">
  <ap>
    Two parameters.  Smart parameters are supported:<br/>
    <br/><br/>
    <b>1.</b> A value or a smart parameter, which is a reference to a value, that will be copied.<br/>
    <br/>
    <b>2.</b> A smart parameter referencing a target which is receiving the value.<br/>
    <br/><br/>
    
    Either parameter is optional.  If a parameter is not specified, it will default to
    the calling object.  If the calling object is a field, it will use the field value.
    For batch, document and page objects, it will use a variable called "Text", creating
    the variable if it does not exist.
  </ap>
  <h>
    Uses the parameter's elements to locate the value of a source object's variable,
    and assign it to a specific variable of a second, receiving object.
    The action rrSet will set the target with the value from the source.  If using a field, only the value of the
    field will be changed.  You can use rrCopy if you wish to copy a field's
    value, confidence and image references (field positions) of the source field object.<br/>
    <e>
      <b>rrSet("@F.MySourceVar","@P.MyTargetVar")</b><br/>
      Obtains the value from the calling field "MySourceVar" variable and assigns it to parent page 
      of the calling object "MyTartgetVar" variable.<br/><br/>

      <b>rrSet("@D.Tot_Pages","@B.Tot_Pages")</b><br/>      
      This example assumes that the calling object is a child of a <b>Document</b> object. 
      It locates the value in the calling document's
      <i>Tot_Pages</i> variable and assigns it to the <i>Tot_Pages</i> variable of the <b>Batch</b> object.
      <br/><br/>
      
      <b>rrSet("@DICT_VALUE(..\MONTH)","")</b><br/>
      This example shows how Smart Parameters translates the OMR recognized value of the 
      MONTH field to the text from a predefined dictionary.  The text is then assigned
      to the calling object's Text property, if it is a field, or Text variable if it is not a field.
    </e>
    <br/>
    <br/>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the action cannot locate the target object.  Otherwise, <b>True.</b>
  </ret>
  <see>
    rrCopy, rr_Get, rrCompare
  </see>
</ref>

  <ref id="rrSet_ID" qi="Renames the target dco node with the source value.">
    <ap>
      Two parameters.  Smart parameters are supported:<br/>
      <br/><br/>
      <b>1.</b> A value or a smart parameter, which is a reference to a value, that will be used as the new Target ID.<br/>
      <br/>
      <b>2.</b> A smart parameter referencing a target which is receiving the new ID.<br/>
      <br/><br/>

      Either parameter is optional.  If a parameter is not specified, it will default to
      the calling object.  
    </ap>
    <h>
      Uses the parameter's elements to locate the value of a source object's variable,
      and assign it as the ID of a second, receiving object.
      The action rrSet_ID will set the target's ID with the value from the source.<br/>
      <e>
        <b>rrSet_ID("@F.MySourceVar","@P")</b><br/>
        Obtains the value from the calling field "MySourceVar" variable and assigns as the ID of 
        of the calling object's Parent page.<br/><br/>       
      </e>
      <br/>
      <br/>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if the action cannot locate the target object.  Otherwise, <b>True.</b>
    </ret>
    <see>
      rrCopy, rr_Get, rrCompare, rrSet
    </see>
  </ref>  
  
  
<ref id="rr_Get">
  <ap>
    A value or a smart parameter, which is a reference to a value, that will be copied to the calling object.
  </ap>  
  <h>
    Uses the parameter's elements to locate the value of a source object's variable,
    and assign it to the calling object.  If the calling object is a field, only the value of the
    field will be changed.
    <e>
      <b>rr_Get("@B.OPERATOR")</b><br/>
      This example retrieves the value of the <b>Batch</b> object's <b>Operator</b>
      property and assigns it to the calling object's <b>Text</b> property, if the calling object is a field.<br/><br/>
    
      <b>rr_Get("@DICT_WORD(..\MONTH)")</b><br/>
      This example shows how Smart Parameters translates the OMR recognized value of the
      MONTH field to the text from a predefined dictionary.  The text is then assigned
      to the calling object's Text property, if it is a field, or Text variable if it is not a field.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> the parameter is missing. Otherwise, <b>True.</b>
  </ret>
  <see>rrSet, rrCompare</see>
</ref>

  <ref id="rrContains">
    <ap>
      Three Parameters.<br/><br/>

      <b>1.</b> A value or a smart parameter, which is a reference to a value to be searched for.<br/><br/>

      <b>2.</b> A value or a smart parameter, which is a reference to a value that may contain the value from argument 1.<br/><br/>

      <b>3.</b> True to perform a case sensitive comparison, False to ignore case sensitivity. Default is False.<br/><br/> 

      <b>Note:</b> Either reference can specify a variable of the calling
      object (the bound object of the Document Hierarchy.) Alternatively, both references can
      identify a variable of an object that is a parent or child of the calling object.<br/><br/>

      All parameters are optional.  If either of the first two parameters are not specified, the argument will default to
      the calling object.  If the calling object is a field, it will use the field value.
      For batch, document and page objects, it will use look for a variable called "Text". It will not create
      the variable if it does not exist. If both first and second parameters are optional the action will always return
      true as the default object is being compared to itself.
    </ap>
    <h>
      Uses the Smart Parameters that you enter as the parameter to locate and
      compare the values of two object's variables.
      <e>
        rrContains("Dr","@P.Name")<br/><br/>

        This example shows how a value <i>Dr</i> is used as direct input, and the <b>Page</b> object's 
        <i>Name</i> variable is solicited. The two values are then compared: the action returns False 
        if the value <i>Dr</i> is not found in the value solicited from @P.Name.
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if the value of argument 1 is found in the value of argument 2. Otherwise, <b>False.</b>
    </ret>
    <see>rrCompareNot, rrCompare</see>
  </ref>

  <ref id="rrCompare">
  <ap>
    Two Smart Parameters.<br/><br/>

    <b>1.</b> A value or a smart parameter, which is a reference to a value.<br/><br/>

    <b>2.</b> A value or a smart parameter, which is a reference to a value, for comparison.<br/><br/>

    <b>Note:</b> Either reference can specify a variable of the calling
    object (the bound object of the Document Hierarchy.) Alternatively, both references can
    identify a variable of an object that is a parent or child of the calling object.<br/><br/>

    Either parameter is optional.  If a parameter is not specified, it will default to
    the calling object.  If the calling object is a field, it will use the field value.
    For batch, document and page objects, it will use a variable called "Text", creating
    the variable if it does not exist.
  </ap>
  <h>
    Uses the Smart Parameters that you enter as the parameter to locate and
    compare the values of two object's variables.
    <e>
      rrCompare("Expected_Pages","@B.Tot_Pages")<br/><br/>

      This example shows how a value is solicited from the field <i>Expected_Pages</i>
      off of the calling object and the <b>Batch</b> object. The two values are then
      compared: the action returns False if the values are not the same.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the compared values do not match. Otherwise, <b>True.</b>
  </ret>
  <see>rrCompareNot</see>
</ref>  
 
<ref id="rrCompareCase">
   <ap>
      Three Parameters.<br/><br/>

      <b>1.</b> A value or a smart parameter, which is a reference to a value.<br/><br/>

      <b>2.</b> A value or a smart parameter, which is a reference to a value, for comparison.<br/><br/>
      
      <b>Note:</b> Either reference can specify a variable of the calling
      object (the bound object of the Document Hierarchy.) Alternatively, both references can
      identify a variable of an object that is a parent or child of the calling object.<br/><br/>

      Either parameter is optional.  If a parameter is not specified, it will default to
      the calling object.  If the calling object is a field, it will use the field value.
      For batch, document and page objects, it will use a variable called "Text", creating
      the variable if it does not exist.<br/><br/>

      <b>3.</b> 'True' performs a case sensitive compare.  'False' performs a case insensitive compare.
     If not supplied, the default is 'False'.<br/><br/>
    </ap>
    <h>
      Performs a comparison of two strings or smart parameters to see if they are identical.  
      The comparison can be performed case sensitive or case insensitive.
      <e>
        <b>rrCompareCase("Main_Job","@JOBID", "False")</b><br/><br/>
        
        Compares the string "Main_Job" to the current Job ID.  The compare is
        case insensitive.  If the current Job ID is "MAIN_JOB", the action will return True.<br/><br/>

        <b>rrCompareCase("Main_Job","@JOBID", "True")</b><br/><br/>

        Compares the string "Main_Job" to the current Job ID.  The compare is
        case sensitive.  If the current Job ID is "MAIN_JOB", the action will return False.<br/><br/>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if the compared values do not match. Otherwise, <b>True.</b>
    </ret>
    <see>rrCompareNot, rrCompare</see>
  </ref>

<ref id="rrCompareCaseLength">
  <ap>
    Five Parameters.<br/><br/>

    <b>1.</b> A value or a smart parameter, which is a reference to a value.<br/><br/>

    <b>2.</b> A value or a smart parameter, which is a reference to a value, for comparison.<br/><br/>

    <b>3.</b> 'True' performs a case sensitive compare.  'False' performs a case insensitive compare.<br/><br/>

    <b>4.</b> An integer for the number of characters to compare.  If the length is 0, then the entire string will be compared.<br/><br/>

    <b>5.</b> 'True' compares from the start of the string.  'False' compares from the end of the string.<br/><br/>
  </ap>
  <h>
    Uses the Smart Parameters that you enter as the parameter to locate and
    compare the values of two object's variables.  The comparison can be limited to
    a specified number of characters from the start or end of the string. 
    The comparison can be performed case sensitive or case insensitive.
    <e>
      <b>rrCompareCaseLength("Main","@JOBID", "False", 4, "True")</b><br/><br/>

      Compares the string "Main" to the current Job ID.  Only the first 4 letters are compared and the compare is
      case insensitive.  If the current Job ID is "MAIN_JOB", the action will return True.<br/><br/>

      <b>rrCompareCaseLength("Main","@JOBID", "True", 4, "True")</b><br/><br/>

      Compares the string "Main" to the current Job ID.  The compare is
      case sensitive. If the current Job ID is "MAIN_JOB", the compare will not match due to case and the action will return False.<br/><br/>

      <b>rrCompareCaseLength("Main Line","Main Job", "True", 4, "True")</b><br/><br/>

      Compares the string "Main Line" to the string "Main Job.  The compare is
      case sensitive and only the first 4 characters are compared.  
      The action will return True.<br/><br/>

      <b>rrCompareCaseLength("@P.ScanSrcPath","GOOD.BMP", "False", 8, "False")</b><br/><br/>

      Performs a case insensitive compare of the last 8 characters of the
      ScanSrcPath page variable to the last 8 characters of the string "GOOD.BMP".
      If the value of ScanSrcPath is "c:\test\testvalidate\images\good.bmp", the
      action will return True.<br/><br/>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the compared values do not match. Otherwise, <b>True.</b>
  </ret>
  <see>rrCompareNotCaseLength, rrCompareNot, rrCompare</see>
</ref>

<ref id="rrCompareNotCase">
  <ap>
    Two Smart Parameters.<br/>
    <br/>
    <b>1.</b> A value or a smart parameter, which is a reference to a value.<br/>
    <br/>
    <b>2.</b> A value or a smart parameter, which is a reference to a value, for comparison.<br/><br/>
    
    <b>Note:</b> Either reference can specify a variable of the calling object.
    Alternatively, both references can identify 
    a variable of an object that is a parent or child of the calling object.<br/><br/>

    Either parameter is optional.  If a parameter is not specified, it will default to
    the calling object.  If the calling object is a field, it will use the field value.
    For batch, document and page objects, it will use a variable called "Text", creating
    the variable if it does not exist.

    <b>3.</b> 'True' performs a case sensitive compare.  'False' performs a case insensitive compare.
    If not supplied, the default is 'False'.<br/><br/>
  </ap>
  <h>
    This action is the negation of rrCompareCase.  It can be handy for when an action should be
    performed only when two values are different.
    <e>
      <b>rrCompareNotCase("Main_Job","@JOBID", "False")</b><br/><br/>

      Compares the string "Main_Job" to the current Job ID.  The compare is
      case insensitive.  If the current Job ID is "MAIN_JOB", the strings match 
      so the action will return False.<br/><br/>

      <b>rrCompareNotCase("Main_Job","@JOBID", "True")</b><br/><br/>

      Compares the string "Main_Job" to the current Job ID.  The compare is
      case sensitive. If the current Job ID is "MAIN_JOB", the strings do not match
      so the action will return True.<br/><br/>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True</b> if the compared values do not match. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="rrCompareNot">
  <ap>
    Two Smart Parameters.<br/>
    <br/>
    <b>1.</b> A value or a smart parameter, which is a reference to a value.<br/>
    <br/>
    <b>2.</b> A value or a smart parameter, which is a reference to a value, for comparison.<br/><br/>
    
    <b>Note:</b> Either reference can specify a variable of the calling object.
    Alternatively, both references can identify 
    a variable of an object that is a parent or child of the calling object.<br/><br/>

    Either parameter is optional.  If a parameter is not specified, it will default to
    the calling object.  If the calling object is a field, it will use the field value.
    For batch, document and page objects, it will use a variable called "Text", creating
    the variable if it does not exist.
  </ap>
  <h>
    This action is the negation of rrCompare.  It can be handy for when an action should be
    performed only when two values are different.
    <e>
      <b>rrCompareNot("Expected_Pages","@B.Tot_Pages")</b><br/>
      rr_AbortBatch()<br/><br/>

      This example shows how a value is solicited from the field <i>Expected_Pages</i>
      off of the calling object and the <b>Batch</b> object. The two values are then compared: the action
      returns True if the values are not the same.  Here, the batch will abort if the expected
      pages do not match the total pages.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True</b> if the compared values do not match. Otherwise, <b>False.</b>
  </ret>
</ref>

<ref id="rrCompareNotCaseLength">
  <ap>
    Five Parameters.<br/><br/>

    <b>1.</b> A value or a smart parameter, which is a reference to a value.<br/><br/>

    <b>2.</b> A value or a smart parameter, which is a reference to a value, for comparison.<br/><br/>

    <b>3.</b> 'True' performs a case sensitive compare.  'False' performs a case insensitive compare.<br/><br/>

    <b>4.</b> An integer for the number of characters to compare.  If the length is 0, then the entire string will be compared.<br/><br/>

    <b>5.</b> 'True' compares from the start of the string.  'False' compares from the end of the string.<br/><br/>
  </ap>
  <h>
    This action is the negation of rrCompareCaseLength.  It can be handy for when an action should be
    performed only when two values are different.<br/><br/>
    
    Uses the Smart Parameters that you enter as the parameter to locate and
    compare the values of two object's variables.  The comparison can be limited to
    a specified number of characters from the start or end of the string.
    The comparison can be performed case sensitive or case insensitive.
    <e>
      <b>rrCompareNotCaseLength("Main","@JOBID", "False", 4, "True")</b><br/><br/>

      Compares the string "Main" to the current Job ID.  Only the first 4 letters are compared and the compare is
      case insensitive.  If the current Job ID is "MAIN_JOB", the action will return False.<br/><br/>

      <b>rrCompareNotCaseLength("Main","@JOBID", "True", 4, "True")</b><br/><br/>

      Compares the string "Main" to the current Job ID.  The compare is
      case sensitive so the current Job ID is "MAIN_JOB", the comparison will 
      not match due to case differences and the action will return True.<br/><br/>

      <b>rrCompareNotCaseLength("Main Line","Main Job", "True", 4, "True")</b><br/><br/>

      Compares the string "Main Line" to the string "Main Job.  The compare is
      case sensitive and only the first 4 characters are compared.  The comparison matches so
      the action will return False.<br/><br/>

      <b>rrCompareNotCaseLength("@P.ScanSrcPath","GOOD.BMP", "False", 8, "False")</b><br/><br/>

      Performs a case insensitive compare of the last 8 characters of the
      ScanSrcPath page variable to the last 8 characters of the string "GOOD.BMP".
      If the value of ScanSrcPath is "c:\test\testvalidate\images\good.bmp", the
      comparison will match so the action will return False.<br/><br/>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True</b> if the compared values do not match. Otherwise, <b>False.</b>
  </ret>
  <see>rrCompareNotCaseLength, rrCompareNot, rrCompare</see>
</ref>

<ref id="rrCopy">
  <ap>
    Two Smart Parameters:<br/><br/>
    <b>1.</b> A reference to the source field.<br/>
    <b>2.</b> A reference to the target field.<br/><br/>
    
    Either parameter is optional.  If a parameter is not specified, the calling object 
    must be a field.
  </ap>
  <h>
    The action retrieves the value, confidence and image references (field positions) of the source field object,
    and copies them to the target field object.
    Uses the Smart Parameters you enter as a parameter to copy the value of a source
    field object to a target field object. This action is unusual in that it is intended
    to work only on field objects.<br/><br/>

    Note: rrCopy copies more than just the value of the field as mentioned above.
    Use rrSet if only the field value should be copied.   
    This action is unusual in that it is intended to work only on field objects.<br/>
    <e>
      <b>rrCopy("@B\OPERATOR","@P\OPERATOR")</b>
    </e><br/>
    This example copies the Batch field <i>OPERATOR</i> value to the
    <i>OPERATOR</i> field of the bound object of the Document Hierarchy - whatever that happens to be.
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the action cannot retrieve the target or source object. Otherwise, <b>True.</b>
  </ret>
  <see>
    rrSet, rr_Get
  </see>
</ref>

<ref id="rrAppend">
  <ap>
    Two Smart Parameters:<br/><br/>
    <b>1.</b> The source value.<br/><br/>
    <b>2.</b> A reference to the target field.<br/><br/>

    Both parameters are optional.  If a parameter is not specified, it will default to
    the calling object.  If the calling object is a field, it will use the field value.
    
  </ap>
  <h>
    The action retrieves the value of the source object, and "appends" it to the target value.
    <e>
      <b>rrAppend("@D.DocID","@F")</b><br/>
      <br/>
      This action inserts the current calling object's parent DocID variable value and
      appends it to the calling field's value.
    </e>
    Note: Target can not be a variable. If the source and target are the same, the action has no effect.    
  </h>
  <lvl>All</lvl>
  <ret>
    <b>False</b> if the action cannot
    locate the target object or if the source value is empty. Otherwise, <b>True.</b>
  </ret>
  <see>rrPrepend</see>
</ref>

<ref id="rrPrepend">
  <ap>
    Two Smart Parameters:<br/><br/>
    <b>1.</b> The source value.<br/><br/>
    <b>2.</b> A reference to the target object.<br/><br/>

    Either parameter is optional.  If a parameter is not specified, it will default to
    the calling object.  If the calling object is a field, it will use the field value.
  </ap>
  <h>
    The action retrieves the value of the source object, and "pre-appends" it to the target field value.
    <e>
      <b>rrPrepend("@D.DocID","@F")</b><br/>
      <br/>
      This action inserts the current calling object's parent DocID variable value and pre-appends
      it to the calling field's value.
    </e>
    Note: Target can not be a variable.
  </h>
  <lvl>All, target must be a field object.</lvl>
  <ret>
    <b>False</b> if the calling object and target object are the same, if the action cannot
    locate the target object's variable, or if the source value argument or object returns
    an empty string. Otherwise, <b>True.</b>
  </ret>
  <see>rrAppend</see>
</ref>  
  
<ref id="rr_WriteNode">
  <ap>None.</ap>
  <h>
    Sets up a separate XML data file element for the calling object during rulerunner processing.
    <e>
      <b>rr_WriteNode()</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="rr_AbortBatch">
  <ap>None.</ap>
  <h>
    Stops processing the current batch and sets the status of the batch to Abort.
    <e>rr_AbortBatch()</e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="GoToNextFunction">
  <ap>None.</ap>
  <h>
    Returns a <b>False</b> condition so that the next function in the RuleSet can run.
    <e>
      <scr>IsFieldMatching("Skip")</scr><br/>
      <b>GoToNextFunction()</b><br/><br/>

      If the condition in the first action is met, the sequence assigns a
      <b>False</b> status to the second action and to the rule of
      which it is a part. As a result, execution contines with the next function in the Rule.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>False.</b>
  </ret>
</ref>

<ref id="SetReturnValue">
  <ap>
    <b>True:</b> The action will return true.<br/>
    <b>False:</b> The action will return false.
  </ap>
  <h>
    This action will return true or false based on the input parameter.<br/><br/>
    
    By passing in true, the action will return true and continue with the actions in the current function.  If this is the last
    action in a function, any following functions within the rule to be skipped.<br/><br/>

    One use for this action
    is a quick way to disable a rule by adding a new function, that precedes all other functions
    in the rule, where the new function contains only this action with a parameter of true.  This will cause
    all other functions in the rule to be skipped and the next rule will run.<br/><br/>

    Using a parameter of false, this action will return false, causing all following actions in the function 
    to be skipped and control carries forward to the next function in the same rule.  In this way, the operation
    is identical to the action GoToNextFunction.
    <e>
      <b>SetReturnValue("true")</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True,</b> if the action is passed the parameter 'true'.  Otherwise, <b>False.</b>
  </ret>
  <see>GoToNextFunction, FailRuleSet, rr_AbortBatch</see>
</ref>

  <ref id="ProcessChildren">
    <ap>
      A two-part, comma-separated specification of a Condition and a Command.<br/><br/>

      The Condition is any valid VBScript expression. The Command is the VB executable
      that results from the Condition.
    </ap>
    <h>
      A follow-up action that initiates the processing of elements represented by the bound object, and all its children.
      <e>
        <b>ProcessChildren("1,Exit")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if the number or sequence of the arguments are invalid. Otherwise, <b>True.</b>
    </ret>
  </ref>
  <ref id="SetBatchPriority">
    <ap>
      A single value to update the batch priority at the end of the Task.<br/><br/>      
    </ap>
    <h> 
      Sets the priority of the batch at the completion of the Task. Values are typically 1-9 with 5 being the median. Batches with priority 1 are processed first, batches with priority 9 are processed last.
      <e>
        <b>SetBatchPriority("1")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if the value of the argument is invalid. Otherwise, <b>True.</b>
    </ret>
  </ref>
  <ref id="SetOperatorID">
    <ap>
      A Single value representing the new Operator ID value.<br/><br/>
    </ap>
    <h>
      Sets the Operator ID at the completion of the Task.
      <e>
        <b>SetOperatorID("admin")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if setting the value throws an error. Otherwise, <b>True.</b>
    </ret>
  </ref>
  <ref id="SetStationID">
    <ap>
      A Single value representing the new Station ID value.<br/><br/>
    </ap>
    <h>
      Sets the Station ID at the completion of the Task.
      <e>
        <b>SetStationID("4")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if setting the value throws an error. Otherwise, <b>True.</b>
    </ret>
  </ref>
  
  <ref id="rrCompareNumeric">
    <ap>
      Two Smart Parameters and one Operator.<br/><br/>

      <b>1.</b> A numeric value or a smart parameter, which is a reference to a numeric value.<br/><br/>
      <b>2.</b> Comparison operator as second parameter. Operator can be one of these <b>&gt; ,</b><b>&lt; ,</b><b>=</b><br/><br/>

      <b>3.</b> A numeric value or a smart parameter, which is a reference to a numeric value, for comparison.<br/><br/>

      <b>Note:</b> Either reference can specify a variable of the calling
      object (the bound object of the Document Hierarchy.) Alternatively, both references can
      identify a variable of an object that is a parent or child of the calling object.<br/><br/>

      Either of the two parameter to compare is optional.  If a parameter is not specified, it will default to
      the calling object.  If the calling object is a field, it will use the field value.
      For batch, document and page objects, it will use a variable called "Text", creating
      the variable if it does not exist.<br/><br/>
    </ap>
    <h>
      Uses the Smart Parameters that you enter as the parameter to locate and
      compare the numeric values of two object's variables.
      <e>
        Example 1 : rrCompareNumeric("@P\Total_Cost",&gt;,"100")<br/><br/>
        
        Assuming rule is configured at page level and getting the <i>Total_Cost</i>  field value present in that page.
        If the value in field <i>Total_Cost</i> is greater that 100 then the action will return TRUE else will return FALSE.<br/><br/>
      

        Example 2 : rrCompareNumeric("@P.TemplateID",=,"555")<br/><br/>
        
        This example shows a value from a page variable <i>@P.TemplateID</i> to be compare with the value 555 which is default fingerprint.
        If the <i>@P.TemplateID</i> is equal to 555 then the action will return True else it will return false. 
        From the result the conclusion can be make that the default fingerprint is being used.

      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if the parameters to compare are not numeric, if operator is not specified or if the condition is not satisfied, else will return  <b>True.</b>
    </ret>
  </ref>

  <ref id="rrIsValidTMGroup">
    <ap>
      <b>GroupName</b> The name of a group to test. Smart parameter is supported.<br/>
    </ap>
    <h>
      <p>
        Tests if given group can be assigned to the current batch. 
      </p>
      <p>
        Only groups to which current user belongs can be assigned to the current batch.
      </p>
      <p>
        This action is only useful when running in Taskmaster environment against a live batch.
      </p>
      <e>
        <p>
          <b>rrIsValidTMGroup</b>("Verifiers2")<br/>
        </p>
        This example tests if group 'Verifiers2' can be assigned to the current batch
      </e>
    </h>
    <lvl>Any level</lvl>
    <ret>
      <b>True</b> if given group can be assigned to the current batch. Otherwise <b>False</b>. If errors happen while attempting to validate the group <b>False</b> is returned.
    </ret>
  </ref>

  <ref id="rrAddTMGroup2Batch">
    <ap>
      <b>GroupName</b> The name of a group to assign to batch. Smart parameter is supported.<br/>
      <b>IgnoreFailure</b> Set to <b>True</b> to ignore errors and/or if given group is invalid and return success to avoid failing rule function. Otherwise set to <b>False</b> <br/>
    </ap>
    <h>
      <p>
        Adds given group, if valid, to the list of assigned groups of the current batch
      </p>
      <p>
        Only groups to which current user belongs can be assigned to the current batch.
      </p>
      <p>
        This action is only useful when running in Taskmaster environment against a live batch.
      </p>
      <p>
        Validity of the given group is always enforced even if <b>IgnoreFailure</b> is set to <b>True</b>.<br/>
        If <b>IgnoreFailure</b> is set to <b>True</b> action will report success always but it will not assign invalid group to the batch.
      </p>
      <e>
        <p>
          <b>rrAddTMGroup2Batch</b>("Verifiers2", False)<br/>
        </p>
        This example attempts to assign group 'Verifiers2' to the current batch. If errors happen or if 'Verifiers2' is invalid the action fails and doesn't assign the group to the batch.
      </e>
      <e>
        <p>
          <b>rrAddTMGroup2Batch</b>("Scanners1", True)<br/>
        </p>
        This example attempts to assign group 'Scanners1' to the current batch. If errors happen or if 'Scanners1' is invalid the action succeeds anyway but doesn't assign the group to the batch.
      </e>
    </h>
    <lvl>Any level</lvl>
    <ret>
      <b>True</b> if given group can be assigned to the current batch. Otherwise <b>False</b>. If errors happen while attempting to validate the group <b>False</b> is returned.
    </ret>
  </ref>
</help>
</rrx>
<rrx namespace="SharedRecognitionTools" src="c:\datacap\RRS\SharedRecognitionTools.dll">

<net ref="SharedRecognitionTools.Actions">
	<h>
<![CDATA[
]]>
<![CDATA[    The shared recognition tools actions expose helped actions that can be used after recognition using the different OCR libraries, such OCR_A, OCR_SR, etc.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
		<br>
		</br>
		<br>
		</br>
<![CDATA[Actions that can produce the layout XML include OCR_SR.Recognize and OCR_A.Recognize, both of which can process color images and PDF files.  To use the Locate actions and perform click ‘n’ key during verification, use the action CreateCcoFromLayout to create a CCO file for the page after producing the layout XML file.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</h>
	<method name="CreateCcoFromLayout">
		<h>
<![CDATA[
]]>
<![CDATA[      Creates a CCO file after recognition or conversion is performed.  The CCO is needed for the locate actions and for click ‘n’ key during verification.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      CreateCcoFromLayout requires a previously created layout file (for example: tm000001_layout.xml) where text is grouped into blocks.  ]]>
<![CDATA[
]]>
<![CDATA[      See the DocumentAnalytics help introduction for information on the layout XML file.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        Recognize()]]>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[CreateCcoFromLayout()]]>
				</b>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[Page]]>
		</lvl>
		<ret>
<![CDATA[
]]>
<![CDATA[      Always ]]>
			<b>
<![CDATA[True.]]>
			</b>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
	</method>
</net>
</rrx>
<rrx namespace="SPExport" src="c:\datacap\RRS\SPExport.dll">

<i ref="rrunner">
</i>
<af name="SP_SetUrl" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SP_SetContentType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SP_Login" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SP_CreateFolder" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SP_SetProperty" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SP_Upload" access="public" bInter="bInter" bDebug="bDebug">
</af>
<af name="SP_UploadDir" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SP_SetFileType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<af name="SP_SetUploadMode" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
</af>
<help>
<![CDATA[

'************************************************************************
' SPExport.rrx - Microsoft SharePoint Server Upload Actions
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2014 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************************
' 
' Converted from SPExport.rrx, and 
' initial Help.xml created 6/12/2012 VKandasamy
'
]]>
  <ref id="SP_SetUrl">
    <ap>
      The full URL to the SharePoint repository.  Smart parameters are supported.  Refer to
      the Smart Parameter documentation for more information.
    </ap>
    <h>
      Sets target URL of location to which image files are uploaded.<br/><br/>
      Note: ”/Docs/Documents/” is default Document Library within SharePoint site.
      <e>
        <b>SP_SetUrl("http://blue/Docs/Documents/+@BatchID+/+@ID")</b><br/><br/>

        With this example, directories with names defined by /+@BatchID+/+@ID will be created
        automatically during upload.
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if the action succeeded. Otherwise, <b>False.</b>
    </ret>
  </ref>
  
  <ref id="SP_SetContentType">
    <ap>
      A valid SharePoint content type in the selected Library. No error is raised if it
      is not a valid content type.  Smart Parameters are supported.
    </ap>
    <h>
      This action sets the SharePoint Content Type for each document that is subsequently
      uploaded. Content Type is a SharePoint concept that defines a subset of columns
      (fields) within a library of documents, to be displayed and edited for a specific purpose.
      <e>
        <b>SP_SetContentType("Invoice")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if the content type was successfully set or if the content type is not a valid content type.<br/>
      <b>False</b> if there is failure returned from SharePoint.
    </ret>
  </ref> 
  
  <ref id="SP_Login" >
    <ap>
      A string containing 3 comma separated input parameters.<br/>
      <b>1.</b> SharePoint userID.<br/>
      <b>2.</b> Password. <br/>
      <b>3.</b> An optional SharePoint domain.  If not included, do not include the preceding comma.<br/><br/>

      Smart Parameters are supported.  Use smart parameters to prevent clear text
      passwords in your application by obtaining the password from
      the appliation service.
    </ap>
    <h>
      Login to SharePoint with credentials OTHER than the logged-in Windows User.
      <e>
        SP_SetUrl("http://blue/Docs/Documents/+@BatchID+/+@ID")<br/>
        <b>SP_Login("userID,password,domain")</b><br/>
        SP_SetContentType("Invoice")<br/>
        SP_SetFileType("jpg")<br/>
        SP_SetProperty("Date,@Value")<br/>
        SP_Upload()<br/><br/>

        Alternativly, you can use smart parameters to obtain information from
        the application service to prevent clear text passwords.  Here is an example
        where the password is stored in a custom value called SPPassword in
        the application service:<br/><br/>

        <b>SP_Login("userID,@APPVAR(values/adv/SPPassword),domain")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if the login succeeded.  Otherwise, <b>False.</b><br/>
      Note that if the login parameters are invalid, a failure may not occur until you call "SP_Upload".
    </ret>
  </ref>
  
  <ref id="SP_CreateFolder">
    <ap>
      The URL that specifies the folder to create in SharePoint.  Smart parameters are supported.
      Refer to the Smart Parameter documentation for more information.
    </ap>
    <h>
      Creates the SharePoint folder specified in the parameter string.<br/>
      Note: The SP_SetUrl action optionally can define directories and subdirectories
      to be created during the upload.
      <e>
        <b>SP_CreateFolder("http://blue/Docs/Documents/Test")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if the folder was created successfully or if it already exists.  Otherwise, <b>False.</b>
    </ret>
  </ref>
  
  <ref id="SP_SetProperty">
    <ap>
      Two comma separated values:<br/>
      <b>1.</b> Column name is the name or ID of the target column in SharePoint.<br/>
      <b>2.</b> Data value is the value to be uploaded to that column. Refer to
      the documentation for more information about the column types.<br/>
      Smart Parameters are supported.
    </ap>
    <h>
      Sets an index value (column in SharePoint) for the document(s) to follow.  Can be
      called multiple times to set multiple index values.<br/><br/>

      Notes:<br/>
      Any spaces in column names must be replaced with “_0x02c_”. <br/>
      The “real” column name may be different from what is displayed in SharePoint. To
      determine the real Column name select the column settings and check the browser address.
      For example for the property called "Description" you may
      see "....3F2%7D Field=Comments" at the end.  This means that the real name of the
      Column to be used in the SP_SetProperty action is "Comments".

      <e>
        <b>SP_SetProperty("Date,@Value")</b><br/>
        SP_Upload()<br/><br/>
        Moves the value of the current field to the SharePoint column named Date.
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if the parameters are not blank.  The index information is uploaded to
      SharePoint when a document is subsequently uploaded.  Otherwise, <b>False.</b>
    </ret>
  </ref>

  <ref id="SP_SetProperty">
    <ap>
      Two comma separated values:<br/>
      <b>1.</b> Column name is the name or ID of the target column in SharePoint.<br/>
      <b>2.</b> Data value is the value to be uploaded to that column. Refer to
      the documentation for more information about the column types.<br/>
      Smart Parameters are supported.
    </ap>
    <h>
      Sets an index value (column in SharePoint) for the document(s) to follow.  Can be
      called multiple times to set multiple index values.<br/><br/>

      Notes:<br/>
      Any spaces in column names must be replaced with “_0x02c_”. <br/>
      The “real” column name may be different from what is displayed in SharePoint. To
      determine the real Column name select the column settings and check the browser address.
      For example for the property called "Description" you may
      see "....3F2%7D Field=Comments" at the end.  This means that the real name of the
      Column to be used in the SP_SetProperty action is "Comments".

      <e>
        <b>SP_SetProperty("Date,@Value")</b><br/>
        SP_Upload()<br/><br/>
        Moves the value of the current field to the SharePoint column named Date.
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if the parameters are not blank.  The index information is uploaded to
      SharePoint when a document is subsequently uploaded.  Otherwise, <b>False.</b>
    </ret>
  </ref>

  <ref id="SP_Upload">
    <ap>None.</ap>
    <h>
      Uploads the image file and any indexes specified for the current page, document,
      or batch to SharePoint.  Uses TiffMerge file naming scheme to find document level or batch level
      image file: DocID.TIF or BatchID.TIF by default.  Pages associated with other image file types
      (e.g. TM000001.pdf, TM000001.jpg, etc) can be uploaded.<br/><br/>

      Note: after uploading, the variable “Upload_Folder” in the page/doc/batch will be set
      to the SharePoint URL where the document(s) were uploaded.<br/><br/>

      Note: if some documents in a batch are successfully uploaded and some fail, and the
      batch is re-run through the SharePoint Upload task, only documents that failed to upload will
      be re-uploaded.<br/><br/>

      Note: if any document is re-uploaded, SharePoint will replace the existing document with the
      newer one, or save the old version and replace it with the new version, depending on
      SharePoint Versioning settings.
      <e>
        <b>SP_Upload()</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>True</b> if all documents and indexes were successfully uploaded.  Otherwise, <b>False.</b>
    </ret>
  </ref>

  <ref id="SP_UploadDir">
    <ap>
      Two comma separated parameters:<br/><br/>
      <b>1.</b> The Windows folder containing only document files to upload.<br/>
      <b>2.</b> A Boolean. True means delete file after upload, false means move file to the
      ‘Uploaded’ folder in current directory<br/><br/>
      
      Smart parameters are supported.
    </ap>
    <h>
      Uploads all files in specified folder.
      <e>
        <b>SP_UploadDIR("C:\ParentDir\Invoice\Images\Input\,false")</b>
      </e>
    </h>
    <lvl>Batch or Document level.</lvl>
    <ret>
      <b>True</b> if the upload succeeds for all files in the directory.  Otherwise, <b>False.</b>
    </ret>
  </ref>

  <ref id="SP_SetFileType">
    <ap>
      A string indicating the type or filename extension of the images to be uploaded for
      each document or batch. When uploading the Batch or Document this extension is
      appended to the BatchID or DocumentID to select the image. The IMAGEFILE property takes
      precedence for Page uploads. See the description of SP_Upload for details.<br/><br/>
      
      Valid parameters include: tif, tiff, jpg, jpeg, jpe, gif or pdf.
      The parameter may optionally include a period (for example .tif and .jpeg are also valid).<br/><br/>
      
      Smart parameters are supported.
    </ap>
    <h>
      NOTE: SP_SetUploadMode takes precedence over SP_SetFileType, if SP_SetUploadMode is called
      prior to SP_Upload this parameter has no effect.<br/>
      If neither SP_SetFileType nor SP_SetUploadMode are called, tif is used as the default file type.
      <e>
        <b>SP_SetFileType("jpg")</b>
      </e>
    </h>
    <lvl>All.</lvl>
    <ret>
      <b>False</b> if the parameter is not a three-character extension, jpeg, or tiff, with or without a leading period. .  Otherwise <b>True.</b><br/>
      Note: if a three-character extension is supplied that is invalid for Sharepoint images, the upload may fail.
    </ret>
    <see>SP_Upload</see>
  </ref>

  <ref id="SP_SetUploadMode">
    <ap>
      A string or Smart Parameter identifying the page level variable where file name stored.
      If this action is not called the value defaults to blank and regular upload logic applied.<br/>
      For example SP_SetUploadMode("ParentImage") will cause uploading file with the name stored
      in  'ParentImage' variable on the page level.
    </ap>
    <h>
      Use this action to identify the files that will be uploaded to SharePoint.
      <e>
        <b>SP_SetUploadMode(ParentImage)</b><br/>
        SP_Upload()
      </e>
    </h>
    <lvl>Batch, Document or Page level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>  
</help>
</rrx>
<rrx namespace="split" src="c:\datacap\RRS\split.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="SplitBatch" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Splits documents or pages in the batch into sub-batches, according to the value of the smart parameter you enter.]]>
<![CDATA[
]]>
<![CDATA[  ' If a page is part of a document, it goes along with all other pages in that parent document. For more information, ]]>
<![CDATA[
]]>
<![CDATA[  ' see the Parameters and Details sections below. "]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   'A <b>smart parameter</b> that determines the sub-batch for each document or page.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[   ' <b>Important:</b> The action evaluates each document and loose page in the batch. ]]>
<![CDATA[
]]>
<![CDATA[   ' An unbound page is any page not inside a document.  ]]>
<![CDATA[
]]>
<![CDATA[   ' The set of smart parameter values found during the evaluation are grouped into "buckets":<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[   ' 1. Identical values go into the same bucket.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[   ' 2. If there are multiple buckets, all pages/documents that share the same value will ]]>
<![CDATA[
]]>
<![CDATA[   ' split to the same child batch.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[   ' 3. There can be only <i>one child batch</i> for <i>each unique bucket value.</i><br/><br/>]]>
<![CDATA[
]]>
<![CDATA[   ' ]]>
<![CDATA[
]]>
<![CDATA[   ' Child batches are named like the parent batch, but with a suffix such as .01, .02, etc.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[   ' For example you might use for splitting:<br/><br/>  ]]>
<![CDATA[
]]>
<![CDATA[   ' <b>@D.Inbox.</b> If there is an Inbox variable in each document, this will split documents by ]]>
<![CDATA[
]]>
<![CDATA[   ' the value of the Inbox. Important! Any document or loose page ]]>
<![CDATA[
]]>
<![CDATA[   ' that does not have this value set will remain in the parent batch.]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim nPages]]>
<![CDATA[
]]>
<![CDATA[	Dim CurrentPage]]>
<![CDATA[
]]>
<![CDATA[	Dim retn]]>
<![CDATA[
]]>
<![CDATA[	Dim retSplit]]>
<![CDATA[
]]>
<![CDATA[	Dim sBucketValue]]>
<![CDATA[
]]>
<![CDATA[	Dim oPage]]>
<![CDATA[
]]>
<![CDATA[	Dim i]]>
<![CDATA[
]]>
<![CDATA[	Dim nIndex]]>
<![CDATA[
]]>
<![CDATA[	Dim bReturn]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Pilot.ChildrenQuantity = 0]]>
<![CDATA[
]]>
<![CDATA[	sBucketName = StrParam]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SplitBatch = False]]>
<![CDATA[
]]>
<![CDATA[	retSplit = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType <> DCO_BATCH Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("SplitBatch action must be bound at the batch level. Failed.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Force write DCO Data files]]>
<![CDATA[
]]>
<![CDATA[  If Instr(lcase(Pilot.dcofile),lcase(Pilot.BatchDir))<=0 Then]]>
<![CDATA[
]]>
<![CDATA[    sPageFile = Pilot.BatchDir + "\" + Pilot.dcofile]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    sPageFile = Pilot.dcofile]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  bReturn=DCO.Write(sPageFile)]]>
<![CDATA[
]]>
<![CDATA[	If bReturn=False then ]]>
<![CDATA[
]]>
<![CDATA[		Call Writelog("ERROR Writing File: '" & Pilot.dcofile & "'. Aborting Batch.")]]>
<![CDATA[
]]>
<![CDATA[		Call Writelog("DCO Last Error:'" & DCO.GetLastError() & "'.")]]>
<![CDATA[
]]>
<![CDATA[    Call AbortBatch()]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("SplitBatch on value: '" & StrParam & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sStatID = dco.Variable("ScanStation")]]>
<![CDATA[
]]>
<![CDATA[	sScanUser = dco.Variable("ScanUser")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Goto 0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nPages = CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[	Call WriteLog("SplitBatch processing " + CStr(CurrentObj.NumOfChildren())+" pages or docs")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If nPages = 0 Then]]>
<![CDATA[
]]>
<![CDATA[		' abort the batch]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set dictBuckets = CreateObject("Scripting.Dictionary")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[ 	For CurrentPage = 0 To nPages - 1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'		Call WriteLog("SplitBatch evaluate # " + CStr(CurrentPage+1))]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = CurrentObj.GetChild(CurrentPage)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If oPage.ObjectType = DCO_PAGE or oPage.ObjectType = DCO_DOCUMENT Then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If sBucketName = "" then ' for testing - when no parameter just use pageID]]>
<![CDATA[
]]>
<![CDATA[				sBucketValue = oPage.ID]]>
<![CDATA[
]]>
<![CDATA[				Else]]>
<![CDATA[
]]>
<![CDATA[					On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[					Set oSaveCurrentObj = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[					Set CurrentObj = oPage]]>
<![CDATA[
]]>
<![CDATA[					If IsAlive(g_DCSmart) then g_DCSmart.SetRRCurrentDCO(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[					sBucketValue = CStr(MetaWord(sBucketName))]]>
<![CDATA[
]]>
<![CDATA[					Call WriteLog("Page or document value: " & sBucketValue)]]>
<![CDATA[
]]>
<![CDATA[					Set CurrentObj = oSaveCurrentObj]]>
<![CDATA[
]]>
<![CDATA[					If IsAlive(g_DCSmart) then g_DCSmart.SetRRCurrentDCO(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[					On Error Goto 0]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[				if sBucketValue <> "" then]]>
<![CDATA[
]]>
<![CDATA[					if Not dictBuckets.Exists(sBucketValue) then]]>
<![CDATA[
]]>
<![CDATA[							dictBuckets.Add sBucketValue, sBucketValue]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			'Call WriteLog("Process unknown object - failed")	]]>
<![CDATA[
]]>
<![CDATA[			'Set dictBuckets = Nothing]]>
<![CDATA[
]]>
<![CDATA[			'bAbort = True]]>
<![CDATA[
]]>
<![CDATA[			'nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[			'Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next	' next page in batch]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	' Was maximum of 99 sub-batches now with new object 'oDCBase36' and AlphaDecimal names (01 to ZZ) allows 1295 sub-batches]]>
<![CDATA[
]]>
<![CDATA[	if dictBuckets.Count > 1295 Then]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("More than 1295 values in " & sBucketName & ", SplitBatch failed")]]>
<![CDATA[
]]>
<![CDATA[	   	Set dictBuckets = Nothing]]>
<![CDATA[
]]>
<![CDATA[			bAbort = True]]>
<![CDATA[
]]>
<![CDATA[      nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If dictBuckets.Count > 0 Then]]>
<![CDATA[
]]>
<![CDATA[		' we will split N batches]]>
<![CDATA[
]]>
<![CDATA[		Pilot.ChildrenQuantity = dictBuckets.Count	' this must be done before setting any of the conditions ]]>
<![CDATA[
]]>
<![CDATA[		aBuckets = dictBuckets.Keys]]>
<![CDATA[
]]>
<![CDATA[		For i = 0 to dictBuckets.Count-1]]>
<![CDATA[
]]>
<![CDATA[			WriteLog ("SplitBatch process subbatch " & CStr(i) & " " & aBuckets(i))]]>
<![CDATA[
]]>
<![CDATA[			retSplit = SplitChildBatch(CurrentObj, aBuckets(i), i) ' split a subbatch for each bucket]]>
<![CDATA[
]]>
<![CDATA[			if retSplit <> True then ]]>
<![CDATA[
]]>
<![CDATA[				bAbort = True]]>
<![CDATA[
]]>
<![CDATA[	      nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[				Exit For]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Next ' next i]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		' clear out all pages/docs that were split from the page file]]>
<![CDATA[
]]>
<![CDATA[		For nIndex = CurrentObj.NumOfChildren-1 to 0 Step -1]]>
<![CDATA[
]]>
<![CDATA[			Set oPage = CurrentObj.GetChild(nIndex)]]>
<![CDATA[
]]>
<![CDATA[			if sBucketName = "" then ' for testing - when no parameter just use pageID]]>
<![CDATA[
]]>
<![CDATA[				sBucketValue = oPage.ID]]>
<![CDATA[
]]>
<![CDATA[			else]]>
<![CDATA[
]]>
<![CDATA[				On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[				Set oSaveCurrentObj = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[				Set CurrentObj = oPage]]>
<![CDATA[
]]>
<![CDATA[				If IsAlive(g_DCSmart) then g_DCSmart.SetRRCurrentDCO(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[				sBucketValue = CStr(MetaWord(sBucketName))]]>
<![CDATA[
]]>
<![CDATA[				Call WriteLog("Page or document value: " & sBucketValue)]]>
<![CDATA[
]]>
<![CDATA[				Set CurrentObj = oSaveCurrentObj]]>
<![CDATA[
]]>
<![CDATA[				If IsAlive(g_DCSmart) then g_DCSmart.SetRRCurrentDCO(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[				On Error Goto 0]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[			if sBucketValue <> "" then  ' delete any page or doc that has a bucket value - e.g. is split]]>
<![CDATA[
]]>
<![CDATA[				CurrentObj.Deletechild(nIndex)]]>
<![CDATA[
]]>
<![CDATA[		  End If]]>
<![CDATA[
]]>
<![CDATA[		Next 'nIndex]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set dictBuckets = Nothing		]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If retSplit = True Then]]>
<![CDATA[
]]>
<![CDATA[		SplitBatch = True]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'************************************************************************
' Batch Split Actions
'
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2012 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************************
]]>	
<ref id="SplitBatch" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
  <ap>
    A <b>smart parameter</b> pointing to a Document or Page variable that determines if the Document or Page is to be split to a Child Batch.<br/><br/>
    <b>Important:</b> The action evaluates all documents and pages (including unbound* pages) in the batch.<br/> 
     
    The values of the smart parameter variable found during the document and page evaluation are grouped into "buckets":<br/><br/>
    1. Pages/documents that contain the variable and the variable values are identical go into the same bucket.<br/><br/>
    2. If there are multiple buckets, all pages/documents that share the same value will split to the same child batch.<br/><br/>
    3. There can be only <i>one child batch</i> for <i>each unique bucket value.</i><br/><br/>
    
    Child batches have the same name as the parent batch, but include an additional two character alpha-decimal suffix such as .01, .02, .0A, ..., up to .ZZ.  This hexadecimal numbering for child batches is required by Taskmaster Server.  Taskmaster Server creates the batch and queue entries for the child batches after the task is finished, when the split condition is processed.  There is a maximum of 1295 child batches.<br/><br/>
    Example:<br/><br/>  
    <b>@D.Inbox.</b> If there is an Inbox variable in each document, this will split documents by the value of the Inbox variable.<br/><br/>
    <b>Important:</b> Any document or unbound* page that does not have this Inbox variable value, will remain in the parent batch.<br/><br/>
    
    *An unbound page is any page not inside a document. 
  </ap>
  <h>
    This action will process all of the documents and "unbound" pages that are in the batch and attempt to split
    the identified documents and pages into child batches. The action will look in the documents or
    unbound pages for the variable specified in the a parameter, group the objects that have a matching value,
    and split each group into a unique child batch.<br/><br/>

    Only documents and unbound pages will be processed.  Pages that are already placed within in a document
    structure will not be processed individually, the pages will be as part of their document, not as a separate page.
    <br/><br/>
    
    Additional considerations:<br/>
    <br/>
    There is only one "job routing condition" raised by this action: it is the first one in the task's list of conditions.<br/>
    <br/>
    The task's <i>Task Setup/Task Settings</i> screen <b><i>must</i></b> be configured as <i>Job Router</i>, and a single condition defined (by convention, call it <b>Split</b>).<br/><br/>
    1. Any and all <b>child batches</b> will be routed via this single condition.<br/>
    2. If the application wants to treat the individual buckets differently, then the first step in the workflow after splitting can check the same smart parameter value and branch or re-route the child batch using that value.<br/>
    3. All the structure and variables, etc. that were in the parent batch docs/pages are retained in the child batches.<br/>
    4. In addition, new variables <b>ParentBatch</b> and <b>ParentBatchDir</b> are added.<br/>
    5. The action can only be used once per Parent Batch.<br/>
	6. The maximum number of child batches is 1295.<br/>
	7. The page count and document count in child batches is not accurate after splitting.  It is updated and will be accurate once the next task completes.
    <e>
      SplitBatch(@D.Inbox)
    </e>
  </h>
  <lvl>Batch level only.</lvl>
  <ret>
    False if an error occurs like a file could not be created, etc., and the batch will be set to abort.  Otherwise True.<br/><br/>
    If the specified variable is not found in any documents or unbound pages, meaning there is nothing to split,
    the action is still considered to be successful and will return true.<br/><br/>
    Each child batch split off will generate a condition, which should be configured for <b>Split</b> in the workflow.<br/> 
    Any page or document with a blank value for the splitting value will remain in the original "parent" batch.
  </ret>
</ref>
</help>

</rrx>
<rrx namespace="TifMerge" src="c:\datacap\RRS\TifMerge.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="TifMerge_SetFileName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'Sets the name of the multi-Image file (.tif) to be created by TifMerge."]]>
<![CDATA[
]]>
<![CDATA[  'String value of the file name to be assigned to the multi-page file.  Smart parameters are supported.<br/>]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  This action sets the name of the multi-Image file (.tif) to be created by the <b>TifMerge</b> actions.]]>
<![CDATA[
]]>
<![CDATA[  '  The file’s name can be text, or a combination of text and the value of a variable your enter as a parameter.]]>
<![CDATA[
]]>
<![CDATA[  '  The action automatically adds the “.tif” extension to the file.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	g_TifMergeName = ""]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	on error resume next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartReturn  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  sSmartReturn = MetaWord(Trim(StrParam))  ]]>
<![CDATA[
]]>
<![CDATA[  if Trim(sSmartReturn)<>"" then g_TifMergeName=sSmartReturn]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	if len(trim(g_TifMergeName))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("TifMerge Name has no value. Setting to Default name 'TifMerge'")]]>
<![CDATA[
]]>
<![CDATA[		g_TifMergeName = "TifMerge"]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Setting TifMerge File Name to : " & g_TifMergeName)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TifMerge_SetFileName = True]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function TifMerge_SetFileName")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="TifMerge_SetFilePath" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'Sets the path for the multi-Image file."]]>
<![CDATA[
]]>
<![CDATA[  'String value for the output path of the multi-Image TIF file.  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sDriveName]]>
<![CDATA[
]]>
<![CDATA[	Dim sSmartReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("SET FILE PATH")]]>
<![CDATA[
]]>
<![CDATA[	TifMerge_SetPath = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sSmartReturn = MetaWord(Trim(strParam))]]>
<![CDATA[
]]>
<![CDATA[  if Trim(sSmartReturn)<>"" then strParam=sSmartReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	sDriveName = FileMgr.GetDriveName(strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not FileMgr.DriveExists(sDriveName) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "SET TifMerge_SetFilePath FAILED. NO SUCH DRIVE : " & strParam)]]>
<![CDATA[
]]>
<![CDATA[		TifMerge_SetFilePath = False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If FileMgr.FolderExists(strParam) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "Folder Exists. Setting Export path to: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[		g_TifMergePath = strParam]]>
<![CDATA[
]]>
<![CDATA[		TifMerge_SetFilePath = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "NO SUCH PATH : " & strParam & " Building New Path.")]]>
<![CDATA[
]]>
<![CDATA[		TifMerge_SetFilePath = TifMerge_MakePath(strParam)]]>
<![CDATA[
]]>
<![CDATA[		g_TifMergePath = strParam]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	writelog("Path set to " & g_TifMergePath)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("END TifMerge_SetFilePath")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function TifMerge_SetFilePath")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="TifMerge_MergeImages" access="public" bInter="bInter" bDebug="bDebug" strParam="sPageType">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Merges the images associated with the object of the Document Hierarchy to which the action’s ruleset applies into a single, multi-Image file."]]>
<![CDATA[
]]>
<![CDATA['String value indicating either:<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['  1. "All" if the multi-Image file is to contain images of all pages without regard to Page Type.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['  2. The Page Type(s) of the images to be included (comma-separated list, if the parameter includes more than one Page Type.)<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartReturn]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sSmartReturn = MetaWord(Trim(sPageType))]]>
<![CDATA[
]]>
<![CDATA[  if Trim(sSmartReturn)="" then sSmartReturn=sPageType]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If trim(ucase(sSmartReturn)) = "ALL" or trim(ucase(sSmartReturn)) = "" then sSmartReturn = "*"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TifMerge_MergeImages = tm_TifMerge_MergeImages(CurrentObj, sSmartReturn)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("Function TifMerge_MergeImages")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="TifMerge_MyImage" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   'Adds each single image to the multi-Image file."<ap>None.</ap>	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[   ' Adds the current page image to the multi-Image TIF file.  Actions that proceed the TifMerge_MyImage action]]>
<![CDATA[
]]>
<![CDATA[   ' allow you to specify under which conditions an image is to be added to the multi-Image file.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[   ' A rule with this action can only be applied to a Page object.  The output image file name]]>
<![CDATA[
]]>
<![CDATA[   ' and destination path must have been previously set using TifMerge_SetFileName and TifMerge_SetFilePath.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sMergeFile ]]>
<![CDATA[
]]>
<![CDATA[	Dim StrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim bRes]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	TifMerge_MyImage = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sMergeFile = g_TifMergePath & "\" & g_TifMergeName & ".tif"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType = DCO_PAGE Then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		StrParam = CurrentObj.ImageName         ' Get the filename for the current page.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If Not FileMgr.FileExists(StrParam) Then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("File " & StrParam & " not Found. Skipping Image")	]]>
<![CDATA[
]]>
<![CDATA[		Elseif StrParam = sMergeFile then 	]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Image File is Merge to File. Image not Merged!")	]]>
<![CDATA[
]]>
<![CDATA[		Else				]]>
<![CDATA[
]]>
<![CDATA[			g_TifMergeFile.filename = StrParam ]]>
<![CDATA[
]]>
<![CDATA[			bRes=g_TifMergeFile.save(sMergeFile)]]>
<![CDATA[
]]>
<![CDATA[			If bRes=False then ]]>
<![CDATA[
]]>
<![CDATA[				writelog(StrParam & " ** Merge Failed: " & g_TifMergeFile.GetLastError)]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[				writelog(StrParam & " Merged.")]]>
<![CDATA[
]]>
<![CDATA[				TifMerge_MyImage = True]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Calling Obj is not a Page object. No Image uploaded.")	]]>
<![CDATA[
]]>
<![CDATA[		TifMerge_MyImage = False]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<f name="TifMerge_PreserveCompression" access="public">
	<p name="PreserveCompression">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'Determines the output compression type for merged images."]]>
<![CDATA[
]]>
<![CDATA[  '  <b>TRUE</b> : Preserves the original compression type of the source image.<br/>]]>
<![CDATA[
]]>
<![CDATA[  '  <b>FALSE</b> : Uses G4 compression for black and white images.  JEPG is used for color images.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[			On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      TifMerge_PreserveCompression = true]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      If (UCase(PreserveCompression)="TRUE") Then ]]>
<![CDATA[
]]>
<![CDATA[				g_PreserveCompression = true]]>
<![CDATA[
]]>
<![CDATA[			Else ]]>
<![CDATA[
]]>
<![CDATA[				g_PreserveCompression = false]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	]]>
	</g>
</f>
<f name="TifMerge_CheckStatus" access="public">
	<p name="AcceptablePageStatuses">
	</p>
	<p name="DisregardPageStatuses">
	</p>
	<p name="AcceptableDocStatuses">
	</p>
	<p name="DisregardDocStatuses">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[      'Acceptable Statuses: CSV of status values to accept. Blank indicates no statuses will be checked.]]>
<![CDATA[
]]>
<![CDATA[      'Disregard Statuses: CSV of status values to disregard. Blank indicates no statuses will be checked.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[			On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      TifMerge_CheckStatus = true]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      g_AcceptablePageStatuses=""]]>
<![CDATA[
]]>
<![CDATA[      g_DisregardPageStatuses=""]]>
<![CDATA[
]]>
<![CDATA[      g_AcceptableDocStatuses=""]]>
<![CDATA[
]]>
<![CDATA[      g_DisregardDocStatuses=""]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      AcceptablePageStatuses = replace(AcceptablePageStatuses,Space(1),"")]]>
<![CDATA[
]]>
<![CDATA[      DisregardPageStatuses = replace(DisregardPageStatuses,Space(1),"")]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      AcceptableDocStatuses = replace(AcceptableDocStatuses,Space(1),"")]]>
<![CDATA[
]]>
<![CDATA[      DisregardDocStatuses = replace(DisregardDocStatuses,Space(1),"")]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      g_AcceptablePageStatuses=AcceptablePageStatuses]]>
<![CDATA[
]]>
<![CDATA[      g_DisregardPageStatuses=DisregardPageStatuses]]>
<![CDATA[
]]>
<![CDATA[      g_AcceptableDocStatuses=AcceptableDocStatuses]]>
<![CDATA[
]]>
<![CDATA[      g_DisregardDocStatuses=DisregardDocStatuses]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<help>
  <![CDATA[
'******************************************************************************************
' TifMerge Actions 

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 
' 5725-C15 5725-C69
' 
' © Copyright IBM Corp. 1994, 2014 All Rights Reserved
' 
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
'
'
'*****************************************************************************************
]]>
<ref id="TifMerge_SetFileName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam" qi="Sets the name of the multi-Image file (.tif) to be created by TifMerge.">
  <ap>
   <i>String</i> value of the file name to be assigned to the multi-page file.  Smart parameters are supported.<br/>
  </ap>  
  <h>
    This action sets the name of the multi-Image file (.tif) to be created by the <b>TifMerge</b> actions.
    The file’s name can be text, or a combination of text and the value of a variable your enter as a parameter.
    The action automatically adds the “.tif” extension to the file.<br/><br/>
    <e>
      <b>TifMerge_SetFileName("Doc_+@ID+@DATE(dd.mm.yyyy)")</b><br/>
      TifMerge_SetFilePath("c:\ParentDir\Invoice\MultiImage")<br/>
      TifMerge_MergeImages("All")<br/><br/>
      
      The example above assumes that the rules with these actions are applied to a <b>Document</b> object. 
      The names combine text values such as “Doc_” with values assigned to variables by using smart parameters.<br/><br/>
      
      TifMerge_SetFileName("MultiTif_+@ID")<br/><br/>
      This example combines "MultiTif_" with the ID of the Document Hierarchy object to which the ruleset is applied.
      Usually, a rule containing this action applies to a <b>Batch</b> object or <b>Document</b> object,
      but can apply to a <b>Page</b> or <b>Field</b> object.  <br/><br/>
	  </e>  
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see>TifMerge_SetFilePath</see>
</ref>

<ref id="TifMerge_SetFilePath" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam" qi="Sets the path for the multi-Image file.">
  <ap>
    <i>String</i> value for the output path of the multi-Image TIF file.  Smart parameters are supported.
  </ap>
  <h>
    Sets the path for where the multi-Image file will be created. If the folder designated in the parameter does not exist, 
    the action will create the folder in which the TIF file will be placed.<br/><br/>
    Usually, a rule containing this action applies to a Batch object or Document object of the
    Document Hierarchy, but can apply to a Page or Field object.
    <e>
      TifMerge_SetFileName("Doc_+@ID+@DATE(dd.mm.yyyy)")<br/>
		  <b>TifMerge_SetFilePath("c:\ParentDir\Invoice\MultiImage")</b><br/>
      TifMerge_MergeImages("All")
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the specified drive does not exist or the path cannot be created. Otherwise, <b>True.</b>
  </ret>
  <see>TifMerge_SetFileName</see>
  </ref>

<ref id="TifMerge_MergeImages" access="public" bInter="bInter" bDebug="bDebug" strParam="sPageType" qi="Merges the images associated with the object of the Document Hierarchy to which the action’s ruleset applies into a single, multi-Image file.">
  <ap>
    <i>String</i> value indicating either:<br/><br/>
    1. "All" if the multi-Image file is to contain images of all pages without regard to Page Type.<br/><br/>
    2. The Page Type(s) of the images to be included (comma-separated list, if the parameter includes more than one Page Type.)<br/><br/>
    Smart parameters are supported.
  </ap>
  <h>    
    This action merges the images associated with the object to 
    which the action’s rule applies into a single, multi-Image file. <br/><br/>
    
    At the <b>Batch</b> level, the action merges all Image files in the 
    batch into one multi-Image file – or those Image files representing pages of the Page Type you specify as a parameter.

    At the <b>Document</b> level, the action assembles a new multi-Image file for each document in the batch. 
    If you specify a Page Type, the multi-Image file for each document will include only images of pages of that type.<br/><br/>

    Actions TifMerge_SetFileName and TifMerge_SetFilePath must be called before TifMerge_MergeImages.
    <e>
      TifMerge_SetFileName("@BATCHID+@DATE(dd.mm.yyyy)")<br/>
      TifMerge_SetFilePath("C:\ParentDir\Invoice\batches\MultiImage")<br/>
			<b>TifMerge_MergeImages("All")</b><br/><br/>

      TifMerge_SetFileName("Doc_+@ID+@DATE(dd.mm.yyyy)")<br/>
      TifMerge_SetFilePath("C:\ParentDir\Invoice\MultiImage")<br/>
      <b>TifMerge_MergeImages("Invoice,Attachment")</b><br/><br/>

      The first example merges all images into a multi-Image file that uses the Batch ID 
      and the processing Date for its name.<br/><br/>
      
      The second example applies to a <b>Document</b> object of the Document Hierarchy. 
      It assembles a multi-Image file for each document in the batch; the images in a 
      file are limited to <i>Invoice</i> and <i>Attachment</i> pages.
    </e>
  </h>
  <lvl>Batch or Document.</lvl>
  <ret>
    <b>False</b> if the action cannot create the multi-Image file. Otherwise, <b>True.</b>
  </ret>
  
</ref>

<ref id="TifMerge_MyImage" access="public" bInter="bInter" bDebug="bDebug"
  qi="Adds each single image to the multi-Image file.">
  <ap>None.</ap>	
  <h>
    Adds the current page image to the multi-Image TIF file.  Actions that proceed the TifMerge_MyImage action
    allow you to specify under which conditions an image is to be added to the multi-Image file.<br/><br/>
    A rule with this action can only be applied to a Page object.  The output image file name
    and destination path must have been previously set using TifMerge_SetFileName and TifMerge_SetFilePath.
    <e>      
      ChkDDCOStatus("0")<br/>
      <b>TifMerge_MyImage()</b><br/><br/>

      In this example, the <b>ChkDCOStatus</b> action checks that the status of the current page is “0”.
      If so, the image for the current page will be added to the multi-Image file.<br/><br/>

      If the current status of this page is not “0”, the rule will fail and the <b>TifMerge_MyImage</b>
      action will not be run; therefore, the current image will not be added to the multi-Image file.<br/><br/>

      This <b>ChkDCOStatus</b> action is used as an example.  You can use many other
      actions to be sure the current image meets your merging criteria.
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if the action’s ruleset is not applied to a <b>Page</b> object or if the 
    corresponding image file for the current page cannot be found. Otherwise, <b>True.</b>
  </ret>
  <see>TifMerge_SetFileName, TifMerge_SetFilePath</see>
  
</ref>

<ref id="TifMerge_ExportToBatchDir" access="private" bInter="bInter" bDebug="bDebug" qi="Indicates that the path for the multi-Image file is to the current Batch directory. ">
	<ap>None.</ap>
	<lvl>Batch or Document usually, but Page or Field is permissable.</lvl>
	<ret>False if the path does not exist or is not accessible. Otherwise, True</ret>
	<h>
    When saving a multi-image file, this action is used to configure the current batch directory as the destination
    for the output file.  This action must be called before the action to merge the images.
		<e>
			<b>TifMerge_ExportToBatchDir()</b><br/>
      TifMerge_MergeImages("All")
    </e>
	</h>
</ref>
  
<ref id="TifMerge_PreserveCompression" access="public" qi="Determines the output compression type for merged images."><p name="PreserveCompression"/>
	<ap>
    <b>TRUE</b> : Preserves the original compression type of the source image.<br/>
    <b>FALSE</b> : Uses G4 compression for black and white images.  JEPG is used for color images.
  </ap>
	<lvl>Any.</lvl>
	<ret>Always True.</ret>
	<h>
    This action will configure the output format for TifMerge_MergeImages.
    If this action is not called, then the default value of "FALSE" is used, 
    so the original image compression is not preserved.
		<e>
			<b>TifMerge_PreserveCompression("TRUE")</b><br/>
      <b>TifMerge_MergeImages("All")</b>
		</e>
	</h>
</ref>
  <ref id="TifMerge_CheckStatus" access="public" qi="Filters merged pages and document based on DCO status.">
    <ap>
      1. <b>AcceptablePageStatuses</b> : a CSV of Page status values that will be Merged. <br/>
      2. <b>DisregardPageStatuses</b> : a CSV of Page status values that will NOT be Merged.<br/>
      3. <b>AcceptableDocStatuses</b> : a CSV of Document status value that will be Merged.<br/>
      4. <b>DisregardDocStatuses</b> : a CSV of Document status values that will NOT be Merged.<br/>
    </ap>
    <lvl>Any.</lvl>
    <ret>Always True.</ret>
    <h>
      This action will configure the acceptable statuses for documents and pages when calling TifMerge_MergeImages.
      If this action is not called, then the status values of documents and pages will not be checked.<br/><br/>
      In the example below, only pages with an acceptable status of '0' or '49' will be merged, the disinclude page status of '75' 
      is by exclusion in the acceptable status values redundant. By contrast the disinclude document status of
      '128' will prevent all child pages of the document from being merged.<br/><br/>      
      Empty parameters, such as in the example below for the AcceptableDocStatus argument, are ignored.<br/><br/>
      <e>
        <b>TifMerge_CheckStatus("0,49","75","","128")</b>
        <br/>
        <b>TifMerge_MergeImages("All")</b>
      </e>
    </h>
  </ref>
</help>
</rrx>
<rrx namespace="TM524" src="c:\datacap\RRS\TM524.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="TM524" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ' Makes changes to the Page file for the current batch so that it is backward-compatible]]>
<![CDATA[
]]>
<![CDATA[  ' with older tasks that are not rules-based, tasks such as Recog2K, or ExportTX."]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'This action alters the task's Page file for the current batch so that it is]]>
<![CDATA[
]]>
<![CDATA[  'backward-compatible with non-rules-based tasks, such as Recog2K, or ExportTX.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  '  These tasks expect certain batch-, document-, and page-level variables that are not ]]>
<![CDATA[
]]>
<![CDATA[  '  used in the rules-based environment.  After the action is run, old-style tasks will ]]>
<![CDATA[
]]>
<![CDATA[  '  proceed as if the batch was run entirely with that type of task.<br/><br/>  ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If DCO.FindVariable("ED")= -1 then ]]>
<![CDATA[
]]>
<![CDATA[		DCO.Variable("ED")= "0"]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If DCO.FindVariable("AD")= -1 then ]]>
<![CDATA[
]]>
<![CDATA[		DCO.Variable("AD")= "0"]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If DCO.FindVariable("EP")= -1 then ]]>
<![CDATA[
]]>
<![CDATA[		DCO.Variable("EP")= "0"]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If DCO.FindVariable("AP")= -1 then ]]>
<![CDATA[
]]>
<![CDATA[		DCO.Variable("AP")= "0"]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	g_TM524_nIndex = 0]]>
<![CDATA[
]]>
<![CDATA[	TM524 = GetChildren(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Total fields Indexed: " & g_TM524_nIndex) ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="TM4DocIdFormat" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ 'Formats all Document ID's with a Taskmaster 4 layout style."]]>
<![CDATA[
]]>
<![CDATA[  'This action formats all Document ID's with a <i>Taskmaster 4</i>layout style.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[  ' Note: Rules that employ this action must be part of a RuleSet that is bound ]]>
<![CDATA[
]]>
<![CDATA[  '  to the Document Hierarchy's <b>Batch</b> object.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	TM4DocIdFormat = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType <> 0 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Action Must be Bound at the Batch level. Exiting Function.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim nSize]]>
<![CDATA[
]]>
<![CDATA[	Dim rChild]]>
<![CDATA[
]]>
<![CDATA[	Dim i]]>
<![CDATA[
]]>
<![CDATA[	Dim cIndex]]>
<![CDATA[
]]>
<![CDATA[	Dim sOrigID	]]>
<![CDATA[
]]>
<![CDATA[	Dim sNewID]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nSize = CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Found " & cstr(nSize) & " children to Process.")]]>
<![CDATA[
]]>
<![CDATA[	cIndex = 1		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Starting w/ " & CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To nSize-1]]>
<![CDATA[
]]>
<![CDATA[		Set rChild=CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		if Not(rChild is Nothing) then ]]>
<![CDATA[
]]>
<![CDATA[			Debuglog("Child is Type '" & rChild.ObjectType & "' ")]]>
<![CDATA[
]]>
<![CDATA[			If rChild.ObjectType = 1 Then ]]>
<![CDATA[
]]>
<![CDATA[				sOrigID = rChild.ID]]>
<![CDATA[
]]>
<![CDATA[				sNewID = Pilot.BatchID & "." & Right("00" & cstr(cIndex),2)]]>
<![CDATA[
]]>
<![CDATA[				rChild.ID = sNewID]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Renaming Document '" & sOrigID & "' to '" & sNewID & "' ")]]>
<![CDATA[
]]>
<![CDATA[				cIndex = cIndex + 1]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'i]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("TM4DocIdFormat")]]>
<![CDATA[
]]>
<![CDATA[	TM4DocIdFormat = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>

<help>
<![CDATA[
'********************************************************************************
' TM524.rra Actions
'--------------------------------------------------------------------------------
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'********************************************************************************
]]>
  
<ref id="TM524" access="public" bInter="bInter" bDebug="bDebug" qi="Makes changes to the Page file for the current batch so that it is backward-compatible with older tasks that are not rules-based, tasks such as Recog2K, or ExportTX.">
  <ap>None.</ap>  
  <h>
    This action alters the task's Page file for the current batch so that it is 
    backward-compatible with non-rules-based tasks, such as Recog2K, or ExportTX.<br/><br/>
    
    These tasks expect certain batch-, document-, and page-level variables that are not 
    used in the rules-based environment.  After the action is run, old-style tasks will 
    proceed as if the batch was run entirely with that type of task.<br/><br/>
    
    <b>Note:</b> Rules that employ this action must be part of a RuleSet that is bound  
    to the Document Hierarchy's <b>Batch</b> object.
    <e>
      <b>TM524()</b>
    </e>
  </h>
  <lvl>Batch level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>

</ref>
	
<ref id="TM4DocIdFormat" access="public" bInter="bInter" bDebug="bDebug" qi="Formats all Document ID's with a Taskmaster 4 layout style.">
  <ap>None.</ap>  
  <h>
    This action formats all Document ID's with a <i>Taskmaster 4</i>layout style.<br/><br/>
    <b>Note:</b>R ules that employ this action must be part of a RuleSet that is bound 
    to the Document Hierarchy's <b>Batch</b> object.
    <e>
      <b>TM4DocIdFormat()</b>
    </e>
  </h>
  <lvl>Batch only.</lvl>
  <ret>
    <b>False,</b> if not called at the batch level.  Otherwise, <b>True.</b>
  </ret>
</ref>
</help>

</rrx>
<rrx namespace="Validations" src="c:\datacap\RRS\Validations.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<af name="IsFieldPercentNumeric" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA['A number (0-100) indicating the percentage that results in a  condition. The ]]>
<![CDATA[
]]>
<![CDATA['default percentage is 100.  The value must be numeric, without the percent sign.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	Dim Value, TrueCount, FalseCount, TFRatio, Lval, sCharacter, locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.IsNumeric(StrParam,locale) Then StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  StrParam = cint(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldPercentNumeric percentage parameter set to " & StrParam & " percent.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsFieldPercentNumeric = False]]>
<![CDATA[
]]>
<![CDATA[	TrueCount = 0]]>
<![CDATA[
]]>
<![CDATA[	FalseCount = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Value = Trim(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[	ValueLen = len(Value)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{N} or \p{Number}: any kind of numeric character in any script. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Nd} or \p{Decimal_Digit_Number}: a digit zero through nine in any script except ideographic scripts. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Nl} or \p{Letter_Number}: a number that looks like a letter, such as a Roman numeral. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{No} or \p{Other_Number}: a superscript or subscript digit, or a number that is not a digit 0..9 (excluding numbers from ideographic scripts). ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	For Cx = 1 To Len(value)]]>
<![CDATA[
]]>
<![CDATA[    sCharacter=Mid(value,Cx,1)]]>
<![CDATA[
]]>
<![CDATA[		If DCGlobalStrings.RegExIsMatch(sCharacter,"\p{N}") Then]]>
<![CDATA[
]]>
<![CDATA[			TrueCount = TrueCount + 1]]>
<![CDATA[
]]>
<![CDATA[    Elseif DCGlobalStrings.RegExIsMatch(sCharacter,"\p{Mn}") Then]]>
<![CDATA[
]]>
<![CDATA[      ValueLen = ValueLen - 1]]>
<![CDATA[
]]>
<![CDATA[		Else	]]>
<![CDATA[
]]>
<![CDATA[			FalseCount = FalseCount + 1]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next 'Cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TFRatio = (StrParam/100)*ValueLen]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If TrueCount >= TFRatio and ValueLen>0 Then IsFieldPercentNumeric = True]]>
<![CDATA[
]]>
<![CDATA[	If ValueLen <= 0 Then ValueLen = 1 ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(3) & "Value is " & (TrueCount/ValueLen)*100 & "% Numeric") ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldPercentNumeric returns " & IsFieldPercentNumeric ) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldPercentNumeric = False Then ]]>
<![CDATA[
]]>
<![CDATA[    sReturn = RRState.LoadString("validations","IsFieldPercentNumeric_01","Field '{0}' value '{1}' contains less than the expected {2} percent of numeric characters.")]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[    DCOMessage(sReturn)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldPercentAlpha" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	' A number (0-100) indicating the percentage necessary to return a  condition.  The value must be numeric, without the percent sign.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim Value, TrueCount, FalseCount, TFRatio, Cx, Lval, locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	IsFieldPercentAlpha = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	' StrParam is a value between 0 and 100]]>
<![CDATA[
]]>
<![CDATA[	' This action determines the percentage of numbers required to return True]]>
<![CDATA[
]]>
<![CDATA[	' Defaults to 100% ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.IsNumeric(StrParam, locale) Then StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  StrParam = cint(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("IsFieldPercentAlpha percentage parameter set to " & StrParam & " percent.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TrueCount = 0]]>
<![CDATA[
]]>
<![CDATA[	FalseCount = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Value = Trim(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[  ValueLen = len(Value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' \p{L} or \p{Letter}: any kind of letter from any language. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Ll} or \p{Lowercase_Letter}: a lowercase letter that has an uppercase variant. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Lu} or \p{Uppercase_Letter}: an uppercase letter that has a lowercase variant. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Lt} or \p{Titlecase_Letter}: a letter that appears at the start of a word when only the first letter of the word is capitalized. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{L&} or \p{Letter&}: a letter that exists in lowercase and uppercase variants (combination of Ll, Lu and Lt). ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Lm} or \p{Modifier_Letter}: a special character that is used like a letter. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Lo} or \p{Other_Letter}: a letter or ideograph that does not have lowercase and uppercase variants. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Mn} : a non spacing mark - used with non composite character sets.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  For Cx = 1 To Len(value)]]>
<![CDATA[
]]>
<![CDATA[    sCharacter=Mid(value,Cx,1)]]>
<![CDATA[
]]>
<![CDATA[		If DCGlobalStrings.RegExIsMatch(sCharacter,"\p{L}") Then]]>
<![CDATA[
]]>
<![CDATA[			TrueCount = TrueCount + 1]]>
<![CDATA[
]]>
<![CDATA[    Elseif DCGlobalStrings.RegExIsMatch(sCharacter,"\p{Mn}") Then]]>
<![CDATA[
]]>
<![CDATA[      ValueLen = ValueLen - 1]]>
<![CDATA[
]]>
<![CDATA[		Else	]]>
<![CDATA[
]]>
<![CDATA[			FalseCount = FalseCount + 1]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next 'Cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TFRatio = (StrParam/100)*ValueLen]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If TrueCount >= TFRatio and ValueLen>0 Then IsFieldPercentAlpha = True]]>
<![CDATA[
]]>
<![CDATA[	If ValueLen <= 0 Then ValueLen = 1 ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(3) & "Value is " & (TrueCount/ValueLen)*100 & "% Alphabetic") ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldPercentAlpha returns " & IsFieldPercentAlpha) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldPercentAlpha = False Then ]]>
<![CDATA[
]]>
<![CDATA[		sReturn = RRState.LoadString("validation","IsFieldPercentAlpha_01","Field '{0}' value '{1}' contains less than the expected {2} percent of Alphabetic characters.")]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[    DCOMessage(sReturn)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call ErrorHandler("Function IsAlpha")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldDate" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ '   Checks that the captured value of the field represented by the bound Field ]]>
<![CDATA[
]]>
<![CDATA[ '   object has an acceptable Date format.]]>
<![CDATA[
]]>
<![CDATA[ '   This action will accept any valid date from 01/01/0001 through 12/31/9999.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim value]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	  IsFieldDate = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	  value = Trim(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	  If Not DCGlobalDates.IsDate(value,locale) Then ]]>
<![CDATA[
]]>
<![CDATA[		  IsFieldDate = False]]>
<![CDATA[
]]>
<![CDATA[      sReturn = RRState.LoadString("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognized date format.")]]>
<![CDATA[
]]>
<![CDATA[      sReturn = replace(sReturn,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sReturn = replace(sReturn,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[		  DCOMessage(sReturn)]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog(DCGlobalDates.GetLog)]]>
<![CDATA[
]]>
<![CDATA[	  	]]>
<![CDATA[
]]>
<![CDATA[	  WriteLog("IsFieldDate returns " & IsFieldDate)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldDateEqualOrAfter" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ '   The name of the Field object of the Document Hierarchy to be compared with the ]]>
<![CDATA[
]]>
<![CDATA[ '   current field's Date value.]]>
<![CDATA[
]]>
<![CDATA[ '   Checks that the Date value in the current field represented by the bound Field]]>
<![CDATA[
]]>
<![CDATA[ '   object of the Document Hierarchy is greater than or equal to the Date value in the]]>
<![CDATA[
]]>
<![CDATA[ '   field specified as the parameter.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim oDcoObj]]>
<![CDATA[
]]>
<![CDATA[	Dim sDateFrom]]>
<![CDATA[
]]>
<![CDATA[	Dim sDateThru]]>
<![CDATA[
]]>
<![CDATA[	Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	IsFieldDateEqualOrAfter=True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oDcoObj = ReturnNamedComponent(trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[	If oDcoObj is nothing then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Compare to Field '" & StrParam & "' not found.")]]>
<![CDATA[
]]>
<![CDATA[		IsFieldDateEqualOrAfter=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sDateFrom = Trim(GetFieldValue())  ]]>
<![CDATA[
]]>
<![CDATA[  sDateFrom = DCGlobalDates.ReplaceIndicWithWesternDigits(sDateFrom)]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalDates.IsDate(sDateFrom,locale) Then]]>
<![CDATA[
]]>
<![CDATA[		IsFieldDateEqualOrAfter = False]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.Loadstring("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognised date format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",sDateFrom)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sDateThru = Trim(oDcoObj.Text)]]>
<![CDATA[
]]>
<![CDATA[  sDateThru = DCGlobalDates.ReplaceIndicWithWesternDigits(sDateThru)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalDates.IsDate(sDateThru,locale) Then]]>
<![CDATA[
]]>
<![CDATA[		IsFieldDateEqualOrAfter = False]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.Loadstring("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognised date format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",oDcoObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",sDateThru)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldDateEqualOrAfter=False Then ]]>
<![CDATA[
]]>
<![CDATA[		Set oDcoObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Select Case DCGlobalDates.CompareDate(sDateFrom,sDateThru,locale)]]>
<![CDATA[
]]>
<![CDATA[  	Case "-1"]]>
<![CDATA[
]]>
<![CDATA[	  	IsFieldDateEqualOrAfter = False]]>
<![CDATA[
]]>
<![CDATA[      sMessage = RRState.Loadstring("validations","IsDateEqualorAfter_01","Field '{0}' date of '{1}' must be after or the same date as Field '{2}' date of '{3}'.")]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{1}",sDateFrom)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{2}",oDcoObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{3}",sDateThru)]]>
<![CDATA[
]]>
<![CDATA[	  	DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		  Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  Case "1","0"]]>
<![CDATA[
]]>
<![CDATA[      sMessage = "From date is greater than or equal to through date"]]>
<![CDATA[
]]>
<![CDATA[		  Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[    Case else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("unknown result")]]>
<![CDATA[
]]>
<![CDATA[	End Select]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldDateEqualOrBefore" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ' The name of the Field object of the Document Hierarchy to be compared with ]]>
<![CDATA[
]]>
<![CDATA[  ' the current field's Date value.]]>
<![CDATA[
]]>
<![CDATA[  ' Checks that the date in the current field represented by the bound Field object of the]]>
<![CDATA[
]]>
<![CDATA[  ' Document Hierarchy is less than or equal to the Date value in the field specified as the parameter.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim oDcoObj]]>
<![CDATA[
]]>
<![CDATA[	Dim sDateFrom]]>
<![CDATA[
]]>
<![CDATA[	Dim sDateThru]]>
<![CDATA[
]]>
<![CDATA[	Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	IsFieldDateEqualOrBefore=True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oDcoObj = ReturnNamedComponent(trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[	If oDcoObj is nothing then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Compare to Field '" & StrParam & "' not found.")]]>
<![CDATA[
]]>
<![CDATA[		IsFieldDateEqualOrBefore=False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sDateFrom = Trim(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[  'writelog("sDateFrom = " & sDateFrom)  ]]>
<![CDATA[
]]>
<![CDATA[  sDateFrom = DCGlobalDates.ReplaceIndicWithWesternDigits(sDateFrom)]]>
<![CDATA[
]]>
<![CDATA[  'writelog("sDateFrom = " & sDateFrom)]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalDates.IsDate(sDateFrom,locale) Then]]>
<![CDATA[
]]>
<![CDATA[    writelog("sDateFrom = " & sDateFrom)]]>
<![CDATA[
]]>
<![CDATA[		IsFieldDateEqualOrBefore = False]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.Loadstring("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognised date format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",sDateFrom)]]>
<![CDATA[
]]>
<![CDATA[   	DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sDateThru = Trim(oDcoObj.Text)]]>
<![CDATA[
]]>
<![CDATA[  sDateThru = DCGlobalDates.ReplaceIndicWithWesternDigits(sDateThru)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalDates.IsDate(sDateThru,locale) Then]]>
<![CDATA[
]]>
<![CDATA[		IsFieldDateEqualOrBefore = False]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.Loadstring("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognised date format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",oDcoObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",sDateThru)]]>
<![CDATA[
]]>
<![CDATA[   	DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldDateEqualOrBefore=False Then ]]>
<![CDATA[
]]>
<![CDATA[		Set oDcoObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Select Case DCGlobalDates.CompareDate(sDateFrom,sDateThru,locale)]]>
<![CDATA[
]]>
<![CDATA[  	Case "-1","0"]]>
<![CDATA[
]]>
<![CDATA[      sMessage = "From field date is less than or equal to through date."]]>
<![CDATA[
]]>
<![CDATA[	    Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  Case "1"]]>
<![CDATA[
]]>
<![CDATA[      IsFieldDateEqualOrBefore = False]]>
<![CDATA[
]]>
<![CDATA[      sMessage = RRState.Loadstring("validations","IsDateEqualorBefore_01","Field '{0}' date of '{1}' must be before or the same date as Field '{2}' date of '{3}'.")]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{1}",sDateFrom)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{2}",oDcoObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{3}",sDateThru)]]>
<![CDATA[
]]>
<![CDATA[      DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	    Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[    Case else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("unknown result")]]>
<![CDATA[
]]>
<![CDATA[	End Select]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<f name="CalculateDateDifference" access="public">
	<p name="startDate">
	</p>
	<p name="endDate">
	</p>
	<p name="targetVariable">
	</p>
	<p name="dateProperty">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	CalculateDateDifference=True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  startDate    = Trim(MetaWord(startDate)) ]]>
<![CDATA[
]]>
<![CDATA[  endDate      = Trim(MetaWord(endDate))]]>
<![CDATA[
]]>
<![CDATA[  dateProperty = MetaWord(dateProperty)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("startDate = " & startDate & ". endDate = " & endDate & ". dateProperty = " & dateProperty & " Locale = " & locale & ".")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalDates.IsDate(startDate, locale) Then]]>
<![CDATA[
]]>
<![CDATA[		CalculateDateDifference = False    ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = "The startDate value of '{1}' is not a valid date or recognised date format."]]>
<![CDATA[
]]>
<![CDATA[   ' sMessage = RRState.Loadstring("validations","IsFieldDate_01","The date value of '{1}' is not a valid date or recognised date format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",startDate)]]>
<![CDATA[
]]>
<![CDATA[   ' DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  Writelog("Start date error: " & sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalDates.IsDate(endDate, locale) Then]]>
<![CDATA[
]]>
<![CDATA[		CalculateDateDifference = False]]>
<![CDATA[
]]>
<![CDATA[    sMessage = "The endDate value of '{1}' is not a valid date or recognised date format."]]>
<![CDATA[
]]>
<![CDATA[   ' sMessage = RRState.Loadstring("validations","IsFieldDate_01","The date value of '{1}' is not a valid date or recognised date format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",endDate)]]>
<![CDATA[
]]>
<![CDATA[   ' DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  Writelog("End date error: " & sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  dim result]]>
<![CDATA[
]]>
<![CDATA[  result = DCGlobalDates.SubtractDates(startDate,endDate, dateProperty, locale)  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog(DCGlobalDates.GetLog())]]>
<![CDATA[
]]>
<![CDATA[  Writelog("SubtractDates result: " & result)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If len(targetVariable) = 0 Then targetVariable = DCONavType()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  targetVariable = Trim(targetVariable)]]>
<![CDATA[
]]>
<![CDATA[  CalculateDateDifference = DCONavSetValue(targetVariable, result)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</f>
<af name="AssignFieldDefault" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['   Assigns a default value to the current field.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not(CurrentObj is Nothing) then ]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Clear]]>
<![CDATA[
]]>
<![CDATA[		AssignFieldDefault = u_ModifyText("","",1,StrParam)]]>
<![CDATA[
]]>
<![CDATA[	Elseif not(isObject(LogWindow)) then]]>
<![CDATA[
]]>
<![CDATA[		AssignFieldDefault = False]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("AssignFieldDefault returns " & AssignFieldDefault)	]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	end If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("AssignFieldDefault returns " & AssignFieldDefault)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldLengthMax" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    Checks that the character length of the current Field object's captured value is equal to ]]>
<![CDATA[
]]>
<![CDATA['    or less than the value set as a parameter..]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim wCount, msg, locale]]>
<![CDATA[
]]>
<![CDATA[  Dim Value]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = " "]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	IsFieldLengthMax = False ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[  wCount = Len(DCGlobalStrings.RegExReplace(Value,"\p{Mn}",""))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalCurrency.IsNumeric(StrParam, locale) Then]]>
<![CDATA[
]]>
<![CDATA[		If wCount <= CInt(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[			IsFieldLengthMax = True]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		msg = vbCr & "Parameter is not Numeric."]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldLengthMax is " & StrParam & " character(s). Character count is " & wCount & msg)]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldLengthMax returns: " & IsFieldLengthMax)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldLengthMax = False Then ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldLengthMax_01","Field '{0}' value of '{1}' is too long. The field has {3} characters and the maximum allowed length is {2}.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{3}",wCount)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function IsFieldLengthMax")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldLengthMin" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['   Checks the character length of the current Field object's captured value to see if its ]]>
<![CDATA[
]]>
<![CDATA['   length is equal to or longer than a number <var>n</var>]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim wCount, msg, locale]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	IsFieldLengthMin = False]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then WriteLog("IsFieldLengthMin: Invalid Parameter '" & strParam & "' . Function Failed")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  wCount = Len(DCGlobalStrings.RegExReplace(GetFieldValue(),"\p{Mn}",""))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("IsFieldLengthMin: Start Value = '" & GetFieldValue() & "'   Length = " & wCount)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalCurrency.IsNumeric(StrParam, locale) Then]]>
<![CDATA[
]]>
<![CDATA[		If wCount >= CInt(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[			IsFieldLengthMin = True]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		msg = vbCr & "Parameter is not Numeric."]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldLengthMin is " & StrParam & " character(s). Character count is " & wCount & msg)]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldLengthMin returns: " & IsFieldLengthMin)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldLengthMin = False Then ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldLengthMin_01","Field '{0}' value of '{1}' is too short. The field has {3} characters and the minium allowed length is {2}.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{3}",wCount)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function IsFieldLengthMin")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="InsertChars" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[' 1. The characters or character string to be inserted; defaults to a space.]]>
<![CDATA[
]]>
<![CDATA['	2. A number n indicating the target position within the captured value; ]]>
<![CDATA[
]]>
<![CDATA['    defaults to the end of the value.]]>
<![CDATA[
]]>
<![CDATA[' 3. The number of insertions; defaults to 1.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' Inserts a character or string of characters into the captured value, one or more times.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim l,w,c]]>
<![CDATA[
]]>
<![CDATA[	Dim w_left,v_top,w_right,v_bottom]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam, PlaceAt, sInsert, addPos, Cx]]>
<![CDATA[
]]>
<![CDATA[	Dim Tstring]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[	StrParam = StrParam & ", , "]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	CurCount = Len(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = " , ,1"]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam &",," ,",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalCurrency.isnumeric(aStrParam(1),locale) then]]>
<![CDATA[
]]>
<![CDATA[		If aStrParam(1) < 1 Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.IsNumeric(aStrParam(1),locale) Or aStrParam(1) = " " Then ]]>
<![CDATA[
]]>
<![CDATA[		aStrParam(1) = CurCount + 1]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		PlaceAt = aStrParam(1) ]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.IsNumeric(aStrParam(2),locale) Then aStrParam(2) = "1"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sInsert = aStrParam(0)  'string to insert]]>
<![CDATA[
]]>
<![CDATA[	PlaceAt = aStrParam(1)  'position to insert]]>
<![CDATA[
]]>
<![CDATA[	iNumber = aStrParam(2)  'times to insert]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("InsertChars Insert String '" & sInsert & "' starting at position# '" & PlaceAt & "' , '" & iNumber & "' times.")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Tstring = ""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If CInt(CurCount) < CInt(PlaceAt) Then PlaceAt = CurCount + 1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Len(sInsert)= 0 Then sInsert = " "]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For Cnt = 1 To CInt(iNumber)]]>
<![CDATA[
]]>
<![CDATA[		Tstring = Tstring & sInsert]]>
<![CDATA[
]]>
<![CDATA[	Next 'Cnt]]>
<![CDATA[
]]>
<![CDATA[		      ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Inserting value:'" & Tstring & "'")         ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[  if CurrentObj is Nothing then exit Function         ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[  For xChar = 1 To Len(Tstring)]]>
<![CDATA[
]]>
<![CDATA[    NewValue = Mid(Tstring,xChar,1)]]>
<![CDATA[
]]>
<![CDATA[    Set oNewChar = CurrentObj.AddChild(4,"",PlaceAt-1)	]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Adding character '" & NewValue & "' to position '" & PlaceAt)]]>
<![CDATA[
]]>
<![CDATA[    nChar = oNewChar.AddValue(CLng(Ascw(NewValue)), CLng(9))]]>
<![CDATA[
]]>
<![CDATA[    bRes = oNewChar.SetPosition(clng(0),clng(0),clng(0),clng(0))]]>
<![CDATA[
]]>
<![CDATA[		Set oNewChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[    PlaceAt = PlaceAt + 1]]>
<![CDATA[
]]>
<![CDATA[  Next 'xChar]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Field value after InsertChars is '" & GetFieldValue() & "' ")]]>
<![CDATA[
]]>
<![CDATA[ 		]]>
<![CDATA[
]]>
<![CDATA[	InsertChars = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AddPaddingToEnd" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA['    A number <var>n</var> indicating the maximum permissible length of the value. If the]]>
<![CDATA[
]]>
<![CDATA['    action finds that a value's length is less than this number, it will insert spaces until]]>
<![CDATA[
]]>
<![CDATA['    the maximum length is reached.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    Pads the current Field object's captured value with spaces to the right.]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  CurCount = Len(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  strParam = MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.isnumeric(strParam, locale) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter must be numeric. '" & StrParam & "' is not a numeric value")]]>
<![CDATA[
]]>
<![CDATA[		Exit function	]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = CurCount]]>
<![CDATA[
]]>
<![CDATA[ 			]]>
<![CDATA[
]]>
<![CDATA[	ActionNum = Abs(CInt(strParam)) - CurCount]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If cint(ActionNum)>cint(0) then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("AddPaddingToEnd: add " & ActionNum & " space(s)")]]>
<![CDATA[
]]>
<![CDATA[		AddPaddingToEnd = InsertChars(bInteractive, bDebug, Space(ActionNum) & "," & CurCount+1 & ",1")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Field Value is greater or equal to parameter '" & StrParam & "' no padding will be performed.")]]>
<![CDATA[
]]>
<![CDATA[		AddPaddingToEnd = True]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AddPaddingToStart" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA['    A number <var>n</var> indicating the maximum permissible length of the value. If the]]>
<![CDATA[
]]>
<![CDATA['    action finds that a value's length is less than this number, it will insert spaces]]>
<![CDATA[
]]>
<![CDATA['    until the maximum length is reached.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['   Pads the current Field object's captured value with spaces to the left of the first character.]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  strParam = MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.isnumeric(strParam, locale) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter must be numeric. '" & StrParam & "' is not a numeric value")]]>
<![CDATA[
]]>
<![CDATA[		Exit function	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurCount = Len(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = CurCount ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ActionNum = Abs(CInt(strParam)) - CurCount]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If cint(ActionNum)>cint(0) then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("AddPaddingToStart: add " & ActionNum & " space(s)")]]>
<![CDATA[
]]>
<![CDATA[		AddPaddingToStart = InsertChars(bInteractive, bDebug,Space(ActionNum) & ",1,1")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Field Value is greater or equal to parameter '" & StrParam & "' no padding will be performed.")]]>
<![CDATA[
]]>
<![CDATA[		AddPaddingToStart = True]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="TrimSpaces" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA['    Deletes extra spaces at the beginning and end of the current Field object's captured value.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim CurCount]]>
<![CDATA[
]]>
<![CDATA[  Dim Value]]>
<![CDATA[
]]>
<![CDATA[  Dim Tcnt]]>
<![CDATA[
]]>
<![CDATA[  Dim nChilds]]>
<![CDATA[
]]>
<![CDATA[  Dim bRes]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[    CurCount = Len(Value)]]>
<![CDATA[
]]>
<![CDATA[    nChilds = CurrentObj.Numofchildren - CurCount	]]>
<![CDATA[
]]>
<![CDATA[    Tcnt = 0	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Start Value'" & Value & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If not(CurrentObj is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      CharValue = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If len(CurrentObj.Text) > 0 then CharValue = CurrentObj.Getchild(nChilds).CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      While clng(CharValue)= clng(32)]]>
<![CDATA[
]]>
<![CDATA[        bRes = CurrentObj.DeleteChild(nChilds)]]>
<![CDATA[
]]>
<![CDATA[        CharValue = 0  		]]>
<![CDATA[
]]>
<![CDATA[        If len(CurrentObj.Text) > 0 then CharValue = CurrentObj.Getchild(nChilds).CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[        Tcnt = Tcnt + 1]]>
<![CDATA[
]]>
<![CDATA[      Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If len(CurrentObj.Text) > 0 then CharValue = CurrentObj.Getchild(CurrentObj.Numofchildren-1).CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      While clng(CharValue)= clng(32)]]>
<![CDATA[
]]>
<![CDATA[        bRes = CurrentObj.DeleteChild(CurrentObj.Numofchildren-1)]]>
<![CDATA[
]]>
<![CDATA[        CharValue = 0  		]]>
<![CDATA[
]]>
<![CDATA[        If len(CurrentObj.Text) > 0 then CharValue = CurrentObj.Getchild(CurrentObj.Numofchildren-1).CharValue(0)]]>
<![CDATA[
]]>
<![CDATA[        Tcnt = Tcnt + 1]]>
<![CDATA[
]]>
<![CDATA[      Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TrimSpaces = True]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("TrimSpaces: " & Tcnt & " position(s) trimmed.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="TruncateFromStart" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[' A number that is the value's maximum length.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' This action deletes characters from the start of the current object's captured ]]>
<![CDATA[
]]>
<![CDATA[' value until the value's length equals the length specified by the parameter. ]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  Dim value]]>
<![CDATA[
]]>
<![CDATA[  Dim bRes]]>
<![CDATA[
]]>
<![CDATA[  Dim nVLen]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TruncateFromStart = False]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.isnumeric(strParam,locale) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter must be numeric. '" & StrParam & "' is not a numeric value")]]>
<![CDATA[
]]>
<![CDATA[		Exit function	]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'LenT counts text length not byte length.]]>
<![CDATA[
]]>
<![CDATA[  nVLen = clng(LenT(Value))]]>
<![CDATA[
]]>
<![CDATA[	If nVLen > Clng(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Start Field Value:'" & Value & "' ")]]>
<![CDATA[
]]>
<![CDATA[		If not (CurrentObj is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[			Do While nVLen>clng(StrParam)]]>
<![CDATA[
]]>
<![CDATA[				bRes = CurrentObj.DeleteChild(0)]]>
<![CDATA[
]]>
<![CDATA[        Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[        nVLen = clng(LenT(Value))]]>
<![CDATA[
]]>
<![CDATA[			loop]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Writelog("New Field Value:'" & Value & "' ")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TruncateFromStart = True]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("TruncateFromStart returns " & TruncateFromStart)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="TruncateFromEnd" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    A Number <var>n</var> that is the value's maximum length.]]>
<![CDATA[
]]>
<![CDATA['    This action deletes characters from the end of the current object's captured value until the value's length equals the length indicated by the parameter.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim Value]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  Dim nVLen]]>
<![CDATA[
]]>
<![CDATA[  locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TruncateFromEnd = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.isnumeric(StrParam, locale) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter must be numeric. '" & StrParam & "' is not a numeric value")]]>
<![CDATA[
]]>
<![CDATA[		Exit function	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  nVLen = clng(LenT(Value))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If nVLen > clng(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Start Field Value:'" & Value & "' length:'" & cstr(nVLen) & "'.")]]>
<![CDATA[
]]>
<![CDATA[    If not (CurrentObj is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[      Do While nVLen > clng(StrParam)]]>
<![CDATA[
]]>
<![CDATA[			  DeleteLastPos = Len(GetFieldValue)-1 	]]>
<![CDATA[
]]>
<![CDATA[        If DeleteLastPos<0 then Exit Do]]>
<![CDATA[
]]>
<![CDATA[				bRes = CurrentObj.DeleteChild(DeleteLastPos)]]>
<![CDATA[
]]>
<![CDATA[        'Writelog("Deleting character at position:'" & DeleteLastPos & "'.")]]>
<![CDATA[
]]>
<![CDATA[        Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[        nVLen = clng(LenT(Value))]]>
<![CDATA[
]]>
<![CDATA[      Loop]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Writelog("End Field Value:'" & Value & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TruncateFromEnd = True]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("TruncateFromEnd returns " & TruncateFromEnd)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AddLeadingZeros" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['    A number <var>n</var> which is the value's maximum length.]]>
<![CDATA[
]]>
<![CDATA['    Adds zeros ("0") to the beginning of the current Field object's captured value until the value's total length reaches the maximum n you specify as the parameter.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim CurCount]]>
<![CDATA[
]]>
<![CDATA[	Dim ActionNum]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[	AddLeadingZeros = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  strParam = MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.isnumeric(strParam, locale) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter must be numeric. '" & StrParam & "' is not a numeric value")]]>
<![CDATA[
]]>
<![CDATA[    AddLeadingZeros = False]]>
<![CDATA[
]]>
<![CDATA[		Exit function	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurCount = LenT(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = CurCount ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ActionNum = Abs(clng(strParam)) - CurCount]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Adding " & cstr(ActionNum) & " leading Zeros.")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If clng(ActionNum)>clng(0) then  ]]>
<![CDATA[
]]>
<![CDATA[	  AddLeadingZeros = InsertChars(bInteractive, bDebug,String(ActionNum,"0") & ",1,1")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AddTrailingZeros" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[' A number <var>n</var> which is the value's maximum length.]]>
<![CDATA[
]]>
<![CDATA[' Adds zeros ("0") to the end of the current Field's captured value until the value's length reaches the maximum <var>n</var> you enter as the parameter.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim CurCount]]>
<![CDATA[
]]>
<![CDATA[	Dim ActionNum	]]>
<![CDATA[
]]>
<![CDATA[	Dim locale]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[	AddTrailingZeros = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  strParam = MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.isnumeric(strParam, locale) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter must be numeric. '" & StrParam & "' is not a numeric value")]]>
<![CDATA[
]]>
<![CDATA[    AddTrailingZeros = False]]>
<![CDATA[
]]>
<![CDATA[		Exit function	]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	CurCount = LenT(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = CurCount]]>
<![CDATA[
]]>
<![CDATA[ 			]]>
<![CDATA[
]]>
<![CDATA[	ActionNum = Abs(Clng(strParam)) - CurCount]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Adding " & cstr(ActionNum) & " trailing zeros.")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If clng(ActionNum)>clng(0) then ]]>
<![CDATA[
]]>
<![CDATA[    	AddTrailingZeros = InsertChars(bInteractive, bDebug, String(ActionNum,"0") & "," & CurCount+1 & ",1")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteSelectedChars" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA['     The character or string of characters to be deleted.]]>
<![CDATA[
]]>
<![CDATA['		 A number indicating the starting index within the string to start deletion.  If this parameter]]>
<![CDATA[
]]>
<![CDATA['    is blank or is not a number, the starting index value will default to 1, the first position in the string.]]>
<![CDATA[
]]>
<![CDATA['		 The number of times the character or character string is to be deleted from the ]]>
<![CDATA[
]]>
<![CDATA['    value. The default is "1" and  "*" deletes all instances.]]>
<![CDATA[
]]>
<![CDATA[' ]]>
<![CDATA[
]]>
<![CDATA['   Deletes specific characters from the current Field object's captured value.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = StrParam & ",,"]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = ",,1"]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  delChars = MetaWord(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[  if IsEmpty(delChars) Then]]>
<![CDATA[
]]>
<![CDATA[     delCars = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[  end if   ]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("Delete string = '" & delChars & "'")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	DeleteSelectedChars = u_ModifyText(delChars, aStrParam(1), aStrParam(2),"")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("DeleteSelectedChars end value: '" & GetFieldValue() & "' ") 		 		]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteAllAlpha" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sResult  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sExpression]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  'Deletes all alphabetic characters from the current Field object's captured value.  ]]>
<![CDATA[
]]>
<![CDATA[	' \p{L} or \p{Letter}: any kind of letter from any language. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Mn} : a non spacing mark - required for non composed characters. ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Expression to match all letters from any language]]>
<![CDATA[
]]>
<![CDATA[  'sExpression = "\p{L}+"]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Expression to match all letters with and without upto two trailing non spacing mark characters.]]>
<![CDATA[
]]>
<![CDATA[  sExpression = "(\p{L}\p{Mn}{0,2})+"]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sResult = DCGlobalStrings.RemoveReplace(sExpression,cint(0),"",cint(0), CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  DeleteAllAlpha=True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Alphabetic characters deleted")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteAllNumeric" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sResult]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Removes all Numeric characters from the current Field object's captured value. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{N} or \p{Number}: any kind of numeric character in any script. ]]>
<![CDATA[
]]>
<![CDATA[  sResult = DCGlobalStrings.RemoveReplace("\p{N}+",cint(0),"",cint(0), CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  DeleteAllNumeric=TRUE]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteAllPunct" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sResult]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  DeleteAllPunct=TRUE]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '  Removes all punctuation characters current Field object's captured value. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{P} or \p{Punctuation}: any kind of punctuation character.]]>
<![CDATA[
]]>
<![CDATA[  sResult = DCGlobalStrings.RemoveReplace("\p{P}+",cint(0),"",cint(0), CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteAllMiscChars" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sResult]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Removes all characters with ASCII values 123 through 191 from the current Field object's captured value. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{S} or \p{Symbol}: math symbols, currency signs, dingbats, box-drawing characters, etc.. ]]>
<![CDATA[
]]>
<![CDATA[  sResult = DCGlobalStrings.RemoveReplace("\p{S}+",cint(0),"",cint(0), CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[  DeleteAllMiscChars = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteAllSysChars" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sResult]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' The action removes all characters with ASCII values 0 through 31 from the current ]]>
<![CDATA[
]]>
<![CDATA[  '  object's captured value.]]>
<![CDATA[
]]>
<![CDATA[  ' \p{C} or \p{Other}: invisible control characters and unused code points.]]>
<![CDATA[
]]>
<![CDATA[  sResult=DCGlobalStrings.RemoveReplace("\p{C}+",cint(0),"",cint(0), CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[  DeleteAllSysChars = True]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("System characters deleted")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FilterFieldSelectedChars" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	    ]]>
<![CDATA[
]]>
<![CDATA[  '  A String containing the character(s) to be removed.]]>
<![CDATA[
]]>
<![CDATA[  '  Every instance of the character(s) will be removed from the captured 	value.]]>
<![CDATA[
]]>
<![CDATA[  '  Removes all instances of the character(s) you enter as the parameter from the current]]>
<![CDATA[
]]>
<![CDATA[  '  Field object's captured value.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = rr_EscapeRegExProtectedChars(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	FilterFieldSelectedChars = u_RemoveReplace("[" & Strparam &"]+",1,"","*")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("'" & StrParam & "' character(s) removed from field value")]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ReplaceChars" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  '   The character or string of characters to be replaced; defaults to a space. SmartParameter Enabled.]]>
<![CDATA[
]]>
<![CDATA[  '   The character(s) of the replacement String. SmartParameter Enabled.]]>
<![CDATA[
]]>
<![CDATA[  '   The number of times replacement is to occur. The default is "1"	and  "*" replaces all instances.]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Replaces a character or string of characters in the current Field object's captured value with a String you enter as one of the parameters.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim sFind, sPush, iIndex]]>
<![CDATA[
]]>
<![CDATA[  Dim sFindMW, sPushMW ]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  ReplaceChars=False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  StrParam = StrParam & ",,"]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Len(aStrParam(0)) = 0 Then aStrParam(0) = " "]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.IsNumeric(aStrParam(2), locale) And Not(Trim(aStrParam(2)) = "*") Then aStrParam(2) = 1]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sFind = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[	sPush = aStrParam(1)]]>
<![CDATA[
]]>
<![CDATA[	iIndex = aStrParam(2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sFindMW = MetaWord(sFind)]]>
<![CDATA[
]]>
<![CDATA[  sPushMW = MetaWord(sPush)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Only use MetaWord result if it returns a value]]>
<![CDATA[
]]>
<![CDATA[  If sFindMW<>"" Then sFind=sFindMW]]>
<![CDATA[
]]>
<![CDATA[  If sPushMW<>"" Then sPush=sPushMW]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sFind="" Then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("String to replace (search string) is empty.")]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	ReplaceChars = u_ModifyText(sFind,1,iIndex,sPush)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("ReplaceChars new field value is '" & GetFieldValue & "'")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AllowOnlyChars" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[  ' Two actions exist with the same name so single source the code by calling AllowOnlyCharacters]]>
<![CDATA[
]]>
<![CDATA[  'WriteLog("Validations - AllowOnlyChars")      ]]>
<![CDATA[
]]>
<![CDATA[  AllowOnlyChars = AllowOnlyCharacters(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DateStampField" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'A Date format such as mm/dd/yy or dd/mm/yy.  (* defaults to 	mm/dd/yyyy)]]>
<![CDATA[
]]>
<![CDATA[  'Updates the current Field object with today's date. ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim dd,ddd,mm,yyyy,yy,y,m,d,mmm]]>
<![CDATA[
]]>
<![CDATA[  Dim sPattern, sReplace, bIgnoreCase]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	DateStampField = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Updates field with current Date value]]>
<![CDATA[
]]>
<![CDATA[	'Strparam is the pattern to update the field with]]>
<![CDATA[
]]>
<![CDATA[	'Value: '*' sets to default value]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	if strParam = "" then strParam = "*"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Check Parameter for invalid chars]]>
<![CDATA[
]]>
<![CDATA[	Dim sCheck ]]>
<![CDATA[
]]>
<![CDATA[	sCheck = Ucase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"C","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ," ","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"/","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"-","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,".","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"&","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"DAY","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"MONTH","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"YEAR","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"JULIAN","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"Y","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"D","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"M","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If (len(trim(sCheck))>0 AND (not "*" = trim(sCheck)))then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Invalid characters in parameter:'" & sCheck & "' ")]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'End Check]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If InStr(StrParam,"*")>0 Then StrParam = "mm/dd/yyyy"]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"c","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam," "," & CHR(32) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"/"," & CHR(47) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"-"," & CHR(45) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"."," & CHR(46) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"& &","&")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"day","dd")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"month","mm")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"year","yyyy")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"julian","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"jjj","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"j","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"yd","y & d")			]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"ym","y & m")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"my","m & y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"md","m & d")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"dy","d & y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"dm","d & m")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sPattern = "& *&"]]>
<![CDATA[
]]>
<![CDATA[	sReplace = "&"]]>
<![CDATA[
]]>
<![CDATA[  bIgnoreCase = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'RegExReplace(string value, string pattern, string replacewith, bool ignorecase = false)]]>
<![CDATA[
]]>
<![CDATA[  StrParam = DCGlobalStrings.RegExReplace(StrParam, sPattern, sReplace, bIgnoreCase)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Strparam after character substitution:'" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	d = Day(Now)]]>
<![CDATA[
]]>
<![CDATA[	dd = Right("0" & d,2)]]>
<![CDATA[
]]>
<![CDATA[	yyyy = Year(Now)]]>
<![CDATA[
]]>
<![CDATA[	yy = Right(yyyy,2)]]>
<![CDATA[
]]>
<![CDATA[	m = Month(Now)]]>
<![CDATA[
]]>
<![CDATA[	mm = Right("0" & m,2)]]>
<![CDATA[
]]>
<![CDATA[	mmm = MonthName(Month(Now), True)]]>
<![CDATA[
]]>
<![CDATA[	ccyy = yyyy]]>
<![CDATA[
]]>
<![CDATA[	y = DatePart("y",Now)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Text = Eval(Strparam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("DateStampField returns True. Date value: '" & CurrentObj.text & "'")]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function DateStampField")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set RX = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
	</g>
</af>
<af name="TimeStampField" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[  ' A time format (for example, HH:MM:SS, or HH:MM.)]]>
<![CDATA[
]]>
<![CDATA[  '  * defaults to HH:MM:SS]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	Dim mm,ss,hh,hhhh,m,s,h]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	TimeStampField = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Updates field with current Time value]]>
<![CDATA[
]]>
<![CDATA[	'Strparam is the pattern to update the field with]]>
<![CDATA[
]]>
<![CDATA[	'Value: '*' sets to default value]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	'Check Parameter for invalid chars]]>
<![CDATA[
]]>
<![CDATA[		Dim sCheck ]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Ucase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"M","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"H","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"S","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,":","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ," ","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"/","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"&","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"MIN","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"MINUTE","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"SEC","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"SECOND","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"HR","")]]>
<![CDATA[
]]>
<![CDATA[		sCheck = Replace(sCheck ,"HOUR","")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If len(trim(sCheck))>0 then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Invalid characters in parameter:'" & sCheck & "' ")]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'End Check]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Trim(StrParam) = "*" Then StrParam = "HH:MM:SS"]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"/"," & CHR(47) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam," "," & CHR(32) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,":"," & CHR(58) &")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"& &","&")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"min","mm")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"minute","mm")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"sec","ss")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"second","ss")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"hr","hh")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(StrParam,"hour","hh")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Strparam after character substitution:'" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	m = Minute(Now)]]>
<![CDATA[
]]>
<![CDATA[	s = Second(Now)]]>
<![CDATA[
]]>
<![CDATA[	h = Hour(Now)]]>
<![CDATA[
]]>
<![CDATA[	hhhh = hh]]>
<![CDATA[
]]>
<![CDATA[	mm = Right("0" & m,2)]]>
<![CDATA[
]]>
<![CDATA[	ss = Right("0" & s,2)]]>
<![CDATA[
]]>
<![CDATA[	hh = Right("0" & h,2)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text = Eval(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("TimeStampField returns True. Time value: " & CurrentObj.text) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
	</g>
</af>
<af name="SetIsOverrideable" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  '  Specifies that if the validation fails for the current object, If it is non-overrideable ]]>
<![CDATA[
]]>
<![CDATA[  '  or overrideable by the user.]]>
<![CDATA[
]]>
<![CDATA[  '  This status may prevent an operator from overriding a field's validations ]]>
<![CDATA[
]]>
<![CDATA[  '  and then continuing to subsequent pages. ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("SetIsOverrideable parameter is " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If Ucase(StrParam) = Ucase("True") Then]]>
<![CDATA[
]]>
<![CDATA[		nDefaultRtn = nRtn_Over]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Setting Rule to Overrideable.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		nDefaultRtn = nRtn_Fail]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Setting Rule to NON Overrideable.")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	SetIsOverrideable = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldDateUpToToday" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Checks that the current Field object's Date value is today's date or	earlier. ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim Value]]>
<![CDATA[
]]>
<![CDATA[	Dim dNow]]>
<![CDATA[
]]>
<![CDATA[	Dim locale]]>
<![CDATA[
]]>
<![CDATA[  Dim sCompare]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	IsFieldDateUpToToday = False]]>
<![CDATA[
]]>
<![CDATA[	value = Trim(GetFieldValue())	]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If len(Trim(value))=0 then ]]>
<![CDATA[
]]>
<![CDATA[	  Writelog("Field value is empty. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[	  Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Check Date]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalDates.IsDate(Value,locale) then]]>
<![CDATA[
]]>
<![CDATA[	  writelog("Current field value ( " & value & " ) is a valid Date value.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[	  sReturn = RRState.LoadString("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognized date format.")]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sReturn)]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call Writelog(DCGlobalDates.GetLog)]]>
<![CDATA[
]]>
<![CDATA[  	]]>
<![CDATA[
]]>
<![CDATA[  'dNow = cstr(MonthName(month(Now)) & Space(1) & Day(now) & space(1) & Year(now))]]>
<![CDATA[
]]>
<![CDATA[  'dNow = MetaWord("@DATE(dd/mm/yyyy)")]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[  Dim sDateFormat ]]>
<![CDATA[
]]>
<![CDATA[  Dim sSmartDate]]>
<![CDATA[
]]>
<![CDATA[  sDateFormat = DCGlobalDates.GetShortDateFormat(locale)   ]]>
<![CDATA[
]]>
<![CDATA[  sSmartDate = "@DATE(" & sDateFormat & ")"]]>
<![CDATA[
]]>
<![CDATA[  writelog( "sSmartDate = " & sSmartDate)]]>
<![CDATA[
]]>
<![CDATA[  dNow = MetaWord(sSmartDate)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'writelog("value = " & value & ". dNow = " & dNow & ".")]]>
<![CDATA[
]]>
<![CDATA[  sCompare = DCGlobalDates.CompareDate(Value,dNow,locale)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Select Case sCompare]]>
<![CDATA[
]]>
<![CDATA[  	Case "-1","0"]]>
<![CDATA[
]]>
<![CDATA[	  	IsFieldDateUpToToday = True]]>
<![CDATA[
]]>
<![CDATA[      sMessage= "Field date value is today or earlier"]]>
<![CDATA[
]]>
<![CDATA[		  WriteLog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  Case "1"]]>
<![CDATA[
]]>
<![CDATA[      sMessage=RRState.LoadString("validations","IsFieldDateUpToToday_01","Field '{0}' date value of '{1}' must be today's date or earlier.") ]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = replace(sMessage,"{2}",dNow)]]>
<![CDATA[
]]>
<![CDATA[		  DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		  WriteLog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[    Case else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Unknown result from Date Compare call. Returned value:'" & sCompare & "'")]]>
<![CDATA[
]]>
<![CDATA[	End Select  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ 	Call Writelog(DCGlobalDates.GetLog)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function IsFieldDateUpToToday") ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldDateWithinXDays" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[  'A number <var>n</var> that specifies how many days make up the review period.]]>
<![CDATA[
]]>
<![CDATA[  'Checks that current Field object's captured Date value is within <var>n</var> days of ]]>
<![CDATA[
]]>
<![CDATA[  'the number entered as a parameter.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim XDays, ActualDays]]>
<![CDATA[
]]>
<![CDATA[  Dim dNow]]>
<![CDATA[
]]>
<![CDATA[	Dim locale]]>
<![CDATA[
]]>
<![CDATA[  Dim ValueShortFormat]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	IsFieldDateWithinXDays = False]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	XDays = Trim(StrParam)	]]>
<![CDATA[
]]>
<![CDATA[  XDays = DCGlobalDates.ReplaceIndicWithWesternDigits(XDays)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.IsNumeric(XDays, locale) Or Len(XDays)=0 Then ]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Number of days is not numeric: " & XDays)]]>
<![CDATA[
]]>
<![CDATA[     Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if   ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	value = Trim(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[  value = DCGlobalDates.ReplaceIndicWithWesternDigits(value)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If len(Trim(value))=0 then]]>
<![CDATA[
]]>
<![CDATA[	    Writelog("Field value is empty. Exiting Action")]]>
<![CDATA[
]]>
<![CDATA[	    Exit Function]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[ 	'Check Date]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalDates.IsDate(Value,locale) then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Current field value ( " & value & " ) is a valid Date value.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		sReturn = RRState.LoadString("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognized date format.")]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sReturn)]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  dNow = Now]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  ValueShortFormat = DCGlobalDates.FormatDateTime(value,"d",locale)]]>
<![CDATA[
]]>
<![CDATA[  ActualDays = DCGlobalDates.SubtractDates(dNow, ValueShortFormat, 0, locale)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("[IsFieldDateWithinXDays] Action Limit = " & XDays & "   Calculated Days = " & ActualDays)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If ABS(CLng(ActualDays)) <= CLng(XDays) Then]]>
<![CDATA[
]]>
<![CDATA[		IsFieldDateWithinXDays = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldDateWithinXDays returns " & IsFieldDateWithinXDays) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldDateWithinXDays = False Then ]]>
<![CDATA[
]]>
<![CDATA[    sMessage=RRState.LoadString("validations","IsFieldDateWithinXDays","Field '{0}' date value of '{1}' is {3} days from today's date. The date must be within {2} of days of today's date.") ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",XDays)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{3}",ABS(CLng(ActualDays)))]]>
<![CDATA[
]]>
<![CDATA[    DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldDateWithinRange" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Comma-separated Dates that define the range: Start Date,  End Date]]>
<![CDATA[
]]>
<![CDATA[  '  TODAY can represent the current Date.]]>
<![CDATA[
]]>
<![CDATA[  '  Checks that the value assigned to the Text property of the bound object 	is a valid Date. If so, the action confirms that the Date is within the 	range specified by the parameters. ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sFromDate]]>
<![CDATA[
]]>
<![CDATA[	Dim sThruDate]]>
<![CDATA[
]]>
<![CDATA[	Dim sTempDate	]]>
<![CDATA[
]]>
<![CDATA[  Dim bExit]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  bExit = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	IsFieldDateWithinRange = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Check CurrentObj for Valid Date Value]]>
<![CDATA[
]]>
<![CDATA[	sValue = Trim(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'Convert Format]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalDates.IsDate(sValue,locale) then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Current field value (" & sValue & ") is a valid Date value. Locale:(" & DCGlobalDates.FormatDateTime(sValue,"D",locale) & ")")]]>
<![CDATA[
]]>
<![CDATA[		sValue = DCGlobalDates.FormatDateTime(sValue,"d",locale)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		sReturn = RRState.LoadString("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognized date format.")]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sReturn = replace(sReturn,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sReturn)]]>
<![CDATA[
]]>
<![CDATA[    writelog(sReturn)]]>
<![CDATA[
]]>
<![CDATA[    writelog(DCGlobalDates.Getlog())]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	Writelog("-----")		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Checking Action Parameters...")		]]>
<![CDATA[
]]>
<![CDATA[	'Parse CSV StrParam]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = split(strParam & ",",",")]]>
<![CDATA[
]]>
<![CDATA[	sFromDate=Trim(MetaWord(aStrParam(0)))]]>
<![CDATA[
]]>
<![CDATA[	sThruDate=Trim(MetaWord(aStrParam(1)))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Checking Parameters for Valid Date Values or Keywords		]]>
<![CDATA[
]]>
<![CDATA[	If instr(ucase(sFromDate),"TODAY") then sFromDate = now]]>
<![CDATA[
]]>
<![CDATA[	If instr(ucase(sThruDate),"TODAY") then sThruDate = now]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(sFromDate)=0 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "Action Parameter 1 (From Date) is Empty. Using Current Date '" & now & "'")]]>
<![CDATA[
]]>
<![CDATA[		sFromDate = now]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(sThruDate)=0 then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "Action Parameter 2 (Thru Date) is Empty. Using Current Date '" & now & "'")]]>
<![CDATA[
]]>
<![CDATA[		sThruDate = now]]>
<![CDATA[
]]>
<![CDATA[	end if	]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	'Convert format]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalDates.IsDate(sFromDate,locale) then]]>
<![CDATA[
]]>
<![CDATA[    writelog("FROM Date field value (" & sFromDate & ") is a valid Date value. Locale:(" & DCGlobalDates.FormatDateTime(sFromDate,"D",locale) &")")]]>
<![CDATA[
]]>
<![CDATA[		sFromDate = DCGlobalDates.FormatDateTime(sFromDate,"d",locale)]]>
<![CDATA[
]]>
<![CDATA[    'writelog(DCGlobalDates.Getlog)]]>
<![CDATA[
]]>
<![CDATA[    'writelog("'d' format:" & sFromDate)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "FROM Date parameter does not have a valid date Format:'" & sFromDate & "'")]]>
<![CDATA[
]]>
<![CDATA[    writelog(DCGlobalDates.Getlog())]]>
<![CDATA[
]]>
<![CDATA[		bExit=True]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Convert format]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalDates.IsDate(sThruDate,locale) then]]>
<![CDATA[
]]>
<![CDATA[    writelog("THRU Date field value (" & sThruDate & ") is a valid Date value. Locale:(" & DCGlobalDates.FormatDateTime(sThruDate,"D",locale) & ")")]]>
<![CDATA[
]]>
<![CDATA[		sThruDate = DCGlobalDates.FormatDateTime(sThruDate,"d",locale)]]>
<![CDATA[
]]>
<![CDATA[   ' writelog(DCGlobalDates.Getlog)]]>
<![CDATA[
]]>
<![CDATA[   'writelog("'d' format:" & sThruDate)]]>
<![CDATA[
]]>
<![CDATA[   else]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(5) & "Thru-Date parameter does not have a valid date Format:'" & sThruDate & "'")]]>
<![CDATA[
]]>
<![CDATA[    writelog(DCGlobalDates.Getlog())]]>
<![CDATA[
]]>
<![CDATA[		bExit=True]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'If the parameters failed authenticity then exit the function]]>
<![CDATA[
]]>
<![CDATA[  If bExit then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'Check That FromDate is before ThruDate]]>
<![CDATA[
]]>
<![CDATA[  If DCGlobalDates.CompareDate(sFromDate,sThruDate,locale)>0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog(Space(5) & "Warning: From-date (" + sFromDate + ") is after Thru-date (" + sThruDate + ") : Switching Values.")]]>
<![CDATA[
]]>
<![CDATA[    writelog(DCGlobalDates.Getlog)]]>
<![CDATA[
]]>
<![CDATA[		sTempDate=sFromDate]]>
<![CDATA[
]]>
<![CDATA[		sFromDate=sThruDate]]>
<![CDATA[
]]>
<![CDATA[		sThruDate=sTempDate]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	Writelog("-----")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Checking Field Value Against Parameter Range...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Check Range]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalDates.CompareDate(sValue,sFromDate,locale)<0 or DCGlobalDates.CompareDate(sValue,sThruDate,locale)>0 Then]]>
<![CDATA[
]]>
<![CDATA[		sMessage=RRState.LoadString("validations","IsFieldDateWithinRange_01","Field '{0}' date value of '{1}' must be between the dates of '{2}' to '{3}'.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",sValue)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",sFromDate)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{3}",sThruDate)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Current Date Value '" & cstr(sValue) & "' is within range: '" & cstr(sFromDate) & "' - '" & cstr(sThruDate) & "'")]]>
<![CDATA[
]]>
<![CDATA[	IsFieldDateWithinRange=True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldDateWithinRange returns " & IsFieldDateWithinRange)]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldDateWithReformat" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  The Date format you want to use.]]>
<![CDATA[
]]>
<![CDATA[  '  mm/dd/yy]]>
<![CDATA[
]]>
<![CDATA[  '  dd/mm/yy]]>
<![CDATA[
]]>
<![CDATA[  '  mm.dd.yy, etc.]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  y yy yyy yyyy  "8 08 008 2008"   year]]>
<![CDATA[
]]>
<![CDATA[  '  M MM MMM MMMM  "3 03 Mar March"  month]]>
<![CDATA[
]]>
<![CDATA[  '  d dd ddd dddd  "9 09 Sun Sunday" day]]>
<![CDATA[
]]>
<![CDATA[  '  h hh H HH      "4 04 16 16"      hour 12/24]]>
<![CDATA[
]]>
<![CDATA[  '  m mm           "5 05"            minute]]>
<![CDATA[
]]>
<![CDATA[  '  s ss           "7 07"            second]]>
<![CDATA[
]]>
<![CDATA[  '  f ff fff ffff  "1 12 123 1230"   sec.fraction]]>
<![CDATA[
]]>
<![CDATA[  '  F FF FFF FFFF  "1 12 123 123"    without zeroes]]>
<![CDATA[
]]>
<![CDATA[  '  t tt           "P PM"            A.M. or P.M.]]>
<![CDATA[
]]>
<![CDATA[  '  z zz zzz       "-6 -06 -06:00"   time zone]]>
<![CDATA[
]]>
<![CDATA[  '              ]]>
<![CDATA[
]]>
<![CDATA[  '  t ShortTimePattern h:mm tt ]]>
<![CDATA[
]]>
<![CDATA[  '  d ShortDatePattern M/d/yyyy ]]>
<![CDATA[
]]>
<![CDATA[  '  T LongTimePattern h:mm:ss tt ]]>
<![CDATA[
]]>
<![CDATA[  '  D LongDatePattern dddd, MMMM dd, yyyy ]]>
<![CDATA[
]]>
<![CDATA[  '  f (combination of D and t) dddd, MMMM dd, yyyy h:mm tt ]]>
<![CDATA[
]]>
<![CDATA[  '  F FullDateTimePattern dddd, MMMM dd, yyyy h:mm:ss tt ]]>
<![CDATA[
]]>
<![CDATA[  '  g (combination of d and t) M/d/yyyy h:mm tt ]]>
<![CDATA[
]]>
<![CDATA[  '  G (combination of d and T) M/d/yyyy h:mm:ss tt ]]>
<![CDATA[
]]>
<![CDATA[  '  m, M MonthDayPattern MMMM dd ]]>
<![CDATA[
]]>
<![CDATA[  '  y, Y YearMonthPattern MMMM, yyyy ]]>
<![CDATA[
]]>
<![CDATA[  '  r, R RFC1123Pattern ddd, dd MMM yyyy HH':'mm':'ss 'GMT' (*) ]]>
<![CDATA[
]]>
<![CDATA[  '  s SortableDateTi­mePattern yyyy'-'MM'-'dd'T'HH':'mm':'ss (*) ]]>
<![CDATA[
]]>
<![CDATA[  '  u UniversalSorta­bleDateTimePat­tern yyyy'-'MM'-'dd HH':'mm':'ss'Z' (*) 	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  IsFieldDateWithReformat = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Trim(MetaWord(StrParam))]]>
<![CDATA[
]]>
<![CDATA[  Writelog("IsFieldDateWithReformat argument = '" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[	value = Trim(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start Field Value:'" & value & "' ")]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If DCGlobalDates.IsDate(value,locale)=False then]]>
<![CDATA[
]]>
<![CDATA[    IsFieldDateWithReformat = False			]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","InvalidDate_01","Field '{0}' date value of '{1}' is not a valid date or recognized date format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  		]]>
<![CDATA[
]]>
<![CDATA[	'Updates field with reformatted Date value]]>
<![CDATA[
]]>
<![CDATA[	'Strparam is the pattern to format to]]>
<![CDATA[
]]>
<![CDATA[	'Value: '*' sets to short date format value]]>
<![CDATA[
]]>
<![CDATA[  StrParam = Replace(StrParam,"*","d")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"c","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"day","dd")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"month","MM")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"year","yyyy")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"ccyy","yyyy")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"julian","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"jjj","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"j","y")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"yd","yd")			]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"ym","yM")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"my","My")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"md","Md")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"dy","dy")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"dm","dM")]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Replace(lcase(StrParam),"m","M")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'default to short date format]]>
<![CDATA[
]]>
<![CDATA[  If len(trim(StrParam))= 0 then StrParam = "d"]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Eval String:'" & StrParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[  CurrentObj.Text = DCGlobalDates.FormatDateTime(value, StrParam,locale)]]>
<![CDATA[
]]>
<![CDATA[  		     	]]>
<![CDATA[
]]>
<![CDATA[  If Err.Number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[  	IsFieldDateWithReformat = False			]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Err:" & err.number & ":" & Err.description)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldDateWithReformat_01","There was a problem formatting the date value '{1}' in field '{0}' to the pattern '{2}'.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[    Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[    DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldDateWithReformat returns " & IsFieldDateWithReformat & ". Date value:'" & CurrentObj.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[	Set RX = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldCurrency" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Determines if the current Field object's captured value is 100% Numeric 	]]>
<![CDATA[
]]>
<![CDATA[  '  and includes a two-digit decimal amount. When determining the Numeric %, 	]]>
<![CDATA[
]]>
<![CDATA[  '  the action ignores spaces and punctuation such as commas and decimal points. ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	IsFieldCurrency = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  IsFieldCurrency = DCGlobalCurrency.IsCurrency(value,locale)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("IsFieldCurrency returns " & IsFieldCurrency)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldCurrency = False Then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog(DCGlobalCurrency.Getlog())]]>
<![CDATA[
]]>
<![CDATA[    sMessage=RRState.LoadString("validations","IsFieldCurrency_01","Field '{0}' value of '{1}' was not recognised as a valid currency format.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function IsFieldCurrency")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GoToNextRule" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'This action has been deprecated. It has been replaced by "GoToNextFunction".]]>
<![CDATA[
]]>
<![CDATA[	GoToNextRule = False]]>
<![CDATA[
]]>
<![CDATA[	GoToNextRule = GoToNextFunction()]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldMatching" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'The value to be checked against the Field object's value.]]>
<![CDATA[
]]>
<![CDATA[	'Determines if the value entered as the parameter is identical to the captured value of the current Field object. ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	IsFieldMatching = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Checking if field value" & value & " matches " & strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Trim(value) = Trim(strParam) Then]]>
<![CDATA[
]]>
<![CDATA[		IsFieldMatching = True]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldMatching returns " & IsFieldMatching)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldMatching = False Then ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldMatching_01","Field '{0}' value of '{1}' did not match '{2}'.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",strParam)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call ErrorHandler("Function IsFieldMatching") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CopyFieldToField" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'The name of the target Field object of the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[  'Copies the captured value of the current Field object to the Field object designated as the action's parameter. ]]>
<![CDATA[
]]>
<![CDATA[   		]]>
<![CDATA[
]]>
<![CDATA[	Dim oNewChar, oCurChar	]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld,bRes]]>
<![CDATA[
]]>
<![CDATA[	Dim nLeft,nTop,nRight,nBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CopyFieldToField = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("GET FIELD " & Ucase(StrParam))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If oFld is nothing Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Cannot locate field '" & StrParam & "'. Exiting Action")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oFld.Text=""	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Append New Characters]]>
<![CDATA[
]]>
<![CDATA[	nChildren=Currentobj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	For xChar = 1 to nChildren]]>
<![CDATA[
]]>
<![CDATA[		'Add Characters ]]>
<![CDATA[
]]>
<![CDATA[		Set oCurChar = CurrentObj.GetChild(xChar-1)]]>
<![CDATA[
]]>
<![CDATA[    If IsAlive(oCurChar) then]]>
<![CDATA[
]]>
<![CDATA[      If oCurChar.objecttype=4 Then]]>
<![CDATA[
]]>
<![CDATA[        Set oNewChar = oFld.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[        nChar = oNewChar.AddValue(CLng(oCurChar.CharValue(0)), CLng(oCurChar.CharConfidence(0)))]]>
<![CDATA[
]]>
<![CDATA[        bRes = oCurChar.GetPosition(nLeft,nTop,nRight,nBottom) ]]>
<![CDATA[
]]>
<![CDATA[        bRes = oNewChar.SetPosition(nLeft,nTop,nRight,nBottom)]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'xChar	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("New value for Field " & StrParam  & " : '" & oFld.Text & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CopyFieldToField = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCurChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oNewChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = Nothing ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AppendToField" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  'The name of the Field object to which the value is to be 	appended.]]>
<![CDATA[
]]>
<![CDATA[  'Appends the captured value of the current Field object to the captured value of the ]]>
<![CDATA[
]]>
<![CDATA[  'Field object specified by the parameter.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim oNewChar, oCurChar	]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld,bRes]]>
<![CDATA[
]]>
<![CDATA[	Dim nLeft,nTop,nRight,nBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim nAdjust]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	AppendToField= False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("GET FIELD " & Ucase(StrParam))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If oFld is nothing Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Cannot locate field '" & StrParam & "'. Exiting Action") ]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nChildren=CurrentObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	For xChar = 1 to nChildren]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Set oCurChar = CurrentObj.GetChild(xChar-1)]]>
<![CDATA[
]]>
<![CDATA[    If IsAlive(oCurChar) Then]]>
<![CDATA[
]]>
<![CDATA[      If oCurChar.ObjectType=4 then]]>
<![CDATA[
]]>
<![CDATA[        'Add Characters ]]>
<![CDATA[
]]>
<![CDATA[        Set oNewChar = oFld.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[        nChar = oNewChar.AddValue(CLng(oCurChar.CharValue(0)), CLng(oCurChar.CharConfidence(0)))]]>
<![CDATA[
]]>
<![CDATA[        bRes = oCurChar.GetPosition(nLeft,nTop,nRight,nBottom) ]]>
<![CDATA[
]]>
<![CDATA[        bRes = oNewChar.SetPosition(nLeft,nTop,nRight,nBottom)]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'xChar]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("New value for Field '" & oFld.Text & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	AppendToField= True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCurChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oNewChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = Nothing ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AppendFromField" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'The name of the Field object whose text value is to be appended to the 	current field's value.]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Appends the captured value of the specified Field object to the]]>
<![CDATA[
]]>
<![CDATA[  '  captured value of the current Field object.  You can also apply this 	]]>
<![CDATA[
]]>
<![CDATA[  '  action at the Page level.  A Text page-level variable with the appended 	]]>
<![CDATA[
]]>
<![CDATA[  '  value will be added to the page's Data file. ]]>
<![CDATA[
]]>
<![CDATA[	Dim oNewChar, oCurChar	]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld,bRes]]>
<![CDATA[
]]>
<![CDATA[	Dim nLeft,nTop,nRight,nBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim nAdjust]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	AppendFromField= False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("GET FIELD " & Ucase(StrParam))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If oFld is nothing Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Cannot locate field '" & StrParam & "'. Exiting Action")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nChildren=oFld.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	For xChar = 1 to nChildren		]]>
<![CDATA[
]]>
<![CDATA[		Set oCurChar = oFld.GetChild(xChar-1)]]>
<![CDATA[
]]>
<![CDATA[    If IsAlive(oCurChar) then]]>
<![CDATA[
]]>
<![CDATA[      If oCurChar.ObjectType=4 then]]>
<![CDATA[
]]>
<![CDATA[        'Add Characters ]]>
<![CDATA[
]]>
<![CDATA[	  	  Set oNewChar = CurrentObj.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[		    nChar = oNewChar.AddValue(CLng(oCurChar.CharValue(0)), CLng(oCurChar.CharConfidence(0)))]]>
<![CDATA[
]]>
<![CDATA[        bRes = oCurChar.GetPosition(nLeft,nTop,nRight,nBottom) ]]>
<![CDATA[
]]>
<![CDATA[        bRes = oNewChar.SetPosition(nLeft,nTop,nRight,nBottom)]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'xChar]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("New value for Field '" & CurrentObj.Text & "' ")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType<3 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Non-Field Object. Saving as 'Text' variable")]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("Text") = CurrentObj.Variable("Text") & oFld.Text]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	AppendFromField= True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCurChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oNewChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CopyField" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  'The name of the target Field object.]]>
<![CDATA[
]]>
<![CDATA[  'Assigns the current Field object's captured value to a sibling Field object you specify as the parameter.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim oNewChar, oCurChar	]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld, bRes]]>
<![CDATA[
]]>
<![CDATA[	Dim nLeft,nTop,nRight,nBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim FieldNm, NewValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CopyField = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strParam & "," , ",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FieldNm = aStrParam(0)]]>
<![CDATA[
]]>
<![CDATA[	NewValue = aStrParam(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Getting Field '" & FieldNm & "'" )]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(FieldNm)]]>
<![CDATA[
]]>
<![CDATA[	If oFld is nothing Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Cannot locate field '" & FieldNm & "'. Exiting Action")]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	oFld.Text = ""]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(Trim(NewValue))=0 then]]>
<![CDATA[
]]>
<![CDATA[		NewValue=CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Append New Characters]]>
<![CDATA[
]]>
<![CDATA[	For xChar = 1 to len(NewValue)]]>
<![CDATA[
]]>
<![CDATA[		'Add Characters ]]>
<![CDATA[
]]>
<![CDATA[		Set oNewChar = oFld.AddChild(4,"",-1)	]]>
<![CDATA[
]]>
<![CDATA[		nChar = oNewChar.AddValue(CLng(Ascw( Mid(NewValue,xChar,1))), CLng(9)) ]]>
<![CDATA[
]]>
<![CDATA[     	bRes = oNewChar.SetPosition(clng(0),clng(0),clng(0),clng(0))]]>
<![CDATA[
]]>
<![CDATA[	Next 'xChar]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("New value for Field " & oFld.ID & " is '" & oFld.Text & "'.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CopyField = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oNewChar = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="EmptyFieldValue" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  'The name of the Field object that is to be emptied.]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Clears the text value in the field represented by the Field object of the ]]>
<![CDATA[
]]>
<![CDATA[  '  Document Hierarchy specified by the parameter.]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim oNewChar, oCurChar	]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld, bRes]]>
<![CDATA[
]]>
<![CDATA[	Dim nLeft,nTop,nRight,nBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim FieldNm, NewValue]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	EmptyFieldValue = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	FieldNm = Trim(strParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Getting Field '" & FieldNm & "'" )]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(FieldNm)]]>
<![CDATA[
]]>
<![CDATA[	If oFld is nothing Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Cannot locate field '" & FieldNm & "'. Exiting Action") ]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Start value for field '" & oFld.Text & "' ")]]>
<![CDATA[
]]>
<![CDATA[	oFld.Text=""]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("End value for field '" & oFld.Text & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	EmptyFieldValue = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldGreaterOrEqual" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[  'The Numeric or Currency value which is the basis for comparison.]]>
<![CDATA[
]]>
<![CDATA[  'Determines if the captured value of the current Field object is greater than (or equal to) the value entered as a parameter. If the field's value is not Numeric or currency, the action will return a  condition.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim value]]>
<![CDATA[
]]>
<![CDATA[	Dim sMessage	]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[	IsFieldGreaterOrEqual= True]]>
<![CDATA[
]]>
<![CDATA[	value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	sMessage = ""	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  strParam = MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not DCGlobalCurrency.IsNumeric(strParam, locale, locale) Then ]]>
<![CDATA[
]]>
<![CDATA[    writelog("Action Parameter is not Numeric!")]]>
<![CDATA[
]]>
<![CDATA[    Writelog(DCGlobalCurrency.Getlog())]]>
<![CDATA[
]]>
<![CDATA[    IsFieldGreaterOrEqual= False]]>
<![CDATA[
]]>
<![CDATA[   End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.IsNumeric(value, locale, locale) Then ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Field's value is not numeric!")]]>
<![CDATA[
]]>
<![CDATA[    Writelog(DCGlobalCurrency.Getlog())]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","NotNumeric_01","Field '{0}' value of '{1}' must be numeric.")]]>
<![CDATA[
]]>
<![CDATA[    IsFieldGreaterOrEqual= False]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldGreaterOrEqual= True then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If CDBL(value) >= CDBL(strParam) Then ]]>
<![CDATA[
]]>
<![CDATA[		   IsFieldGreaterOrEqual = True]]>
<![CDATA[
]]>
<![CDATA[		   WriteLog(value & " is greater than or equal to " & strParam)]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[       IsFieldGreaterOrEqual = False]]>
<![CDATA[
]]>
<![CDATA[		   WriteLog(value & " is less than " & strParam)]]>
<![CDATA[
]]>
<![CDATA[       sMessage = RRState.LoadString("validations","IsFieldGreaterOrEqual_01","Field '{0}' value of '{1}' must be greater than '{2}'.") ]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldGreaterOrEqual returns " & IsFieldGreaterOrEqual)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldGreaterOrEqual = False then]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",strParam)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldLessOrEqual" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  'The Numeric or Currency value you want to compare against.]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Determines if the captured value of the current Field object is less than (or equal to) ]]>
<![CDATA[
]]>
<![CDATA[  '  the value entered as a parameter.  If the field's value is not Numeric or Currency, the ]]>
<![CDATA[
]]>
<![CDATA[  '  action will return a  condition.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim Value]]>
<![CDATA[
]]>
<![CDATA[	Dim sMessage]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	sMessage = ""	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsFieldLessOrEqual= True]]>
<![CDATA[
]]>
<![CDATA[	Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  strParam = MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  If Not DCGlobalCurrency.IsNumeric(strParam, locale, locale) Then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog(DCGlobalCurrency.Getlog())]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Action Parameter is not Numeric!") ]]>
<![CDATA[
]]>
<![CDATA[    IsFieldLessOrEqual= False]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.IsNumeric(value, locale, locale) Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog(DCGlobalCurrency.Getlog()) ]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Field's value is not numeric!")   ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","NotNumeric_01","Field '{0}' value of '{1}' must be numeric.")]]>
<![CDATA[
]]>
<![CDATA[    IsFieldLessOrEqual= False]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldLessOrEqual= True then]]>
<![CDATA[
]]>
<![CDATA[		If CDBL(value) <= CDBL(strParam) Then ]]>
<![CDATA[
]]>
<![CDATA[		   IsFieldLessOrEqual = True]]>
<![CDATA[
]]>
<![CDATA[		   WriteLog(value & " is less than or equal to " & strParam)]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[		   WriteLog(value & " is greater than " & strParam)]]>
<![CDATA[
]]>
<![CDATA[       sMessage = RRState.LoadString("validations","IsFieldLessOrEqual_01","Field '{0}' value of '{1}' must be less than '{2}'.")]]>
<![CDATA[
]]>
<![CDATA[       IsFieldLessOrEqual= False]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	end if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldLessOrEqual returns " & IsFieldLessOrEqual)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldLessOrEqual = False then ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{1}",value)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{2}",strParam)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="InsertDecimalPoint" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'A number <var>n</var> indicating the character position at which to place the decimal.]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Places a decimal character in the captured value, at the character position specified as a parameter.]]>
<![CDATA[
]]>
<![CDATA[  '  The parameter indicates the position of the decimal point, moving from right to left.]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim Place]]>
<![CDATA[
]]>
<![CDATA[  Dim sDecimalSeparator]]>
<![CDATA[
]]>
<![CDATA[  Dim sGroupSeparator]]>
<![CDATA[
]]>
<![CDATA[  Dim sDecimalDigits]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sDecimalDigits = DCGlobalCurrency.CurrencyDecimalDigits(locale)]]>
<![CDATA[
]]>
<![CDATA[  sGroupSeparator = DCGlobalCurrency.CurrencyGroupSeparator(locale)]]>
<![CDATA[
]]>
<![CDATA[  sDecimalSeparator = DCGlobalCurrency.CurrencyDecimalSeparator(locale)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  strparam = MetaWord(strparam)]]>
<![CDATA[
]]>
<![CDATA[  If Not DCGlobalCurrency.IsNumeric(strparam, locale) or Trim(strparam)="" then]]>
<![CDATA[
]]>
<![CDATA[    strParam = sDecimalDigits]]>
<![CDATA[
]]>
<![CDATA[    writelog("Number of decimal places defaulted to " & strparam)]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Place = CInt(strParam)-1]]>
<![CDATA[
]]>
<![CDATA[	InsertDecimalPoint = True]]>
<![CDATA[
]]>
<![CDATA[	value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start Field value:'" & value & "'")]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	If InStr(value,sDecimalSeparator) then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Decimal separator found. Value unchanged. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.IsNumeric(value, locale) then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Non-numeric value found. Value unchanged. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Len(value)<2 then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Value has less than 2 characters. Value unchanged. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	If InStr(Right(value,3),sGroupSeparator)>0 Then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Group Separator detected in third position. Value unchanged. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	 	]]>
<![CDATA[
]]>
<![CDATA[  value=InsertCharacters(sDecimalSeparator,Cstr(Len(value)-Place),1)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("End field value:'" & CurrentObj.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
	</g>
</af>
<f name="CalculateFields" access="public">
	<p name="Equation">
	</p>
	<p name="DecimalDigits">
	</p>
	<p name="PreserveStatus">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  The equation that is the basis for the calculation.]]>
<![CDATA[
]]>
<![CDATA[	']]>
<![CDATA[
]]>
<![CDATA[  '  You can use a Field object's name or numeric values with any arithmetic operator (+,-,*,/,^). ]]>
<![CDATA[
]]>
<![CDATA[  '  To use a Field object's name, surround the field name with single quotation marks (').  ]]>
<![CDATA[
]]>
<![CDATA[  '  A null is treated as a "0".]]>
<![CDATA[
]]>
<![CDATA[  ']]>
<![CDATA[
]]>
<![CDATA[  '  Calculates the equation entered as a parameter and compares the result to the current Field object's captured value.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim nNum]]>
<![CDATA[
]]>
<![CDATA[	Dim aDecimal]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim Sobj    ]]>
<![CDATA[
]]>
<![CDATA[	Dim Nx  ]]>
<![CDATA[
]]>
<![CDATA[	Dim nDecimal]]>
<![CDATA[
]]>
<![CDATA[  Dim nDecimalDefault]]>
<![CDATA[
]]>
<![CDATA[	Dim sExpression]]>
<![CDATA[
]]>
<![CDATA[	Dim nValue]]>
<![CDATA[
]]>
<![CDATA[	Dim sBasicExpression]]>
<![CDATA[
]]>
<![CDATA[	Dim oCurParent]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim bHasChildren]]>
<![CDATA[
]]>
<![CDATA[	Dim dictCalcObj]]>
<![CDATA[
]]>
<![CDATA[	Dim sTempNode]]>
<![CDATA[
]]>
<![CDATA[	Dim sCResult]]>
<![CDATA[
]]>
<![CDATA[	Dim bPreserveStatus	]]>
<![CDATA[
]]>
<![CDATA[	Dim nDigits]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  Dim tNode]]>
<![CDATA[
]]>
<![CDATA[  Dim bconvertdecimal]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set dictCalcObj = CreateObject("Scripting.Dictionary")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	CalculateFields = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oCurParent = CurrentObj.Parent()]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	bHasChildren = CurrentObj.NumOfChildren > Len(CurrentObj.Text) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  StrParam=Equation]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  bPreserveStatus = FALSE]]>
<![CDATA[
]]>
<![CDATA[  PreserveStatus=Trim(Ucase(PreserveStatus))]]>
<![CDATA[
]]>
<![CDATA[  If PreserveStatus="TRUE" or PreserveStatus="1" then]]>
<![CDATA[
]]>
<![CDATA[    bPreserveStatus=TRUE]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Set and log number of decimal digits to use for formatting]]>
<![CDATA[
]]>
<![CDATA[  nDigits = 8 'final eval default to prevent memory error for very small remainders]]>
<![CDATA[
]]>
<![CDATA[	nDecimal = Trim(DecimalDigits)]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Decimal digits:'" & nDecimal & "'  (Blank if not set, defaults to regional setting)")]]>
<![CDATA[
]]>
<![CDATA[  if len(nDecimal)>0 then nDigits=nDecimal]]>
<![CDATA[
]]>
<![CDATA[  sCResult = ""]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Split the array based on the apostrophe character ]]>
<![CDATA[
]]>
<![CDATA[  'surrounding all dco types]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(strparam & "'", "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Get the Group and Decimal Separator regional characters]]>
<![CDATA[
]]>
<![CDATA[  Dim GroupSeparator]]>
<![CDATA[
]]>
<![CDATA[  Dim DecimalSeparator]]>
<![CDATA[
]]>
<![CDATA[  GroupSeparator = DCGlobalCurrency.CurrencyGroupSeparator(locale)]]>
<![CDATA[
]]>
<![CDATA[  DecimalSeparator = DCGlobalCurrency.CurrencyDecimalSeparator(locale)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  bconvertdecimal=true]]>
<![CDATA[
]]>
<![CDATA[  If ucase(cstr(CurrentObj.Variable("convertdecimal")))="TRUE" then bconvertdecimal=true]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim elements]]>
<![CDATA[
]]>
<![CDATA[  elements=Ubound(aStrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Process each element]]>
<![CDATA[
]]>
<![CDATA[  For Nx = 1 to Ubound(aStrParam)]]>
<![CDATA[
]]>
<![CDATA[    aNode = aStrParam(Nx-1) ]]>
<![CDATA[
]]>
<![CDATA[    bNode = False]]>
<![CDATA[
]]>
<![CDATA[    If Nx>1 then Writelog(vbcrlf)]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Processing node [" & Nx & "] of [" & elements & "]. Node Value:'" & aStrParam(Nx-1) & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Temp var for checking for complex operator]]>
<![CDATA[
]]>
<![CDATA[    tNode = aNode]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Check for complex operator]]>
<![CDATA[
]]>
<![CDATA[    tNode = Replace(tNode,"<","")]]>
<![CDATA[
]]>
<![CDATA[    tNode = Replace(tNode,">","")]]>
<![CDATA[
]]>
<![CDATA[    tNode = Replace(tNode,"+","")]]>
<![CDATA[
]]>
<![CDATA[    tNode = Replace(tNode,"=","")]]>
<![CDATA[
]]>
<![CDATA[    tNode = Replace(tNode,"/","")]]>
<![CDATA[
]]>
<![CDATA[    tNode = Replace(tNode,"*","")]]>
<![CDATA[
]]>
<![CDATA[    tNode = Replace(tNode,"-","")]]>
<![CDATA[
]]>
<![CDATA[    tNode = Replace(tNode,"abs","")]]>
<![CDATA[
]]>
<![CDATA[    tNode = Replace(tNode,"(","")]]>
<![CDATA[
]]>
<![CDATA[    tNode = Replace(tNode,")","")]]>
<![CDATA[
]]>
<![CDATA[    tNode = Replace(tNode,"^","")]]>
<![CDATA[
]]>
<![CDATA[    tNode = Replace(tNode," ","")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If Trim(tNode) = "" Then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Node " & Nx & " is empty or contains expected mathmatical operator characters.")]]>
<![CDATA[
]]>
<![CDATA[      bNode = True]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    'Check if Blank, Numeric or special character]]>
<![CDATA[
]]>
<![CDATA[    If instr("<>+=/*-abs()^",Trim(aNode))>0 or Trim(aNode) = "" or DCGlobalCurrency.IsNumeric(Trim(aNode),locale)=True Then bNode = True]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Check if self]]>
<![CDATA[
]]>
<![CDATA[    If aStrParam(Nx-1)= CurrentObj.Type Then ]]>
<![CDATA[
]]>
<![CDATA[      if err.number<>0 then err.clear]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[      If(Trim(CurrentObj.Text) = "") Then ]]>
<![CDATA[
]]>
<![CDATA[        aStrParam(Nx-1) = 0]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        'Remove the regional Group separator]]>
<![CDATA[
]]>
<![CDATA[        aStrParam(Nx-1)= Trim(replace(CurrentObj.Text,GroupSeparator,""))]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      bNode = True]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & CurrentObj.Type & " is Calling Object. Node value is '" & aStrParam(Nx-1) & "'.")     ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Writelog(Space(3) & "Checking point 3 value:'" & aStrParam(Nx-1) & "'.")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Check Page/Document of Self]]>
<![CDATA[
]]>
<![CDATA[    If Not(bNode) And Not(oCurParent Is Nothing) Then ]]>
<![CDATA[
]]>
<![CDATA[      nValue = ""			]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      'If no DCO path is present	]]>
<![CDATA[
]]>
<![CDATA[      If instr(aStrParam(Nx-1),"..\")=0 then ]]>
<![CDATA[
]]>
<![CDATA[          'Search Parent Page, or Document(If called at Page or Document level)]]>
<![CDATA[
]]>
<![CDATA[          Set oParent = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[          While (oParent.ObjectType>2 or (oParent.ObjectType>1 And CurrentObj.ObjectType=2)) And oParent.ObjectType<>0 And nValue=""]]>
<![CDATA[
]]>
<![CDATA[            Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[            'nValue will return 0+ if children found and "" if no children found.]]>
<![CDATA[
]]>
<![CDATA[            nValue = u_SumFields(aStrParam(Nx-1),oParent)]]>
<![CDATA[
]]>
<![CDATA[            'Writelog(Space(3) & "u_SumFields returned:'" & nValue & "'.")]]>
<![CDATA[
]]>
<![CDATA[          Wend]]>
<![CDATA[
]]>
<![CDATA[          Set oParent = Nothing	]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[          writelog(Space(3) & "DCO path detected. Using fixed path navigation.")]]>
<![CDATA[
]]>
<![CDATA[          nValue = u_SumFields(aStrParam(Nx-1),CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      If nValue <> "" then]]>
<![CDATA[
]]>
<![CDATA[        'Remove the digits separator (?!)]]>
<![CDATA[
]]>
<![CDATA[        'aStrParam(Nx-1) = Trim(replace(nValue,GroupSeparator,""))]]>
<![CDATA[
]]>
<![CDATA[        aStrParam(Nx-1) = Trim(nValue)]]>
<![CDATA[
]]>
<![CDATA[        bNode = True]]>
<![CDATA[
]]>
<![CDATA[                       ]]>
<![CDATA[
]]>
<![CDATA[        'Writelog("Sibling Node(s) found. New Value is " & aStrParam(Nx-1))]]>
<![CDATA[
]]>
<![CDATA[        For Each fKey in dictTypeVars.keys]]>
<![CDATA[
]]>
<![CDATA[          If not(dictCalcObj.Exists(fKey)) then Set dictCalcObj(fKey) = dictTypeVars.Item(fKey)]]>
<![CDATA[
]]>
<![CDATA[        Next]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Writelog(Space(3) & "Node value is:'" & aStrParam(Nx-1) & "'")]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'Writelog(Space(3) & "Checking point 4 value:'" & aStrParam(Nx-1) & "'.")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If bNode = False Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Node not found as Sibling or Child. Node value is '" & aStrParam(Nx-1) & "'.")]]>
<![CDATA[
]]>
<![CDATA[      'Check for complex operators]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"<","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,">","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"+","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"=","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"/","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"*","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"-","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"abs","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"(","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,")","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=replace(aNode,"^","")]]>
<![CDATA[
]]>
<![CDATA[      aNode=Trim(aNode)]]>
<![CDATA[
]]>
<![CDATA[      If len(aNode)>0 Then ]]>
<![CDATA[
]]>
<![CDATA[        If Not DCGlobalCurrency.IsNumeric(aStrParam(Nx-1), locale) then aStrParam(Nx-1)=0]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[      'Writelog(Space(3) & "Checking point 5 value:'" & aStrParam(Nx-1) & "'.")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[      If Not DCGlobalCurrency.IsNumeric(aStrParam(Nx-1), locale, locale) And Trim(aNode)<>"" And Len(tNode)>0 Then ]]>
<![CDATA[
]]>
<![CDATA[        dclog = (DCGlobalCurrency.Getlog())]]>
<![CDATA[
]]>
<![CDATA[        Writelog(Space(3) & "Calculate Fails. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[        Writelog(dclog)]]>
<![CDATA[
]]>
<![CDATA[        CalculateFields = False ]]>
<![CDATA[
]]>
<![CDATA[        Exit Function			]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[      'Writelog(Space(3) & "Checking point 6 value:'" & aStrParam(Nx-1) & "'.")]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[      'Convert Numeric for use with Eval function       ]]>
<![CDATA[
]]>
<![CDATA[      If DCGlobalCurrency.IsNumeric(aStrParam(Nx-1), locale, locale) then]]>
<![CDATA[
]]>
<![CDATA[                   ]]>
<![CDATA[
]]>
<![CDATA[          'Disabled 09/29/2015 due to update of u_sumfields to adjust according to locale & target (calling obj) locale.         ]]>
<![CDATA[
]]>
<![CDATA[          If DecimalSeparator<>"." and bconvertdecimal=true then ]]>
<![CDATA[
]]>
<![CDATA[            aStrParam(Nx-1)=replace(aStrParam(Nx-1),DecimalSeparator,".")]]>
<![CDATA[
]]>
<![CDATA[            Writelog("converting decimal from '" & DecimalSeparator & "' to '.'")]]>
<![CDATA[
]]>
<![CDATA[          End if]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[          If nDecimal<>"" Then          ]]>
<![CDATA[
]]>
<![CDATA[            aStrParam(Nx-1) = FormatNumber(cdbl(aStrParam(Nx-1)),nDecimal,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[          Else ]]>
<![CDATA[
]]>
<![CDATA[            aStrParam(Nx-1) = FormatNumber(cdbl(aStrParam(Nx-1)),-1,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[          End if]]>
<![CDATA[
]]>
<![CDATA[                    ]]>
<![CDATA[
]]>
<![CDATA[          Writelog(Space(3) & "Node pre basic expression build value is now '" & aStrParam(Nx-1) & "'.")          ]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[          Writelog(Space(3) & "Node did not pass pre basic expression numeric check. '" & aStrParam(Nx-1) & "'.")   ]]>
<![CDATA[
]]>
<![CDATA[      End if]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[     ' Writelog(Space(3) & "Checking point 7 value:'" & aStrParam(Nx-1) & "'.") ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    End If]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Next	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sExpression = Join(aStrParam,"")]]>
<![CDATA[
]]>
<![CDATA[  sBasicExpression = sExpression]]>
<![CDATA[
]]>
<![CDATA[  Writelog("BASIC Expression is: " & sBasicExpression)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Equalize Expression Decimal Places ]]>
<![CDATA[
]]>
<![CDATA[  If instr(sExpression,"=") Then]]>
<![CDATA[
]]>
<![CDATA[    aDecimal = Split(sExpression,"=")]]>
<![CDATA[
]]>
<![CDATA[    For Nx = 0 to Ubound(aDecimal)]]>
<![CDATA[
]]>
<![CDATA[        sLeft = ""]]>
<![CDATA[
]]>
<![CDATA[        sRight = ""]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        'Check for < or > symbols]]>
<![CDATA[
]]>
<![CDATA[        If Len(aDecimal(Nx))>2 then]]>
<![CDATA[
]]>
<![CDATA[  			]]>
<![CDATA[
]]>
<![CDATA[            If left(aDecimal(Nx),1) = "<" or left(aDecimal(Nx),1) = ">" then]]>
<![CDATA[
]]>
<![CDATA[              sLeft = left(aDecimal(Nx),1)]]>
<![CDATA[
]]>
<![CDATA[              aDecimal(Nx) = right(aDecimal(Nx),len(aDecimal(Nx))-1)]]>
<![CDATA[
]]>
<![CDATA[            End if		]]>
<![CDATA[
]]>
<![CDATA[    				]]>
<![CDATA[
]]>
<![CDATA[            If right(aDecimal(Nx),1) = "<" or right(aDecimal(Nx),1) = ">" then]]>
<![CDATA[
]]>
<![CDATA[              sRight = right(aDecimal(Nx),1)]]>
<![CDATA[
]]>
<![CDATA[              aDecimal(Nx) = left(aDecimal(Nx),len(aDecimal(Nx))-1)]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            If DCGlobalCurrency.IsNumeric(aDecimal(Nx), locale, locale) and nDecimal<>"" then]]>
<![CDATA[
]]>
<![CDATA[              If DecimalSeparator<>"." and instr(aDecimal(Nx),".")>0 and bconvertdecimal=true then aDecimal(Nx)=replace(aDecimal(Nx),".",DecimalSeparator)]]>
<![CDATA[
]]>
<![CDATA[              writelog("Formatting number[1]: " & aDecimal(Nx)) ]]>
<![CDATA[
]]>
<![CDATA[              aDecimal(Nx) =  FormatNumber(cdbl(aDecimal(Nx)),nDecimal,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[              If DecimalSeparator<>"." and bconvertdecimal=true then aDecimal(Nx)=replace(aDecimal(Nx),DecimalSeparator,".")]]>
<![CDATA[
]]>
<![CDATA[           End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Elseif DCGlobalCurrency.IsNumeric(aDecimal(Nx), locale, locale) then			 ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[           If DCGlobalCurrency.IsNumeric(aDecimal(Nx), locale, locale) and nDecimal<>"" then]]>
<![CDATA[
]]>
<![CDATA[              If DecimalSeparator<>"." and instr(aDecimal(Nx),".")>0 and bconvertdecimal=true then aDecimal(Nx)=replace(aDecimal(Nx),".",DecimalSeparator)]]>
<![CDATA[
]]>
<![CDATA[              writelog("Formatting number[2]: " & aDecimal(Nx))]]>
<![CDATA[
]]>
<![CDATA[              aDecimal(Nx) = FormatNumber(cdbl(aDecimal(Nx)),nDecimal,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[              If DecimalSeparator<>"." and bconvertdecimal=true then aDecimal(Nx)=replace(aDecimal(Nx),DecimalSeparator,".")]]>
<![CDATA[
]]>
<![CDATA[           End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[			  ]]>
<![CDATA[
]]>
<![CDATA[        'EVAL statement does not interpret numbers not using the decimal characters as the decimal separator]]>
<![CDATA[
]]>
<![CDATA[        ' for the eval ONLY we change the system to use the decimal character.]]>
<![CDATA[
]]>
<![CDATA[        If DecimalSeparator<>"." and bconvertdecimal=true then aDecimal(Nx)=replace(aDecimal(Nx),DecimalSeparator,".")]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[        'aDecimal(Nx)= "FormatNumber(" & aDecimal(Nx) & "," & nDigits & ",0,0)+0" 'plus zero to compensate for 'negative zero' string evaluation]]>
<![CDATA[
]]>
<![CDATA[        aDecimal(Nx)= FormatNumber(cdbl(aDecimal(Nx)), nDigits,0,0)+0 'plus zero to compensate for 'negative zero' string evaluation]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        aDecimal(Nx) = sLeft & aDecimal(Nx) & sRight]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[		Next 'Nx]]>
<![CDATA[
]]>
<![CDATA[		sExpression = Join(aDecimal,"=")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	If instr(sExpression,"<>") Then]]>
<![CDATA[
]]>
<![CDATA[		aDecimal = Split(sExpression,"<>")]]>
<![CDATA[
]]>
<![CDATA[		For Nx = 0 to Ubound(aDecimal)]]>
<![CDATA[
]]>
<![CDATA[			'aDecimal(Nx) = "FormatNumber(" & aDecimal(Nx) & "," & nDigits & ",0,0)+0" 'plus zero to compensate for 'negative zero' string evaluation]]>
<![CDATA[
]]>
<![CDATA[      aDecimal(Nx) = FormatNumber(cdbl(aDecimal(Nx)), nDigits,0,0)+0 'plus zero to compensate for 'negative zero' string evaluation]]>
<![CDATA[
]]>
<![CDATA[		Next 'Nx]]>
<![CDATA[
]]>
<![CDATA[		sExpression = Join(aDecimal,"<>")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Formatted Expression: '" & sExpression & "'")	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	sCResult = Eval(Trim(sExpression))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	writelog("EVAL returns: '" & sCResult & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If Instr(sExpression,">")>0 or Instr(sExpression,"<")>0 or Instr(sExpression,"=")>0 then]]>
<![CDATA[
]]>
<![CDATA[    Select Case sCResult]]>
<![CDATA[
]]>
<![CDATA[        Case False]]>
<![CDATA[
]]>
<![CDATA[            CalculateFields = False]]>
<![CDATA[
]]>
<![CDATA[            sMessage = RRState.LoadString("validations","CalculateFields_01","Field '{0}' failed Calculation '{1}'.") ]]>
<![CDATA[
]]>
<![CDATA[            sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[            sMessage = replace(sMessage,"{1}",sExpression)]]>
<![CDATA[
]]>
<![CDATA[            sMessage = replace(sMessage,"FormatNumber(","")]]>
<![CDATA[
]]>
<![CDATA[            sMessage = replace(sMessage,"," & nDigits & ",0,0)","")]]>
<![CDATA[
]]>
<![CDATA[            DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            If bPreserveStatus = FALSE then]]>
<![CDATA[
]]>
<![CDATA[                For Each fKey in dictCalcObj.keys]]>
<![CDATA[
]]>
<![CDATA[                    Set kObj = dictCalcObj.Item(fKey)]]>
<![CDATA[
]]>
<![CDATA[                    ]]>
<![CDATA[
]]>
<![CDATA[                    If kObj.Variable("STATUS")<>cstr(nFail) then ]]>
<![CDATA[
]]>
<![CDATA[                        writelog("Setting " & kObj.ID & " to STATUS '1'")]]>
<![CDATA[
]]>
<![CDATA[                        kObj.Variable("STATUS")=1]]>
<![CDATA[
]]>
<![CDATA[                        ]]>
<![CDATA[
]]>
<![CDATA[                        'build message]]>
<![CDATA[
]]>
<![CDATA[                        txtmsg = RRState.LoadString("validations","CalculateFields_03","Field '{0}' failed by Calculate Action on by Field '{1}'.")]]>
<![CDATA[
]]>
<![CDATA[                        txtmsg = replace(txtmsg,"{0}",kObj.ID)]]>
<![CDATA[
]]>
<![CDATA[                        txtmsg = replace(txtmsg,"{1}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[                        ]]>
<![CDATA[
]]>
<![CDATA[                        If Not kObj.AddVariable("MESSAGE",txtmsg) Then ]]>
<![CDATA[
]]>
<![CDATA[                            kObj.Variable("MESSAGE") = txtmsg]]>
<![CDATA[
]]>
<![CDATA[                        End If]]>
<![CDATA[
]]>
<![CDATA[                    End if]]>
<![CDATA[
]]>
<![CDATA[                    ]]>
<![CDATA[
]]>
<![CDATA[                Next 'fKey]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[        Case True ]]>
<![CDATA[
]]>
<![CDATA[            writelog("Expression returns TRUE")]]>
<![CDATA[
]]>
<![CDATA[            CalculateFields = True]]>
<![CDATA[
]]>
<![CDATA[            ]]>
<![CDATA[
]]>
<![CDATA[            'Check related field status]]>
<![CDATA[
]]>
<![CDATA[            If bPreserveStatus = FALSE then]]>
<![CDATA[
]]>
<![CDATA[                For Each fKey in dictCalcObj.keys]]>
<![CDATA[
]]>
<![CDATA[                    Set kObj = dictCalcObj.Item(fKey)]]>
<![CDATA[
]]>
<![CDATA[                    If trim(kObj.Variable("STATUS"))=cstr(nFail) then ]]>
<![CDATA[
]]>
<![CDATA[                    ]]>
<![CDATA[
]]>
<![CDATA[                        'build message]]>
<![CDATA[
]]>
<![CDATA[                        txtmsg = RRState.LoadString("validations","CalculateFields_03","Field '{0}' failed by Calculate Action on by Field '{1}'.")]]>
<![CDATA[
]]>
<![CDATA[                        txtmsg = replace(txtmsg,"{0}",kObj.ID)]]>
<![CDATA[
]]>
<![CDATA[                        txtmsg = replace(txtmsg,"{1}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[                        ]]>
<![CDATA[
]]>
<![CDATA[                        If instr(kObj.Variable("MESSAGE"),txtmsg)>0 then]]>
<![CDATA[
]]>
<![CDATA[                            'Change Status to pass]]>
<![CDATA[
]]>
<![CDATA[                            kObj.Variable("STATUS")=cstr(nPass)]]>
<![CDATA[
]]>
<![CDATA[                            Call kObj.DeleteVariable("MESSAGE")]]>
<![CDATA[
]]>
<![CDATA[                        End if]]>
<![CDATA[
]]>
<![CDATA[                        ]]>
<![CDATA[
]]>
<![CDATA[                    End if]]>
<![CDATA[
]]>
<![CDATA[                Next 'fKey]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[        Case Else]]>
<![CDATA[
]]>
<![CDATA[            Writelog("Expression returns unexpected result:'" & sCResult & "'.")]]>
<![CDATA[
]]>
<![CDATA[            CalculateFields = False]]>
<![CDATA[
]]>
<![CDATA[    End Select]]>
<![CDATA[
]]>
<![CDATA[  Else		]]>
<![CDATA[
]]>
<![CDATA[      If DCGlobalCurrency.Isnumeric(sCResult, locale) then ]]>
<![CDATA[
]]>
<![CDATA[          If DCGlobalCurrency.Isnumeric(nDecimal, locale) then sCResult = FormatNumber(sCResult, nDecimal,,,0)]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Expression = " & sCResult)]]>
<![CDATA[
]]>
<![CDATA[          CurrentObj.Text = sCResult]]>
<![CDATA[
]]>
<![CDATA[          CalculateFields = True]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[          sMessage = RRState.LoadString("validations","CalculateFields_02","Field '{0}' calling the calculate action has an unexpected result from the expression '{1}'.")]]>
<![CDATA[
]]>
<![CDATA[          sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[          sMessage = replace(sMessage,"{1}",sExpression)]]>
<![CDATA[
]]>
<![CDATA[          sMessage = replace(sMessage,"FormatNumber(","")]]>
<![CDATA[
]]>
<![CDATA[          sMessage = replace(sMessage,"," & nDigits & ",0,0)","")]]>
<![CDATA[
]]>
<![CDATA[          DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[          Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[          CalculateFields = False]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	dictCalcObj.RemoveAll()]]>
<![CDATA[
]]>
<![CDATA[	Set dictCalcObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[    If cstr(Err.Number)<>cstr(13) then CalculateFields = False]]>
<![CDATA[
]]>
<![CDATA[		Err.Clear]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</f>
<af name="IsFieldEmpty" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'The Field object's name.]]>
<![CDATA[
]]>
<![CDATA[  'Checks if the Field object designated as a parameter does not have a captured value.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsFieldEmpty = False]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Checking field " & strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(strParam)]]>
<![CDATA[
]]>
<![CDATA[	if oFld is nothing Then]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldEmpty_01","Unable to locate Field '{0}' to check if the field value is empty.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Len(oFld.Text) = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[		IsFieldEmpty = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldEmpty_02","Field '{0}' is not Empty.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[    Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldEmpty returns: " & IsFieldEmpty)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldFilled" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'The name of the Field object.]]>
<![CDATA[
]]>
<![CDATA[  'Determines whether the Field object designated as a parameter contains a captured value or is empty. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsFieldFilled = False]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Checking field " & strParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oFld = ReturnNamedComponent(strParam)]]>
<![CDATA[
]]>
<![CDATA[	if oFld is nothing Then]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldFilled_01","Unable to locate Field '{0}' to check if the field has a value.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(sMessage) ]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Len(oFld.Text) > 0 Then  ]]>
<![CDATA[
]]>
<![CDATA[		IsFieldFilled = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldFilled_02","Field '{0}' is Empty.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = replace(sMessage,"{0}",CurrentObj.ID)  ]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[    Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldFilled returns " & IsFieldFilled)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CheckSubFields" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[  '  An "expression" that specifies which child fields are to be checked for the presence or absence ]]>
<![CDATA[
]]>
<![CDATA[  '  of captured values. Within the expression, each child Field object's name needs to be surrounded ]]>
<![CDATA[
]]>
<![CDATA[  '  with single quotation marks ('). You can also use parentheses () in your expression.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	CheckSubFields=True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Dim aDel()]]>
<![CDATA[
]]>
<![CDATA[	Dim NumChildren]]>
<![CDATA[
]]>
<![CDATA[	Dim oSuperField]]>
<![CDATA[
]]>
<![CDATA[	Dim tNode]]>
<![CDATA[
]]>
<![CDATA[	Dim aNode]]>
<![CDATA[
]]>
<![CDATA[	Dim eString]]>
<![CDATA[
]]>
<![CDATA[	Dim nValue]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ReDim Preserve aDel(CurrentObj.NumofChildren + 1)]]>
<![CDATA[
]]>
<![CDATA[	Set Sobj = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For i = 0 To CurrentObj.NumOfChildren -1]]>
<![CDATA[
]]>
<![CDATA[		bNoGood = False]]>
<![CDATA[
]]>
<![CDATA[		Set oSuperField = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		If Not (oSuperField Is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			'Check Sub-fields for Data	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			eString = ""]]>
<![CDATA[
]]>
<![CDATA[			aStrParam = Split(strparam, "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			For aNode = 0 to ubound(aStrParam) ]]>
<![CDATA[
]]>
<![CDATA[				nValue = Trim(ucase(aStrParam(aNode)))]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				nValue = replace(nValue,"(","")]]>
<![CDATA[
]]>
<![CDATA[				nValue = replace(nValue,")","")]]>
<![CDATA[
]]>
<![CDATA[				nValue = replace(nValue,"OR","")]]>
<![CDATA[
]]>
<![CDATA[				nValue = replace(nValue,"AND","")]]>
<![CDATA[
]]>
<![CDATA[				nValue = replace(nValue," ","")]]>
<![CDATA[
]]>
<![CDATA[				nValue = replace(nValue,"'","")	]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				If Len(nValue)>0 Then				]]>
<![CDATA[
]]>
<![CDATA[					Set Sobj = oSuperField.FindChild(TRIM(aStrParam(aNode)))]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					If Not(Sobj Is Nothing) Then ]]>
<![CDATA[
]]>
<![CDATA[						If Len(Trim(Sobj.Text))>0 Then ]]>
<![CDATA[
]]>
<![CDATA[							eString = eString & " Cbool(True) " ]]>
<![CDATA[
]]>
<![CDATA[						Else ]]>
<![CDATA[
]]>
<![CDATA[							eString = eString & " Cbool(False) " ]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						Set Sobj = Nothing]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[				Else]]>
<![CDATA[
]]>
<![CDATA[					eString = eString & aStrParam(aNode) & " "]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			Next	]]>
<![CDATA[
]]>
<![CDATA[ 	]]>
<![CDATA[
]]>
<![CDATA[			writelog("Expression: " & eString)]]>
<![CDATA[
]]>
<![CDATA[		    ]]>
<![CDATA[
]]>
<![CDATA[			bGood = Eval(eString)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Expression not valid.")]]>
<![CDATA[
]]>
<![CDATA[				Err.Clear]]>
<![CDATA[
]]>
<![CDATA[				bGood=False]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			If not bGood Then ]]>
<![CDATA[
]]>
<![CDATA[			    aDel(i) = CStr(i)	]]>
<![CDATA[
]]>
<![CDATA[			Else]]>
<![CDATA[
]]>
<![CDATA[			    aDel(i) = ""	]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Next 'i	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set Sobj = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For Fx = (CurrentObj.NumOfChildren - 1) To 0 Step -1]]>
<![CDATA[
]]>
<![CDATA[		If Not aDel(Fx)="" Then ]]>
<![CDATA[
]]>
<![CDATA[			Call CurrentObj.Deletechild(aDel(fx))]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next 'x]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("CheckSubFields returns " & CheckSubFields)]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SumFields" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'String value of a Field object's Type property or the name of a variable.]]>
<![CDATA[
]]>
<![CDATA[  'Sums captured values of any "child" Field if a child object's Type property is identical to the Type you specify as a parameter.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  dictTypeVars.RemoveAll()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call fFindTypeValues(CurrentObj, StrParam,"")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim kObj]]>
<![CDATA[
]]>
<![CDATA[	Dim fKey]]>
<![CDATA[
]]>
<![CDATA[	Dim nTally]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[	nTally = cdbl(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For Each fKey in dictTypeVars.keys]]>
<![CDATA[
]]>
<![CDATA[		Set kObj = dictTypeVars.Item(fKey)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(3) & "Checking '" & fKey & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		if kObj.Type = StrParam then ]]>
<![CDATA[
]]>
<![CDATA[			sVal = kObj.Text]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			sVal = kObj.Variable(StrParam)]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If DCGlobalCurrency.isNumeric(sVal, locale) then ]]>
<![CDATA[
]]>
<![CDATA[			nTally = nTally + cdbl(sVal)]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(3) & "Value '" & cdbl(sVal) & "' is numeric. Total value is '" & nTally & "' ")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(3) & "Value '" & sVal & "' is not numeric.")]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Next 'kObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If dictTypeVars.Count = 0 then ]]>
<![CDATA[
]]>
<![CDATA[		writelog(Space(3) & "No Fields or Variables of Type '" & StrParam & "' were found.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("SumFields_" & StrParam) = nTally]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	dictTypeVars.RemoveAll()]]>
<![CDATA[
]]>
<![CDATA[	SumFields = True ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ResetField" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  '  This action deletes the selected Field object's captured value, and sets the field's ]]>
<![CDATA[
]]>
<![CDATA[  '  attribute to 0,0,0,0.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ResetField = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType<> 3 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Not a field object. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("Position") = "0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text=""]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If isObject(Logwindow) then]]>
<![CDATA[
]]>
<![CDATA[ 		ValueUP.Text = ""]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ResetField = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Current captured value and field position attributes reset.") ]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ConvertToUpperCase" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Converts the lower case characters in a Field object's captured value to Upper Case characters. ]]>
<![CDATA[
]]>
<![CDATA[  ' A Validate rule with this action, if applied to a State Field object which accepts only abbreviations, ]]>
<![CDATA[
]]>
<![CDATA[  '  would be sure the captured values contain Upper Case letters (AZ, AL, etc.) ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sConf]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If value <> "" Then]]>
<![CDATA[
]]>
<![CDATA[		Value = Ucase(Value)]]>
<![CDATA[
]]>
<![CDATA[		sConf = CurrentObj.ConfidenceString ]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Text = Value]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.ConfidenceString = sConf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If IsObject(LogWindow) then ValueUp.text = Value]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Value converted to all caps. New value is: '" & value & "'")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	ConvertToUpperCase = True ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ConvertToLowerCase" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Converts any Upper Case characters in a Field object's captured value to lower case characters. ]]>
<![CDATA[
]]>
<![CDATA[  'To ensure that the characters in all Product ID's are lower case, a Validate rule that applies to a Document Hierarchy's Item Field object would include this action. ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim sConf]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	If value <> "" Then]]>
<![CDATA[
]]>
<![CDATA[		Value = Lcase(Value)]]>
<![CDATA[
]]>
<![CDATA[		sConf = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Text = Value]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.ConfidenceString = sConf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If IsObject(LogWindow) then ValueUp.text = Value		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Value converted to all lowercase. New value is: " & Value)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	ConvertToLowerCase = True ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SplitFieldValueRight" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	'This action has been deprecated. It has been replaced by "SplitFieldValuePreserveEnd".]]>
<![CDATA[
]]>
<![CDATA[	SplitFieldValueRight = False]]>
<![CDATA[
]]>
<![CDATA[	SplitFieldValueRight = SplitFieldValuePreserveEnd(bInter, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="SplitFieldValuePreserveEnd" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'String value of the separating character. SmartParameter Enabled.]]>
<![CDATA[
]]>
<![CDATA[  'Splits a Field object's captured value at the first instance of the character specified as a parameter.]]>
<![CDATA[
]]>
<![CDATA[  'The action deletes all characters to the left of the separating character, as well as the separation character.  All text to the right of the separating character remains. ]]>
<![CDATA[
]]>
<![CDATA[  'If the object's value is "InvNumber=A1234," this action truncates it to "A1234".  ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim pos]]>
<![CDATA[
]]>
<![CDATA[	Dim sConf]]>
<![CDATA[
]]>
<![CDATA[	Dim Fleft,FTop,FBottom,FRight]]>
<![CDATA[
]]>
<![CDATA[	Dim Cleft,CTop,Cbottom,CRight]]>
<![CDATA[
]]>
<![CDATA[	Dim sNewParam]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Fleft=""]]>
<![CDATA[
]]>
<![CDATA[	FTop=""]]>
<![CDATA[
]]>
<![CDATA[	FBottom=""]]>
<![CDATA[
]]>
<![CDATA[	FTop=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SplitFieldValuePreserveEnd = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start value is: '" & Value & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sNewParam = MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  'Only use MetaWord result if it returns a value]]>
<![CDATA[
]]>
<![CDATA[  If sNewParam<>"" Then strParam=sNewParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'InstrT is a rrunner.rrx helper function using dcglobal.]]>
<![CDATA[
]]>
<![CDATA[	pos = InStrT(Value, strParam,1,0)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If pos = 0 then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Split value '" & strParam & "' not found in field.")]]>
<![CDATA[
]]>
<![CDATA[    Exit function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'Character Index begins after any child fields]]>
<![CDATA[
]]>
<![CDATA[	nFields = (CurrentObj.NumOfChildren - len(CurrentObj.Text))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For Cx = (CurrentObj.NumOfChildren-1) to nFields Step-1 ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If Cx>=(pos+nFields) then]]>
<![CDATA[
]]>
<![CDATA[			Set cObj = CurrentObj.GetChild(Cx)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			If Not cObj is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[				bRes = cObj.GetPosition(Cleft,Ctop,Cright,Cbottom)]]>
<![CDATA[
]]>
<![CDATA[									]]>
<![CDATA[
]]>
<![CDATA[				If Not(Cleft=0 and Ctop=0 and Cright=0 and Cbottom=0) Then 			]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[					If Fleft="" then FLeft=Clng(Cleft)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Cleft)<Fleft then FLeft=Clng(Cleft)]]>
<![CDATA[
]]>
<![CDATA[					If Ftop="" then Ftop=Clng(Ctop)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Ctop)<Ftop then Ftop=Clng(Ctop)]]>
<![CDATA[
]]>
<![CDATA[					If Fright="" then Fright=Clng(Cright)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Cright)>Fright then Fright=Clng(Cright)]]>
<![CDATA[
]]>
<![CDATA[					If Fbottom="" then Fbottom=Clng(Cbottom)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Cbottom)>Fbottom then Fbottom=Clng(Cbottom)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			'Delete Character Node]]>
<![CDATA[
]]>
<![CDATA[			If CurrentObj.Deletechild(Cx)=False then]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Child Index '" & Cx & "' not deleted successfully.")]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'x]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Fleft="" then FLeft=Clng(0)		]]>
<![CDATA[
]]>
<![CDATA[	If Ftop="" then Ftop=Clng(0)]]>
<![CDATA[
]]>
<![CDATA[	If Fright="" then Fright=Clng(0)]]>
<![CDATA[
]]>
<![CDATA[	If Fbottom="" then Fbottom=Clng(0)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("Position") = cstr(Fleft) & "," & cstr(Ftop) & "," & cstr(Fright) & "," & cstr(Fbottom)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) then ValueUp.text = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Value split at position " & pos & " . New value is: '" & GetFieldValue() & "' , confidence: '" & GetFieldConf() & "'.")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SplitFieldValuePreserveEnd = True ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SplitFieldValueLeft" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	'This action has been deprecated. It has been replaced by "SplitFieldValuePreserveStart".]]>
<![CDATA[
]]>
<![CDATA[	SplitFieldValueLeft = False]]>
<![CDATA[
]]>
<![CDATA[	SplitFieldValueLeft = SplitFieldValuePreserveStart(bInter, bDebug, StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="SplitFieldValuePreserveStart" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  'String value of the separating character. SmartParameter Enabled.]]>
<![CDATA[
]]>
<![CDATA[  'Splits a Field object's captured value at the first instance of the character specified as a parameter.]]>
<![CDATA[
]]>
<![CDATA[  'The action deletes all characters to the right of the separating character, including the separating character. ]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
<![CDATA[	Dim pos]]>
<![CDATA[
]]>
<![CDATA[	Dim sConf]]>
<![CDATA[
]]>
<![CDATA[	Dim Fleft,FTop,FBottom,FRight]]>
<![CDATA[
]]>
<![CDATA[	Dim Cleft,CTop,Cbottom,CRight]]>
<![CDATA[
]]>
<![CDATA[	Dim sNewParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Fleft=""]]>
<![CDATA[
]]>
<![CDATA[	FTop=""]]>
<![CDATA[
]]>
<![CDATA[	FBottom=""]]>
<![CDATA[
]]>
<![CDATA[	FTop=""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	SplitFieldValuePreserveStart = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start value is: '" & Value & "' ")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sNewParam = MetaWord(strParam)]]>
<![CDATA[
]]>
<![CDATA[  'Only use MetaWord result if it returns a value]]>
<![CDATA[
]]>
<![CDATA[  If sNewParam<>"" Then strParam=sNewParam]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Get the number of character places in the parameter]]>
<![CDATA[
]]>
<![CDATA[  iStr=len(strParam)-1]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'InstrT is a rrunner.rrx helper function using dcglobal.]]>
<![CDATA[
]]>
<![CDATA[  pos = InStrT(Value, strParam,1,0)+iStr  ]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[  If pos = 0 then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Split value '" & strParam & "' not found in field.")]]>
<![CDATA[
]]>
<![CDATA[    Exit function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	'Character Index begins after any child fields]]>
<![CDATA[
]]>
<![CDATA[	nFields = (CurrentObj.NumOfChildren - len(CurrentObj.Text))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For Cx = (CurrentObj.NumOfChildren-1) to nFields Step-1 ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If Cx<(pos+nFields-1) then]]>
<![CDATA[
]]>
<![CDATA[			Set cObj = CurrentObj.GetChild(Cx)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			If Not cObj is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[				bRes = cObj.GetPosition(Cleft,Ctop,Cright,Cbottom)]]>
<![CDATA[
]]>
<![CDATA[									]]>
<![CDATA[
]]>
<![CDATA[				If Not(Cleft=0 and Ctop=0 and Cright=0 and Cbottom=0) Then 			]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[					If Fleft="" then FLeft=Clng(Cleft)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Cleft)<Fleft then FLeft=Clng(Cleft)]]>
<![CDATA[
]]>
<![CDATA[					If Ftop="" then Ftop=Clng(Ctop)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Ctop)<Ftop then Ftop=Clng(Ctop)]]>
<![CDATA[
]]>
<![CDATA[					If Fright="" then Fright=Clng(Cright)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Cright)>Fright then Fright=Clng(Cright)]]>
<![CDATA[
]]>
<![CDATA[					If Fbottom="" then Fbottom=Clng(Cbottom)]]>
<![CDATA[
]]>
<![CDATA[					If Clng(Cbottom)>Fbottom then Fbottom=Clng(Cbottom)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			'Delete Character Node]]>
<![CDATA[
]]>
<![CDATA[			If CurrentObj.Deletechild(Cx)=False then]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Child Index '" & Cx & "' not deleted successfully.")]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'x]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Fleft="" then FLeft=Clng(0)		]]>
<![CDATA[
]]>
<![CDATA[	If Ftop="" then Ftop=Clng(0)]]>
<![CDATA[
]]>
<![CDATA[	If Fright="" then Fright=Clng(0)]]>
<![CDATA[
]]>
<![CDATA[	If Fbottom="" then Fbottom=Clng(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("Position") = cstr(Fleft) & "," & cstr(Ftop) & "," & cstr(Fright) & "," & cstr(Fbottom)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsObject(LogWindow) then ValueUp.text = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Value split at position " & pos & " .  New value is: '" & GetFieldValue() & "' , confidence: '" & GetFieldConf() & "'.")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SplitFieldValuePreserveStart = True ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldPercentNonNumeric" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    A number (0-100) indicating the percentage that results in a  condition. The default percentage is 100.]]>
<![CDATA[
]]>
<![CDATA['    The value must be numeric, without the percent sign.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim Value, TrueCount, FalseCount, TFRatio, Cx, Lval]]>
<![CDATA[
]]>
<![CDATA[  Dim ValueLen]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsFieldPercentNonNumeric = False	]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If IsNull(StrParam) Then StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.IsNumeric(StrParam, locale) Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Percentage parameter not numeric. Value defaults to 100 percent.")]]>
<![CDATA[
]]>
<![CDATA[		StrParam = 100]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("IsFieldPercentNonNumeric percentage parameter set to " & StrParam & " percent.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TrueCount = 0]]>
<![CDATA[
]]>
<![CDATA[	FalseCount = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Value = Trim(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[  ValueLen = len(Value)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' \p{N} or \p{Number}: any kind of numeric character in any script. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Nd} or \p{Decimal_Digit_Number}: a digit zero through nine in any script except ideographic scripts. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{Nl} or \p{Letter_Number}: a number that looks like a letter, such as a Roman numeral. ]]>
<![CDATA[
]]>
<![CDATA[  ' \p{No} or \p{Other_Number}: a superscript or subscript digit, or a number that is not a digit 0..9 (excluding numbers from ideographic scripts). ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	For Cx = 1 To Len(value)]]>
<![CDATA[
]]>
<![CDATA[    sCharacter=Mid(value,Cx,1)]]>
<![CDATA[
]]>
<![CDATA[		If DCGlobalStrings.RegExIsMatch(sCharacter,"\p{N}") Then]]>
<![CDATA[
]]>
<![CDATA[      FalseCount = FalseCount + 1]]>
<![CDATA[
]]>
<![CDATA[    Elseif DCGlobalStrings.RegExIsMatch(sCharacter,"\p{Mn}") Then]]>
<![CDATA[
]]>
<![CDATA[      ValueLen = ValueLen - 1]]>
<![CDATA[
]]>
<![CDATA[		Else	]]>
<![CDATA[
]]>
<![CDATA[			TrueCount = TrueCount + 1]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next 'Cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	TFRatio = (StrParam/100)*ValueLen]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If TrueCount >= TFRatio and ValueLen>0 Then IsFieldPercentNonNumeric = True]]>
<![CDATA[
]]>
<![CDATA[	If ValueLen <= 0 Then ValueLen = 1 ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(Space(3) & "Value is " & (TrueCount/ValueLen)*100 & "% non-numeric") ]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsFieldPercentNonNumeric returns " & IsFieldPercentNonNumeric) ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If IsFieldPercentNonNumeric = False Then ]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsFieldPercentNonNumeric_01","Field '{0}' value '{1}' contains less than the required percentage of '{2}' non-numeric characters.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{0}",CurrentObj.id)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{1}",Value)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsMaxOMRChecked" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'An Integer value specifying this maximum.]]>
<![CDATA[
]]>
<![CDATA[  'Indicates the maximum number of checkboxes that can contain a value (a check, for example). ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue ]]>
<![CDATA[
]]>
<![CDATA[	Dim sMsg]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsMaxOMRChecked = False]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If Not(DCGlobalCurrency.Isnumeric(StrParam, locale)) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter '" & StrParam & "' is required to be numeric.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.variable("RecogType")<>"4" Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Field is not OMR type.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sValue = Trim(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'remove unchecked values]]>
<![CDATA[
]]>
<![CDATA[	sValue = Replace(sValue,"0","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If len(sValue)<=cint(StrParam) Then]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("'" & Len(sValue) & "' checked boxes found. Maximum permitted is '" & StrParam & "'.") ]]>
<![CDATA[
]]>
<![CDATA[		IsMaxOMRChecked = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsMaxOMRChecked_01","OMR Field '{0}' has '{1}' selected boxes. The maximum permitted number of selected boxes for this field is {2}.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{1}",len(sValue))]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[		WriteLog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsMaxOMRChecked returns " & IsMaxOMRChecked) ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsMinOMRChecked" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue ]]>
<![CDATA[
]]>
<![CDATA[	Dim sMsg]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'An Integer value specifying this minimum.]]>
<![CDATA[
]]>
<![CDATA[  'Indicates the minimum number of checkboxes that can contain a value (a check, for example).]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsMinOMRChecked = False]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	If Not(DCGlobalCurrency.Isnumeric(StrParam, locale)) then ]]>
<![CDATA[
]]>
<![CDATA[		sMsg = "Parameter '" & StrParam & "' is required to be numeric. Ask Admin for assistance."]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sMsg)]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.variable("RecogType")<>"4" Then]]>
<![CDATA[
]]>
<![CDATA[		sMsg = "Field is not OMR type. Ask Admin for assistance."]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sMsg)]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sValue = Trim(GetFieldValue())]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'remove unchecked values]]>
<![CDATA[
]]>
<![CDATA[	sValue = Replace(sValue,"0","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If len(sValue)>=cint(StrParam) then ]]>
<![CDATA[
]]>
<![CDATA[		IsMinOMRChecked = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsMinOMRChecked_01","OMR Field '{0}' has '{1}' selected boxes. The minimum permitted number of selected boxes for this field is {2}.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{1}",len(sValue))]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsMinOMRChecked returns " & IsMinOMRChecked)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CompareFields" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Five comma-separated values: ]]>
<![CDATA[
]]>
<![CDATA[  'String value of the source field's name.  This is the field with a value to be compared.]]>
<![CDATA[
]]>
<![CDATA[  'String value of the target field's name.  This is the field with a value to be compared to.]]>
<![CDATA[
]]>
<![CDATA[  'String value: Y or Yes; N or No. Alternatively, a Numeric value: 0 = No or 1=Yes.  ]]>
<![CDATA[
]]>
<![CDATA[  '"Yes" (or Y or 1) allows the action to carry out a fuzzy rather precise comparison of the fields' values.]]>
<![CDATA[
]]>
<![CDATA[  ' Numeric value of the percentage of required precision. Numbers less than ]]>
<![CDATA[
]]>
<![CDATA[  ' "100" permit increasing fuzziness.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	Dim SourceField]]>
<![CDATA[
]]>
<![CDATA[	Dim CompareToField]]>
<![CDATA[
]]>
<![CDATA[	Dim byWord]]>
<![CDATA[
]]>
<![CDATA[	Dim bPFuzzy]]>
<![CDATA[
]]>
<![CDATA[	Dim nFuzzy]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim SourceValue]]>
<![CDATA[
]]>
<![CDATA[	Dim CompareToValue]]>
<![CDATA[
]]>
<![CDATA[	Dim SourceObj]]>
<![CDATA[
]]>
<![CDATA[	Dim CompareToObj]]>
<![CDATA[
]]>
<![CDATA[	Dim regEx]]>
<![CDATA[
]]>
<![CDATA[	Dim Match]]>
<![CDATA[
]]>
<![CDATA[	Dim Matches]]>
<![CDATA[
]]>
<![CDATA[	Dim Pattern]]>
<![CDATA[
]]>
<![CDATA[	Dim StrStart]]>
<![CDATA[
]]>
<![CDATA[	Dim FirstChar		]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[	Dim nWCount]]>
<![CDATA[
]]>
<![CDATA[	Dim sWords]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CompareFields = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[	Set SourceObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set CompareToObj = Nothing	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & ",,,",",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SourceField = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	CompareToField = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	bPFuzzy = Trim(aStrParam(2))]]>
<![CDATA[
]]>
<![CDATA[	nFuzzy = Trim(aStrParam(3))]]>
<![CDATA[
]]>
<![CDATA[	byWord = ucase(Trim(aStrParam(4)))	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If SourceField = "" Then SourceField = CurrentObj.ID ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set SourceObj = ReturnNamedComponent(SourceField)]]>
<![CDATA[
]]>
<![CDATA[	Set CompareToObj = ReturnNamedComponent(CompareToField)	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If (SourceObj is Nothing) or (CompareToObj is Nothing) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Fields not found to compare. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		Set SourceObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Set CompareToObj = Nothing	]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	SourceValue = SourceObj.Text]]>
<![CDATA[
]]>
<![CDATA[	CompareToValue = CompareToObj.Text]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Comparing " & SourceValue & " to " & CompareToValue)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	bPFuzzy = UCase(bPFuzzy)]]>
<![CDATA[
]]>
<![CDATA[	byWord = UCase(byWord)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If bPFuzzy = "Y" or bPFuzzy = "YES" or bPFuzzy = "1" then ]]>
<![CDATA[
]]>
<![CDATA[		bPFuzzy = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		bPFuzzy = False	]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.isnumeric(nFuzzy, locale) then nFuzzy = cint(100)]]>
<![CDATA[
]]>
<![CDATA[	nFuzzy = cint(nFuzzy)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If byWord = "Y" or byWord = "YES" or byWord = "1" then ]]>
<![CDATA[
]]>
<![CDATA[		byWord = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		byWord = False	]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sWords=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If byWord = False Then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If bPFuzzy Then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Root search value: '" & Cstr(SourceValue) & "' ")]]>
<![CDATA[
]]>
<![CDATA[		      ]]>
<![CDATA[
]]>
<![CDATA[			StrStart = SourceValue	]]>
<![CDATA[
]]>
<![CDATA[			FirstChar = Left(SourceValue,1)		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If Len(SourceValue)>1 Then SourceValue = Right(SourceValue, Len(SourceValue)-1)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[      SourceValue = DCGlobalStrings.RegExReplace(SourceValue,"[:#]", "[:#]+")   ]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[      SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[B8]", "[B8]")         ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[Z2]", "[Z2]")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[S5]", "[S5]")]]>
<![CDATA[
]]>
<![CDATA[		                                                 					]]>
<![CDATA[
]]>
<![CDATA[      SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[o0O]", "[o0O]")]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[ilt1I]", "[ilt1I]")]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[      SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "\ +", "[ ]*")  ]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[			SourceValue = "^?[\b\s\n\r]*" & FirstChar & SourceValue & "[\b\s\$]*"]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Search value: '" & Cstr(SourceValue) & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If DCGlobalStrings.RegExIsMatch(CompareToValue,SourceValue,True) Then ]]>
<![CDATA[
]]>
<![CDATA[       Writelog(DCGlobalStrings.GetLog)]]>
<![CDATA[
]]>
<![CDATA[       sWords = 1]]>
<![CDATA[
]]>
<![CDATA[       CompareFields = True]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    'Check for Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & SourceValue & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      CompareFields = False]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if       ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Else		]]>
<![CDATA[
]]>
<![CDATA[		'Find number of source Words to find in compare to value]]>
<![CDATA[
]]>
<![CDATA[		aSourceVal = Split(SourceValue & Space(1),Chr(32))]]>
<![CDATA[
]]>
<![CDATA[		nWords = ubound(aSourceVal)]]>
<![CDATA[
]]>
<![CDATA[		nWCount = 0	]]>
<![CDATA[
]]>
<![CDATA[		bFound = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		For i = 0 to (nWords-1)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			If bPFuzzy Then ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Root search value: '" & Cstr(aSourceVal(i)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[		    			      ]]>
<![CDATA[
]]>
<![CDATA[				StrStart = aSourceVal(i)	]]>
<![CDATA[
]]>
<![CDATA[				FirstChar = Left(aSourceVal(i),1)		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				If Len(aSourceVal(i))>1 Then aSourceVal(i) = Right(aSourceVal(i), Len(aSourceVal(i))-1)]]>
<![CDATA[
]]>
<![CDATA[			    ]]>
<![CDATA[
]]>
<![CDATA[	      SourceValue = DCGlobalStrings.RegExReplace(SourceValue,"[:#]", "[:#]+")   ]]>
<![CDATA[
]]>
<![CDATA[              ]]>
<![CDATA[
]]>
<![CDATA[        SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[B8]", "[B8]")         ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[        SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[Z2]", "[Z2]")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[S5]", "[S5]")]]>
<![CDATA[
]]>
<![CDATA[		                                                 					]]>
<![CDATA[
]]>
<![CDATA[        SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[o0O]", "[o0O]")]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[        SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "[ilt1I]", "[ilt1I]")]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[        SourceValue = DCGlobalStrings.RegExReplace(SourceValue, "\ +", "[ ]*")  ]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[				aSourceVal(i) = "^?[\b\s\n\r]*" & FirstChar & aSourceVal(i) & "[\b\s\$]*"]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			If len(aSourceVal(i))>0 Then]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Search Value: '" & Cstr(aSourceVal(i)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[        If DCGlobalStrings.RegExIsMatch(CompareToValue,Cstr(aSourceVal(i))) Then]]>
<![CDATA[
]]>
<![CDATA[          Writelog(DCGlobalStrings.GetLog)]]>
<![CDATA[
]]>
<![CDATA[          CompareFields = True]]>
<![CDATA[
]]>
<![CDATA[          bfound=true]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[    					]]>
<![CDATA[
]]>
<![CDATA[        'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[        If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[          Writelog(Space(3) & "Invalid Pattern '" & Cstr(aSourceVal(i)) & "'")]]>
<![CDATA[
]]>
<![CDATA[          Err.Clear]]>
<![CDATA[
]]>
<![CDATA[          CompareFields = False]]>
<![CDATA[
]]>
<![CDATA[          Exit Function]]>
<![CDATA[
]]>
<![CDATA[        End if  ]]>
<![CDATA[
]]>
<![CDATA[          			]]>
<![CDATA[
]]>
<![CDATA[				sWords = sWords + 1]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[				If bFound=False then WriteLog(Space(4) & "No value matched.")				]]>
<![CDATA[
]]>
<![CDATA[			End if	]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			If bFound = True then ]]>
<![CDATA[
]]>
<![CDATA[				nWCount = nWCount + 1	]]>
<![CDATA[
]]>
<![CDATA[				bFound = False]]>
<![CDATA[
]]>
<![CDATA[			End if	]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		Next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Check % vs nFuzzy value	]]>
<![CDATA[
]]>
<![CDATA[		If sWords <= 0 then sWords = 1]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		PMatch = cint((nWCount/sWords)*100)]]>
<![CDATA[
]]>
<![CDATA[		Writelog(PMatch & "% of the 'Compare To' value matched the search words.")]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		If PMatch >= cint(nFuzzy) And nWCount>0 Then ]]>
<![CDATA[
]]>
<![CDATA[			CompareFields = True				]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Minimum match percentage is set to " & nFuzzy & "%. Not enough words matched, Returning 'Failed'.")	]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set SourceObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set CompareToObj = Nothing ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsThisFieldEmpty" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Confirms if the current field has no captured value. ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If(CurrentObj.ObjectType = DCO_FIELD) Then]]>
<![CDATA[
]]>
<![CDATA[    If(CurrentObj.Text="") Then]]>
<![CDATA[
]]>
<![CDATA[      IsThisFieldEmpty = true]]>
<![CDATA[
]]>
<![CDATA[	  Else]]>
<![CDATA[
]]>
<![CDATA[      IsThisFieldEmpty = false  ]]>
<![CDATA[
]]>
<![CDATA[      sMessage = RRState.LoadString("validations","IsThisFieldEmpty_01","Field '{0}' is not empty.")]]>
<![CDATA[
]]>
<![CDATA[      sMessage = Replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = Replace(sMessage,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[      DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	  End if]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action IsThisFieldEmpty works only on field level")]]>
<![CDATA[
]]>
<![CDATA[    IsThisFieldEmpty = false]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsThisFieldEmpty returns " & IsThisFieldEmpty) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsThisFieldFilled" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Confirms if the current field has a captured value.]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  If(CurrentObj.ObjectType = DCO_FIELD) Then]]>
<![CDATA[
]]>
<![CDATA[		If(Trim(CurrentObj.Text)<>"") Then]]>
<![CDATA[
]]>
<![CDATA[			IsThisFieldFilled = true]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			IsThisFieldFilled = false]]>
<![CDATA[
]]>
<![CDATA[      sMessage = RRState.LoadString("validations","IsThisFieldFilled_01","Field '{0}' is not filled.")]]>
<![CDATA[
]]>
<![CDATA[      sMessage = Replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[      sMessage = Replace(sMessage,"{1}",CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[			DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    writelog("Action IsThisFieldFilled works only on field level")]]>
<![CDATA[
]]>
<![CDATA[    IsThisFieldFilled = False]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsThisFieldFilled returns " & IsThisFieldFilled)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteLCSpaces" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim ReqConf]]>
<![CDATA[
]]>
<![CDATA[	Dim sTemp]]>
<![CDATA[
]]>
<![CDATA[	Dim oSetupNode]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Deletes all low confidence spaces from the captured value. Uses ReqConf Setup dco variable as threshold for low confidence values; defaults to 9]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ReqConf = 10 ]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  Set oSetupNode = CurrentObj.SetupNode]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  If(oSetupNode is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[	  writelog ("Unable to get setupNode for field " & CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[	  DeleteLCSpaces = False]]>
<![CDATA[
]]>
<![CDATA[	  Exit function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sTemp = Trim(oSetupNode.Variable("ReqConf"))]]>
<![CDATA[
]]>
<![CDATA[	If len(sTemp)<>0 and DCGlobalCurrency.IsNumeric(sTemp, locale) then ReqConf = sTemp]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Spaces with confidence below " & ReqConf & " will be removed.")]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	nNumOfChar = CurrentObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Character ASCII value : Character Confidence")]]>
<![CDATA[
]]>
<![CDATA[	For i = 1 to nNumOfChar]]>
<![CDATA[
]]>
<![CDATA[		Writelog CurrentObj.GetChild(nNumOfChar - i).CharValue(0) & ":" & CurrentObj.GetChild(nNumOfChar - i).CharConfidence(0)]]>
<![CDATA[
]]>
<![CDATA[		If((CurrentObj.GetChild(nNumOfChar - i).CharValue(0) = 32) and (CurrentObj.GetChild(nNumOfChar - i).CharConfidence(0) < (ReqConf-1))) then ]]>
<![CDATA[
]]>
<![CDATA[			CurrentObj.DeleteChild(nNumOfChar - i)]]>
<![CDATA[
]]>
<![CDATA[	 	End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	DeleteLCSpaces = true ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsMatchingJobID" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'String value of the Job ID to be compared to the current Job ID.]]>
<![CDATA[
]]>
<![CDATA[  'Checks that the Job ID of the current User Application job matches the parameter's Job ID value. ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  IsMatchingJobID = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Strparam = trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Ucase(Pilot.JobID)=ucase(StrParam) Then ]]>
<![CDATA[
]]>
<![CDATA[		IsMatchingJobID = True]]>
<![CDATA[
]]>
<![CDATA[		Writelog("JobID: '" & Pilot.JobID & "' matches.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = "Current JobID '{0}' does not match '{1}'."]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{0}",Ucase(Pilot.JobID))]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{1}",Ucase(StrParam))]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GetJobID" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Assigns the Job ID of the current User Application job - the job's 	Pilot.JobID property - to the CurrentObj.Text variable of the bound object 	of the Document Hierarchy. ]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[  GetJobID = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text = Pilot.JobID]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Len(CurrentObj.Text)>0 then ]]>
<![CDATA[
]]>
<![CDATA[		GetJobID = True]]>
<![CDATA[
]]>
<![CDATA[		Writelog("JobID of '" & Pilot.JobID & "' set as field value.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No JobID Found.")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FieldContainsValue" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Text that the action is looking for in the current field.]]>
<![CDATA[
]]>
<![CDATA[  'This action determines if a field represented by the bound object of the ]]>
<![CDATA[
]]>
<![CDATA[  'Document Hierarchy contains some or all of the parameter's text value, without additional unspecified text. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim sCurrentValue]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FieldContainsValue = False]]>
<![CDATA[
]]>
<![CDATA[	StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	sCurrentValue = CurrentObj.Text]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Checking if string '" & sCurrentValue & "' contains value '" & strParam & "'")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If instr(sCurrentValue,StrParam)>0 Then]]>
<![CDATA[
]]>
<![CDATA[		FieldContainsValue = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","FieldContainsValue_01","Field '{0}' with value '{1}' does not contain the value '{2}'.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{1}",sCurrentValue)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{2}",strParam)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("FieldContainsValue action returns " & FieldContainsValue & " for value: " & StrParam)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteChildType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim x]]>
<![CDATA[
]]>
<![CDATA[	Dim i]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ '   String value of the child object Type. ]]>
<![CDATA[
]]>
<![CDATA[ '   "Field", for example, will eliminate all  objects. In the <i>Invoices</i> ]]>
<![CDATA[
]]>
<![CDATA[ '   application, however, "LineItem" will remove child fields of the parent <i>Details</i> ]]>
<![CDATA[
]]>
<![CDATA[ '   parent  object. ]]>
<![CDATA[
]]>
<![CDATA[ '   Deletes child objects of the type you designate as a parameter from the Document Hierarchy.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  x = CurrentObj.NumOfChildren - len(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Current number of Children: " & x)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For i = x to 0 Step -1]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		If Not(oChild is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[			if oChild.Type = StrParam Then]]>
<![CDATA[
]]>
<![CDATA[				WriteLog("Deleting Child " & oChild.ID)]]>
<![CDATA[
]]>
<![CDATA[				CurrentObj.DeleteChild(i)]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		end if]]>
<![CDATA[
]]>
<![CDATA[	Next 'i]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Removal of ChildType " & StrParam & " complete")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ParseName" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Three comma separated parameters:]]>
<![CDATA[
]]>
<![CDATA[  'The name of the Last Name Field object.]]>
<![CDATA[
]]>
<![CDATA[  'The name of the First Name Field object.]]>
<![CDATA[
]]>
<![CDATA[  'The name of the Middle Name or Middle Initial Field object.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ParseName = u_ParseName(CurrentObj,StrParam)]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("ParseName returns " & ParseName)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ParseMultilineAddress" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' Comma-separated Smart Parameter String values of the names of fields which will hold the]]>
<![CDATA[
]]>
<![CDATA[  ' parsed data, in the following order:]]>
<![CDATA[
]]>
<![CDATA[  ' Name, AddressLine1, AddressLine2, City , State , Zip , Phone]]>
<![CDATA[
]]>
<![CDATA[  ' Comma-separated String values of the names of fields which will hold the parsed data,]]>
<![CDATA[
]]>
<![CDATA[  '  in the following order: Name, AddressLine1, AddressLine2, City, State, Zip, Phone.]]>
<![CDATA[
]]>
<![CDATA[  '  Example below assumes fields are sibling fields of the calling object. For other relationships]]>
<![CDATA[
]]>
<![CDATA[  '  please review smart parameter syntax.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim oFldParse]]>
<![CDATA[
]]>
<![CDATA[	Dim oChild]]>
<![CDATA[
]]>
<![CDATA[	Dim oValue]]>
<![CDATA[
]]>
<![CDATA[	Dim oConf]]>
<![CDATA[
]]>
<![CDATA[	Dim oFld_Parsed]]>
<![CDATA[
]]>
<![CDATA[	Dim nStart]]>
<![CDATA[
]]>
<![CDATA[	Dim nEnd]]>
<![CDATA[
]]>
<![CDATA[  Dim ParentValue]]>
<![CDATA[
]]>
<![CDATA[  Dim ParentConf]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If(Trim(StrParam) = "" ) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parameter list of: Name, AddressLine1 ,AddressLine2 ,City ,State ,Zip , Phone, is empty!")]]>
<![CDATA[
]]>
<![CDATA[		ParseMultilineAddress = false]]>
<![CDATA[
]]>
<![CDATA[		Exit function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	arFieldList = Split(StrParam & ",,,,,",",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If len(trim(CurrentObj.Text))=0 Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Calling object has no value. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[		ParseMultilineAddress = False]]>
<![CDATA[
]]>
<![CDATA[		Exit function		]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oFldParse = CreateObject("Datacap.FldParse")]]>
<![CDATA[
]]>
<![CDATA[	If (oFldParse is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Unable to create Datacap.FldParse object")]]>
<![CDATA[
]]>
<![CDATA[		ParseMultilineAddress = False]]>
<![CDATA[
]]>
<![CDATA[		Exit function		]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ParentValue = CurrentObj.text]]>
<![CDATA[
]]>
<![CDATA[  ParentConf = CurrentObj.ConfidenceString]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'oFldParse requires pipe char as line terminator value]]>
<![CDATA[
]]>
<![CDATA[  ParentValue = replace(ParentValue,vbcrlf,"|")]]>
<![CDATA[
]]>
<![CDATA[  ParentValue = replace(ParentValue,vbcr,"|")]]>
<![CDATA[
]]>
<![CDATA[  ParentValue = replace(ParentValue,vblf,"|")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Current Field Value:" & Currentobj.Text)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Choices for testing...]]>
<![CDATA[
]]>
<![CDATA[	Set oFld_Parsed = oFldParse.GetHCField33Object(ParentValue,ParentConf)]]>
<![CDATA[
]]>
<![CDATA[	'Set oFld_Parsed = oFldParse.GetHCField32Object(ParentValue,ParentConf)]]>
<![CDATA[
]]>
<![CDATA[	'Set oFld_Parsed = oFldParse.GetUBField1Object(ParentValue,ParentConf)]]>
<![CDATA[
]]>
<![CDATA[	'Set oFld_Parsed = oFldParse.GetUBField13Object(ParentValue,ParentConf)]]>
<![CDATA[
]]>
<![CDATA[	'Set oFld_Parsed = oFldParse.GetUBField38Object(ParentValue,ParentConf)]]>
<![CDATA[
]]>
<![CDATA[	'Set oFld_Parsed = oFldParse.GetUBField66Object(ParentValue,ParentConf)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If (oFld_Parsed is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Did not create Datacap oFld_Parsed object")]]>
<![CDATA[
]]>
<![CDATA[		ParseMultilineAddress = false]]>
<![CDATA[
]]>
<![CDATA[		Exit function]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (Trim(arFieldList(0)) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[    If Instr(arFieldList(0),"\")<=0 then arFieldList(0)="..\" & arFieldList(0)]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = DCONav(arFieldList(0))]]>
<![CDATA[
]]>
<![CDATA[    If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[    If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("did not find Name Field")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			oValue = oFld_Parsed.Name]]>
<![CDATA[
]]>
<![CDATA[			oConf =  oFld_Parsed.NameConf]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[			oChild.Variable("Position")="0,0,0,0"			]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[			nStart = Instr(CurrentObj.Text,oValue)]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyChars(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyPos(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[      Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[			Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & ochild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If (Trim(arFieldList(1)) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[    If Instr(arFieldList(1),"\")<=0 then arFieldList(1)="..\" & arFieldList(1)]]>
<![CDATA[
]]>
<![CDATA[		Set oChild  = DCONav(arFieldList(1))]]>
<![CDATA[
]]>
<![CDATA[    If oChild Is CurrentObj then Set oChild = Nothing  ]]>
<![CDATA[
]]>
<![CDATA[		If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Did not find Address1 Field")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			oValue = oFld_Parsed.Add1]]>
<![CDATA[
]]>
<![CDATA[			oConf =  oFld_Parsed.Add1Conf]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[			oChild.Variable("Position")="0,0,0,0"			]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			nStart = Instr(CurrentObj.Text,oValue)]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyChars(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyPos(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[      Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & ochild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If(Trim(arFieldList(2)) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[    If Instr(arFieldList(2),"\")<=0 then arFieldList(2)="..\" & arFieldList(2)]]>
<![CDATA[
]]>
<![CDATA[    Set oChild = DCONav(arFieldList(2))]]>
<![CDATA[
]]>
<![CDATA[		If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[    If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Did not find Address2 Field")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			oValue = oFld_Parsed.Add2]]>
<![CDATA[
]]>
<![CDATA[			oConf =  oFld_Parsed.Add2Conf]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[			oChild.Variable("Position")="0,0,0,0"			]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			nStart = Instr(CurrentObj.Text,oValue)]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyChars(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyPos(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[      Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & ochild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If(Trim(arFieldList(3)) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[    If Instr(arFieldList(3),"\")<=0 then arFieldList(3)="..\" & arFieldList(3)]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = DCONav(arFieldList(3))]]>
<![CDATA[
]]>
<![CDATA[		If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[    If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Did not find City Field.")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			oValue = oFld_Parsed.City]]>
<![CDATA[
]]>
<![CDATA[			oConf =  oFld_Parsed.CityConf]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[			oChild.Variable("Position")="0,0,0,0"			]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			nStart = Instr(CurrentObj.Text,oValue)]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyChars(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyPos(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[      Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & ochild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If(Trim(arFieldList(4)) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[    If Instr(arFieldList(4),"\")<=0 then arFieldList(4)="..\" & arFieldList(4)]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = DCONav(arFieldList(4))]]>
<![CDATA[
]]>
<![CDATA[		If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[    If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Did not find State field.")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			oValue = oFld_Parsed.State]]>
<![CDATA[
]]>
<![CDATA[			oConf =  oFld_Parsed.StateConf]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[			oChild.Variable("Position")="0,0,0,0"			]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			nStart = Instr(CurrentObj.Text,oValue)]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyChars(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyPos(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[      Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & ochild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If(Trim(arFieldList(5)) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[    If Instr(arFieldList(5),"\")<=0 then arFieldList(5)="..\" & arFieldList(5)]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = DCONav(arFieldList(5))]]>
<![CDATA[
]]>
<![CDATA[		If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[    If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Did not find Zip field.")]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			oValue = oFld_Parsed.Zip]]>
<![CDATA[
]]>
<![CDATA[			oConf =  oFld_Parsed.ZipConf]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[			oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[			oChild.Variable("Position")="0,0,0,0"			]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			nStart = Instr(CurrentObj.Text,oValue)]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyChars(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[			Call RRCopyPos(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[      Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[      Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & ochild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	If(Trim(arFieldList(6)) <> "") Then]]>
<![CDATA[
]]>
<![CDATA[    If Instr(arFieldList(6),"\")<=0 then arFieldList(6)="..\" & arFieldList(6)]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = DCONav(arFieldList(6))]]>
<![CDATA[
]]>
<![CDATA[		If oChild Is CurrentObj then Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[    If (oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Did not find phone field.")]]>
<![CDATA[
]]>
<![CDATA[		Else		]]>
<![CDATA[
]]>
<![CDATA[			oValue = oFld_Parsed.Phone]]>
<![CDATA[
]]>
<![CDATA[			oConf =  oFld_Parsed.PhoneConf ]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[				oChild.Text=""]]>
<![CDATA[
]]>
<![CDATA[				oChild.Variable("Position")="0,0,0,0"			]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[				nStart = Instr(CurrentObj.Text,oValue)]]>
<![CDATA[
]]>
<![CDATA[				Call RRCopyChars(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[				Call RRCopyPos(CurrentObj, oChild, nStart, Len(oValue))]]>
<![CDATA[
]]>
<![CDATA[        Call RRCopyImage(CurrentObj, oChild)]]>
<![CDATA[
]]>
<![CDATA[				Writelog(oChild.ID & " value set to '" & oChild.Text & "' position'" & ochild.variable("Position") & "'")]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oFld_Parsed = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oFldParse = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Err.Number<>0 then Err.Clear]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ParseMultilineAddress = True ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsVariableEmpty" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'Name of the current object's variable to be checked.]]>
<![CDATA[
]]>
<![CDATA[	'Confirms if the variable specified by the parameter does not contain a value.  This action only checks variables of the current object. ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	IsVariableEmpty = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    If CurrentObj.FindVariable(strparam) < 0 then]]>
<![CDATA[
]]>
<![CDATA[        sMessage = "Variable " & StrParam & " was not found"]]>
<![CDATA[
]]>
<![CDATA[        Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Len(CurrentObj.Variable(strParam)) = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[		IsVariableEmpty = True]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Variable " & strParam & "is empty")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = "Variable " & strParam & " is not empty."]]>
<![CDATA[
]]>
<![CDATA[    Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsVariableEmpty returns " & IsVariableEmpty)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsVariableFilled" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Name of the current object's variable to be checked.]]>
<![CDATA[
]]>
<![CDATA[  'Confirms if the variable specified by the parameter contains a value.  This action ]]>
<![CDATA[
]]>
<![CDATA[  'only checks variables of the current object.]]>
<![CDATA[
]]>
<![CDATA[      	]]>
<![CDATA[
]]>
<![CDATA[	IsVariableFilled = False]]>
<![CDATA[
]]>
<![CDATA[   If CurrentObj.FindVariable(strparam) < 0 then]]>
<![CDATA[
]]>
<![CDATA[        sMessage = "Variable " & StrParam & " was not found"]]>
<![CDATA[
]]>
<![CDATA[        Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	If Len(CurrentObj.Variable(strParam)) > 0 Then  ]]>
<![CDATA[
]]>
<![CDATA[		IsVariableFilled = True]]>
<![CDATA[
]]>
<![CDATA[		WriteLog("Variable " & strParam & " contains a value")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = "Variable " & strparam & "is not filled" ]]>
<![CDATA[
]]>
<![CDATA[		Writelog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsVariableFilled returns " & IsVariableFilled) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="HasChildOfType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'The name of a level of the Document Hierarchy (Batch, Document, Page, Field) or of a runtime variable.]]>
<![CDATA[
]]>
<![CDATA[  'Determines if the bound object of the Document Hierarchy has a child or children of the type specified by the parameter. The action can also determine if a runtime variable specified as a parameter has been assigned to the bound object.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim n, i]]>
<![CDATA[
]]>
<![CDATA[	Dim sType]]>
<![CDATA[
]]>
<![CDATA[	Dim oChild]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	sType = ""	]]>
<![CDATA[
]]>
<![CDATA[	Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[	n = 0]]>
<![CDATA[
]]>
<![CDATA[	i = 0	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	HasChildOfType = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	n = CurrentObj.NumOfChildren - len(CurrentObj.Text)]]>
<![CDATA[
]]>
<![CDATA[	sType = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Checking for Children of type: '" & sType & "' .")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For i = 1 to n]]>
<![CDATA[
]]>
<![CDATA[		Set oChild = CurrentObj.GetChild(i-1)]]>
<![CDATA[
]]>
<![CDATA[		If Not(oChild is Nothing) Then]]>
<![CDATA[
]]>
<![CDATA[			If oChild.Type = sType Then ]]>
<![CDATA[
]]>
<![CDATA[				HasChildOfType = True]]>
<![CDATA[
]]>
<![CDATA[				WriteLog("Found Child of type: '" & sType & "' .")]]>
<![CDATA[
]]>
<![CDATA[				Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[				Exit Function]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next 'i]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oChild = Nothing]]>
<![CDATA[
]]>
<![CDATA[  sMessage = cstr(n) & space(1) & "children checked. Type not found:" & strparam ]]>
<![CDATA[
]]>
<![CDATA[	Writelog(sMessage) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="DeleteParentObj" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Deletes the parent of the Document Hierarchy object to which a rule with this action is bound. ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  DeleteParentObj = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim x, i]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim oGrandParent]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = CurrentObj.Parent()]]>
<![CDATA[
]]>
<![CDATA[	If oParent is Nothing then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Parent Object is Nothing.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Parent ID to delete is '" & oParent.ID & "'.")	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oGrandParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[	If oGrandParent is Nothing then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("GrandParent Object is Nothing.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	i = oGrandParent.FindChildIndex(oParent.ID)	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Parent Index is:'" & cstr(i) & "'.")	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set oParent = Nothing	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	DeleteParentObj = oGrandParent.DeleteChild(i)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	Set oGrandParent = Nothing ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsPatternInField" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim Match]]>
<![CDATA[
]]>
<![CDATA[	Dim Matches]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[  Dim bIgnoreCase]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	' String value of the Regular Expression. The expression can include any Regular Expression characters.]]>
<![CDATA[
]]>
<![CDATA[  ' Uses VBScript Regular Expression Pattern entered as parameter to search for a matching pattern in ]]>
<![CDATA[
]]>
<![CDATA[  ' current object's Text value.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	IsPatternInField = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[  bIgnoreCase = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	sValue= Replace(GetFieldValue,"~"," ")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Looking for value '" & strParam & "' in string: '" & sValue & "'")		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ ' Use dcglobal dotNet regex engine:]]>
<![CDATA[
]]>
<![CDATA[  If DCGlobalStrings.RegExIsMatch(sValue, StrParam, bIgnoreCase) Then]]>
<![CDATA[
]]>
<![CDATA[     sDCGlobalLog = DCGlobalStrings.GetLog()]]>
<![CDATA[
]]>
<![CDATA[     WriteLog(sDCGlobalLog)]]>
<![CDATA[
]]>
<![CDATA[ 	   bFound = True]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		IsPatternInField = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    sMessage = RRState.LoadString("validations","IsPatternInField_01","Field '{0}' value of '{1}' does not contain the pattern '{2}'.")]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{0}",CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{1}",sValue)]]>
<![CDATA[
]]>
<![CDATA[    sMessage = Replace(sMessage,"{2}",StrParam)]]>
<![CDATA[
]]>
<![CDATA[		DCOMessage(sMessage)]]>
<![CDATA[
]]>
<![CDATA[		Debuglog(sMessage)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("IsPatternInField returns " & IsPatternInField)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ConvertFieldToCurrency" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Formats a field's text value as a currency value.  The following steps are performed on the field:]]>
<![CDATA[
]]>
<![CDATA[  '      ]]>
<![CDATA[
]]>
<![CDATA[  '   1. Removes existing currency symbols.Off]]>
<![CDATA[
]]>
<![CDATA[  '   2. Replaces negative value characters such as parenthesis, 'NEG', 'CR' and trailing hyphen ]]>
<![CDATA[
]]>
<![CDATA[  '   with a leading hyphen.]]>
<![CDATA[
]]>
<![CDATA[  '   3. If a decimal exists, its position is not changed.]]>
<![CDATA[
]]>
<![CDATA[  '   4. If a decimal does not exist and the field contains 2 or more characters, a decimal is inserted ]]>
<![CDATA[
]]>
<![CDATA[  '   before the last two characters in the field.]]>
<![CDATA[
]]>
<![CDATA[  '   5. If a decimal does not exist and the field contains less than 2 characters, no decimal is inserted.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim cObj]]>
<![CDATA[
]]>
<![CDATA[	Dim nLen]]>
<![CDATA[
]]>
<![CDATA[	Dim nChar]]>
<![CDATA[
]]>
<![CDATA[	Dim RegEx]]>
<![CDATA[
]]>
<![CDATA[	Dim Matches]]>
<![CDATA[
]]>
<![CDATA[	Dim Match	]]>
<![CDATA[
]]>
<![CDATA[	Dim m	]]>
<![CDATA[
]]>
<![CDATA[	Dim Index		]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Dim sLocalNum]]>
<![CDATA[
]]>
<![CDATA[	Dim sDecimal]]>
<![CDATA[
]]>
<![CDATA[	Dim sGroup	]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	sDecimal = DCGlobalCurrency.CurrencyDecimalSeparator(locale) ]]>
<![CDATA[
]]>
<![CDATA[	sGroup = DCGlobalCurrency.CurrencyGroupSeparator(locale)]]>
<![CDATA[
]]>
<![CDATA[  sSymbol = DCGlobalCurrency.CurrencySymbol(locale)  ]]>
<![CDATA[
]]>
<![CDATA[  sDecimalDigits = DCGlobalCurrency.CurrencyDecimalDigits(locale)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	ConvertFieldToCurrency = False]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Start value: '" & currentobj.text & "'")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Remove all currency symbols]]>
<![CDATA[
]]>
<![CDATA[  sResult = DCGlobalStrings.RemoveReplace("[\s\p{Sc}_]*",cint(0),"",cint(0), CurrentObj) ]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Check for Negative Currency values]]>
<![CDATA[
]]>
<![CDATA[  If DCGlobalStrings.RegExIsMatch(CurrentObj.Text,"\(\d\d+\)|\d\d+CR|\d\d+NEG|\d\d+-") then]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    'If we found Negative currency indicator(s), remove the symbols and then replace with a leading hyphen character]]>
<![CDATA[
]]>
<![CDATA[    sResult = DCGlobalStrings.RemoveReplace("[\(\)-]|CR|NEG",cint(0),"",cint(0), CurrentObj) ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'Check to see if the value is already Negative]]>
<![CDATA[
]]>
<![CDATA[		If instr(CurrentObj.text,"-")<>1 then]]>
<![CDATA[
]]>
<![CDATA[			Set cObj = CurrentObj.AddChild(4,"",CurrentObj.NumOfchildren-Len(Currentobj.Text))]]>
<![CDATA[
]]>
<![CDATA[			nChar = cObj.AddValue(CLng(45), CLng(10))]]>
<![CDATA[
]]>
<![CDATA[		  bRes = cObj.SetPosition(clng(0),clng(0),clng(0),clng(0))]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End if				]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Numeric Check - look at a copy of the field value  ]]>
<![CDATA[
]]>
<![CDATA[	If DCGlobalStrings.RegExIsMatch(CurrentObj.Text,"[^\p{N}\.,-']") then  ]]>
<![CDATA[
]]>
<![CDATA[		ConvertFieldToCurrency = False]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Value must be numeric to format as currency. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Current locale decimal separator character is { " & sDecimal & " }")        ]]>
<![CDATA[
]]>
<![CDATA[          ]]>
<![CDATA[
]]>
<![CDATA[	'Add Decimal Character - preserve confidence of existing values]]>
<![CDATA[
]]>
<![CDATA[  'Assumes two position decimal if no decimal symbols are found]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalStrings.RegExIsMatch(CurrentObj.Text,"[\.,\u066b]") and (len(CurrentObj.Text)>2) then]]>
<![CDATA[
]]>
<![CDATA[	  Set cObj = CurrentObj.AddChild(4,"",len(CurrentObj.Text)-2)]]>
<![CDATA[
]]>
<![CDATA[		nChar = cObj.AddValue(CLng(ASCW(sDecimal)), CLng(10))]]>
<![CDATA[
]]>
<![CDATA[    bRes = cObj.SetPosition(clng(0),clng(0),clng(0),clng(0))]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[  If Not DCGlobalStrings.RegExIsMatch(CurrentObj.Text,"[^\p{N}\.,-'\u066b]") then]]>
<![CDATA[
]]>
<![CDATA[    If len(CurrentObj.Text)>=2 then  ]]>
<![CDATA[
]]>
<![CDATA[		  ConvertFieldToCurrency = True]]>
<![CDATA[
]]>
<![CDATA[    end if]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Non currency character in value")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	writelog("Formatted value: '" & currentobj.text & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set cObj = Nothing]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsFieldHidden" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Note: This action returns True if the calling field is 'Hidden'...if the corresponding object of the Document Hierarchy has a variable STATUS equal to -1.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Dim oSetupNode]]>
<![CDATA[
]]>
<![CDATA[  Dim oNodeValue]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  IsFieldHidden=False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType<>3 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action must be called on a DCO field. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Set oSetupNode = CurrentObj.SetupNode]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If oSetupNode is nothing then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Unable to get setupNode for field " & CurrentObj.ID)]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    If Trim(cstr(oSetupNode.Variable("STATUS")))="-1" then IsFieldHidden=True]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Trim(cstr(CurrentObj.STATUS))="-1" then IsFieldHidden=True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  WriteLog("IsFieldHidden returns " & IsFieldHidden)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Set oSetupNode=Nothing ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="IsSupportedImageFile" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamInput">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[   ' A Boolean that determines the type of test to perform.]]>
<![CDATA[
]]>
<![CDATA[   ']]>
<![CDATA[
]]>
<![CDATA[   '  True: Tests the validity of the image by checking the file extension and attempting to load the image.]]>
<![CDATA[
]]>
<![CDATA[   '  False: Only a file extension check is performed to determine if it is a supported file.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim oDCImage]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  IsSupportedImageFile = FALSE]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType<>2 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action must be called on a DCO page. Exiting Action.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  strParam = UCase(Trim(strParamInput))  ]]>
<![CDATA[
]]>
<![CDATA[  If (trim(strParam) = "") then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Parameter missing.  A parameter of True or False is required.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If ((strParam <> "TRUE") and (strParam <> "FALSE")) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("A parameter of True or False is required.  Parameter is: " & strParam)]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ImageName <> "" Then]]>
<![CDATA[
]]>
<![CDATA[    If CBool(strParam) = TRUE Then]]>
<![CDATA[
]]>
<![CDATA[      Set oDCImage = createObject("DCIMAGE.DcimageCtrl.1")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      oDCImage.FileName = CurrentObj.ImageName]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      If Err.Number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Image file '" & CurrentObj.ImageName & "' is not supported."]]>
<![CDATA[
]]>
<![CDATA[        Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        If oDCImage.Filename = "" Then]]>
<![CDATA[
]]>
<![CDATA[	        Writelog "Image file '" & CurrentObj.ImageName & "' is not supported."]]>
<![CDATA[
]]>
<![CDATA[        Else]]>
<![CDATA[
]]>
<![CDATA[	        Writelog "Image file '" & CurrentObj.ImageName & "' is supported."]]>
<![CDATA[
]]>
<![CDATA[          IsSupportedImageFile = TRUE]]>
<![CDATA[
]]>
<![CDATA[        End If ]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      Set oDCImage = Nothing]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      sFileName = UCase(CurrentObj.ImageName)]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      If InStr(sFileName,".TIF") >  0 Then]]>
<![CDATA[
]]>
<![CDATA[        IsSupportedImageFile = TRUE]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Image file '" & CurrentObj.ImageName & "' is supported."]]>
<![CDATA[
]]>
<![CDATA[      ElseIf InStr(sFileName,".TIFF") >  0 Then]]>
<![CDATA[
]]>
<![CDATA[        IsSupportedImageFile = TRUE]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Image file '" & CurrentObj.ImageName & "' is supported."]]>
<![CDATA[
]]>
<![CDATA[      ElseIf InStr(sFileName,".JPG") >  0 Then]]>
<![CDATA[
]]>
<![CDATA[        IsSupportedImageFile = TRUE]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Image file '" & CurrentObj.ImageName & "' is supported."]]>
<![CDATA[
]]>
<![CDATA[      ElseIf InStr(sFileName,".JPEG") >  0 Then]]>
<![CDATA[
]]>
<![CDATA[        IsSupportedImageFile = TRUE]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Image file '" & CurrentObj.ImageName & "' is supported."]]>
<![CDATA[
]]>
<![CDATA[      Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog "Image file '" & CurrentObj.ImageName & "' is not supported."]]>
<![CDATA[
]]>
<![CDATA[      End If]]>
<![CDATA[
]]>
<![CDATA[    End  If]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog "The current page does not have an image associated with it."]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="ReplaceValueAtPosition" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  ' Two-part comma-separated value:]]>
<![CDATA[
]]>
<![CDATA[  ' 1. The position that contains the value to be replaced.]]>
<![CDATA[
]]>
<![CDATA[  ' 2. The replacement string; this parameter defaults to "" indicating a deletion.]]>
<![CDATA[
]]>
<![CDATA[  ' This action replaces the value at a specific position with a string replacement value, or a deletion.]]>
<![CDATA[
]]>
<![CDATA[  Dim locale ]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ReplaceValueAtPosition = False]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    locale = DetermineLocale() 'From rrunner.rrx]]>
<![CDATA[
]]>
<![CDATA[	StrParam = StrParam & ","]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[	Value = GetFieldValue()]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[  nStartIndex = MetaWord(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	ReplaceWithString = MetaWord(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not DCGlobalCurrency.IsNumeric(aStrParam(0), locale) And Not(Trim(aStrParam(0)) = "*") Then aStrParam(0) = "1"]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Start value:'" & CurrentObj.Text & "' Replace character index:'" & sFind & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If clng(sFind)<=clng(Len(currentobj.text)) then]]>
<![CDATA[
]]>
<![CDATA[      FindString=Mid(CurrentObj.Text,nStartIndex,1)]]>
<![CDATA[
]]>
<![CDATA[    	ReplaceValueAtPosition = u_ModifyText(FindString,nStartIndex,1,ReplaceWithString)]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Replace position is outside of field length.")]]>
<![CDATA[
]]>
<![CDATA[    End if	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("End value:'" & CurrentObj.Text & "'")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<f name="FormatNumberToLocale" access="public">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  	    ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  FormatNumberToLocale = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim StartValue ]]>
<![CDATA[
]]>
<![CDATA[  Dim EndValue]]>
<![CDATA[
]]>
<![CDATA[  Dim locale]]>
<![CDATA[
]]>
<![CDATA[  Dim sLogVal]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  locale = DetermineLocale() ' in rrunner]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Start Field value:" & CurrentObj.text)]]>
<![CDATA[
]]>
<![CDATA[  EndValue = DCGlobalCurrency.NormalizeNumber(CurrentObj,locale)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sLogVal=DCGlobalCurrency.GetLog]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Writelog(sLogVal)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("End value:" & CurrentObj.text)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Err.number=0 then ]]>
<![CDATA[
]]>
<![CDATA[    FormatNumberToLocale = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    Err.Clear]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<help>
  <![CDATA[
'************************************************************************
' Validation Action help
'------------------------------------------------------------------------
' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2015 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************************
    
  ]]>
<ref id="IsFieldPercentAlpha">
  <ap>
    A number (0-100) indicating the percentage necessary to return a <b>True</b> condition.  The value must be numeric, without the percent sign.
    Smart parameters are supported.
  </ap>
  <lvl>Field level.</lvl>
  <ret><b>True</b> if the parameter's requirement is met. Otherwise <b>False</b>, including if the Field is empty.</ret>
  <h>Determines if the characters in the current Field object's captured value are <var>n%</var> alphabetic. 
    <e>
      <b>IsFieldPercentAlpha("50")</b>   #RPR-1421 returns <b>False</b><br/>
      <b>IsFieldPercentAlpha("30")</b>   #RPR1421 returns <b>True</b>
    </e>
</h>
<see><scr>IsFieldPercentNumeric</scr>,<scr>IsFieldMatching</scr></see>
</ref>
<ref id="IsFieldDate">
    <ap>None.</ap>
    <h>
      Checks that the value of the field has an acceptable Date format. Uses the current locale setting to determine
      valid patterns.<br/><br/>

      This action will accept any valid date from January 1st year 1 through December 31st 9999.
      <e>
        <b>IsFieldDate()</b><br/><br/>

        In locale en-US (United States):<br/>

        April 6, 1944   returns <b>True</b><br/>
        04/06/44   returns <b>True</b><br/>
        30.6.44   returns <b>False</b><br/>
        Feb 31,2003   returns <b>False</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>True</b> if the action's specifications are met. Otherwise, <b>False.</b>
    </ret>
  </ref>
  <ref id="IsFieldDateEqualOrAfter">
    <ap>
      The name of the Field object of the Document Hierarchy to be compared with the
      current field's Date value.
    </ap>
    <h>
      Checks that the Date value in the current field represented by the bound Field
      object of the Document Hierarchy is greater than or equal to the Date value in the
      field specified as the parameter.
      <e>
        <b>IsFieldDateEqualOrAfter("24aDtFr1")</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the date condition is not met, if the action is not applied at the Field level, or either field
      does not contain a valid date. Otherwise, <b>True.</b>
    </ret>
    <see>
      <scr>IsFieldDateEqualOrBefore</scr>
    </see>
  </ref>
  <ref id="IsFieldDateEqualOrBefore">
    <ap>
      The name of the Field object of the Document Hierarchy to be compared with
      the current field's Date value.
    </ap>
    <h>
      Checks that the date in the current field represented by the bound Field object of the
      Document Hierarchy is less than or equal to the Date value in the field specified as the parameter.
      <e>
        <b>IsFieldDateEqualOrBefore("24aDtFr1")</b>
      </e>
    </h>
    <lvl>Field Level.</lvl>
    <ret>
      <b>False</b> if the date condition is not met, if the action is not applied at the Field level, or if either field
      does not contain a valid date value.  Otherwise, <b>True.</b>
    </ret>
    <see>
      <scr>IsFieldDateEqualOrAfter</scr>
    </see>
  </ref>

  <ref id="CalculateDateDifference">
    <ap>
      <b>startDate</b> : The starting date.<br/>
      <b>endDate</b> : The ending date.<br/>
      <b>targetVariable</b> : The variable to hold the calculated result value.<br/>
      <b>dateProperty</b> : The value to calculate.  0 = days, 1 = months, 2 = quarters, 3 = years.<br/><br/>
      
      Smart parameters are supported.
    </ap>
    <h>
      Calculates the number of days, months, quarters or years between two dates.  
      Only whole numbers are returned.  Any fractional parts of the value are dropped.
      Quarters are calculated simply by dividing the number of months by 3.
      The order of the dates does not matter.<br/><br/>
      
      Note this action only supports Gregorian short dates as input and the date format must match the default format of the current locale.
      <e>
        <b>CalculateDateDifference("4/20/2012", "5/19/2012", "@P.Months", 1)</b><br/>
        This example will create the page variable "Months" with a value of "0".<br/><br/>
        
        <b>CalculateDateDifference("4/20/2012", "5/20/2012", "@P.Months", 1)</b><br/>
        This example will create the page variable "Months" with a value of "1".<br/><br/>
        
        <b>CalculateDateDifference("4/20/2012", "4/19/2013", "@P.Years", 3)</b><br/>
        This example will create the page variable "Years" with a value of "0".<br/><br/>
        
        <b>CalculateDateDifference("4/20/2012", "4/20/2013", "@P.Years", 3)</b><br/>
        This example will create the page variable "Years" with a value of "1".<br/><br/>

        <b>CalculateDateDifference(@P\MyDate1, @P\MyDate2, "@P.Days", 0)</b><br/>
        This example will create the page variable "Days" with the number of days between the dates specified by the values in field MyDate1 and field MyDate2.<br/><br/>

        <b>CalculateDateDifference(@P.MyDate1, @P.MyDate2, "@P.Days", 0)</b><br/>
        This example will create the page variable "Days" with the number of days between the dates specified by page variables MyDate1 and MyDate2.
      </e>
    </h>
    <lvl>Any level.</lvl>
    <ret>
      <b>False,</b> If the format of either date is invalid.  Otherwise, <b>True.</b>
    </ret>
  </ref>
  
  <ref id="AssignFieldDefault">
    <ap>The String value you're assigning to the field.</ap>
    <h>
      Assigns a default value to the current field.
      <e>
        <b>AssignFieldDefault("Bill Paid")</b><br/>
        or<br/>
        <b>AssignFieldDefault("PastDue!")</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if not called on the correct level.  Otherwise, <b>True.</b>
    </ret>
  </ref>
  <ref id="IsFieldLengthMax">
    <ap>
      A number <var>n</var> designating the value's maximum length.  Smart parameters are supported.
    </ap>
    <h>
      Checks that the character length of the current Field object's captured value is equal to
      or less than the value set as a parameter..
      <e>
        <b>IsFieldLengthMax("6")</b>
        <br/>
        <scr>
          EU2240 returns <b>True</b>
        </scr>
        <br/>
        <scr>
          EU002240 returns <b>False</b>
        </scr>
        <br/>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the parameter you enter is not numeric, or if the number of characters
      exceeds the parameter's value. Otherwise, <b>True.</b>
    </ret>
    <see>
      <scr>IsFieldLengthMin</scr>
    </see>
  </ref>

  <ref id="IsFieldLengthMin">
    <ap>
      A number <var>n</var> designating the value's minimum length.  Smart parameters are supported.
    </ap>
    <h>
      Checks the character length of the current Field object's captured value to see if its
      length is equal to or longer than a number <var>n</var>
      <e>
        <b>IsFieldLengthMin("6")</b><br/>
        EU2240 returns <b>True</b>
        EU22 returns <b>False</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the parameter you enter is not numeric, or if the number of characters
      is less than the parameter's value. Otherwise, <b>True</b>.
    </ret>
    <see>
      <scr>IsFieldLengthMax</scr>
    </see>
  </ref>
  <ref id="InsertChars">
    <ap>
      <b>1.</b> The characters or character string to be inserted; defaults to a space.<br/>
      <b>2.</b> A number <var>n</var> indicating the target position within the captured value;
      defaults to the end of the value.<br/>
      <b>3.</b> The number of insertions; defaults to 1.<br/>
    </ap>
    <h>
      Inserts a character or string of characters into the captured value, one or more times.
      <e>
        <b>InsertChars("=$,1,1")</b><br/>
        345.67 becomes  =$345.67<br/><br/>

        <b>InsertChars("=$,1,2")</b><br/>
        345.67 becomes  =$=$345.67
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>
  <ref id="AddPaddingToRight">
    <ap>
    </ap>
    <h>
      This action has been deprecated and is expected to be removed in a future release.
      AddPaddingToRight has been replaced by AddPaddingToEnd.
    </h>
    <lvl></lvl>
    <ret>
    </ret>
  </ref>
  <ref id="AddPaddingToEnd">
    <ap>
      A number <var>n</var> indicating the maximum permissible length of the value. If the
      action finds that a value's length is less than this number, it will insert spaces until
      the maximum length is reached.  Smart parameters are supported.
    </ap>
    <h>
      Pads the current Field object's captured value with spaces from after the last character
      in the string out to the number of specificed characters.
      <e>
        <b>AddPaddingToEnd("10")</b> uses spaces to expand a value with less than 10 characters.<br/><br/>

        For example:<br/>
        456.11 becomes 456.11_ _ _ _
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>
      <scr>AddPaddingToStart</scr>
    </see>
  </ref>
  <ref id="AddPaddingToLeft">
    <ap>
    </ap>
    <h>
      This action has been deprecated and is expected to be removed in a future release.
      AddPaddingToStart has been replaced by AddPaddingToStart.
    </h>
    <lvl></lvl>
    <ret>
    </ret>
  </ref>
  <ref id="AddPaddingToStart">
    <ap>
      A number <var>n</var> indicating the maximum permissible length of the value. If the
      action finds that a value's length is less than this number, it will insert spaces
      until the maximum length is reached. Smart parameters are supported.
    </ap>
    <h>
      Pads the current Field object's captured value with spaces from the start of the string 
      up to the first character until the specified length is reached.
      <e>
        <b>AddPaddingToStart("12")</b> uses spaces to expand a value with less than 12 characters. <br/><br/>
        For example: RSJ-112 becomes _ _ _ _ _RSJ-112
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>
      <scr>AddPaddingToEnd</scr>
    </see>
  </ref>
  <ref id="TrimSpaces">
    <ap>None.</ap>
    <h>
      Deletes extra spaces at the beginning and end of the current Field object's captured value.
      <e>
        <b>TrimSpaces()</b><br/><br/>

        456.11_ _ _ _ becomes 456.11
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>
      <scr>DeleteSelectedChars</scr>
    </see>
  </ref>
  <ref id="RightTruncate">
    <ap>
    </ap>
    <h>
      This action has been deprecated and is expected to be removed in a future release.
      RightTruncate has been replaced by TruncateFromStart.
    </h>
    <lvl></lvl>
    <ret>
    </ret>
  </ref>
  <ref id="TruncateFromStart">
    <ap>
      A number <var>n</var> that is the value's maximum length.  Smart parameters are supported.
    </ap>
    <h>
      This action deletes characters from the start of the current <b>Field</b>object's captured
      value until the value's length equals the length specified by the parameter.
      <e>
        <scr>TruncateFromStart("6")</scr> reduces the following value:<br/>
        3,344.01 becomes 344.01
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>
      <scr>TruncateFromEnd</scr>
    </see>
  </ref>
 <ref id="LeftTruncate">
    <ap>
    </ap>
    <h>
      This action has been deprecated and is expected to be removed in a future release.
      LeftTruncate has been replaced by TruncateFromEnd.
    </h>
    <lvl></lvl>
    <ret>
    </ret>
 </ref>  
<ref id="TruncateFromEnd">
  <ap>
    A Number <var>n</var> that is the value's maximum length.  Smart parameters are supported.
  </ap>
  <h>
    This action deletes characters from the end of the current <b>Field</b>object's captured value until 
    the value's length equals the length indicated by the parameter.
    <e>
      <b>TruncateFromEnd("6")</b><br/><br/>
      EU0002240 becomes EU0002
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter is not Numeric. Otherwise, <b>True.</b>
  </ret>
  <see><scr>TruncateFromStart, IsFieldLengthMax</scr></see>
</ref>
<ref id="AddLeadingZeros">
  <ap>
    A number <var>n</var> which is the value's maximum length. Smart parameters are supported.
  </ap>
  <h>
    Adds zeros ("0") to the beginning of the current Field object's captured value until the value's total length reaches the maximum n you specify as the parameter.
    <e>
      <scr>AddLeadingZeros("10")</scr><br/><br/>

      2240.00 becomes       0002240.00
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter you enter is not numeric; otherwise, <b>True.</b>
  </ret>
  <see><scr>AddTrailingZeros, IsFieldLengthMax</scr></see>
</ref>
<ref id="AddTrailingZeros">
	<ap>A number <var>n</var> which is the value's maximum length.  Smart parameters are supported.</ap>
  <h>
    Adds zeros ("0") to the end of the current Field's captured value until the value's length reaches the maximum <var>n</var> you enter as the parameter.
    <e>
      <scr>AddTrailingZeros("10")</scr><br/><br/>
      2240.00 becomes 2240.00000
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter you enter is not numeric; otherwise, <b>True.</b>
  </ret>
  <see><scr>AddLeadingZeros</scr></see>	
</ref>
<ref id="DeleteSelectedChars">
	<ap>
    <b>1.</b> The character or string of characters to be deleted.  Smart parameters are supported.<br/>
		<b>2.</b> A number indicating the starting index within the string to start deletion.  If this parameter
    is blank or is not a number, the starting index value will default to the first position in the string.<br/>
		<b>3.</b> The number of times the character or character string is to be deleted from the 
    value. The default is "1" and  "*" deletes all instances.
  </ap>
  <h>Deletes specific characters from the current Field object's captured value.
     Deleting a comma requires the use of a smart paramter as shown in the example.
    <e>
      <b>DeleteSelectedChars("-, ,*")</b><br/>
      223-56-7669 becomes 223567669<br/><br/>
      
      <b>DeleteSelectedChars("-,5,*")</b><br/>
      223-86-7669 becomes 223-867669<br/><br/>

      <b>DeleteSelectedChars("@CHR(44),,2")</b><br/>
      "Hello, Roger, Tom, and Jan" becomes "Hello Roger Tom, and Jan"<br/><br/>

      <b>DeleteSelectedChars("er+@CHR(44),,*")</b><br/>
      "Hello, Roger, Tom, and Jan" becomes "Hello, Rog Tom, and Jan"
    </e>	
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see><scr>DeleteAllAlpha, DeleteAllMiscChars, DeleteAllNumeric, DeleteAllPunct</scr></see>	
</ref>
<ref id="DeleteAllAlpha">
  <ap>None.</ap>
  <h>Deletes all alphabetic characters from the current Field object's captured value. 
    <e>
      <b>DeleteAllAlpha()</b><br/><br/>
      JAN2003 becomes 2003
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see><scr>DeleteSelectedChars, DeleteAllMiscChars, DeleteAllNumeric, DeleteAllPunct</scr></see>
</ref>  
<ref id="DeleteAllNumeric">
  <ap>None.</ap>
  <h>Removes all Numeric characters from the current Field object's captured value. 
    <e>
      <b>DeleteAllNumeric()</b><br/><br/> 

      JAN2003 becomes JAN
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see><scr>DeleteAllAlpha, DeleteSelectedChars, DeleteAllMiscChars, DeleteAllPunct</scr></see>
</ref>  
<ref id="DeleteAllPunct">
  <ap>None.</ap>  
  <h>
    Removes all characters with ASCII values 33-47,58-64,91-96, and 123-191 from the 
    current Field object's captured value. 
    <e><b>DatePUNCT()</b> 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see><scr>DeleteAllAlpha, DeleteSelectedChars, DeleteAllMiscChars, DeleteAllNumeric</scr></see>
</ref>  
<ref id="DeleteAllMiscChars">
  <ap>None.</ap>
  <h>Removes all UNICODE Symbol Category characters from the current Field object's captured value.
    <e>
      <b>DeleteAllMiscChars()</b><br/><br/>
      '100¢ = $1' becomes '100  1'
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
  <see><scr>DeleteAllAlpha, DeleteSelectedChars, 	DeleteAllMiscChars, DeleteAllNumeric</scr></see>
</ref>  
<ref id="DeleteAllSysChars">	
  <ap>None.</ap>
  <h>
    The action removes all characters with ASCII values 0 through 31 from the current 
    <b>Field </b>object's captured value.
    <e>
      <b>DeleteAllSysChars()</b><br/><br/>
      A field containing <i>Hello Dolly</i> will become <i>HelloDolly.</i> 
    </e>	
  </h>
  <lvl>Field only.</lvl>
  <ret>True.</ret>
</ref>
<ref id="FilterFieldSelectedChars">
  <ap>
    A String containing the character(s) to be removed.<br/><br/>

    Every instance of the character(s) will be removed from the captured 	value.
  </ap>
  <h>
    Removes all instances of the character(s) you enter as the parameter from the current
    Field object's captured value.
    <e>
      <b>FilterFieldSelectedChars(0)</b><br/><br/>
      11002900 becomes 1129
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
  <see><scr>DeleteSelectedChars</scr></see>
</ref>  
<ref id="ReplaceChars">
  <ap>
    <b>1.</b> The character or string of characters to be replaced; defaults to a space. SmartParameter Enabled.<br/><br/>

    <b>2.</b> The character(s) of the replacement String. SmartParameter Enabled.<br/><br/>

    <b>3.</b> The number of times replacement is to occur. The default is "1"	and  "*" replaces all instances.
  </ap>
  <h>
    Replaces a character or string of characters in the current Field object's captured value with a String you enter as one of the parameters.
    <e>
      <b>ReplaceChars(".,/,*")</b><br/><br/>

      01.02.2005 becomes 01/02/2005
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>

<ref id="AllowOnlyChars">
  <ap>A value that specifies permitted characters in the current word.</ap>
  <h>This action identifies <b><i>and</i></b>removes all characters NOT in the parameter from the Field's value.<br/><br/>
    Note: An empty argument will remove ALL characters.
    <e>
      AllowOnlyChars("ABCDEFG.")<br/><br/>
      HELLO DOLLY. becomes ED.</e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False,</b> if called on the wrong level.  Otherwise <b>True.</b>
  </ret>
</ref>
<ref id="DateStampField">
  <ap>A Date format such as mm/dd/yy or dd/mm/yy.  (* defaults to 	mm/dd/yyyy)<br/>
      Smart parameters are supported.
  </ap>
  <h>Updates the current Field object with today's date.  Only the Gregorian calendar is supported.
    <e>
      <b>DateStampField("*")</b> produces<br/>      
      01/20/2005<br/><br/>
      
      <b>DateStampField("dd/mm/yy")</b> produces<br/>
      20/01/05 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
<ref id="TimeStampField">
  <ap>
    A time format (for example, HH:MM:SS, or HH:MM.)<br/><br/>

    * defaults to HH:MM:SS<br/>
    Smart parameters are supported.
  </ap>
  <h>Updates the current Field object with the current time.
    <e>
      <b>TimeStampField("*")</b> produces<br/>
      09:20:02<br/><br/>

     <b>TimeStampField("HH:MM")</b> produces<br/>
     09:20 
	</e>
</h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
  <see><scr>DateStampField</scr></see>
</ref>
<ref id="SetIsOverrideable">
  <ap>None.</ap>
  <h>
    Specifies that if the validation fails for the current object, If it is non-overrideable 
    or overrideable by the user.<br/><br/>

    <b>Important!</b> This status may prevent an operator from overriding a field's validations 
    and then continuing to subsequent pages. 
    <e>
      <b>SetIsOverrideable("False")</b><br/>
      IsFieldPercentNumeric("100")<br/><br/>

      In this sequence, if the field's captured value is not 100% Numeric, an operator 
      cannot override a Validation rule's subsequent rejection of the value. 
   </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
<ref id="IsFieldDateUpToToday">
  <ap>None.</ap>
  <h>Checks that the current Field object's Date value is today's date or	earlier. 
    <e>
      <scr>IsFieldDate()</scr><br/>
      <b>IsFieldDateUpToToday()</b><br/><br/>

      This sequence confirms that a value is a date and that it is the same as, or earlier than, today's date. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the field's value is not a valid date or if the date is after "Today". Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsFieldDate, DateStampField</scr></see>
</ref>
<ref id="IsFieldDateWithinXDays">
  <ap>A number <var>n</var> that specifies how many days make up the review period.  Smart parameters are supported.</ap>
  <h>Checks that current Field object's captured Date value is within <var>n</var> days of 
  the number entered as a parameter.
    <e>
      <scr>IsFieldDate()</scr><br/>
      <b>IsFieldDateWithinXDays("30")</b><br/><br/>
      This sequence checks that a value is a date within 30 days of today's date. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b>if the field's value is not a valid date or if the date is
    older than the number of days in the parameter; otherwise, <b>True.</b>
  </ret>
  <see><scr>IsFieldDate, IsFieldDateUpToToday</scr></see>
</ref>
<ref id="IsFieldDateWithinRange">
  <ap>
    Comma-separated Dates that define the range:<br/>
    <b>1.</b> Start Date<br/>
    <b>2.</b> End Date<br/><br/>

    TODAY can represent the current Date.  Smart parameters are supported.</ap>
  <h>Checks that the value assigned to the Text property of the bound object 	is a valid Date. If so, the action confirms that the Date is within the 	range specified by the parameters. 
	  <e>
      <b>IsFieldDateWithinRange("1/1/2006, 1/31/2006")</b><br/>
	    <b>IsFieldDateWithinRange("1/1/2006,TODAY")</b>
	  </e>
  </h>
  <lvl>All, but generally at the Field Level.</lvl>
  <ret>
    <b>False</b> if the value assigned to the current object's Text property is not a valid date;
    if either parameters is invalid; or the Text property's Date value is not within the range
    specified by the parameters.  Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="MessageBox">
  <ap>The message you want to display to the Data Entry operator.  Smart parameters are supported.</ap>
  <h>
     * This Action has been Deprecated and this functionality is no longer supported. *
    
    Causes a Message Box with two buttons, labeled "Yes" and "No," to appear on the operator's 
    screen during the Verification task, and displays a message you enter as the parameter.<br/><br/>  

    <b>Alert!</b> This action should only be placed in a rule that is run interactively. 
    If a background station runs this rule, it will stop processing until a user responds to the message box.<br/><br/>

    If the Data Entry operator clicks on the Yes button in the Message Box, 	
    the action returns <b>True</b> and the rule continues.  If the 	
    operator chooses the No button, the action returns False and the rule fails. 
    <e>
      IsFieldEmpty("Date")<br/> 
      <b>MessageBox("Date missing! Do you want to Continue?")</b><br/><br/> 

      After checking to be sure the Date field does not have a value, the 		
      MessageBox action issues a warning, and asks the operator to respond 		
      by clicking on the Yes or No button. 
    </e>
</h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the current task is not interactive - or if the operator clicks on the
    Message Box's No button. Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="IsFieldDateWithReformat">
  <ap>
    The Date format you want to use.<br/><br/>

    mm/dd/yyyy<br/>
    mm/dd/yy<br/>
    dd/mm/yy<br/>
    mm.dd.yy, etc.
    
    Defaults to system short date format if no format or single '*' is used.  Smart parameters are supported.
    
  </ap>
  <h>
    Confirms that a field's data is a valid date and then formats its Date 
    value according to the format entered as the parameter. 
    <e>
      <b>IsFieldDateWithReformat("*")</b><br/>
      June 3, 2002 becomes 06/03/2002<br/><br/>

      <b>IsFieldDateWithReformat("mm.dd.yy")</b><br/>
      June 3, 2002 becomes 06.03.02 
    </e>	
</h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter is invalid, or the current field value is not a valid date given the specified format.  Otherwise <b>True.</b>
  </ret>
</ref>
<ref id="IsFieldCurrency">
  <ap>None.</ap>
  <h>
    Determines if the Field's captured value meets the current locale's currency format,
    including the number of decimal places, decimal and digit separator characters and 
    any present currency indicators.
	  <e>
      <b>IsFieldCurrency()</b><br/><br/>
	    $1,200 returns <b>False</b><br/> 
	    $1,200.00 returns <b>True</b>
	  </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the current locale's format criteria are met. Otherwise, <b>False.</b>
  </ret>
</ref>
<ref id="FailRuleSet">
  <ap>None.</ap>
  <h>
    <b>This action has been deprecated and is expected to be removed in a future release.</b><br/>
    GoToNextFunction in the rrunnner library replaces FailRuleSet.<br/><br/>
    
    Causes the entire RuleSet to fail. 
  <e>
    IsFieldMatching("False")<br/>
    <b>FailRuleSet()</b> 
  </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>False.</b>
  </ret>
</ref>
<ref id="IsFieldMatching">
	<ap>The value to be checked against the Field object's value.</ap>
	<h>Determines if the value entered as the parameter is identical to the captured value of the current Field object. 
		<e>If the Field object's value is 525.00<br/><br/>
      <b>IsFieldMatching("525.00")</b> returns <b>True</b>
      <b>IsFieldMatching("525")</b> returns <b>False</b> 
		</e>
	</h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the action's requirement is met. Otherwise, <b>False.</b>
  </ret>
  <see><scr>IsFieldPercentAlpha, IsFieldPercentNumeric</scr></see>
	</ref>
<ref id="CopyFieldToField">
  <ap>The name of the target Field object of the Document Hierarchy.</ap>
  <h>
    Copies the captured value of the current Field object to the Field object designated as the action's parameter. 
    <e>
      If the current field's value is "1/1/05"<br/><br/>

      <b>CopyFieldToField("Date")</b><br/><br/>

      assigns "1/1/05" (without the quotation marks) to the Document Hierarchy's Date field. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter does not match a Field object's name. Otherwise, <b>True.</b>
  </ret>
  <see><scr>CopyField</scr></see>
</ref>
<ref id="AppendToField">
  <ap>The name of the Field object to which the value is to be 	appended.</ap>
  <h>
    Appends the captured value of the current Field object to the captured value of the 
    Field object specified by the parameter.
    <e>
      <b>AppendToField("FirstName")</b><br/><br/>

      If the current Field object is MiddleInitial, a rule with this action would 
      append the value of the Middle Initial field to the FirstName Field object. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter is not a Field object's name. Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="AppendFromField">
  <ap>The name of the Field object whose text value is to be appended to the 	current field's value.</ap>
  <h>
    Appends the captured value of the specified Field object to the
    captured value of the current Field object.  You can also apply this 	
    action at the Page level.  A Text page-level variable with the appended 	
    value will be added to the page's Data file. 
    <e>
      <b>AppendFromField("Number")</b> 
    </e>
  </h>
  <lvl>Page or Field Level.</lvl>
  <ret>
    <b>False</b> if the parameter is not a Field object's name. Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="ReadFieldValue">
  <ap>The name of the source Field object.</ap>
  <h>
    <b>This action has been deprecated</b> and is expected to be removed in a future release.<br/>
    ReadFieldValue has been replaced by rrSet.<br/><br/>
    
    Retrieves the captured value from a sibling Field object specified as 	
    the parameter, and assigns the value to the current Field object.  
    If the action is not bound at the Field level, then a variable called Text will be 
    created in the current object, and the found value will be written to this variable.
    <e>
      <b>ReadFieldValue("Date")</b><br/><br/>

      This action assigns the captured value in the Date field to the working fingerprint's current field.<br/><br/>

      In the future use:<br/>
      <b>rrSet("@P\Date","@F")</b><br/>
      If bound to the current field it sets the value of the current field<br/>
      to the value of its sibling field "Date".<br/>


    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter does not match a Field object's name. Otherwise, <b>True.</b>
  </ret>
  <see><scr>CopyField</scr></see>
</ref>
<ref id="CopyField">
  <ap>The name of the target Field object.</ap>
  <h>Assigns the current Field object's captured value to a sibling Field object you specify as the parameter.
    <e>
      <b>CopyField("Date")</b><br/><br/>

      This action places the captured value of the current field into the Date field. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter does not match a Field object's name. Otherwise, <b>True.</b>
  </ret>
  <see><scr>GetFieldValue</scr></see>
</ref>
<ref id="EmptyFieldValue">
  <ap>The name of the Field object that is to be emptied.</ap>
  <h>
    Clears the text value in the field represented by the Field object of the 
    Document Hierarchy specified by the parameter.
  </h>
  <lvl>Page or Field level.</lvl>
  <ret>
    <b>False</b> if the field specified by the parameter does not exist.  Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="IsFieldGreaterOrEqual">
  <ap>The Numeric or Currency value which is the basis for comparison.  Smart parameters are supported.</ap>
  <h>Determines if the captured value of the current Field object is greater than (or equal to) the value entered as a parameter. If the field's value is not Numeric or currency, the action will return a <b>False</b> condition.
    <e>
      <b>IsFieldGreaterOrEqual("624")</b><br/>
      Returns <b>True</b> if the Field object's value is 625.00<br/>
      Returns <b>False</b> if the value is 623.99.<br/>
      Returns <b>True</b> if the value is 624.00. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter or Field object's captured value is not Numeric - or if the
    result does not meet the action's requirements. Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsFieldLessOrEqual</scr></see>
</ref>
<ref id="IsFieldLessOrEqual">
  <ap>The Numeric or Currency value you want to compare against. Smart parameters are supported.</ap>
  <h>
    Determines if the captured value of the current Field object is less than (or equal to) 
    the value entered as a parameter.  If the field's value is not Numeric or Currency, the 
    action will return a <b>False</b> condition.
    <e>
      <b>IsFieldLessOrEqual("625")</b><br/>
      Returns <b>True</b> if the Field object's value is 624.99<br/>
      Returns <b>False</b> if the value is 625.01<br/>
      Returns <b>True</b> if the value is 625.00 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter or Field object's captured value is not Numeric - 
    or if the result does not meet the action's requirements. Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsFieldGreaterOrEqual</scr></see>
</ref>
<ref id="InsertDecimalPoint">
  <ap>A number <var>n</var> indicating the character position at which to place the decimal. Smart parameters are supported.</ap>
  <h>
    Places a decimal character in the captured value, at the character position specified as a parameter.
    The parameter indicates the position of the decimal point, moving from right to left.
    <e>
      <b>InsertDecimalPoint("2")</b><br/>
      324556 becomes 3245.56<br/><br/> 
      
      <b>InsertDecimalPoint("2")</b><br/>
      355 becomes 3.55
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  <ref id="Calculate">
    <h>
      This Action has been marked for Deprecation and will removed in a future release. It has been replaced with Action <b>CalculateFields</b>.
    </h>
  </ref>
  <ref id="CalculateFields">
  <ap>
    <b>1.</b>The equation that is the basis for the calculation.<br/>
	  You can use a Field object's name or numeric values with any arithmetic operator (+,-,*,/,^). 
    To use a Field object's name, surround the field name with single quotation marks (').  
    A null is treated as a "0".<br/>
    <b>2.</b>The number of decimal places to limit the logical comparison.(Optional)<br/>
    <b>3.</b>A True/<b>False</b>(Default) operator to toggle Failure of all associated fields if the calculation fails. (Optional)<br/>
</ap>
  <h>
    Calculates the equation entered as a parameter and compares the result to the current Field object's captured value.<br/><br/>

    <b>Note:</b> If the result does not match the equation's result, dependant fields (fields involved in the 
    equation) will receive a Failed status and will appear pink in the applicable field of the Data Entry panel. <br/><br/>
    
    If the results of a previously failed CalculateFields call are corrected by a user, such that the calculation no longer returns false, dependant fields that 
    were set to status Failed by the CalculateFields action will be updated to status Pass. <br/><br/>

    It is likely that dependant fields could have their statuses updated via other rules and actions, so it is important when configuring your application to propery stage,
    and sequence your validations action logic to work in tandem with the CalculateFields action.
    
	  <e>
      <b>CalculateFields("'SubTotal' + 'Shipping' + 'Tax' = 'Total'")</b><br/>
      or<br/>
      <b>CalculateFields("('SubTotal' + 'Shipping' + 'Tax') - '0.05' = 'Total'")</b><br/><br/>
      
      for use with a 'tolerance' use two actions in sequence:<br/>
      <b>CalculateFields("('Wages' + 'Interest' + 'Unemployment')&gt;=('Gross'-'.05')")</b><br/>
      <b>CalculateFields("('Wages' + 'Interest' + 'Unemployment')&lt;=('Gross'+'.05')")</b><br/>
    </e>    
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the expression evaluates to True. <br/>
    <b>False</b> if the expression evaluates to False or the expression is not valid (eg. a field's value is not numeric).
  </ret>
</ref>
<ref id="IsFieldEmpty">
  <ap>The Field object's name.</ap>
  <h>Checks if the Field object designated as a parameter does not  have a captured value.
  <e>
    <b>IsFieldEmpty("Shipping")</b><br/>
    <scr>AssignFieldDefault("NoShipping")</scr><br/><br/>
	
    In this example, if the Shipping Field object's captured value is $921.11, this action will 
    return a <b>False</b> condition and therefore terminate the rule.<br/><br/>
	
    If the Shipping Field object does not have a value (<b>True</b>), the AssignFieldDefault action 
    enters its parameter ("NoShipping") as the Field object's captured value.  
  </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the Field object's name does not exist - or if the field contains a captured value. Otherwise, <b>True.</b>
  </ret>
  <see><scr>AssignFieldDefault, IsFieldFilled</scr></see>
</ref>
<ref id="IsFieldFilled">
  <ap>The name of the Field object.</ap>
  <h>Determines whether the Field object designated as a parameter contains a captured value or is empty. 
	  <e>
      <b>IsFieldFilled("PaymentDue")</b><br/><br/>

	    If the action returns <b>True</b> - if the field does contain a value - the rule invokes its next action. If the action returns <b>False</b>, the rule closes and the task applies the next 			rule, which might include a <scr>CopyFieldToField</scr> action. 
	  </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the Field object's name does not exist - or if the field does not contain a captured value. Otherwise, <b>True.</b>
  </ret>
  <see><scr>AssignFieldDefault, IsFieldEmpty</scr></see>
</ref>
<ref id="CheckSubFields">
	<ap>
    An "expression" that specifies which LINEITEM child fields are to be checked for the presence or absence 
    of captured values. Within the expression, each child Field object's name needs to be surrounded 
    with single quotation marks ('). You can also use parentheses () in your expression. Action is placed on the
    parent of the LINEITEM field.
  </ap>
	<h>Validates an instance of a parent Field object by confirming the presence (or absence) of 
     captured values for one or more of its child fields. (In the Invoices application, as an example, 
     child fields of the LINEITEM parent include: ItemID, ItemDesc, Quantity, Price and LineTotal.)
     <br/><br/>
	   Invalid parent Field objects are deleted if they do not meet this criteria.<br/><br/>
	   This action usually runs in its own RuleSet (for example, in a Filter RuleSet) and would be applied 
     to the DETAILS Field object (parent object to the LINEITEM field) in the Invoices example.
		<e><b>Example 1:</b> The captured values for a LINEITEM field are:<br/> 
       ItemID = 12345<br/>
       ItemDesc =<br/>
       Price = 12.00<br/>
       LineTotal = <br/><br/>

       The action's parameter contains this expression:<br/> 
       <b>CheckSubFields("('ItemID' OR 'ItemDesc') AND ('Price' OR 'LineTotal')")</b><br/><br/>

       In this example the action returns <b>True</b> and the current 	LINEITEM object is Valid.<br/><br/>

       <b>Example 2:</b> The captured values for the LINEITEM field are:<br/> 
       ItemID = 12345<br/>
       ItemDesc = Thank you for your order<br/>
       Price =<br/>
       LineTotal = <br/><br/>

       The action's parameter contains this expression:<br/>
       <b>CheckSubFields("('ItemID' OR 'ItemDesc') AND ('Price' OR 'LineTotal')")</b><br/><br/>

       In this example the action's equation returns is <b>False</b> and the current LINEITEM 
       object is Invalid. The field and the values of its child fields are deleted from the Data file.<br/><br/>

       <b>Example 3:</b>  The captured values for the LINEITEM field are:<br/>
       ItemID = 12345<br/>
       LineTotal = gonetolunch<br/><br/>

       The action's parameter contains this expression:<br/>
       <b>CheckSubFields("('ItemID') AND ('LineTotal')")</b><br/><br/>

       In this case, the action returns <b>True</b> and validates the LINEITEM field - despite the 
       presence of a nonsense entry in the LineTotal child field! 
		</e>
	</h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
<ref id="SumFields">
  <ap>String value of a Field object's Type property or the name of a variable.</ap>
  <h>Sums captured values of any "child" Field if a child object's Type property is identical to the Type you specify as a parameter.<br/><br/>

	Alternatively, the actions sums values assigned to a variable of the child Field objects - a variable which is the same as the variable entered as a	parameter.<br/><br/>

	<b>Remember:</b> This action must be applied to the parent object. 
		<e>
      <b>SumFields("Detail")</b><br/><br/>

		  <b>SumFields("LineTotal")</b><br/><br/>

		The first action above sums the captured values of Detail Field objects which are children of the current Field object.<br/><br/>

		The second action sums values assigned to the LineTotal variable of child Field objects.<br/><br/>

		The result, in both cases, is a Long number. 
		</e>
	</h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
<ref id="ResetField">
  <ap>None.</ap>
  <h>
    This action deletes the selected Field object's captured value, and sets the field's <b>Position</b>
    attribute to 0,0,0,0.<br/><br/>
    
    Note, however, that the action does not clear any Alt-Text values 
    associated with the bound <b>Field</b>object. (Typically, that is the responsibility of a 
    <b>ClearAltText</b>action.)
    <e>
      <b>ResetField()</b><br/><br/>

      This action typically belongs to a follow-up Validate rule that deals with a <b>False</b> response to 
      an action such as IsDate() in the previous rule. If the field's value is not a date (in this example), 
      the <b>ResetField</b> action will remove the value that is there. <b>Note:</b>It will also set the 
      field's <b>Position</b> attribute to 0,0,0,0.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if not called on the field level.  Otherwise, <b>True.</b>
  </ret>
  </ref>
<ref id="SaveAsCurrentObjVariable">
  <ap>
    <b>1.</b> The name of the variable<br/>
    <b>2.</b> The String value to be assigned.<br/><br/>

    These are comma-separated parameters, and the second is optional. If you do not include this parameter,
    the action will automatically assign the captured value of the selected Field object to the variable.
  </ap>
  <h>
    <b>This action has been deprecated</b> and is expected to be removed in a future release.<br/>
    SaveAsCurrentObjVariable has been replaced by rrSet.<br/>
    Use the @F smart variable to access the current field value.
    <e>
      In the future use:<br/>
      <b>rrSet("@F","@F.Variable")</b><br/>
      Sets the value of the current fields variable called "Variable" to the value of the current field.<br/>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
<ref id="ReadCurrentObjVariable">
  <ap>The name of the bound object's property or variable.</ap>
  <h>
    <b>This action has been deprecated</b> and is expected to be removed in a future release.<br/>
    ReadCurrentObjVariable has been replaced by rrSet.<br/><br/>

    Reads the Text value of the bound object of the Document Hierarchy.<br/><br/>

    For a Field object, this is the value of the object's Text property. For objects at other levels, the value is in a runtime variable of the bound object (see the examples).<br/><br/>

    <e>
      <b>ReadCurrentObjVariable("Text")</b>
      <br/>
      <br/>

      <b>ReadCurrentObjVariable("TemplateID")</b><br/><br/>

      In the future use:<br/>
      <b>rrSet("@P.TemplateID","@P\FieldName")</b><br/>
      Sets the value of the variable "TemplateID" to the<br/>
      Field DCO object "FieldName".<br/>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the property or variable specified by the parameter is not found.  Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="SaveAsPageVariable">
  <ap>
    <b>1.</b> The name of the variable<br/>
    <b>2.</b>The String value to be assigned.<br/><br/>

    These are comma-separated parameters, and the second is optional. If you do not include this parameter, 
    the action will automatically assign the Text property of the calling object to the variable.
  </ap>
  <h>
    <b>This action has been deprecated</b> and is expected to be removed in a future release.<br/>
    SaveAsPageVariable has been replaced by rrSet.<br/><br/>
    
    Assigns a value to a variable of the current Page object.<br/><br/>
    
    
    <e>
      <b>SaveAsPageVariable("Amount")</b><br/><br/>

      <b>SaveAsPageVariable("Amount,15000")</b><br/><br/>

      The first example assigns the captured value of the current Field object to the current Page's Amount
      variable. The second example assigns "15000" to the variable.<br/><br/>

      In the future use:<br/>
      <b>rrSet("@F","@P.Variable")</b><br/>
      Sets the value of the current page variable called "Variable" to the value of the current field.<br/>
    </e>
  </h>
  <lvl>Page or Field Level.</lvl>
  <ret>
    <b>False</b> if the parent page cannot be found.  Otherwise, <b>True.</b>
  </ret>
  <see><scr>ReadPageVariableValue</scr></see>
</ref>
<ref id="ReadPageVariableValue">
  <ap>The name of the Page object's variable.</ap>
  <h>
    <b>This action has been deprecated</b> and is expected to be removed in a future release.<br/>
    ReadPageVariableValue has been replaced by rrSet.<br/><br/>
    
    Assigns the value of a variable of the Page object to the selected Field object. If the action is not placed at the field level, then a variable called Text will be created in the current object, and the found value will be written to this variable.
    <e>
      <b>ReadPageVariableValue("FieldCount")</b><br/><br/>

      A Validate rule with this action could transfer the number of fields in the Page object 
      that is the "parent" of a selected Field object such as TotalFields.<br/><br/>

      <b>Important!</b> A Document Hierarchy may well include multiple Page objects and certain 
      variables that are the same for both pages. This action refers to variables of the Page 
      object to which the selected Field object belongs.<br/><br/>

      In the future use:<br/>
      <b>rrSet("@P.FieldCount","@F")</b><br/>
      If bound to the current field it sets the current field to the value of the page variable "FieldCount".<br/>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter is not a valid Page-level variable; otherwise, <b>True.</b>
  </ret>
  <see><scr>ReadBatchVariableValue, ReadDocumentVariableValue</scr></see>
</ref>
<ref id="ConvertToUpperCase">
  <ap>None.</ap>
  <h>Converts the lower case characters in a Field object's captured value to Upper Case characters. 
  <e>
    <b>ConvertToUpperCase()</b><br/><br/>

    A Validate rule with this action, if applied to a State Field object which accepts only abbreviations, 
    would be sure the captured values contain Upper Case letters (AZ, AL, etc.) 
  </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
  <see><scr>ConvertToLowerCase</scr></see>
</ref>
<ref id="ConvertToLowerCase">
  <ap>None.</ap>
  <h>Converts any Upper Case characters in a Field object's captured value to lower case characters. 
    <e>
      <b>ConvertToLowerCase()</b><br/><br/>

      To ensure that the characters in all Product ID's are lower case, a Validate rule that applies to a Document Hierarchy's Item Field object would include this action. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
  <see><scr>ConvertToUpperCase</scr></see>
</ref>
<ref id="SplitFieldValueRight">
  <ap></ap>
  <h>
    This action has been depricated and is expected to be removed in a future release.
    SplitFieldValueRight has been replaced by SplitFieldValuePreserveEnd.
  </h>
  <lvl></lvl>
  <ret>
  </ret>
</ref>  
<ref id="SplitFieldValuePreserveEnd">
  <ap>String value of the separating character. SmartParameter Enabled.</ap>
  <h>
    Splits a Field object's captured value at the first instance of the character specified as a parameter.<br/><br/>

    The action deletes all characters prior to the separating character, as well as the separation character.
    All text after the separating character remains. 
    <e>
      <b>SplitFieldValuePreserveEnd("=")</b><br/><br/>

      If the object's value is "InvNumber=A1234," this action truncates it to "A1234".  
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret><b>True</b> if the separator character is found. Otherwise <b>False.</b>
</ret>
  <see><scr>SplitFieldValuePreserveStart</scr></see>
</ref>
<ref id="SplitFieldValueLeft">
  <ap></ap>
  <h>
    This action has been depricated and is expected to be removed in a future release.
    SplitFieldValueLeft has been replaced by SplitFieldValuePreserveStart.
  </h>
  <lvl></lvl>
  <ret>
  </ret>
</ref>  
<ref id="SplitFieldValuePreserveStart">
  <ap>String value of the separating character. SmartParameter Enabled.</ap>
  <h>Splits a Field object's captured value at the first instance of the character specified as a parameter.<br/><br/>

    The action deletes all characters to the end of the string starting from the separating 
    character, as well as the separation character.
    All text prior to the separating character remains.
    <e>
      <b>SplitFieldValuePreserveStart("c")</b><br/><br/>

      If the object's value is "Description," this action truncates it to "Des". 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the separator character is found. Otherwise <b>False.</b>
  </ret>
  <see><scr>SplitFieldValuePreserveEnd</scr></see>
</ref>
<ref id="IsFieldPercentNonNumeric">
  <ap>
    A number (0-100) indicating the percentage that results in a <b>True</b> condition. The default percentage is 100.
    The value must be numeric, without the percent sign.
    Smart parameters are supported.
  </ap>
  <h>Determines if any of the characters in the captured value of the current Field object are <var>n%</var> not numeric
  characters, this includes and is not limited to valid decimal and numeric separator characters.   
    <e>Given the current value is "1,234.56US"<br/><br/>
    (Percentage of non-numeric characters is 40%)
    <b>IsFieldPercentNonNumeric("0")</b> returns <b>True</b><br/><br/>
    <b>IsFieldPercentNonNumeric("30")</b> returns <b>True</b><br/><br/>
    <b>IsFieldPercentNonNumeric("40")</b> returns <b>True</b><br/><br/>
    <b>IsFieldPercentNonNumeric("70")</b> returns <b>False</b><br/><br/>  
    <b>IsFieldPercentNonNumeric("100")</b> returns <b>False</b> 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter is non-numeric, if the field is empty, or if the field's 
    value exceeds the parameter's percentage of numeric characters. Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsFieldPercentAlpha, IsFieldMatching</scr></see>
</ref>
  <ref id="IsFieldPercentNumeric">
    <ap>
      A number (0-100) indicating the percentage that results in a <b>True</b> condition. The default percentage is 100.
      The value must be numeric, without the percent sign.
      Smart parameters are supported
    </ap>
    <h>
      Determines if the characters in the captured value of the current Field object are <var>n%</var> numeric
      characters. Does not include, and is not limited to, valid decimal and numeric separator characters.
      <e>
        Given the current value is "1,234.56US"<br/><br/>
        (Percentage of numeric characters is 60%)
        <b>IsFieldPercentNumeric("0")</b> returns <b>True</b><br/><br/>
        <b>IsFieldPercentNumeric("50")</b> returns <b>True</b><br/><br/>
        <b>IsFieldPercentNumeric("60")</b> returns <b>True</b><br/><br/>
        <b>IsFieldPercentNumeric("70")</b> returns <b>False</b><br/><br/>
        <b>IsFieldPercentNumeric("100")</b> returns <b>False</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the parameter is non-numeric, if the field is empty, or if the field's
      value exceeds the parameter's percentage of numeric characters. Otherwise, <b>True.</b>
    </ret>
    <see>
      <scr>IsFieldPercentAlpha, IsFieldMatching</scr>
    </see>
  </ref>
<ref id="IsMaxOMRChecked">
  <ap>An Integer value specifying this maximum. Smart parameters are supported.</ap>
  <h>Indicates the maximum number of checkboxes that can contain a value (a check, for example). 
    <e>
      <b>IsMaxOMRChecked("1")</b> 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter you enter is not numeric, or the field is not an OMR field.<br/><br/>

    <b>True</b> if the number of OMR boxes checked is less than or equal to the parameter you entered.
  </ret>
  <see><scr>IsMinOMRChecked</scr></see>
</ref>
<ref id="IsMinOMRChecked">
  <ap>An Integer value specifying this minimum. Smart parameters are supported.</ap>
  <h>Indicates the minimum number of checkboxes that can contain a value (a check, for example).
    <e>
      <b>IsMinOMRChecked("1")</b> 
    </e>	
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameter you enter is not numeric, or the field is not an OMR field.<br/><br/>
    <b>True</b> if the number of OMR boxes checked is greater than or equal to the parameter you entered.
  </ret>
  <see><scr>IsMaxOMRChecked</scr></see>
</ref>
<ref id="CompareFields">
  <ap>Five comma-separated values:<br/><br/> 

  <b>1.</b>String value of the source field's name.  This is the field with a value to be compared.<br/><br/>

  <b>2.</b>String value of the target field's name.  This is the field with a value to be compared to.<br/><br/>

  <b>3.</b>String value: Y or Yes; N or No. Alternatively, a Numeric value: 0 = No or 1=Yes.  
  "Yes" (or Y or 1) allows the action to carry out a fuzzy rather precise comparison of the fields' values.<br/><br/>

  <b>4.</b>Numeric value of the percentage of required precision. Numbers less than 
  "100" permit increasing fuzziness.<br/><br/>

  <b>5.</b>String value: Y or Yes; N or No. Alternatively, a Numeric value: 0 = No or 1=Yes.  "Yes" (or Y or 1) directs the action to compare values in 	the fields word-by-word. 
  </ap>
  <h>Locates values in two fields specified by the first two parameters.<br/><br/>

  If values are present in both fields, the action compares the values according to the matching criteria of the last three parameters. 
  <e>
    <b>CompareFields("Invoice_Date,Due_Date,Yes,100,Yes")</b> 
  </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the designations of  Field objects in the first two parameters are not valid, or if
    the Data Types of the values in the first two fields do not match.  Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="IsThisFieldEmpty">
  <ap>None.</ap>
  <h>Confirms if the current field has no captured value. 
    <e>
      <b>IsThisFieldEmpty()</b> 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if not applied to the Field level, or if the current field has a text value.  Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsThisFieldFilled, IsFieldEmpty</scr></see>
</ref>	
<ref id="IsThisFieldFilled">
  <ap>None.</ap>
  <h>
    Confirms if the current field has a captured value.
    <e>
      <b>IsThisFieldFilled()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if not applied to the Field level, or if the current field has no text value. Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsThisFieldEmpty, IsFieldFilled</scr></see>
</ref>
<ref id="DeleteLCSpaces">
  <ap>None.</ap>
  <h>Deletes all low confidence spaces from the captured value. Uses ReqConf Setup dco variable as threshold for low confidence values; defaults to 9
  <e>
    <b>DeleteLCSpaces()</b> 
  </e>
  </h>
  <lvl>All, but generally at the Field level.</lvl>
  <ret>
    <b>False</b> if the action is unable to isolate the spaces in a field's value. Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="IsMatchingJobID">
  <ap>String value of the Job ID to be compared to the current Job ID.</ap>
  <h>Checks that the Job ID of the current User Application job matches the parameter's Job ID value. 
    <e><b>IsMatchingJobID("Main")</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>True</b> if the current Job ID matches the parameter's value. Otherwise, <b>False.</b>
  </ret>
</ref>
<ref id="GetJobID">
  <ap>None.</ap>
  <h>Assigns the Job ID of the current User Application job - the job's 	Pilot.JobID property - to the CurrentObj.Text variable of the bound object 	of the Document Hierarchy. 
    <e><b>GetJobID()</b> 
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the action cannot find a JobID value. Otherwise, <b>True.</b>
  </ret>
</ref>	
<ref id="FieldContainsValue">
  <ap>Text that the action is looking for in the current field. Smart parameters are supported.</ap>
  <h>
    This action determines if a field represented by the bound object of the 
    Document Hierarchy contains some or all of the parameter's text value, without additional unspecified text. 
    <e>
      <b>FieldContainsValue("NEW")</b><br/><br/>
      Parameter: "NEW" = TRUE<br/>
      Parameter: "NEW Action" = TRUE<br/>
      Parameter: "Project" = FALSE<br/>
      Parameter: "NEW Project" = TRUE<br/>
      Parameter: "Development" = FALSE 
    </e>
  </h>
  <lvl>All, but generally at the Field level.</lvl>
  <ret>
    <b>False</b> if the object's <b>CurrentObj.Text</b>variable does not contain the parameter's value. Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="DeleteChildType">
  <ap>
    String value of the child object Type. <br/><br/>
    "Field", for example, will eliminate all <b>Field</b> objects. In the <i>Invoices</i> 
    application, however, "LineItem" will remove child fields of the parent <i>Details</i> 
    parent <b>Field</b> object. 
  </ap>
  <h>
    Deletes child objects of the type you designate as a parameter from the Document Hierarchy.
    <e>
      <b>DeleteChildType("Field")</b>
    </e>	
  </h>
  <lvl>All except Batch.</lvl>
  <ret>
    <b>False</b> if the child objects do not exist. Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="ParseName">	
  <ap>Three comma separated parameters:<br/>
    <b>1.</b> The name of the Last Name Field object.<br/>
    <b>2.</b> The name of the First Name Field object.<br/>
    <b>3.</b> The name of the Middle Name or Middle Initial Field object.
  </ap>
  <h>
    Parses a name Field object's captured value.<br/><br/>

    Applied to a "Name" field, the action will parse the Last, First, and Middle names into the fields specified by the parameter. 
    <e><b>ParseName("LastName,FirstName,MidName")</b><br/><br/>

    Bound to a Name Field object which includes values for all three names, the action will place the Last name into the "LastName" 	field, the First name into the "FirstName" field, and the Middle name (or middle initial) into the "MidName" field. 
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if not placed at the Field level; if the current field contains no data; 
    or if the parameters are invalid.  Otherwise, <b>True.</b>
  </ret>
  <see><scr>ParseMultilineAddress</scr></see>
</ref>

<ref id="ParseMultilineAddress">
  <ap>
    Comma-separated Smart Parameter String values of the names of fields which will hold the
    parsed data, in the following order:<br/><br/>

    Name, AddressLine1, AddressLine2, City , State , Zip , Phone
  </ap>
  <h>
    Parses a multiline U.S. address Field object's captured value.<br/><br/>
    
    Comma-separated String values of the names of fields which will hold the parsed data,
    in the following order: Name, AddressLine1, AddressLine2, City, State, Zip, Phone.
    Example below assumes fields are sibling fields of the calling object. For other relationships
    please review smart parameter syntax.<br/><br/>

    <b>Expected Pattern:</b><br/><br/>   
    Phone Number (optional)<br/>
    Name<br/>
    Address Line One<br/>
    Address Line Two (optional)<br/>
    City, State, Zip code <br/>
    Phone Number (optional)<br/><br/>    
        
    NOTE: Parsing logic assumes State and Zip are on the same address line. Only one Phone number per address 
    field is supported, the expected pattern shows the two optional positions for this value.
    <e>
      <b>ParseMultilineAddress("VendorName,VenAddress1,VenAddress2,VenCity,VenState,VenZip,VenPhone")</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the parameters are invalid, or parsing cannot take place.  Otherwise, <b>True.</b><br/>
  </ret>
</ref>
<ref id="IsVariableEmpty">
	<ap>Name of the current object's variable to be checked.</ap>
	<h>Confirms if the variable specified by the parameter does not contain a value.  This action only checks variables of the current object. 
		<e><b>IsVariableEmpty("TemplateID")</b> 
		</e>
	</h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter is invalid, or if the variable contains a value.  Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsVariableFilled</scr></see>
</ref>
<ref id="IsVariableFilled">
  <ap>Name of the current object's variable to be checked.</ap>
  <h>
    Confirms if the variable specified by the parameter contains a value.  This action 
    only checks variables of the current object.
    <e>
      <b>IsVariableFilled("TemplateID")</b>
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the parameter is invalid, or if the variable does not contain a value. Otherwise, <b>True.</b>
  </ret>
  <see><scr>IsVariableEmpty</scr></see>
</ref>

<ref id="HasChildOfType">
  <ap>The name of a level of the Document Hierarchy (Batch, Document, Page, Field) or of a runtime variable.</ap>
  <h>
    Determines if the bound object of the Document Hierarchy has a child or children of the type specified by the parameter. The action can also determine if a runtime variable specified as a parameter has been assigned to the bound object.
    <e>
      <b>HasChildOfType("Page")</b><br/><br/>

      This example determines if the bound object is the parent of one or more pages.<br/><br/>

      <b>HasChildOfType("IGNORE")</b><br/><br/>

      In this example, the action determines if IGNORE is a runtime variable of the bound object.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    <b>False</b> if the bound object does not include a child or children specified by the parameter, or a variable identified by the parameter.  Otherwise, <b>True.</b>
  </ret>
</ref>
<ref id="DeleteParentObj">
  <ap>None.</ap>
  <h>Deletes the parent of the Document Hierarchy object to which a rule with this action is bound. 
    <e><b>DeleteParentObj()</b> 
    </e>
  </h>
  <lvl>Document, Page, and Field.</lvl>
  <ret>
    <b>False</b> if a parent or grandparent object cannot be found, or if the deletion 
    of the parent object fails.  Otherwise, <b>True.</b>
  </ret>
</ref>  
<ref id="IsPatternInField">
	<ap>
    String value of the Regular Expression. The expression can include any Regular Expression characters.  Smart parameters are supported.
  </ap>
  <h>Uses VBScript Regular Expression Pattern entered as parameter to search for a matching pattern in 
     current object's Text value.<br/><br/>
     Note: If you are using an input boundary, ^, it must be followed by a space and then the remainder
     of the search string.
    <e>
       <b>IsPatternInField("[\^\b\s\n\r]*Inv[oO0][iItl1]ce[\b\s]*")</b><br/>
       <b>IsPatternInField("@STRING([\^\b\s\n\r]*Inv[oO0][iItl1]ce[\b\s]*)")</b>
      <br/><br/>
      This example searches for the word “Invoice” in the current field.
      To allow for recognition errors, the search allows for common recognition 
      substitutions in “o” and “i” by matching “Invoice”, “InvOice”, “Inv0ice”, 
      “Inv01ce”, “Involce”, etc.  The search will also ignore any text placed before or after the word.
      Encapsulating the parameter with @STRING is recommended when the value is not a Smart Parameter.
    </e>
  </h>
  <lvl>All, but generally at the Field level.</lvl>
  <ret>
    <b>True</b> if the pattern is found within the field.  Otherwise, <b>False.</b>
  </ret>
</ref>
<ref id="ConvertFieldToCurrency">
	<ap>None.</ap>
	<h>Formats a field's text value as a currency value.  The following steps are performed on the field:<br/>
    <br/>   
     1. Removes existing currency symbols.<br/>
     2. Replaces negative value characters such as parenthesis, 'NEG', 'CR' and trailing hyphen 
     with a leading hyphen.<br/>
     3. If a decimal exists, its position is not changed.<br/>
     4. If a decimal does not exist and the field contains 2 or more characters, a decimal is inserted 
     before the last two characters in the field.<br/>
     5. If a decimal does not exist and the field contains less than 2 characters, no decimal is inserted.
    <br/>
		<e><b>ConvertFieldToCurrency()</b><br/>
      A value of <b>1</b> remains <b>1</b><br/>
      A value of <b>12</b> becomes <b>.12</b><br/>
      A value of <b>105</b> becomes <b>1.05</b><br/>
      A value of <b>104.009</b> remains <b>104.009</b><br/>
    </e>
	</h>
  <lvl>All levels, but generally applied at the Field level.</lvl>
  <ret>
    <b>True</b> if the text value is numeric and greater than one character. Otherwise, <b>False</b>.
  </ret>
	</ref>
      
<ref id="IsFieldHidden">
  <ap>None.</ap>
  <h>
    Note: This action returns True if the calling field is 'Hidden'...if the corresponding <b>Field</b>object of the Document Hierarchy has a variable STATUS equal to -1.
    <e>
      <b>IsFieldHidden()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the <b>Field</b>object's STATUS = -1; Otherwise <b>False.</b>
  </ret>
</ref>

<ref id="IsSupportedImageFile">
    <ap>
      A Boolean that determines the type of test to perform.<br/><br/>

      True: Tests the validity of the image by checking the file extension and attempting to load the image.<br/>
      False: Only a file extension check is performed to determine if it is a supported file.
    </ap>
    <h>
      This action tests a file to determine if the file format is supported.  The extension is checked to
      determine if it denotes a supported image type.  If True is passed as a parameter, it also attempts to load
      the file into the Image view control.<br/><br/>
      
      Using False as a parameter will greatly improve the speed of this action.  A parameter of True will
      slow down the processing, especially if the images are very large, but it will add an extra confirmation
      that the file is not corrupted and confirm that any subformat of the file type, such as compression type, 
      is also supported.      
      <e>
        <b>IsSupportedImageFile()</b>
      </e>
    </h>
    <lvl>Page level.</lvl>
    <ret>
      <b>True,</b> if parameter is valid, the action is called at the page level and the page's IMAGEFILE variable 
      (set at scan time by the scan tasks) points to a file whose format 
      is supported (can be displayed) by the Image view control. 
      Otherwise <b>False.</b>
    </ret>
    </ref>
      
<ref id="ReplaceValueAtPosition">
  <ap>
    Two-part comma-separated value:
    <br/><br/>
    1. The position that contains the value to be replaced.<br/><br/>
    2. The replacement string; this parameter defaults to "" indicating a deletion.
  </ap>
  <h>
    This action replaces the value at a specific position with a string replacement value, or a deletion.
    <e>
      <b>ReplaceValueAtPosition("3,/")</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the character replacement is successful. Otherwise, <b>False.</b>
  </ret>
</ref>
  <ref id="FormatNumberToLocale">
    <h>
      This action evaluates the current field value for known number patterns and if a known pattern is detected,
      updates the decimal and digit separators characters (if present) to match that of the current locale,
      for use when processing fields with number types formatted incorrectly for the current locale. ie USA vs European.

      Known patterns are industry standard digits with or without 3 digit group separators, and 1-2 digits following a decimal separator.

      Distinct Analyzed groups:

      1) Numerals with decimal point
      Group Separators using comma, apostrope or space characters.
      Decimal Separator using decimal character.

      2) Numerals with decimal comma
      Group Separator using decimal, apostrope or space characters.
      Decimal Separator using comma character.

      3) Numerals with Arabic/Persian characters
      Group Separator using Arabic/Persian character.
      Decimal Separator using Arabic/Persian character.

      Note: Numerals with lakhs layout and decimal mark (pattern of n,nn,nn,nnn.dd) are not supported.
  
      <e>
        a) Given a US number 1,234.56 to be formatted to UK.<br/>
         <b>FormatNumberToLocale()</b><br/>
        New format will be 1.234,56<br/><br/>

        b) Given a US number 1234.5 to be formatted to UK.<br/>
        <b>FormatNumberToLocale()</b><br/>
        New format will be 1234,5<br/><br/>
        
        c) Given a US number 1,234.567 to be formatted to UK.<br/>
        <b>FormatNumberToLocale()</b><br/>
        Format will remain 1,234.567 since 3 digits following the decimal are not supported.<br/><br/>

        d) Given a US number 12345678.90 to be formatted to UK.<br/>
        <b>FormatNumberToLocale()</b><br/>
        New format will be 12345678.90<br/><br/>

        e) Given a UK number 1.234.567,89 to be formatted to US.<br/>
        <b>FormatNumberToLocale()</b><br/>
        New format will be 1,234,567.89<br/><br/>

        f) Given a UK number 0,5 to be formatted to US.<br/>
        <b>FormatNumberToLocale()</b><br/>
        New format will be 0.5<br/><br/>
        
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>True</b> if no errors are encountered. Otherwise, <b>False.</b>
    </ret>
  </ref>
  
</help>
</rrx>
<rrx namespace="Vote" src="c:\datacap\RRS\Vote.dll">

<i ref="rrunner">
</i>
<g>
</g>
<af name="VoteFld" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['Checks to see if the data entered for by the first Data Entry operator matches the data enter by the second Data Entry operator."]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['   Checks to see if the data entered for by the first Data Entry operator matches the]]>
<![CDATA[
]]>
<![CDATA['   data enter by the second Data Entry operator.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['   Failed (mismatched) values set the confidence for the entire string to '1', ]]>
<![CDATA[
]]>
<![CDATA['   therefore flagging the field as Low Confidence.   Positive matches set the ]]>
<![CDATA[
]]>
<![CDATA['   entire string's confidence to '9' (High Confidence).<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['   This action needs to run after the second Data Entry task has been completed.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim nLen	]]>
<![CDATA[
]]>
<![CDATA[	Dim aVal]]>
<![CDATA[
]]>
<![CDATA[	Dim aConf]]>
<![CDATA[
]]>
<![CDATA[	Dim nVal]]>
<![CDATA[
]]>
<![CDATA[	Dim nConf]]>
<![CDATA[
]]>
<![CDATA[	Dim j,i,k]]>
<![CDATA[
]]>
<![CDATA[	Dim sAllSame]]>
<![CDATA[
]]>
<![CDATA[  Dim g_nPrime]]>
<![CDATA[
]]>
<![CDATA[	Dim g_VoteType]]>
<![CDATA[
]]>
<![CDATA[	Dim g_VoteAdj]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'initial values - Note: AltText(0) is same as Text property.]]>
<![CDATA[
]]>
<![CDATA[	g_nPrime = 0]]>
<![CDATA[
]]>
<![CDATA[	g_VoteType = 0]]>
<![CDATA[
]]>
<![CDATA[	g_VoteAdj = 0]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	VoteFld = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  nLen = Len(CurrentObj.AltText(0))]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("nLen:" &nLen)	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'If Primary value is blank then use AltText(1) for length ]]>
<![CDATA[
]]>
<![CDATA[	if nLen = 0 Then nLen = Len(CurrentObj.AltText(1))]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("nLen:" &nLen)			]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If cstr(g_nPrime)<>"0" then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Primary Index is set to: " & cstr(g_nPrime))]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Redim aVal(1, nLen-1)]]>
<![CDATA[
]]>
<![CDATA[	Redim aConf(1, nLen-1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Read text & confidence Data for Primary value]]>
<![CDATA[
]]>
<![CDATA[	sVal = CurrentObj.AltText(g_nPrime)]]>
<![CDATA[
]]>
<![CDATA[	nConf = CurrentObj.AltConfidenceString(g_nPrime)]]>
<![CDATA[
]]>
<![CDATA[	WriteLog(" Primary Character string '" & sVal & "' and confidence '" & nConf & "'.")]]>
<![CDATA[
]]>
<![CDATA[	For j = 1 To nLen]]>
<![CDATA[
]]>
<![CDATA[		'check to see if length of current string is less than array length]]>
<![CDATA[
]]>
<![CDATA[		If j > Len(sVal) then]]>
<![CDATA[
]]>
<![CDATA[			aVal(0, j-1) = ""]]>
<![CDATA[
]]>
<![CDATA[			aConf(0, j-1) = 1]]>
<![CDATA[
]]>
<![CDATA[		else]]>
<![CDATA[
]]>
<![CDATA[			aVal(0, j-1) = Mid(sVal, j, 1)]]>
<![CDATA[
]]>
<![CDATA[			aConf(0, j-1) = Mid(nConf, j, 1)]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Read text & confidence Data for 1st Alt-Text ]]>
<![CDATA[
]]>
<![CDATA[	sVal = CurrentObj.AltText(1)]]>
<![CDATA[
]]>
<![CDATA[	nConf = CurrentObj.AltConfidenceString(1)]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Alternate Character string '" & sVal & "' and confidence '" & nConf & "'.")]]>
<![CDATA[
]]>
<![CDATA[	For j = 1 To nLen]]>
<![CDATA[
]]>
<![CDATA[		'check to see if length of current string is less than array Length]]>
<![CDATA[
]]>
<![CDATA[		If j > Len(sVal) then]]>
<![CDATA[
]]>
<![CDATA[			aVal(1, j-1) = ""]]>
<![CDATA[
]]>
<![CDATA[			aConf(1, j-1) = 1]]>
<![CDATA[
]]>
<![CDATA[		else]]>
<![CDATA[
]]>
<![CDATA[			aVal(1, j-1) = Mid(sVal, j, 1)]]>
<![CDATA[
]]>
<![CDATA[			aConf(1, j-1) = Mid(nConf, j, 1)]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sVal=""]]>
<![CDATA[
]]>
<![CDATA[	nConf=""	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Compare values - Primary vs. 1st Alt-Text. and update confidence accordingly.]]>
<![CDATA[
]]>
<![CDATA[	For k = 0 To nLen-1]]>
<![CDATA[
]]>
<![CDATA[		If aVal(0,k)<> aVal(1,k) Then]]>
<![CDATA[
]]>
<![CDATA[			'Character Values are different	]]>
<![CDATA[
]]>
<![CDATA[			Writelog("'" & aVal(0,k) & "' <> '" & aVal(1,k) & "' : Mismatch at position " & cstr(k) & ".") ]]>
<![CDATA[
]]>
<![CDATA[			VoteFld = False]]>
<![CDATA[
]]>
<![CDATA[			Select Case g_VoteType]]>
<![CDATA[
]]>
<![CDATA[				Case 0]]>
<![CDATA[
]]>
<![CDATA[					'predefined confidence]]>
<![CDATA[
]]>
<![CDATA[					aConf(0,k) = 1					]]>
<![CDATA[
]]>
<![CDATA[				Case 1]]>
<![CDATA[
]]>
<![CDATA[					aConf(0,k) = aConf(0,k) - g_VoteAdj			'adj confidence ]]>
<![CDATA[
]]>
<![CDATA[					If aConf(0,k) < 0 Then aConf(0,k) = 0]]>
<![CDATA[
]]>
<![CDATA[				Case 2]]>
<![CDATA[
]]>
<![CDATA[					'WriteLog("Clearing Confidence & Value")]]>
<![CDATA[
]]>
<![CDATA[					aConf(0,k) =""					'clear value]]>
<![CDATA[
]]>
<![CDATA[					aVal(0,k) = ""]]>
<![CDATA[
]]>
<![CDATA[			End Select]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			sVal = sVal & aVal(0,k)]]>
<![CDATA[
]]>
<![CDATA[			nConf = nConf & aConf(0,k)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			'Character Values are the same]]>
<![CDATA[
]]>
<![CDATA[			Select Case g_VoteType]]>
<![CDATA[
]]>
<![CDATA[				Case 0]]>
<![CDATA[
]]>
<![CDATA[					aConf(0,k) = 9					'predefined confidence]]>
<![CDATA[
]]>
<![CDATA[				Case 1]]>
<![CDATA[
]]>
<![CDATA[					aConf(0,k) = aConf(0,k) + g_VoteAdj]]>
<![CDATA[
]]>
<![CDATA[					'WriteLog("Confidence: +" & aConf(0,m)) ]]>
<![CDATA[
]]>
<![CDATA[					If aConf(0,k) > 9 Then aConf(0,k) = 9]]>
<![CDATA[
]]>
<![CDATA[			End Select]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			sVal = sVal & aVal(0,k)]]>
<![CDATA[
]]>
<![CDATA[			nConf = nConf & aConf(0,k)]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Update Primary value & confidence]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.AltText(g_nPrime)=sVal]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.AltConfidenceString(g_nPrime)=nConf]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("New Primary Character string.  " & sVal & ". New Confidence string: " & nConf)	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
	</g>
</af>
<help>
  <![CDATA[
'****************************************************
' Vote.rra help

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2011 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'****************************************************
]]>
  	
<ref id="VoteFld" access="public" bInter="bInter" bDebug="bDebug" qi="Checks to see if the data entered for by the first Data Entry operator matches the data enter by the second Data Entry operator.">
  <ap>None.</ap>
  <h> 
    Checks to see if the data entered for by the first Data Entry operator matches the 
    data enter by the second Data Entry operator.<br/><br/>

    Failed (mismatched) values set the confidence for the entire string to '1', 
    therefore flagging the field as Low Confidence.   Positive matches set the 
    entire string's confidence to '9' (High Confidence).<br/><br/>

    This action needs to run after the second Data Entry task has been completed.<br/><br/>

    This action is used for workflows using third pass data entry.
    <e><b>VoteFld()</b> 
    </e>
	</h>
  <lvl>Field level.</lvl>
  <ret>
    <b>False</b> if the values do not match.  Otherwise, <b>True.</b>
  </ret>

</ref></help>

</rrx>
<rrx namespace="VScan" src="c:\datacap\RRS\VScan.dll">

<i ref="rrunner">
</i>
<g>
</g>
<g>
</g>
<af name="SetImageType" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['   String value of the file's identifying extension.  If you are listing multiple types, separate]]>
<![CDATA[
]]>
<![CDATA['   each one with a comma.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['   It is not necessary to include a period before each extension. The parameters are not case-sensitive.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  StrParam=Replace(StrParam,".","")]]>
<![CDATA[
]]>
<![CDATA[  StrParam=Replace(StrParam,Chr(32),"")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  SetImageType = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sExtn = Trim(StrParam) ' LCase(Trim(StrParam))]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Remove period from extension]]>
<![CDATA[
]]>
<![CDATA[  sExtn = Replace(sExtn,".","")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If LCase(sExtn)<>"tiff" and LCase(sExtn)<>"tif" and LCase(sExtn)<>"jpg" and LCase(sExtn)<>"jpeg"then ]]>
<![CDATA[
]]>
<![CDATA[     'If the input is not a single file type of tiff, tif or jpg, then disable fast mode.]]>
<![CDATA[
]]>
<![CDATA[     oOut.SetDoNotOpenInputFiles(True)]]>
<![CDATA[
]]>
<![CDATA[     Writelog("special or multiple extensions were provided : setting Fast Mode to TRUE.")]]>
<![CDATA[
]]>
<![CDATA[  ElseIf gReinitVScanUponRescan Then]]>
<![CDATA[
]]>
<![CDATA[     oOut.SetDoNotOpenInputFiles(False)]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  oIn.SetImageExtension(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  oOut.SetImageExtension(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  SetImageType = True        ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("SetImageType")   ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetMultiPageTiff" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  'Permits the use of multipage source image files.]]>
<![CDATA[
]]>
<![CDATA[  oOut.SetMultiPageTiff(True)]]>
<![CDATA[
]]>
<![CDATA[  SetMultiPageTiff = true]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("SetMultiPageTiff") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetFastMode" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[' Increases speed by preventing the Scan action from opening the files it is scanning.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA['    ]]>
<![CDATA[
]]>
<![CDATA['    This action is provided as backwards compatibility to older applications where this action was]]>
<![CDATA[
]]>
<![CDATA['    required to properly enable fast mode for PDF files.  SetImageType will automatically enable]]>
<![CDATA[
]]>
<![CDATA['    fast mode, if it is called with a PDF extension.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ oOut.SetDoNotOpenInputFiles(True)]]>
<![CDATA[
]]>
<![CDATA[  SetFastMode = true]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("SetFastMode") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SearchInSubdirectory" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['  Looks for source files in sub-directories of the directory you designated with a ]]>
<![CDATA[
]]>
<![CDATA['  SetSourceDirectory action.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  oIn.SearchInSubDirectory(True)]]>
<![CDATA[
]]>
<![CDATA[  SearchInSubdirectory = true]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("SearchInSubdirectory") ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="SetSourceDirectory" access="public" bInter="bInter" bDebug="bDebug" strParam="SmartParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA[' String value of the directory's name and path. Instead, you can use a Smart Parameter such ]]>
<![CDATA[
]]>
<![CDATA[' as @Path to establish the Source Directory's name and path.]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim StrParam]]>
<![CDATA[
]]>
<![CDATA[  Dim oFolder]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  SetSourceDirectory = False]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(SmartParam)]]>
<![CDATA[
]]>
<![CDATA[  If len(Trim(StrParam))=0 Then StrParam=SmartParam]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("looking for:" & StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If trim(StrParam)="" Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Error: Folder '" & StrParam & "' does not exist.")]]>
<![CDATA[
]]>
<![CDATA[    SetSourceDirectory = False]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If FileMgr.FolderExists(StrParam)=False Then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Error: Folder '" & StrParam & "' does not exist")]]>
<![CDATA[
]]>
<![CDATA[    nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Check existing directory and insert DRIVER LETTER: required for Mail Object]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  Set oFolder = FileMgr.GetFolder(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  StrParam = oFolder.Path ]]>
<![CDATA[
]]>
<![CDATA[  Set oFolder = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  oIn.SetSourceDir(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  oOutLook.SetSourceDir(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  If err.number <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("Fatal error: Outlook is not running")]]>
<![CDATA[
]]>
<![CDATA[    SetSourceDirectory = FALSE]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    SourceDir = StrParam]]>
<![CDATA[
]]>
<![CDATA[    SetSourceDirectory = TRUE]]>
<![CDATA[
]]>
<![CDATA[  End If  ]]>
<![CDATA[
]]>
<![CDATA[       ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetMaxImageFiles" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    An optional string value specifying the maximum number of files.]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['   If you do not enter a value, the task will scan all images in the target folder - and ]]>
<![CDATA[
]]>
<![CDATA['   this action will return True.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  Dim strTrimParam  ' Input with leading / trailing space removed]]>
<![CDATA[
]]>
<![CDATA[  Dim lParmValue    ' Value as a long]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  strTrimParam = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Always return success.  If the parameter value is not a valid integer, then we will just]]>
<![CDATA[
]]>
<![CDATA[  'log the problem and use the default value.  Let's set that up as the default condition.]]>
<![CDATA[
]]>
<![CDATA[  SetMaxImageFiles = True]]>
<![CDATA[
]]>
<![CDATA[  oOut.SetMaxImageFiles(MaxImageFiles)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  if len(strTrimParam) = 0 Then]]>
<![CDATA[
]]>
<![CDATA[     ' In this one case where no parameter is present, we will use the largest size.]]>
<![CDATA[
]]>
<![CDATA[     WriteLog("SetMaxImageFiles: No parameter, using largest value: 32767")]]>
<![CDATA[
]]>
<![CDATA[     oOut.SetMaxImageFiles(32767)]]>
<![CDATA[
]]>
<![CDATA[     Exit function]]>
<![CDATA[
]]>
<![CDATA[  end if   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ ' CInt will cause an error if the value is a number that is bigger than an int.  ]]>
<![CDATA[
]]>
<![CDATA[ ' We will validate it is a positive integer.]]>
<![CDATA[
]]>
<![CDATA[ if (Not IsNumeric(strTrimParam)) Then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("SetMaxImageFiles: Parameter: " & strTrimParam & " is not a number, using default value: " & MaxImageFiles)]]>
<![CDATA[
]]>
<![CDATA[    exit function]]>
<![CDATA[
]]>
<![CDATA[ end if   ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ ' We have some kind of number.  It can be an int or a long.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ if (Len(strTrimParam) > 5) then]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("SetMaxImageFiles: Parameter: " & strTrimParam & " is too big, using default value: " & MaxImageFiles)]]>
<![CDATA[
]]>
<![CDATA[    exit function]]>
<![CDATA[
]]>
<![CDATA[ end if   ]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ ' Might or might not be an int, but it must be a long by now.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ lParmValue = CLng(strTrimParam)    ' Set value to a long to prevent overflow]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ if ((lParmValue > 32767) or (lParmValue < 1)) Then]]>
<![CDATA[
]]>
<![CDATA[    ' bigger than signed int or 0 or negative]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("SetMaxImageFiles: Parameter: " & strTrimParam & " is too big or 0, using default value: " & MaxImageFiles)]]>
<![CDATA[
]]>
<![CDATA[    exit function]]>
<![CDATA[
]]>
<![CDATA[ end if   ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[ ' We have a valid, positive integer.]]>
<![CDATA[
]]>
<![CDATA[ oOut.SetMaxImageFiles( CInt(strTrimParam) )  ' Note, CInt rounds and uses system numeric settings]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ Call ErrorHandler("SetMaxImageFiles")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ ]]>
	</g>
</af>
<af name="DeleteImageFile" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['A housekeeping action that deletes the current source image file.  A Scan action ]]>
<![CDATA[
]]>
<![CDATA['must follow this action.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call oIn.ResetFileOption(FILE_DELETE,"")]]>
<![CDATA[
]]>
<![CDATA[  DeleteImageFile = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("DeleteImageFile")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CopyFile" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParamSP">
	<g>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['    <b>1.</b> The String value of the name of the target file system folder.<br/>]]>
<![CDATA[
]]>
<![CDATA['    <b>2.</b> Optional. The file extension you wish to use for each file. If you provide an extension, it must]]>
<![CDATA[
]]>
<![CDATA['    not be preceded by a period.  The action defaults to "tif" if this parameter is blank.<br/>]]>
<![CDATA[
]]>
<![CDATA['    Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim aParam]]>
<![CDATA[
]]>
<![CDATA[  Dim StrParam]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  StrParam = MetaWord(trim(StrParamSP)) ]]>
<![CDATA[
]]>
<![CDATA[  writelog("Input after processing smart parameters: '" & StrParam & "'")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  aParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If uBound(aParam) = 1 Then]]>
<![CDATA[
]]>
<![CDATA[    call oIn.ResetFileOption(FILE_COPY,  StrParam) ]]>
<![CDATA[
]]>
<![CDATA[    CopyFile = true]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    call oIn.ResetFileOption(FILE_COPY,  StrParam & ",tif") ]]>
<![CDATA[
]]>
<![CDATA[    CopyFile = true]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("CopyFile") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="Scan" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  '    Scans a set of waiting Image files, according to the parameters set by earlier actions.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[  '    This is usually the last action in a vScan rule.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  Scan = False]]>
<![CDATA[
]]>
<![CDATA[  If gReinitVScanUponRescan Then Writelog "gReinitVScanUponRescan = True"]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  If cInt(CurrentObj.ObjectType) <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("The Scan action is required to run at the Batch level.  Returning False.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function	]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If (Not FileMgr.FolderExists(SourceDir)) Then]]>
<![CDATA[
]]>
<![CDATA[    If len(trim(SourceDir))=0 then]]>
<![CDATA[
]]>
<![CDATA[      writelog("Source Directory is not setup correctly, an empty path exists for this value. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      writelog("Source Directory '" & SourceDir & "' not Found. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    Scan = False]]>
<![CDATA[
]]>
<![CDATA[    Exit function]]>
<![CDATA[
]]>
<![CDATA[  End if  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If IsAlive(oOutLook) then oOutLook.SaveAttachmentsAndDeleteMail()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  nImages = Ubound(oIn.GetArray())]]>
<![CDATA[
]]>
<![CDATA[  writelog("Found '" & nImages & "' image files in Source folder:'" & SourceDir & "'.")]]>
<![CDATA[
]]>
<![CDATA[  nMaxImageFiles = oOut.GetMaxImageFiles()]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Get image files]]>
<![CDATA[
]]>
<![CDATA[  If cInt(nImages)<>cInt(0) Then ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    If bDocumentStructurePresents=TRUE then]]>
<![CDATA[
]]>
<![CDATA[      'Set the Expected Pages variable]]>
<![CDATA[
]]>
<![CDATA[      DCO.Variable("EP") = cStr(nMaxImageFiles)]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Process Image Files]]>
<![CDATA[
]]>
<![CDATA[    For i = 1 to min(nImages,oOut.GetMaxImageFiles) 'nImages]]>
<![CDATA[
]]>
<![CDATA[      sUnderProcessFile = oIn.GetFile(i)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Select Case cStr(oOut.Perform(sUnderProcessFile))]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Case cStr(PerformPageOk)]]>
<![CDATA[
]]>
<![CDATA[            'we will release files at the end]]>
<![CDATA[
]]>
<![CDATA[            'oIn.ReleaseFile(sUnderProcessFile) ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Case cStr(PerformPageAbort)]]>
<![CDATA[
]]>
<![CDATA[            'oIn.ReleaseFile(sUnderProcessFile) ]]>
<![CDATA[
]]>
<![CDATA[            writelog("Files not released - File Processing Aborting.")]]>
<![CDATA[
]]>
<![CDATA[            nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[            Scan = false]]>
<![CDATA[
]]>
<![CDATA[            Exit function]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[        Case cStr(PerformPageFinish)]]>
<![CDATA[
]]>
<![CDATA[            'we did not process  oIn.ReleaseFile(sUnderProcessFile) ]]>
<![CDATA[
]]>
<![CDATA[            nTaskStatus = RetFinished]]>
<![CDATA[
]]>
<![CDATA[            Exit for]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        Case Else]]>
<![CDATA[
]]>
<![CDATA[            'oIn.ReleaseFile(sUnderProcessFile) ]]>
<![CDATA[
]]>
<![CDATA[            writelog("Files not released - Unexpected result from File Processing.")]]>
<![CDATA[
]]>
<![CDATA[            Scan = False]]>
<![CDATA[
]]>
<![CDATA[            Exit function]]>
<![CDATA[
]]>
<![CDATA[      End Select]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    Next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If nTaskStatus = RetFinished Then]]>
<![CDATA[
]]>
<![CDATA[       writelog("Releasing files...")]]>
<![CDATA[
]]>
<![CDATA[       For i = 1 to min(nImages,oOut.GetMaxImageFiles) 'nImages]]>
<![CDATA[
]]>
<![CDATA[          sUnderProcessFile = oIn.GetFile(i)]]>
<![CDATA[
]]>
<![CDATA[          oIn.ReleaseFile(sUnderProcessFile) ]]>
<![CDATA[
]]>
<![CDATA[       Next]]>
<![CDATA[
]]>
<![CDATA[       Writelog("Files Released.")]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Pilot.ExpectedPages = cStr(nImages)]]>
<![CDATA[
]]>
<![CDATA[    nTaskStatus = RetFinished]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    nTaskStatus = RetPending]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Scan = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[    Call ErrorHandler("Scan") ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AddDocument" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA['   Places all scanned pages into a single, batch-wide document.]]>
<![CDATA[
]]>
<![CDATA['   This action must be called before the Scan action.<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['   The action also adds ED (Expected Documents), AD (Actual Documents), EP (Expected Pages)]]>
<![CDATA[
]]>
<![CDATA['   and AP (Actual Pages) properties to a task's Page file (.xml).<br/><br/>]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['   This action allows a VScan task to create a batch that has all the same ]]>
<![CDATA[
]]>
<![CDATA['   characteristics of a batch that is created using a standard scan task such as kScan or iScan.]]>
<![CDATA[
]]>
<![CDATA['   It is not required to call this action.  Use this action if your application relies on a]]>
<![CDATA[
]]>
<![CDATA['   document structure on import.]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  AddDocument = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If cInt(CurrentObj.ObjectType) <> 0 Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("The AddDocument action is required to run at the Batch level. Returning False.")]]>
<![CDATA[
]]>
<![CDATA[		Exit Function	]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Set oSetupObject = DCO.SetupObject]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  writelog("Checking Setup DCO for a document structure...")]]>
<![CDATA[
]]>
<![CDATA[  nDocs = oSetupObject.NumOfNodes(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If (nDocs >= 1 ) Then '  we suppose there is just one document]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Found '" & cstr(nDocs) & "' document structures in current setup DCO.")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If DCO.NumOfChildren = 0 Then]]>
<![CDATA[
]]>
<![CDATA[         Set oDoc = DCO.AddChild(1,Pilot.BatchID & ".01" ,-1)]]>
<![CDATA[
]]>
<![CDATA[         oDoc.Type = ""   'oDoc.Type=oSetupObject.GetNode(1,0).Name]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[         DCO.Variable("ED") = cStr(nDocs)]]>
<![CDATA[
]]>
<![CDATA[         DCO.Variable("AD") = "0"]]>
<![CDATA[
]]>
<![CDATA[         DCO.Variable("EP") = "0"]]>
<![CDATA[
]]>
<![CDATA[         DCO.Variable("AP") = "0"]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[        Set oDoc = DCO.GetChild(0)]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    bDocumentStructurePresents = True]]>
<![CDATA[
]]>
<![CDATA[    AddDocument = True]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No document structures found in current setup DCO. No Document structure will be created.")]]>
<![CDATA[
]]>
<![CDATA[    bDocumentStructurePresents = false]]>
<![CDATA[
]]>
<![CDATA[    AddDocument = false]]>
<![CDATA[
]]>
<![CDATA[  End If]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Set oSetupObject = Nothing ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetSortOrder" access="public" bInter="bInter" bDebug="bDebug" strParam="strParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['   Two comma-separated String values:]]>
<![CDATA[
]]>
<![CDATA[']]>
<![CDATA[
]]>
<![CDATA['    1. Designation of the images' sorting field: ImageName=1, Type=2, DateCreated=3,]]>
<![CDATA[
]]>
<![CDATA['    DateLastAccessed=4, DateLastModified=5, or Size=6.]]>
<![CDATA[
]]>
<![CDATA['    2. Optional: ASC or 1 (Ascending), DESC or 2 (Descending). If you do not include this ]]>
<![CDATA[
]]>
<![CDATA['    parameter, the action defaults to ASC (1).]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim bValid]]>
<![CDATA[
]]>
<![CDATA[  Dim arParam]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  SetSortOrder = false]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  strParam=trim(strParam)]]>
<![CDATA[
]]>
<![CDATA[  If len(strParam)=0 then]]>
<![CDATA[
]]>
<![CDATA[    writelog("Expecting 1 or 2 parameter values. None found.")]]>
<![CDATA[
]]>
<![CDATA[    Exit function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  arParam = split(strParam,",")]]>
<![CDATA[
]]>
<![CDATA[  if Ubound(arParam) > 1 Then]]>
<![CDATA[
]]>
<![CDATA[    writelog("Wrong number of parameters, should be 1 or 2")]]>
<![CDATA[
]]>
<![CDATA[    exit function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  arParam(0)=Trim(cStr(arParam(0)))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Select Case Ucase(arParam(0))]]>
<![CDATA[
]]>
<![CDATA[	Case "NAME","1"]]>
<![CDATA[
]]>
<![CDATA[		gSortType = "Name"]]>
<![CDATA[
]]>
<![CDATA[ 	Case "TYPE","2"]]>
<![CDATA[
]]>
<![CDATA[		gSortType = "Type"]]>
<![CDATA[
]]>
<![CDATA[	Case "DATECREATED","3"]]>
<![CDATA[
]]>
<![CDATA[		gSortType = "DateCreated"]]>
<![CDATA[
]]>
<![CDATA[	Case "DATELASTACCESSED","4"]]>
<![CDATA[
]]>
<![CDATA[		gSortType = "DateLastAccessed"]]>
<![CDATA[
]]>
<![CDATA[	Case "DATELASTMODIFIED","5"]]>
<![CDATA[
]]>
<![CDATA[		gSortType = "DateLastModified"]]>
<![CDATA[
]]>
<![CDATA[	Case "SIZE","6"]]>
<![CDATA[
]]>
<![CDATA[		gSortType = "Size"]]>
<![CDATA[
]]>
<![CDATA[	Case Else]]>
<![CDATA[
]]>
<![CDATA[		writelog ("first argument has to be one of the names: Name,Type,DateCreated,DateLastAccessed,DateLastModified,Size")]]>
<![CDATA[
]]>
<![CDATA[      	Exit function]]>
<![CDATA[
]]>
<![CDATA[  End Select]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ' Default to assending sort order.]]>
<![CDATA[
]]>
<![CDATA[  gSortOrder = "ASC"]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If uBound(arParam)=1 Then]]>
<![CDATA[
]]>
<![CDATA[    arParam(1)=Trim(cStr(arParam(1)))	]]>
<![CDATA[
]]>
<![CDATA[    Select Case uCase(arParam(1))]]>
<![CDATA[
]]>
<![CDATA[	Case "DESC","2"]]>
<![CDATA[
]]>
<![CDATA[	      gSortOrder = "DESC"]]>
<![CDATA[
]]>
<![CDATA[      	writelog("sort order is DESC")]]>
<![CDATA[
]]>
<![CDATA[    	Case Else]]>
<![CDATA[
]]>
<![CDATA[      	writelog("sort order is ASC")	]]>
<![CDATA[
]]>
<![CDATA[    end Select]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  SetSortOrder = true ]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</g>
</af>
<af name="MoveImageFileToDirectory" access="public" bInter="bInter" bDebug="bDebug" strParam="SmartParam">
	<g>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[ 'The full path to the target location of the Image file.  Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[ ']]>
<![CDATA[
]]>
<![CDATA[ '   A housekeeping action that moves the current Image file to a location you specify.  The source]]>
<![CDATA[
]]>
<![CDATA[ '   image file will be removed from the input directory and moved to the specified directory.]]>
<![CDATA[
]]>
<![CDATA[ '   This action is typically used when it is desired to place images into a specific]]>
<![CDATA[
]]>
<![CDATA[ '   location for archiving.  A copy of the image will still be placed into the batch directory.]]>
<![CDATA[
]]>
<![CDATA[ ']]>
<![CDATA[
]]>
<![CDATA[ '   If the target directory already contains a file of the same name, it will give a unique name to the new file.]]>
<![CDATA[
]]>
<![CDATA[ ']]>
<![CDATA[
]]>
<![CDATA[ '  This action must precede the Scan action.  If MoveImageFileToDirectory is used and the Scan action]]>
<![CDATA[
]]>
<![CDATA[ '  is never subsequently called, the file move will not be performed.]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[ Dim StrParam   ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  StrParam=Metaword(SmartParam)]]>
<![CDATA[
]]>
<![CDATA[  If len(Trim(StrParam))=0 Then StrParam=SmartParam]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If trim(StrParam)<>"" Then]]>
<![CDATA[
]]>
<![CDATA[    If ( Not FileMgr.FolderExists(StrParam) ) Then]]>
<![CDATA[
]]>
<![CDATA[      WriteLog("Fatal error: Folder " & StrParam & " does not exist")]]>
<![CDATA[
]]>
<![CDATA[      nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[      MoveImageFileToDirectory = False]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[      ' check existing directory]]>
<![CDATA[
]]>
<![CDATA[      ' AND insert DRIVER LETTER : it is needed for Mail Object]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Dim folder]]>
<![CDATA[
]]>
<![CDATA[      Set folder = FileMgr.GetFolder(StrParam)]]>
<![CDATA[
]]>
<![CDATA[      StrParam = folder.Path ]]>
<![CDATA[
]]>
<![CDATA[      Set Folder = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      call oIn.ResetFileOption(FILE_MOVE, StrParam)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      MoveImageFileToDirectory = True ]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[  Else]]>
<![CDATA[
]]>
<![CDATA[    WriteLog("MoveImageFileToDirectory: Parameter is not correct.")]]>
<![CDATA[
]]>
<![CDATA[    nTaskStatus = RetAbort]]>
<![CDATA[
]]>
<![CDATA[    MoveImageFileToDirectory = False]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Call ErrorHandler("MoveImageFileToDirectory")]]>
<![CDATA[
]]>
	</g>
</af>
<help>
<![CDATA[
'************************************************************
' help.xml for VScan
'------------------------------------------------------------
'
' Licensed Materials - Property of IBM
' â€œRestricted Materials of IBMâ€
' 5725-C15 5725-C69
'
' Â© Copyright IBM Corp. 1994, 2014 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************

]]>
  <ref id="SetImageType">
    <ap>
      String value of the file's identifying extension.  If you are listing multiple types, separate
      each one with a comma.<br/><br/>

      It is not necessary to include a period before each extension. The parameters are not case-sensitive.<br/><br/>
    </ap>
    <h>
      Uses the value of a file extension(s) to specify the type of files the task will scan.<br/><br/>

      This is an optional vScan action: the task will scan .tif files by default.
      For this action to take effect, it must be called before the Scan action.<br/><br/>

      This action will automatically enable Fast Mode scanning if the input parameter
      is not a single extension of type "tiff", "tif", "jpeg" or "jpg".

      <e>
        <b>SetImageType(".tif)</b><br/>
        Scan()<br/>
        This sequence will scan only TIF files and will not enable Fast Mode.<br/><br/>

        <b>SetImageType("tiff")</b><br/>
        Scan()<br/>
        This sequence will scan only TIFF files and will not enable Fast Mode.<br/><br/>

        <b>SetImageType("bmp,jpg,jpeg,msg,tif,tiff,pdf,zip,doc,docx,xls,xlsx,eml,gif")</b><br/>
        Scan()<br/>
        This sequence will scan all file types listed and will enable Fast Mode.<br/>
      </e>
    </h>
    <lvl>Any level but usually the batch level.</lvl>
    <ret>
      <b>True</b> if the parameter is one of the values specified above. Otherwise, <b>False.</b>
    </ret>
     </ref>
  
 <ref id="SetMultiPageTiff">
   <ap>None.</ap>
   <h>
     Permits the use of multipage source image files.
     For this action to take effect, it must be called before the Scan action.<br/><br/>
     
     This action cannot be used if fast mode is enabled.  It also requires that
     SetImageType be called with only one extension of TIF, TIFF, JPG or JPEG.
     If this action is used when fast mode is enabled, the Scan action will return false.
     <e>
       SetImageType(".tif")<br/>
       <b>SetMultiPageTiff()</b><br/>
       Scan()<br/><br/>

       If the Scan action in this sequence encounters a multipage .tif file, then it will
       read each one into the current batch as a separate image, thereby "bursting" the multipage
       file into individual images.
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     Always <b>True.</b>
   </ret>
     </ref>
  
 <ref id="SetFastMode">
   <ap>None.</ap>
   <h>
     Increases speed by preventing the Scan action from opening the files it is scanning.
     This action prevents the testing that the TIF files are valid and avoid conversion of TIF files to G4 compression for processing.
     Calling this action will allow TIF files that are not compatible with Taskmaster to be placed into a batch.
     <br/><br/>

     This action is provided as backwards compatibility to older applications where this action was
     required to properly enable fast mode for PDF files.<br/><br/>

     SetImageType will automatically enable
     fast mode, if it is called with a extension other than TIF or JPG.
     For this action to take effect, it must be called before the Scan action.<br/>
     <e>
       SetImageType(.pdf)<br/>
       <b>SetFastMode()</b><br/>
       Scan()
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     Always <b>True.</b>
   </ret>
 </ref>
  
 <ref id="SearchInSubdirectory">
   <ap>None.</ap>
   <h>
     Looks for source files in sub-directories of the directory you designated with a
     SetSourceDirectory action.
     For this action to take effect, it must be called before the Scan action.<br/>
     <e>
       SetSourceDirectory("@APPPATH(vscanimagedir)")<br/>
       <b>SearchInSubdirectory()</b><br/><br/>
       In this example, if the scan directory obtained from the application service includes sub-directories, this action will
       direct the Scan action to process the contents of the sub-directories.
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     Always <b>True.</b>
   </ret>
   <see>SetSourceDirectory</see>
     </ref>
  
 <ref id="SetSourceDirectory">
   <ap>
     String value of the directory's name and path. Instead, you can use a Smart Parameter,
     such as @APPPATH, to establish the Source Directory's name and path.
   </ap>
   <h>
     This action indicates the name and path of the directory containing the Image files to be scanned.<br/><br/>
     This is a required action; a task which employs a vScan rule cannot process images
     unless it has this key locator.  This action must be called prior to the scan action.
     <e>
       <b>SetSourceDirectory("c:\ParentDirectory\Application\Images")</b><br/><br/>
       In the above example, the full path to the images directory is coded directly into the application rules.
       <br/><br/>
       <b>SetSourceDirectory("@APPPATH(vscanimagedir)+\+Input")</b><br/><br/>

       In the example above, @APPPATH obtains the vscan directory from the application service.
       This makes the application more flexible in that the same application that is installed in two different
       environments, such as test vs. production, can use two different input directories.  The subdirectory "Input"
       is appended to the path.
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     <b>False</b> if the parameter is blank or the directory does not exist. Otherwise, <b>True.</b><br/><br/>

     If the source directory does not exist, the batch status will be set to abort.
   </ret>
     </ref>
  
  <ref id="SetMaxImageFiles">
    <ap>
      An optional string value specifying the maximum number of files.<br/><br/>

      If you do not enter a value, the task will scan all images in the target folder (up to 32767 files)- and
      this action will return <b>True.</b>
    </ap>
    <h>
      Limits the number of Image files the vScan task will add to a single batch.  This action must
      be placed before the Scan action for the setting to take effect during Scan.
      <e>
        <b>SetMaxImageFiles("50")</b><br/>
        Scan()<br/>
        Sets the maximum number of files to add to a batch at fifty.<br/><br/>

        <b>Remember!</b> A vScan task is a Batch Creation task: it sets up a new batch each
        time it scans Image files.
      </e>
    </h>
    <lvl>Any level but usually the batch level.</lvl>
    <ret>
      <b>False</b> if the parameter is not Numeric. Otherwise, <b>True.</b>
    </ret>
  </ref>
  
  <ref id="DeleteImageFile">
    <ap>None.</ap>
    <h>
      A housekeeping action that deletes the current source image file.  A Scan action
      must follow this action, which will perform the delete during the vscan process.
      If Scan is never called, the files will not be deleted.
      <e>
        <b>DeleteImageFile()</b><br/>
        <scr>Scan()</scr><br/><br/>

        This sequence deletes the image files from their current location after they
        have been added to the current batch folder.
      </e>
    </h>
    <lvl>Any level but usually the batch level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
  </ref>
  
 <ref id="CopyFile">
   <ap>
     <b>1.</b> The String value of the name of the target file system folder.<br/>
     <b>2.</b> Optional. The file extension you wish to use for each file. If you provide an extension, it must
     not be preceded by a period.  The action defaults to "tif" if this parameter is blank.<br/>
     Smart parameters are supported.
   </ap>
   <h>
     A housekeeping action that copies the current source image file to a location
     you specify and specifies the copied file's extension.<br/><br/>

     The source image file will remain in the input directory while a copy is placed into the specified directory.
     This action is typically used when it is desired to place images into a specific
     location for archiving.  A copy of the image will still be placed into the batch directory as well. <br/><br/>

     If the target directory already contains a file of the same name, it will give a unique name to the new file.<br/><br/>

     This action must precede the Scan action.  The CopyFile sets an indicator for the Scan action
     to copy the file.  If CopyFile is used and the Scan action
     is never subsequently called, the copy will not be performed.
     The destination directory must already exist or a message will be logged and no files will be copied.
     <e>
       <b>CopyFile("C:\ParentDirectory\Application\Images\copies,tif")</b><br/>
       <scr>Scan()</scr><br/><br/>

       This example copies the source image file to the "copies" folder and then adds it to the batch.
       It does not delete the image from the source folder.<br/><br/>

       <b>CopyFile("@APPPATH(vscancopydir),tif")</b><br/>
       <scr>Scan()</scr><br/><br/>

       This variant example copies the source image file to the "copies" folder that has been specified
       within the application service.<br/><br/>
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     Always <b>True.</b>  If the target directory does not exist or if the files cannot be created, the files will
     not be copied but the action will still return <b>True.</b>
   </ret>
   <see>
     <scr>Scan</scr>
   </see>
     </ref>
  
 <ref id="SetMailSourceFolder">
   <ap>String value of the Outlook folder you want to search.</ap>
   <h>
     This action has been deprecated and is expected to be removed in a future release.<br/>
     Use actions from Imail and EWSMail libraries.<br/><br/>
     Searches the location you specify for e-mails that contain Image file attachments.
     For this action to take effect, it must be called before the Scan action.<br/>
     <e>
       <b>SetMailSourceFolder("Inbox/Images")</b><br/>
       Scan()<br/><br/>

       This example will search the Images subfolder for any e-mails with attachments,
       and copy these Image files into the newly created batch.<br/><br/>

       <b>SetMailSourceFolder("Inbox+/+@VAR(FOLDERNAME)")</b><br/>
       Scan()<br/><br/>

       This example will get the name of the subfolder from the runtime variable "FOLDERNAME".
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     Always <b>True.</b>
   </ret>
     </ref>
  
 <ref id="Scan">
   <ap>None.</ap>
   <h>
     Scans a set of waiting Image files, according to the parameters set by earlier actions.<br/><br/>
     This is usually the last action in a vScan rule.<br/><br/>

     Important: If any concurrently running threads might be using the same source folder,
     your VScan-related tasks cannot be run in a multi-threaded configuration. Instead, use single-threaded tasks only.
     For information about configuring threads in Rulerunner, see Configuring Rulerunner to run tasks.
     For information about the source folder, see SetSourceDirectory.<br/>
     <e>
       <scr>SetImageType(".tif")</scr><br/>
       <scr>SetSourceDirectory("@APPPATH(vscanimagedir)")</scr><br/>
       <scr>SetMaxImageFiles("100")</scr><br/>
       <b>Scan()</b><br/><br/>

       These are the elements of a sample vScan Rule. The Scan action will load the specified
       number of images (if available) from the specified folder into the current batch folder.
     </e>
   </h>
   <lvl>Batch level.</lvl>
   <ret>
     <b>False</b> if a <scr>SetSourceDirectory</scr> action does not precede this action. False will
     also be returned if fast mode is enabled and SetMultiPageTiff was called.
     Otherwise, <b>True.</b>
   </ret>
     </ref>
  
 <ref id="AddDocument">
  <ap>None.</ap>
   <h>
     Places all scanned pages into a single, batch-wide document.
     This action must be called before the Scan action.<br/><br/>

     The action also adds ED (Expected Documents), AD (Actual Documents), EP (Expected Pages)
     and AP (Actual Pages) properties to a task's Page file (.xml).<br/><br/>

     This action allows a VScan task to create a batch that has all the same
     characteristics of a batch that is created using a standard scan task.
     It is not required to call this action.  Use this action if your application relies on a
     document structure on import.<br/><br/>

     This action must precede the Scan action.  If AddDocument is used and the Scan action
     is never subsequently called, the action will not be performed.<br/>
     <e>
       <b>AddDocument()</b><br/>
       SetSortOrder("Name,ASC")<br/>
       SetMaxImageFiles("100")<br/>
       Scan()
     </e>
   </h>
   <lvl>Batch level.</lvl>
   <ret>
     <b>False</b> if this action is invoked or if called at the wrong level or
     if the setup DCO does not contain any document structure.  
     In this case, the action will not add a document. Otherwise, <b>True.</b>
   </ret>
     </ref>
  
 <ref id="SetSortOrder">
   <ap>
     Two comma-separated String values:<br/><br/>

     <b>Parameter 1.</b> Designation of the images' sorting field can be specified with text or numerically: <br/><br/>
     
     <b>1</b> or <b>Name</b> : The input file name.<br/>
     <b>2</b> or <b>Type</b> : The file type.<br/>
     <b>3</b> or <b>DateCreated</b> : The File creation date.<br/>
     <b>4</b> or <b>DateLastAccessed</b> : The last file access date.<br/>
     <b>5</b> or <b>DateLastModified</b> : The last file modification date.<br/>
     <b>6</b> or <b>Size</b> : The file size.<br/><br/>
     
     <b>Parameter 2.</b> Optional: ASC or 1 (Ascending), DESC or 2 (Descending). If you do not include this
     parameter, the action defaults to ASC (1).
   </ap>
   <h>
     Sets the order in which Image files will be imported to the batch.
     The input files can be sorted by their file name, file type, date created,
     date accessed, date modified or file size.  Using the optional second
     parameter, you can control if the values are sorted in ascending or descending order.
     <br/>
     For this action to take effect, it must be called before the Scan action.<br/>
     <e>
       <b>SetSortOrder("Name,ASC")</b><br/>
       <scr>Scan()</scr>
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     <b>False</b> if the parameters are not valid.  Otherwise, <b>True.</b>
   </ret>
     </ref>
  
 <ref id="MoveImageFileToDirectory">
   <ap>The full path to the target location of the Image file.  Smart parameters are supported.</ap>
   <h>
     A housekeeping action that moves the current Image file to a location you specify.  The source
     image file will be removed from the input directory and moved to the specified directory.
     This action is typically used when it is desired to place images into a specific
     location for archiving.  A copy of the image will still be placed into the batch directory.<br/><br/>

     If the target directory already contains a file of the same name, it will give a unique name to the new file.<br/><br/>

     This action must precede the Scan action.  If MoveImageFileToDirectory is used and the Scan action
     is never subsequently called, the file move will not be performed.  If the move to the new
     directory fails, the batch will be set to abort.
     <e>
       <b>MoveImageFiletoDirectory("C:\ParentDirectory\Application\backup")</b><br/>
       SetMaxImageFiles("100")<br/>
       Scan()<br/><br/>

       This sequence copies the source image files to the current batch, then moves the Image
       files to the specified directory.<br/><br/>

       <b>MoveImageFiletoDirectory("@APPPATH(vscanmovedir)")</b><br/>
       <scr>Scan()</scr><br/><br/>

       This variant example uses a smart parameter to obtain the directory path from the application service.
     </e>
   </h>
   <lvl>Any level but usually the batch level.</lvl>
   <ret>
     <b>False</b> if the parameter is not a valid directory, or if permission to access/write
     to the directory is denied.  Otherwise, <b>True.</b><br/><br/>

     If the file cannot be written to the destination directory, the batch status will be set to abort.
   </ret>
     </ref>
  
  <ref id="SetAlternateImageNames">
    <ap>
      <b>0</b> : Sets the naming scheme of the input files to the format used by eDocument Conversion actions.<br/>
      Any other input value uses the traditional naming schmeme of TM000001, TM000002, etc.
    </ap>
    <h>
      This action sets the file naming scheme of the Scan action.
      If you are using the Convert action library, it is recommended
      that you enable this batch file naming scheme.<br/><br/>      
      
      If this action is not called prior to the Scan action, 
      then the Scan uses the traditional naming schmeme of TM000001, TM000002, etc.
      <e>
        <b>SetAlternateImageNames("0")</b><br/>
        Scan()
      </e>
    </h>
    <lvl>Any level but usually the batch level.</lvl>
    <ret>
      Always <b>True.</b>
    </ret>
    <see>Scan</see>
    </ref>
 </help>

 </rrx>
<rrx namespace="WebService" src="c:\datacap\RRS\WebService.dll">

<net ref="WebService.Actions">
	<h>
<![CDATA[
]]>
<![CDATA[    This library of actions facilitates communication with  external web services.]]>
<![CDATA[
]]>
<![CDATA[    You can use these actions to get formatted responses or image files.]]>
<![CDATA[
]]>
<![CDATA[    The actions can handle both XML and JSON formatted responses, with XML being the expected default.]]>
<![CDATA[
]]>
<![CDATA[    You will need to know the web service's endpoint, any parameters if applicable and the response type before using these actions.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
	</h>
	<method name="WsGetValues">
		<p name="url" type="string" qi="Required: the URL of the web service.">
		</p>
		<p name="nsprefix" type="string" qi="Optional: the prefix of the Namespace if you are using tags to obtain results.">
		</p>
		<p name="nsuri" type="string" qi="Optional: the Namespace URI.  If a namespace has already been set, you do not need to set the URI.">
		</p>
		<p name="source" type="string" qi="Optional: the xpath or tag to obtain the value. The xpath/tag and target are set separately.">
		</p>
		<p name="target" type="string" qi="Optional: the target DCO. You can set the xpath/tag and target separately, and if no path is set then the entire result set is saved to the target.">
		</p>
		<p name="format" type="string" qi="Optional: the return format type. The default is XML.">
		</p>
		<p name="savefile" type="string" qi="Optional: save the response results to this file for reference.">
		</p>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[, if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[        The WsGetValues action returns one or more values from a web service.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        The value for the URL should include the end point.  This is the only required value if the parameters and target values are set before calling the action.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[	Smart parameters are supported.]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          ]]>
				<b>
<![CDATA[Example 1]]>
				</b>
<![CDATA[ uses xpath with a namespace to obtain information from the web service:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<code>
<![CDATA[WsGetvalues("http://api.worldbank.org/countries?format=xml", "wb", "http://www.worldbank.org", "//wb:countries/wb:country[5]/wb:name", "@B.Country", "", "C:\myfolder\myfile.xml")]]>
				</code>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
				<b>
<![CDATA[Example 2]]>
				</b>
<![CDATA[ uses tag value to obtain the information:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<code>
<![CDATA[WsGetvalues("]]>
<![CDATA[http://www.webservicex.net/CurrencyConvertor.asmx/ConversionRate?FromCurrency=USD&ToCurrency=GBP", "", "", "double", "@B.ConversionRate", "", "")]]>
				</code>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<br>
				</br>
				<b>
<![CDATA[Example 3]]>
				</b>
<![CDATA[ shows the syntax for JSON:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<code>
<![CDATA[WsSetParameter("symbols", "USD", true)]]>
<![CDATA[
]]>
<![CDATA[          WsSetParameter("symbols", "GBP", true)]]>
<![CDATA[
]]>
<![CDATA[          WsGetvalues("http://api.fixer.io/latest?", "", "", "", "", "JSON", "@PILOT(BATCHDIR)+/+rates +.json")]]>
				</code>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
	</method>
	<method name="WsGetFile">
		<p name="url" type="string" qi="Required: the URL of the web service. Smart parameters are supported. ">
		</p>
		<p name="filename" type="string" qi="Required: the name to use for the downloaded file. Smart parameters are supported.">
		</p>
		<p name="timeout" type="int" qi="Optional: the timeout value in milliseconds before abandoning the request.">
		</p>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[, if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[      Downloads a file from a web service using the provided file name. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Smart parameters are supported for all parameters.]]>
<![CDATA[
]]>
<![CDATA[      The timeout value specified for this operation will override any timeout value set elsewhere.]]>
<![CDATA[
]]>
<![CDATA[      The default timeout value is 60000 milliseconds, or one minute.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<code>
<![CDATA[WsGetfile("http://maps.googleapis.com/maps/api/staticmap?center=Costa Mesa,CA&zoom=14&size=400x400&sensor=false", "C:\Test\CMmap.png", 120000)]]>
				</code>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
	</method>
	<method name="WsUploadFile">
		<p name="url" type="string" qi="Required: the URI of the resource to receive the file. Smart parameters are supported.">
		</p>
		<p name="filename" type="string" qi="Required: the file to send to the resource. Smart parameters are supported.">
		</p>
		<p name="method" type="string" qi="Optional: the file upload method. By default, 'POST' is used for http and 'STOR' for ftp.">
		</p>
		<p name="timeout" type="int" qi="Optional: the timeout value in milliseconds before abandoning the request. Smart parameters are supported.">
		</p>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[, if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[      Uploads a file to a web service. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      The timeout value specified for this operation will override any timeout value set elsewhere.]]>
<![CDATA[
]]>
<![CDATA[      The default timeout value is 60000 milliseconds, or one minute.]]>
<![CDATA[
]]>
<![CDATA[      If no method is specified, the default is "POST" for http and "STOR" for ftp.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<code>
<![CDATA[WsUploadFile("http://server/service", "C:\Test\myfile.jpg", "", "120000")]]>
				</code>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
	</method>
	<method name="WsUploadData">
		<p name="url" type="string" qi="Required: the URL of the web service.">
		</p>
		<p name="uploadData" type="string" qi="Required: the data to upload.">
		</p>
		<p name="sessionkeys" type="string" qi="Optional: comma-separated list of session key names. ">
		</p>
		<p name="format" type="string" qi="Optional: return format type. The default is xml.">
		</p>
		<p name="responsefile" type="string" qi="Optional: save the response results to this file for later use.">
		</p>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[, if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[        Upload data to a WebService endpoint using a POST request.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        Smart parameters are supported for all parameters.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			<e>
<![CDATA[
]]>
<![CDATA[          The example shows how to use wTM endpoints to log on and create a batch:]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[          ]]>
				<code>
<![CDATA[WsSetHeader("@STRING(Content-Type)", "@STRING(application/xml)", false)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[          WsUploadData("http://localhost:8010/ServicewTM.svc/Session/Logon", ]]>
<![CDATA[
]]>
<![CDATA[                          "]]>
					<LogonProperties>
						<application>
<![CDATA[Demo901]]>
						</application>
						<password>
<![CDATA[admin]]>
						</password>
						<station>
<![CDATA[1]]>
						</station>
						<user>
<![CDATA[admin]]>
						</user>
					</LogonProperties>
<![CDATA[",]]>
<![CDATA[
]]>
<![CDATA[                          "", "xml", "C:\myfolder\logon.xml")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[            WsUploadData("http://localhost:8010/ServicewTM.svc/Queue/CreateBatch",]]>
<![CDATA[
]]>
<![CDATA[            "]]>
					<createBatchAttributes>
						<application>
<![CDATA[Demo901]]>
						</application>
						<batchFolder>
						</batchFolder>
						<job>
<![CDATA[Demo_SingleTIFFs]]>
						</job>
					</createBatchAttributes>
<![CDATA[",]]>
<![CDATA[
]]>
<![CDATA[            "Set-Cookie", "", "C:\myfolder\createbatch.xml")]]>
<![CDATA[
]]>
<![CDATA[          ]]>
				</code>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
			</e>
<![CDATA[
]]>
<![CDATA[      ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
	</method>
	<method name="WsSetParameter">
		<p name="name" type="string" qi="The name of the parameter. Smart parameters are supported.">
		</p>
		<p name="value" type="string" qi="The value for the parameter. Smart parameters are supported.">
		</p>
		<p name="add" type="bool" qi="If the specified parameter already exists, then set this parameter to TRUE for the new value to be added to the existing value. If you set the parameter to FALSE, then the existing value will be replaced by the new value.">
		</p>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[, if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[      Set the parameters required by the web service endpoint.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<code>
<![CDATA[WsSetParameter("FromCurrency", "USD", false)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetParameter("ToCurrency", "GBP", false)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsGetvalues("http://www.webservicex.net/CurrencyConvertor.asmx/ConversionRate", "", "", "double", "@B.GBPConversionRate", "")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetParameter("ToCurrency", "EUR", false)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsGetvalues("http://www.webservicex.net/CurrencyConvertor.asmx/ConversionRate", "", "", "double", "@B.EURConversionRate", "")]]>
				</code>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
	</method>
	<method name="WsEncodeParameter">
		<p name="name" type="string" qi="The name of the parameter to be encoded.">
		</p>
		<p name="encoding" type="string" qi="The type of encoding to apply. URI or DATA types are supported.">
		</p>
		<ret>
<![CDATA[
]]>
<![CDATA[      Always ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[      Set a parameter to a specific encoding as required by the web service endpoint.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Call this action if you need to encode a parameter value for a call to any web service.]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<code>
<![CDATA[WsSetParameter("CountryName", "United States", false)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetParameter("CityName", "Newark", false)]]>
<![CDATA[
]]>
<![CDATA[        ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsEncodeParameter("CountryName", "data")]]>
<![CDATA[
]]>
<![CDATA[        ]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsGetvalues("http://www.webservicex.net/globalweather.asmx/GetWeather?", "", "", "", "@B.htmltext", "")]]>
				</code>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
	</method>
	<method name="WsClearParameters">
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[, if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Clear all of the previously set web service parameters.]]>
<![CDATA[
]]>
<![CDATA[      Call this action if you need to send a new set of parameters for your next call to any web service.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<code>
<![CDATA[WsSetParameter("FromCurrency", "USD", false)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetParameter("ToCurrency", @APPVAR(values/gen/ToCurrency), false)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetResultItem("double", "@B.ConversionRate")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsGetvalues(@APPVAR(values/gen/CurrencyConvertor), "", "", "", "", "")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsClearParameters()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsClearResultItems()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetParameter("address", "10 Downing Street, London", false)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetParameter("sensor", "false", false)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetResultItem("GeocodeResponse/result/geometry/location/lat", "@B.Latitude")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetResultItem("GeocodeResponse/result/geometry/location/lng", "@B.Longitude")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsGetvalues("http://maps.googleapis.com/maps/api/geocode/xml?", "", "", "", "", "")]]>
				</code>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
	</method>
	<method name="WsSetResultItem">
		<p name="source" type="string" qi="The xpath or tags to find the value in the result. Smart parameters are supported.">
		</p>
		<p name="target" type="string" qi="Destination item to assign the value.  ">
		</p>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[, if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[      This action will associate the keys(xpath or tags) to the values from the response to the DCO objects to which you want to assign them. ]]>
<![CDATA[
]]>
<![CDATA[      If the source already exists its corresponding target will be replaced with the new target value.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      This action must be set before calling the response.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[       Use this action if you want to get more than a single value from the response.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<b>
<![CDATA[Example 1]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<code>
<![CDATA[WsSetParameter("FromCurrency", "USD", false)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetParameter("ToCurrency", "GBP", false)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetResultItem("double", "@B.ConversionRate")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsGetvalues("http://www.webservicex.net/CurrencyConvertor.asmx/ConversionRate?", "", "", "", "", "")]]>
				</code>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
				<b>
<![CDATA[Example 2]]>
				</b>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[        ]]>
				<code>
<![CDATA[WsSetResultItem("@STRING(rates.USD)", "@B.EUR2USD")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetResultItem("@STRING(rates.GBP)", "@B.EUR2GBP")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsGetvalues("http://api.fixer.io/latest?", "", "", "", "", "JSON", "")]]>
				</code>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
	</method>
	<method name="WsClearResultItems">
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[, if the action succeeds. Otherwise, ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Clear all key-value pairs associating the result keys and previously set target DCO variables.]]>
<![CDATA[
]]>
<![CDATA[      Call this action if you need to send a new set of result items for your next call to any web service.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<code>
<![CDATA[WsSetParameter("FromCurrency", "USD", false)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetParameter("ToCurrency", "GBP", false)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetResultItem("double", "@B.ConversionRate")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsGetvalues("http://www.webservicex.net/CurrencyConvertor.asmx/ConversionRate?", "", "", "", "", "")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsClearParameters()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsClearResultItems()]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetParameter("address", "10 Downing Street, London", false)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetParameter("sensor", "false", false)]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetResultItem("GeocodeResponse/result/geometry/location/lat", "@B.Latitude")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsSetResultItem("GeocodeResponse/result/geometry/location/lng", "@B.Longitude")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsGetvalues("http://maps.googleapis.com/maps/api/geocode/xml?", "", "", "", "", "")]]>
				</code>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
	</method>
	<method name="WsSetHeader">
		<p name="name" type="string" qi="The name of the header. Smart parameters are supported.">
		</p>
		<p name="value" type="string" qi="The value for the specified header. Smart parameters are supported.">
		</p>
		<p name="add" type="bool" qi="If the specified header already exists, then set this parameter to TRUE for the new value to be added to the existing value. If you set this parameter to FALSE, then the existing value will be replaced by the new value.">
		</p>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[, if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[      Specify any header information about the response content. ]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<code>
<![CDATA[WsSetHeader("Content-Type", "text/xml", true)]]>
				</code>
<![CDATA[
]]>
<![CDATA[        ]]>
				<br>
				</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
	</method>
	<method name="WsClearHeaders">
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[, if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<ap>
<![CDATA[None.]]>
		</ap>
		<h>
<![CDATA[
]]>
<![CDATA[      Clear all the previously set web service headers.]]>
<![CDATA[
]]>
<![CDATA[      Call this action if you need to send a new set of headers for your next call to any web service.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<code>
<![CDATA[WsClearHeaders()]]>
				</code>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
	</method>
	<method name="WsSetNamespace">
		<p name="prefix" type="string" qi="The prefix for the namespace. Smart parameters are supported.">
		</p>
		<p name="uri" type="string" qi="The URI of the namespace. Smart parameters are supported.">
		</p>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[, if the action succeeds. Otherwise, ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[      Specify the namespace associated with the web service response.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<code>
<![CDATA[WsSetNamespace(""wb", "http://www.worldbank.org")]]>
					<br>
					</br>
<![CDATA[
]]>
<![CDATA[        WsGetvalues("http://api.worldbank.org/countries?format=xml", "wb", "", "//wb:countries/wb:country[5]/wb:name", "@B.Country", "")]]>
				</code>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
	</method>
	<method name="WsSetTimeout">
		<p name="timeout" type="int" qi="Timeout value in milliseconds.">
		</p>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[, if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[         The timeout value specified will be used for all subsequent requests to web services.]]>
			<br>
			</br>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[         If no timeout value is specified, the default value of 60000 (60 seconds) is used.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<code>
<![CDATA[WsSetTimeout(120000)]]>
				</code>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
	</method>
	<method name="WsSetCredentials">
		<p name="username" type="string" qi="The credential user name. Smart parameters are supported.">
		</p>
		<p name="password" type="string" qi="The credential password. Smart parameters are supported.">
		</p>
		<ret>
<![CDATA[
]]>
<![CDATA[      ]]>
			<b>
<![CDATA[True]]>
			</b>
<![CDATA[, if the action succeeds.  Otherwise, ]]>
			<b>
<![CDATA[False]]>
			</b>
<![CDATA[.]]>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[    ]]>
		</ret>
		<h>
<![CDATA[
]]>
<![CDATA[      Associates credentials that you need to send with web service calls for authentication.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      Use this action with the WsUploadData or WsUploadFile actions.]]>
			<br>
			</br>
			<br>
			</br>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[      ]]>
			<e>
<![CDATA[
]]>
<![CDATA[        ]]>
				<code>
<![CDATA[WsSetCredentials("abcdef", "xyz123")]]>
				</code>
<![CDATA[
]]>
<![CDATA[      ]]>
			</e>
<![CDATA[
]]>
<![CDATA[    ]]>
		</h>
		<lvl>
<![CDATA[All levels.]]>
		</lvl>
	</method>
</net>
</rrx>
<rrx namespace="Zones" src="c:\datacap\RRS\Zones.dll">

<i ref="rrunner">
</i>
<i ref="Locate">
</i>
<g>
</g>
<af name="PopulateZNField" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	PopulateZNField=DCOFieldFromCCO(CurrentObj, CCO)]]>
<![CDATA[
]]>
<![CDATA[	writelog("Found Value: '" & CurrentObj.Text & "' ")]]>
<![CDATA[
]]>
	</g>
</af>
<af name="PopulateZNLineItemField" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	PopulateZNLineItemField=False]]>
<![CDATA[
]]>
<![CDATA[    sPos=CurrentObj.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    If( sPos<>"" and sPos <> "0,0,0,0" ) Then]]>
<![CDATA[
]]>
<![CDATA[		If Not AdjustPosToParent(CurrentObj,"1") Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[		PopulateZNLineItemField=DCOFieldFromCCO(CurrentObj, CCO)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		PopulateZNLineItemField=true]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ScanDetails" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ScanDetails=False]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ScanDetailsEnter")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Must be a Field Object]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType<>3 Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action must be called from a DCO Field. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not DivideChildsByLines(CurrentObj, CCO, 1)>0 Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text=""]]>
<![CDATA[
]]>
<![CDATA[	nCount=CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To nCount-1]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.GetChild(i).CreateFields()]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	ScanDetails=True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ScanDetailsByLines" access="public" bInter="bInter" bDebug="bDebug" strParam="sParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	ScanDetailsByLines=False    ]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ScanDetailsByLinesEnter")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  'Must be a Field Object]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType<>3 Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action must be called from a DCO Field. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If Not DivideChildsByLines(CurrentObj, CCO, CLng(sParam))>0 Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text=""]]>
<![CDATA[
]]>
<![CDATA[	nCount=CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To nCount-1]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.GetChild(i).CreateFields()]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	ScanDetailsByLines=True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ScanDetailsByVSpace" access="public" bInter="bInter" bDebug="bDebug" strParam="sParam">
	<g>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ScanDetailsByVSpace=False]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ScanDetailsByVSpace...")]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Must be a Field Object]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType<>3 Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action must be called from a DCO Field. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Not DivideChildsByVSpace(CurrentObj, CCO, CLng(sParam))>0 Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Text=""]]>
<![CDATA[
]]>
<![CDATA[	nCount=CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To nCount-1]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.GetChild(i).CreateFields()]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	ScanDetailsByVSpace=True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ScanLineItem" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Dim newPos]]>
<![CDATA[
]]>
<![CDATA[	ScanLineItem=False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  'Must be a Field Object]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.ObjectType<>3 Then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Action must be called from a DCO Field. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	sName=oCurPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	Writelog(sName)]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.CreateFields()]]>
<![CDATA[
]]>
<![CDATA[	nCount=CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[	For i=0 To nCount-1]]>
<![CDATA[
]]>
<![CDATA[		Set oField=CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[		Writelog(oField.ID)]]>
<![CDATA[
]]>
<![CDATA[		If Not oField Is Nothing Then]]>
<![CDATA[
]]>
<![CDATA[            newPos=Trim(oField.Variable("Pos" & sName))]]>
<![CDATA[
]]>
<![CDATA[            If newPos="" then newPos="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[			      oField.Variable("Position")=newPos]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[	ScanLineItem=True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneTOP_UpperBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim l,w]]>
<![CDATA[
]]>
<![CDATA[  Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,UpperBound,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & UpperBound & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    ZoneTOP_UpperBound = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Call zn_CheckIMAGEFILE(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneTOP_LowerBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[  Dim l,w]]>
<![CDATA[
]]>
<![CDATA[  Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[  Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,LowerBound,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & LowerBound & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP_LowerBound = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Call zn_CheckIMAGEFILE(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneBOTTOM_UpperBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim l,w]]>
<![CDATA[
]]>
<![CDATA[  Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[  If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,UpperBound)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & UpperBound)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM_UpperBound = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneBOTTOM_LowerBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[	Dim l,w]]>
<![CDATA[
]]>
<![CDATA[  Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,LowerBound)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & LowerBound)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM_LowerBound = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneLEFT_LeftBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[	Dim l,w]]>
<![CDATA[
]]>
<![CDATA[  Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(LEFTBound,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & LEFTBound & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT_LeftBound = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneLEFT_RightBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[	Dim l,w]]>
<![CDATA[
]]>
<![CDATA[      Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   ]]>
<![CDATA[
]]>
<![CDATA[   If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(RIGHTBound,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & RIGHTBound & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT_RightBound = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneRIGHT_LeftBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[		Dim l,w]]>
<![CDATA[
]]>
<![CDATA[      Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,ZoneTOP,LeftBound,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & ZoneTOP & "," & LeftBound & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT_LeftBound = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneRIGHT_RightBound" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim l,w]]>
<![CDATA[
]]>
<![CDATA[  Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[ If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If clng(l)=clng(0) or clng(w)=clng(0) then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Current CCO Line or Word index selected to set boundry to. Exiting Function")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Item(l).Item(w).Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Item(l).Item(w).Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Item(l).Item(w).Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Item(l).Item(w).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	cStart = 1]]>
<![CDATA[
]]>
<![CDATA[	cEnd = CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	For cX = 1 To CCO.Item(l).Item(w).count]]>
<![CDATA[
]]>
<![CDATA[		If LeftBound = CCO.Item(l).Item(w).item(cx).Left Then cStart = cx]]>
<![CDATA[
]]>
<![CDATA[		If RightBound = CCO.Item(l).Item(w).item(cx).Right Then cEnd = cx]]>
<![CDATA[
]]>
<![CDATA[	Next 'cx]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,ZoneTOP,RIGHTBound,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & ZoneTOP & "," & RIGHTBound & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT_RightBound = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneRIGHT_ImageRight" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[  Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[  If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,ZoneTOP,RIGHTBound,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & ZoneTOP & "," & RIGHTBound & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT_ImageRight= True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneLEFT_ImageLeft" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[      Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   	If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(l,w)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(LEFTBound,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & LEFTBound & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT_ImageLeft= True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneBOTTOM_ImageBottom" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[      Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,LowerBound)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & LowerBound)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM_ImageBottom = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ZoneTOP_ImageTop" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[	Dim l,w]]>
<![CDATA[
]]>
<![CDATA[      Dim LeftBound,UpperBound,RightBound,LowerBound]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[   On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[   	If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	LeftBound = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[	UpperBound = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[	RightBound = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[	LowerBound = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Debuglog("Getting position information...")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ZoneLEFT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneRIGHT = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	ZoneBOTTOM = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[		ZoneLEFT = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		ZoneTOP = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		ZoneRIGHT  = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		ZoneBOTTOM = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Call CurrentObj.GetPosition(ZoneLEFT,ZoneTOP,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Positions found: " & ZoneLEFT & "," & ZoneTOP & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[	Call CurrentObj.SetPosition(ZoneLEFT,UpperBound,ZoneRIGHT,ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position Set to: " & ZoneLEFT & "," & UpperBound & "," & ZoneRIGHT & "," & ZoneBOTTOM)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	ZoneTOP_ImageTop= True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Call zn_CheckIMAGEFILE(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="ReadZones" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sName	]]>
<![CDATA[
]]>
<![CDATA[	Dim PosName]]>
<![CDATA[
]]>
<![CDATA[	Dim sOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim aOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim nXoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim nYoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim oCurPage]]>
<![CDATA[
]]>
<![CDATA[	Dim bPos]]>
<![CDATA[
]]>
<![CDATA[	Dim bPM]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	ReadZones=True]]>
<![CDATA[
]]>
<![CDATA[	sOffSet = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCurPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sOffSet=oCurPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	While oCurPage.ObjectType<>2 AND oCurPage.ObjectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oCurPage = oCurPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[		If len(sOffSet)=0 then sOffSet=oCurPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sName=oCurPage.Variable("TemplateID")	]]>
<![CDATA[
]]>
<![CDATA[	PosName = "Pos" & sName]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ReadZones for " & PosName)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aOffSet = Split(sOffSet & ",0" , ",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nXoffset = (-1*aOffSet(0))]]>
<![CDATA[
]]>
<![CDATA[	nYoffset = (-1*aOffSet(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nXoffSet)) or len(trim(nXoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nXoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("X offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nYoffSet)) or len(trim(nYoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nYoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("Y offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Offsets : " & nXoffset & "," & nYoffset)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oSet = 0]]>
<![CDATA[
]]>
<![CDATA[	xAdj = clng(nXoffSet)]]>
<![CDATA[
]]>
<![CDATA[	Yadj = clng(nYoffSet)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.ObjectType < 4 then ]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		sZonePos = CurrentObj.variable(PosName)]]>
<![CDATA[
]]>
<![CDATA[		'writelog("DCO pos:" & sZonePos)]]>
<![CDATA[
]]>
<![CDATA[		bPM = Not(CurrentObj.Variable("PatternMatch")="1")]]>
<![CDATA[
]]>
<![CDATA[		bPos = CurrentObj.Variable("Position")="0,0,0,0" or CurrentObj.Variable("Position")="" ]]>
<![CDATA[
]]>
<![CDATA[		If sZonePos <> "" and sZonePos <> "0,0,0,0" and bPM and bPos then]]>
<![CDATA[
]]>
<![CDATA[			arZonePos=split(sZonePos,",")]]>
<![CDATA[
]]>
<![CDATA[			If UBound(arZonePos)=3 Then]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(0)=arZonePos(0)+Xadj]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(1)=arZonePos(1)+Yadj]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(2)=arZonePos(2)+Xadj]]>
<![CDATA[
]]>
<![CDATA[				arZonePos(3)=arZonePos(3)+Yadj]]>
<![CDATA[
]]>
<![CDATA[				CurrentObj.Variable("Position")=CStr(arZonePos(0)) & "," & CStr(arZonePos(1)) & "," & CStr(arZonePos(2)) & "," & CStr(arZonePos(3))]]>
<![CDATA[
]]>
<![CDATA[				writelog("new pos:" & CurrentObj.Variable("Position"))		]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		Set oSetupNode = CurrentObj.SetupNode()]]>
<![CDATA[
]]>
<![CDATA[		If Not(oSetupNode is Nothing) then ]]>
<![CDATA[
]]>
<![CDATA[			If oSetupNode.variable("RecogType")="4" then]]>
<![CDATA[
]]>
<![CDATA[				writelog(space(oSet+2) & "OMR recogtype found.") ]]>
<![CDATA[
]]>
<![CDATA[				For nChar = 1 to oSetupNode.NumOfRules]]>
<![CDATA[
]]>
<![CDATA[					Set oSubRule = oSetupNode.GetRule(nChar-1)]]>
<![CDATA[
]]>
<![CDATA[					Set oSubChar = CurrentObj.GetChild(nChar-1)]]>
<![CDATA[
]]>
<![CDATA[					If Not(oSubRule is Nothing) then]]>
<![CDATA[
]]>
<![CDATA[						If oSubChar is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[							Set oSubChar = CurrentObj.AddChild(4, "", -1)]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						sZonePos = oSubRule.variable(PosName)]]>
<![CDATA[
]]>
<![CDATA[						writelog(space(oSet+2) & "Found ZonePos: " & sZonePos)]]>
<![CDATA[
]]>
<![CDATA[						if sZonePos <> "" and sZonePos <> "0,0,0,0" then]]>
<![CDATA[
]]>
<![CDATA[							arZonePos=split(sZonePos,",")]]>
<![CDATA[
]]>
<![CDATA[							If UBound(arZonePos)=3 Then]]>
<![CDATA[
]]>
<![CDATA[										]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(0)=arZonePos(0)+Xadj]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(1)=arZonePos(1)+Yadj]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(2)=arZonePos(2)+Xadj]]>
<![CDATA[
]]>
<![CDATA[								arZonePos(3)=arZonePos(3)+Yadj]]>
<![CDATA[
]]>
<![CDATA[										]]>
<![CDATA[
]]>
<![CDATA[								bRes = oSubChar.SetPosition(clng(arZonePos(0)) ,clng(arZonePos(1)),clng(arZonePos(2)),clng(arZonePos(3)))]]>
<![CDATA[
]]>
<![CDATA[								bRes = oSubChar.GetPosition(clng(arZonePos(0)) ,clng(arZonePos(1)),clng(arZonePos(2)),clng(arZonePos(3)))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[								'writelog("Saved X Y (" & CStr(arZonePos(2)- arZonePos(0)) & "," & CStr(arZonePos(3)-arZonePos(1)) & ") " & vbcrlf)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							end if]]>
<![CDATA[
]]>
<![CDATA[						end if]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[				Next 'nChar]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[		Set oSetupNode = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Call ZoneChildren(CurrentObj, PosName, oSet, Xadj, Yadj)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="LoadZones" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sName	]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosName]]>
<![CDATA[
]]>
<![CDATA[	Dim sOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim aOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim nXoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim nYoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim oCurPage]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	LoadZones=True]]>
<![CDATA[
]]>
<![CDATA[	sOffSet = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCurPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sOffSet=oCurPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	While oCurPage.ObjectType<>2 AND oCurPage.ObjectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oCurPage = oCurPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[		If len(sOffSet)=0 then sOffSet=oCurPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sName=StrParam	]]>
<![CDATA[
]]>
<![CDATA[	sPosName = "Pos" & sName]]>
<![CDATA[
]]>
<![CDATA[	Writelog("LoadZones for " & sPosName)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	aOffSet = Split(sOffSet & ",0" , ",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nXoffset = (-1*aOffSet(0))]]>
<![CDATA[
]]>
<![CDATA[	nYoffset = (-1*aOffSet(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nXoffSet)) or len(trim(nXoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nXoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("X offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nYoffSet)) or len(trim(nYoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nYoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("Y offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Offsets : " & nXoffset & "," & nYoffset)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ZoneChildren(CurrentObj, sPosName, 0, clng(nXoffSet), clng(nYoffSet))]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<f name="FindZoneLineItems" access="public">
	<p name="createSubfields">
	</p>
	<p name="createTempCCO">
	</p>
	<p name="subfieldFillType">
	</p>
	<p name="offsetPercent">
	</p>
	<p name="intersectionRatio">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA['Dev Comments - do not remove this information ]]>
<![CDATA[
]]>
<![CDATA['1)  If true then create and find lineitem subfields]]>
<![CDATA[
]]>
<![CDATA['    If false then only find lineitem]]>
<![CDATA[
]]>
<![CDATA['2)  If true (default) then Analyze the area & create block cco]]>
<![CDATA[
]]>
<![CDATA['    If false then use existing CCO as zone CCO to search]]>
<![CDATA[
]]>
<![CDATA['3)  Fill SubFields Option]]>
<![CDATA[
]]>
<![CDATA['	 1 - Fill by CCO word (default)]]>
<![CDATA[
]]>
<![CDATA['		 Optional setting of colon followed by groupwords value. i.e. '1:1.5']]>
<![CDATA[
]]>
<![CDATA['	 2 - Fill by CCO character]]>
<![CDATA[
]]>
<![CDATA['4)  Adjust Search LineItem Area to CCO Line start if start of line within x% difference of line length]]>
<![CDATA[
]]>
<![CDATA['	   Numeric Value of 0-100% - Larger values for Shorter Search Lines. Defaults to 0.]]>
<![CDATA[
]]>
<![CDATA['5)  Change Intersection Ration of Lines & Words for populating Lineitems & Subfields. Defaults to .25]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim arLine(3)]]>
<![CDATA[
]]>
<![CDATA[	Dim arWord(3)]]>
<![CDATA[
]]>
<![CDATA[	Dim arCurrLine]]>
<![CDATA[
]]>
<![CDATA[	Dim arSubField]]>
<![CDATA[
]]>
<![CDATA[	Dim arRoot]]>
<![CDATA[
]]>
<![CDATA[	Dim arChild]]>
<![CDATA[
]]>
<![CDATA[	Dim arFieldAdj	]]>
<![CDATA[
]]>
<![CDATA[	Dim arSub]]>
<![CDATA[
]]>
<![CDATA[	Dim arZone]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim oSubField	]]>
<![CDATA[
]]>
<![CDATA[	Dim oSubchildField]]>
<![CDATA[
]]>
<![CDATA[ 	Dim oRootItem]]>
<![CDATA[
]]>
<![CDATA[	Dim oRootPage]]>
<![CDATA[
]]>
<![CDATA[	Dim oSubRootChild]]>
<![CDATA[
]]>
<![CDATA[	Dim ochildfield]]>
<![CDATA[
]]>
<![CDATA[	Dim oLine]]>
<![CDATA[
]]>
<![CDATA[	Dim oWord]]>
<![CDATA[
]]>
<![CDATA[	Dim oCurrLine]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sPos]]>
<![CDATA[
]]>
<![CDATA[	Dim nLastLine]]>
<![CDATA[
]]>
<![CDATA[	Dim nLines]]>
<![CDATA[
]]>
<![CDATA[	Dim sConfString]]>
<![CDATA[
]]>
<![CDATA[	Dim OrigConf ]]>
<![CDATA[
]]>
<![CDATA[	Dim sBaseName ]]>
<![CDATA[
]]>
<![CDATA[	Dim zoneCCO]]>
<![CDATA[
]]>
<![CDATA[	Dim nLastLineHeight]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim sName]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosName]]>
<![CDATA[
]]>
<![CDATA[	Dim sOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim aOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim nXoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim nYoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim i,j,k,u,z]]>
<![CDATA[
]]>
<![CDATA[	Dim hDiff,lDiff,pDiff	]]>
<![CDATA[
]]>
<![CDATA[	Dim IRatio]]>
<![CDATA[
]]>
<![CDATA[	Dim iName]]>
<![CDATA[
]]>
<![CDATA[	Dim bAnalyzeBlock]]>
<![CDATA[
]]>
<![CDATA[	Dim bCreateFields]]>
<![CDATA[
]]>
<![CDATA[	Dim bCharBounds	]]>
<![CDATA[
]]>
<![CDATA[	Dim pNm]]>
<![CDATA[
]]>
<![CDATA[	Dim pHt]]>
<![CDATA[
]]>
<![CDATA[	Dim Px]]>
<![CDATA[
]]>
<![CDATA[	Dim Tobj,zTop]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim tPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim sMCCO]]>
<![CDATA[
]]>
<![CDATA[	Dim sFillType]]>
<![CDATA[
]]>
<![CDATA[	Dim nGroupValue]]>
<![CDATA[
]]>
<![CDATA[	Dim arGroup]]>
<![CDATA[
]]>
<![CDATA[	Dim bLineAdj]]>
<![CDATA[
]]>
<![CDATA[	Dim nRatio]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	FindZoneLineItems = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  'Check for sub field to use as 'Lineitem' - required]]>
<![CDATA[
]]>
<![CDATA[  If CurrentObj.SetupNode().NumOfRules=0 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Calling Field '" & CurrentObj.ID & "' has no child fields in the Setup DCO. Exiting")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if    ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Parse and Check Parameter Values	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	bCreateFields = ucase(Trim(createSubfields))  ' Parameter 1]]>
<![CDATA[
]]>
<![CDATA[	bAnalyzeBlock = ucase(Trim(createTempCCO))    ' Parameter 2]]>
<![CDATA[
]]>
<![CDATA[	sFillType     = trim(subfieldFillType)        ' Parameter 3]]>
<![CDATA[
]]>
<![CDATA[	bLineAdj      = ucase(trim(offsetPercent))    ' Parameter 4]]>
<![CDATA[
]]>
<![CDATA[	nRatio        = trim(intersectionRatio)       ' Parameter 5]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'PARAMETER 1]]>
<![CDATA[
]]>
<![CDATA[	If bCreateFields = "" Then bCreateFields = "TRUE"]]>
<![CDATA[
]]>
<![CDATA[	If bCreateFields="TRUE" Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("CreateFields option is 'ON'.")]]>
<![CDATA[
]]>
<![CDATA[	ElseIf bCreateFields="FALSE" Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("CreateFields option is 'OFF'.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Unknown CreateFields Parameter. Using Default of 'ON'.")]]>
<![CDATA[
]]>
<![CDATA[		bCreateFields="TRUE"]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'PARAMETER 2	]]>
<![CDATA[
]]>
<![CDATA[	If bAnalyzeBlock = "" Then bAnalyzeBlock = "TRUE"]]>
<![CDATA[
]]>
<![CDATA[	If bAnalyzeBlock="TRUE" Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("AnalyzeBlock option is 'ON'.")]]>
<![CDATA[
]]>
<![CDATA[	ElseIf bAnalyzeBlock="FALSE" Then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("AnalyzeBlock option is 'OFF'.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Unknown bAnalyzeBlock Parameter. Using Default of 'ON'.")]]>
<![CDATA[
]]>
<![CDATA[		bAnalyzeBlock="TRUE"]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'PARAMETER 3]]>
<![CDATA[
]]>
<![CDATA[	If sFillType = "" Then sFillType = "1:0"]]>
<![CDATA[
]]>
<![CDATA[	If instr(sFillType,":")>0 Then]]>
<![CDATA[
]]>
<![CDATA[		aFillType = Split(sFillType,":")]]>
<![CDATA[
]]>
<![CDATA[		sFillType = aFillType(0)		]]>
<![CDATA[
]]>
<![CDATA[		nGroupvalue = aFillType(1)]]>
<![CDATA[
]]>
<![CDATA[		If Not isnumeric(Trim(nGroupvalue)) Then ]]>
<![CDATA[
]]>
<![CDATA[			nGroupValue=clng(0)]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			nGroupvalue=clng(nGroupValue)]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		nGroupValue = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	If NOT instr("1,2",sFillType)>0 then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Invalid FillType Parameter")]]>
<![CDATA[
]]>
<![CDATA[		sFillType="1"]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'PARAMETER 4]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(bLineAdj) then]]>
<![CDATA[
]]>
<![CDATA[		bLineAdj = "0"]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  Writelog("offsetPercent = '" & bLineAdj & "'.")]]>
<![CDATA[
]]>
<![CDATA[	bLineAdj = cint(bLineAdj)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    'PARAMETER 5]]>
<![CDATA[
]]>
<![CDATA[	If Not IsNumeric(nRatio) then]]>
<![CDATA[
]]>
<![CDATA[		nRatio = ".25"]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[  Writelog("intersectionRatio = '" & nRatio & "'.")]]>
<![CDATA[
]]>
<![CDATA[	nRatio = cdbl(nRatio)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Note: The "LineItem" field Defaults to the first child for the calling field.]]>
<![CDATA[
]]>
<![CDATA[	Set oRootItem = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oRootPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	Set oCurrLine = Nothing]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'look for local offset value before page offset value]]>
<![CDATA[
]]>
<![CDATA[	sOffSet = oRootPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	While oRootPage.ObjectType > 2 And Not(oRootPage.ObjectType<=1)]]>
<![CDATA[
]]>
<![CDATA[		Set oRootPage = oRootPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[		If sOffSet = "" then sOffSet = oRootPage.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'loading current Fingerprint ID]]>
<![CDATA[
]]>
<![CDATA[	sPosName = "Pos" & oRootPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Calculate offset string]]>
<![CDATA[
]]>
<![CDATA[	aOffSet = Split(sOffSet & ",0" , ",")]]>
<![CDATA[
]]>
<![CDATA[	nXoffset = aOffSet(0)]]>
<![CDATA[
]]>
<![CDATA[	nYoffset = aOffSet(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(IsNumeric(nXoffSet)) Or Len(Trim(nXoffSet))=0 Then ]]>
<![CDATA[
]]>
<![CDATA[		nXoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("X offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		nXoffset = (-1*nXoffset)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(IsNumeric(nYoffSet)) Or Len(Trim(nYoffSet))=0 Then ]]>
<![CDATA[
]]>
<![CDATA[		nYoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("Y offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		nYoffset = (-1*nYoffset)]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Offset Value : " & nXoffset & "," & nYoffset)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nLines=0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find Current Position limits]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)	]]>
<![CDATA[
]]>
<![CDATA[	If ubound(arField)<>3 then arField=SplitNumber("0,0,0,0")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Search zone is empty or Zero's (0,0,0,0). Checking parent node for valid zone...")]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		tPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    If tPosition="" or tPosition="0,0,0,0" Then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Position info for " & oParent.Id & ":'" & tPosition & "' is empty or Zero's.")]]>
<![CDATA[
]]>
<![CDATA[    Else]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Setting search zone to position from " & oParent.Id & ":'" & tPosition & "'.")]]>
<![CDATA[
]]>
<![CDATA[      sPosition=tPosition]]>
<![CDATA[
]]>
<![CDATA[	  End if]]>
<![CDATA[
]]>
<![CDATA[  Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  If sPosition="" or sPosition="0,0,0,0" then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("A valid search zone (not empty or Zero's) was not found. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)]]>
<![CDATA[
]]>
<![CDATA[	nStarted=0]]>
<![CDATA[
]]>
<![CDATA[	nLastLine = -1]]>
<![CDATA[
]]>
<![CDATA[	hdiff = 0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	arField(0) = arField(0)-10]]>
<![CDATA[
]]>
<![CDATA[	arField(1) = arField(1)-10]]>
<![CDATA[
]]>
<![CDATA[	If arField(2)>0 then arField(2) = arField(2)+10]]>
<![CDATA[
]]>
<![CDATA[	If arField(3)>0 then arField(3) = arField(3)+10]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Establish Search Limits for ZEROED zone values]]>
<![CDATA[
]]>
<![CDATA[	If arField(0) <= 0 Then ]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = CCO.Left]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If arField(1) <= 0 Then ]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = CCO.Top]]>
<![CDATA[
]]>
<![CDATA[		If CCO.Count > 0 Then arField(1) = CCO.Item(1).Top]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If arField(2) > CCO.Right Or arField(2) <= 0 Then arField(2) = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find Lowest zoneCCO Position]]>
<![CDATA[
]]>
<![CDATA[	If arField(3) > CCO.Bottom Or arField(3) <= 0  Then ]]>
<![CDATA[
]]>
<![CDATA[		If CCO.Count>0 then ]]>
<![CDATA[
]]>
<![CDATA[			arField(3) = CCO.item(CCO.Count).Bottom]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			arField(3) = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If arField(0)>arField(2) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Swapping left and right zone positions")]]>
<![CDATA[
]]>
<![CDATA[		Dim tval]]>
<![CDATA[
]]>
<![CDATA[		tval = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		arField(2) = tval]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If arField(1)>arField(3) Then]]>
<![CDATA[
]]>
<![CDATA[		writelog("Swapping top and bottom zone positions")]]>
<![CDATA[
]]>
<![CDATA[		tval = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = arField(3)]]>
<![CDATA[
]]>
<![CDATA[		arField(3) = tval]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	 ]]>
<![CDATA[
]]>
<![CDATA[	If CurrentObj.Variable("Position") = "0,0,0,0" or CurrentObj.Variable("Position") = "" then]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("Position") = cstr(arField(0)) & "," & cstr(arfield(1)) & "," & cstr(arfield(2)) & "," & cstr(arField(3))]]>
<![CDATA[
]]>
<![CDATA[	End if ]]>
<![CDATA[
]]>
<![CDATA[		 ]]>
<![CDATA[
]]>
<![CDATA[	iName = oCurPage.Imagename ]]>
<![CDATA[
]]>
<![CDATA[	iName = Left(iName, Len(iName)-4) & "_"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If bAnalyzeBlock = "FALSE" Then]]>
<![CDATA[
]]>
<![CDATA[		Set ZoneCCO = CCO]]>
<![CDATA[
]]>
<![CDATA[	ElseIf Not FileMgr.FileExists(iName & CurrentObj.ID & ".CCO") Then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Analyzing New BlockCCO...")]]>
<![CDATA[
]]>
<![CDATA[		Set zoneCCO = CCOCreator.AnalyzeBlock(oRootPage.Imagename,arField(0),arField(1),arField(2),arField(3))	]]>
<![CDATA[
]]>
<![CDATA[		Call GetBlockChars(zoneCCO, arField(0),arField(1),arField(2),arField(3))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Call zoneCCO.Save(iName & CurrentObj.ID & ".CCO")]]>
<![CDATA[
]]>
<![CDATA[		CurrentObj.Variable("CCOBlock") = iName & CurrentObj.ID & ".CCO"]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Dim lbCCOCreator]]>
<![CDATA[
]]>
<![CDATA[		set lbCCOCreator = CreateObject("CCO._CCOCreator.1")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		set zoneCCO = lbCCOCreator.load(iName & CurrentObj.ID & ".CCO")]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Loading BlockCCO '" & iName & CurrentObj.ID & ".CCO" & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ 		Set lbCCOCreator = nothing]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Writelog("** FindLineItems v7.5.29 **")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Create and Init Page Height Dictionary - cumulative height counter by page number]]>
<![CDATA[
]]>
<![CDATA[	pNm=0]]>
<![CDATA[
]]>
<![CDATA[	pHt=0]]>
<![CDATA[
]]>
<![CDATA[	prevHt=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Initialize MCCO Page Counter]]>
<![CDATA[
]]>
<![CDATA[	sMCCO=oCurPage.Variable("CCOBlock")]]>
<![CDATA[
]]>
<![CDATA[	If sMCCO<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = FileMgr.GetFileName(sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("MCCO file loaded: " & sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = sMCCO & "_"]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Function to Find Start Line here! ]]>
<![CDATA[
]]>
<![CDATA[	Dim LookTop]]>
<![CDATA[
]]>
<![CDATA[	Dim LookLine]]>
<![CDATA[
]]>
<![CDATA[	Dim LookEnd]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	LookTop = 1]]>
<![CDATA[
]]>
<![CDATA[	LookEnd = zoneCCO.Count]]>
<![CDATA[
]]>
<![CDATA[	LookLine = LookEnd]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call zoneCCO.LocateLines(arField(1),arField(3),LookTop,LookEnd)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Writelog("ZNTop='" & arField(1) & "' ZNBottom='" & arField(3) & "' LineTop=" & LookTop & " LBottom=" & LookEnd)]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If LookTop = 0 or LookEnd = 0 or zoneCCO.Count=0 then ]]>
<![CDATA[
]]>
<![CDATA[	    Writelog("No Recognition Characters in Search Area.")]]>
<![CDATA[
]]>
<![CDATA[	    Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	For i=LookTop To LookEnd	]]>
<![CDATA[
]]>
<![CDATA[		Set oLine=zoneCCO.Item(i)]]>
<![CDATA[
]]>
<![CDATA[		arLine(0)=oLine.Left]]>
<![CDATA[
]]>
<![CDATA[		arLine(1)=oLine.Top]]>
<![CDATA[
]]>
<![CDATA[		arLine(2)=oLine.Right]]>
<![CDATA[
]]>
<![CDATA[		arLine(3)=oLine.Bottom]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		'Cumulative Page Height Counter	- for merged CCO's		]]>
<![CDATA[
]]>
<![CDATA[		If oLine.ImageNum>pNm then 		]]>
<![CDATA[
]]>
<![CDATA[			pNm = oLine.ImageNum		]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[		'Calculate an intersection ratio of oLine to Search Area]]>
<![CDATA[
]]>
<![CDATA[		IRatio = 1 'IntersectRatio(arField, arLine)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		ErrorHandler("FindZoneLineItems Position 100")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If IRatio>0 Then 'CCO line is within the Details Search Area	- Line (i) Intersects Detail Area. ]]>
<![CDATA[
]]>
<![CDATA[			Writelog(Space(4) & "Line " & cstr(i) & " Image " & pNm & " '" & oLine.Value & "'")]]>
<![CDATA[
]]>
<![CDATA[			For j=1 To zoneCCO.Item(i).Count]]>
<![CDATA[
]]>
<![CDATA[				Set oWord = zoneCCO.Item(i).Item(j)			]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[				arWord(0)=oWord.Left]]>
<![CDATA[
]]>
<![CDATA[				arWord(1)=oWord.Top]]>
<![CDATA[
]]>
<![CDATA[				arWord(2)=oWord.Right]]>
<![CDATA[
]]>
<![CDATA[				arWord(3)=oWord.Bottom]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				'Calculate an intersection ratio of oWord to Search Area]]>
<![CDATA[
]]>
<![CDATA[				IRatio = IntersectRatio(arField, arWord)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				'Calculate GroupWords Area - for SubField Population]]>
<![CDATA[
]]>
<![CDATA[				arGroup=arWord]]>
<![CDATA[
]]>
<![CDATA[				If nGroupValue>clng(0) AND oWord.Count>0 Then]]>
<![CDATA[
]]>
<![CDATA[					'Calculate nPixels]]>
<![CDATA[
]]>
<![CDATA[					nPixels = nGroupValue * ((oWord.Right-oWord.Left)/oWord.Count)]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					'Check Word Left]]>
<![CDATA[
]]>
<![CDATA[					If j>1 then ]]>
<![CDATA[
]]>
<![CDATA[						If (oWord.Left-oLine.Item(j-1).Right)<=nPixels Then]]>
<![CDATA[
]]>
<![CDATA[							arGroup(0)=oLine.Item(j-1).left]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					'Check Word Right]]>
<![CDATA[
]]>
<![CDATA[					If j<oLine.Count then]]>
<![CDATA[
]]>
<![CDATA[						if (oLine.Item(j+1).Left-oWord.Right)<=nPixels Then	]]>
<![CDATA[
]]>
<![CDATA[							arGroup(2)=oLine.Item(j+1).Right]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[					End if	]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[				ErrorHandler("FindZoneLineItems Position 200")]]>
<![CDATA[
]]>
<![CDATA[				If IRatio>0 Then 'CCO Word is within the Details Search Area - Word (j) Intersects Detail Area. 							]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					'Find Next Child to Create (could be the first child)]]>
<![CDATA[
]]>
<![CDATA[					If nLastLine = -1 Then 							]]>
<![CDATA[
]]>
<![CDATA[						If (CurrentObj.NumOfChildren - Len(CurrentObj.Text)) = 0 Then ]]>
<![CDATA[
]]>
<![CDATA[							'No existing sub-fields found - creating first child]]>
<![CDATA[
]]>
<![CDATA[							CurrentObj.CreateFields()]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							'Existing sub-fields found - Creating Next child]]>
<![CDATA[
]]>
<![CDATA[							For Px = 1 To (CurrentObj.NumOfChildren - Len(CurrentObj.Text)) ]]>
<![CDATA[
]]>
<![CDATA[								sBaseName = CurrentObj.SetupNode().GetRule(0).Name ]]>
<![CDATA[
]]>
<![CDATA[								Set TObj = CurrentObj.GetChild(Px-1)]]>
<![CDATA[
]]>
<![CDATA[								sNum = Replace(TObj.Id,sBaseName,"")]]>
<![CDATA[
]]>
<![CDATA[								If Len(sNum) > 0 And IsNumeric(sNum) Then]]>
<![CDATA[
]]>
<![CDATA[									If CInt(sNum) > nLines Then ]]>
<![CDATA[
]]>
<![CDATA[										nLines = CInt(sNum)]]>
<![CDATA[
]]>
<![CDATA[										'writelog(Space(6) & "Next Line number changes to:" & nLines)]]>
<![CDATA[
]]>
<![CDATA[									End If]]>
<![CDATA[
]]>
<![CDATA[								End If 	]]>
<![CDATA[
]]>
<![CDATA[								Set Tobj=nothing]]>
<![CDATA[
]]>
<![CDATA[							Next 'P	]]>
<![CDATA[
]]>
<![CDATA[							nLines = nLines + 1					]]>
<![CDATA[
]]>
<![CDATA[						End If					]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					'THIS SECTION CREATES NEW LINES ONLY]]>
<![CDATA[
]]>
<![CDATA[					If nLines = 0 And i <> nLastLine Then ]]>
<![CDATA[
]]>
<![CDATA[						'ONLY 1ST LINE LOGIC						]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						Set oCurrLine=CurrentObj.GetChild(nLines)]]>
<![CDATA[
]]>
<![CDATA[						If oCurrLine Is Nothing Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[						If oCurrLine.variable(sPosName)<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[							arCurrLine = splitnumber(oCurrLine.variable(sPosName))]]>
<![CDATA[
]]>
<![CDATA[						ElseIf oCurrLine.Variable("Position")<>"" then]]>
<![CDATA[
]]>
<![CDATA[							arCurrLine = splitnumber(oCurrLine.Variable("Position")) ]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							arCurrLine = splitnumber("0,0,0,0")]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						'Calculate Zone Height]]>
<![CDATA[
]]>
<![CDATA[						zTop = arCurrLine(1)]]>
<![CDATA[
]]>
<![CDATA[						hDiff = arCurrLine(3)-arCurrLine(1)]]>
<![CDATA[
]]>
<![CDATA[						lDiff = arLine(3)-arLine(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						'Calculate % difference in height]]>
<![CDATA[
]]>
<![CDATA[						If hDiff>lDiff Then pDiff = lDiff/hDiff		]]>
<![CDATA[
]]>
<![CDATA[				 		If lDiff>hDiff Then pDiff = hDiff/lDiff]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						'Calculate local offset]]>
<![CDATA[
]]>
<![CDATA[						'Writelog("LOF%:'" & cint(abs(oLine.Left-arCurrLine(0))/(arCurrLine(2)-arCurrLine(0))*100) & "%'")]]>
<![CDATA[
]]>
<![CDATA[						'Writelog("CurXoff:'" & nXoffset & "' PercentXoff:'" & (oLine.Left-arCurrLine(0))& "'")]]>
<![CDATA[
]]>
<![CDATA[						If bLineAdj>cint(0) Then]]>
<![CDATA[
]]>
<![CDATA[							If cint(abs(oLine.Left-arCurrLine(0))/(arCurrLine(2)-arCurrLine(0))*100)<=bLineAdj then]]>
<![CDATA[
]]>
<![CDATA[								nXoffset = (oLine.Left-arCurrLine(0))]]>
<![CDATA[
]]>
<![CDATA[								Writelog("Line X offset:'" & nXoffset & "'")]]>
<![CDATA[
]]>
<![CDATA[							End if	]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						'Adjust Zone Positions]]>
<![CDATA[
]]>
<![CDATA[                        If arCurrLine(2)>arCurrLine(0) Then]]>
<![CDATA[
]]>
<![CDATA[    						arCurrLine(0) = arCurrLine(0) + CLng(nXoffset)					]]>
<![CDATA[
]]>
<![CDATA[		    				arCurrLine(2) = arCurrLine(2) + CLng(nXoffset)]]>
<![CDATA[
]]>
<![CDATA[                        End if]]>
<![CDATA[
]]>
<![CDATA[                        arCurrLine(1) = arLine(1) 'Set Top of new line to current CCO line]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						'Need to check zone height restrictions for 1 or 2+ lines-]]>
<![CDATA[
]]>
<![CDATA[						'i.e. are all subfields on same H plane or check line height vs Zone height as a percentage.]]>
<![CDATA[
]]>
<![CDATA[						If pDiff<.8 Then ]]>
<![CDATA[
]]>
<![CDATA[							arCurrLine(3) = arCurrLine(1) + CLng(hdiff) 'Set Bottom of new line to current + zone height]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							arCurrLine(3) = arLine(3) ]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						'Save Adjusted Zone & ID]]>
<![CDATA[
]]>
<![CDATA[						oCurrLine.Id = oCurrLine.Id & CStr(nLines)]]>
<![CDATA[
]]>
<![CDATA[						oCurrLine.Variable("Zone") = CStr(arField(0)) & "," & CStr(arLine(1)) & "," & CStr(arField(2)) & "," & CStr(arLine(3))														]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[						'Save Adjusted Position]]>
<![CDATA[
]]>
<![CDATA[						oCurrLine.Variable("Position") = CStr(arCurrLine(0)) & "," & CStr(arCurrLine(1)-clng(pHt)) & "," & CStr(arCurrLine(2)) & "," & CStr(arCurrLine(3)-clng(pHt))]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[						If pNm>1 then]]>
<![CDATA[
]]>
<![CDATA[							If Ucase(FileMgr.GetFileName(oCurrLine.Variable("IMAGEFILE")))<>ucase(oCurPage.Variable(sMCCO & cstr(pNm))) then							]]>
<![CDATA[
]]>
<![CDATA[								If Trim(oCurPage.Variable(sMCCO & cstr(pNm)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[                                    oCurrLine.Variable("IMAGEFILE")=oCurPage.Variable(sMCCO & cstr(pNm))]]>
<![CDATA[
]]>
<![CDATA[	                            end if]]>
<![CDATA[
]]>
<![CDATA[    						End if]]>
<![CDATA[
]]>
<![CDATA[							oCurrLine.Variable("IMAGEHEIGHT")=oLine.ImageHeight]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[											]]>
<![CDATA[
]]>
<![CDATA[						'Create Sub Fields T/F]]>
<![CDATA[
]]>
<![CDATA[						If bCreateFields = "TRUE" Then Call oCurrLine.CreateFields()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						ErrorHandler("FindZoneLineItems Position 300")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						For k = 1 To (oCurrLine.NumOfChildren - Len(oCurrLine.text)) 																	]]>
<![CDATA[
]]>
<![CDATA[														]]>
<![CDATA[
]]>
<![CDATA[							Set oSubRootChild = oCurrLine.GetChild(k-1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							If oSubRootChild.Variable(sPosName)<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[								arRoot = splitnumber(oSubRootChild.Variable(sPosName))]]>
<![CDATA[
]]>
<![CDATA[							Else]]>
<![CDATA[
]]>
<![CDATA[								arRoot = splitnumber(oSubRootChild.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[												]]>
<![CDATA[
]]>
<![CDATA[							hDiff = arRoot(3)-arRoot(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							'Adjust Zone Positions]]>
<![CDATA[
]]>
<![CDATA[							If arRoot(2)>arRoot(0) then    ]]>
<![CDATA[
]]>
<![CDATA[                                arRoot(0) = arRoot(0) + CLng(nXoffset)]]>
<![CDATA[
]]>
<![CDATA[							    arRoot(2) = arRoot(2) + CLng(nXoffset)]]>
<![CDATA[
]]>
<![CDATA[                            End if]]>
<![CDATA[
]]>
<![CDATA[                            arRoot(1) = arCurrLine(1) + (arRoot(1) - CLng(zTop))]]>
<![CDATA[
]]>
<![CDATA[							arRoot(3) = arRoot(1) + CLng(hDiff)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[							If arRoot(0)<clng(0) then arRoot(0)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[							If arRoot(2)<clng(0) then arRoot(2)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[  							'Save Adjusted Position]]>
<![CDATA[
]]>
<![CDATA[							oSubRootChild.Variable("Position") = CStr(arRoot(0)) & "," & CStr(arRoot(1)-clng(pHt)) & "," & CStr(arRoot(2)) & "," & CStr(arRoot(3)-clng(pHt))]]>
<![CDATA[
]]>
<![CDATA[														]]>
<![CDATA[
]]>
<![CDATA[							sPos = CStr(arRoot(0)) & "," & CStr(arWord(1)) & "," & CStr(arRoot(2)) & "," & CStr(arWord(3))]]>
<![CDATA[
]]>
<![CDATA[														]]>
<![CDATA[
]]>
<![CDATA[							oSubRootChild.Variable("Zone") = sPos]]>
<![CDATA[
]]>
<![CDATA[							oSubRootChild.Status = 0]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[							If pNm>1 then oSubRootChild.Variable("IMAGEHEIGHT")=oLine.ImageHeight]]>
<![CDATA[
]]>
<![CDATA[						Next 'k											]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						nLastLine = i]]>
<![CDATA[
]]>
<![CDATA[						nLines = nLines + 1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					Elseif nLines > 0 And i <> nLastLine Then ]]>
<![CDATA[
]]>
<![CDATA[						'2ND LINE+ LOGIC]]>
<![CDATA[
]]>
<![CDATA[						'Check if word is within the last LineItem's boundries. If yes then bypass creating a new lineitem.]]>
<![CDATA[
]]>
<![CDATA[						IRatio = IntersectRatio(arCurrLine, arWord)]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						If IRatio=0 Then 	]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[							'Get Last Child of same type if oCurrLine is Nothing]]>
<![CDATA[
]]>
<![CDATA[							If oCurrLine is Nothing then Set oCurrLine = CurrentObj.GetChild(CurrentObj.NumOfChildren - Len(CurrentObj.Text)-1)]]>
<![CDATA[
]]>
<![CDATA[														]]>
<![CDATA[
]]>
<![CDATA[							'Create Next Line & Index Name]]>
<![CDATA[
]]>
<![CDATA[							sBaseName = CurrentObj.SetupNode().GetRule(0).Name ]]>
<![CDATA[
]]>
<![CDATA[							Set oNextLine=CurrentObj.AddChild(3, sBaseName & CStr(nLines), -1)]]>
<![CDATA[
]]>
<![CDATA[							If oNextLine Is Nothing Then Exit For]]>
<![CDATA[
]]>
<![CDATA[							oNextLine.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[							oNextLine.Status = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							'Get Zone Position Info]]>
<![CDATA[
]]>
<![CDATA[							If oNextLine.variable(sPosName)<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[								arCurrLine = splitnumber(oNextLine.variable(sPosName))]]>
<![CDATA[
]]>
<![CDATA[							ElseIf oNextLine.Variable("Position")<>"" then]]>
<![CDATA[
]]>
<![CDATA[								arCurrLine = splitnumber(oNextLine.Variable("Position")) ]]>
<![CDATA[
]]>
<![CDATA[							Else]]>
<![CDATA[
]]>
<![CDATA[								arCurrLine = splitnumber("0,0,0,0")]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[														]]>
<![CDATA[
]]>
<![CDATA[							'Calculate Zone Height]]>
<![CDATA[
]]>
<![CDATA[							zTop = arCurrLine(1)]]>
<![CDATA[
]]>
<![CDATA[							hDiff = arCurrLine(3)-arCurrLine(1)]]>
<![CDATA[
]]>
<![CDATA[							lDiff = arLine(3)-arLine(1)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							'Calculate % difference in height]]>
<![CDATA[
]]>
<![CDATA[							If hDiff>lDiff Then pDiff = lDiff/hDiff		]]>
<![CDATA[
]]>
<![CDATA[				 			If lDiff>hDiff Then pDiff = hDiff/lDiff]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							'Calculate local offset]]>
<![CDATA[
]]>
<![CDATA[							'Writelog("LOF%:'" & cint(abs(oLine.Left-arCurrLine(0))/(arCurrLine(2)-arCurrLine(0))*100) & "%'")]]>
<![CDATA[
]]>
<![CDATA[							'Writelog("CurXoff:'" & nXoffset & "' PercentXoff:'" & (oLine.Left-arCurrLine(0))& "'")]]>
<![CDATA[
]]>
<![CDATA[							If bLineAdj>cint(0) Then]]>
<![CDATA[
]]>
<![CDATA[								If cint(abs(oLine.Left-arCurrLine(0))/(arCurrLine(2)-arCurrLine(0))*100)<=bLineAdj then]]>
<![CDATA[
]]>
<![CDATA[									nXoffset = (oLine.Left-arCurrLine(0))]]>
<![CDATA[
]]>
<![CDATA[									Writelog("Line X offset:'" & nXoffset & "'")]]>
<![CDATA[
]]>
<![CDATA[								End if	]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[							'Adjust Zone Positions]]>
<![CDATA[
]]>
<![CDATA[                            If arCurrLine(2)>arCurrLine(0) Then]]>
<![CDATA[
]]>
<![CDATA[    							arCurrLine(0) = arCurrLine(0) + CLng(nXoffset)]]>
<![CDATA[
]]>
<![CDATA[	                            arCurrLine(2) = arCurrLine(2) + CLng(nXoffset)]]>
<![CDATA[
]]>
<![CDATA[                            End if]]>
<![CDATA[
]]>
<![CDATA[    						arCurrLine(1) = arLine(1) 'Set Top of new line to current CCO line]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[							'Need to check zone height restrictions for 1 or 2+ lines-]]>
<![CDATA[
]]>
<![CDATA[							'i.e. are all subfields on same H plane or check line height vs Zone height as a percentage.]]>
<![CDATA[
]]>
<![CDATA[							If pDiff<.8 Then ]]>
<![CDATA[
]]>
<![CDATA[								arCurrLine(3) = arCurrLine(1) + CLng(hdiff) 'Set Bottom of new line to current + zone height]]>
<![CDATA[
]]>
<![CDATA[							Else]]>
<![CDATA[
]]>
<![CDATA[								arCurrLine(3) = arLine(3) ]]>
<![CDATA[
]]>
<![CDATA[							End If]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[							'Save Adjusted Position]]>
<![CDATA[
]]>
<![CDATA[							oNextLine.Variable("Position") = CStr(arCurrLine(0)) & "," & CStr(arCurrLine(1)-clng(pHt)) & "," & CStr(arCurrLine(2)) & "," & CStr(arCurrLine(3)-clng(pHt))]]>
<![CDATA[
]]>
<![CDATA[							oNextLine.Variable("Zone") = CStr(arField(0)) & "," & CStr(arLine(1)) & "," & CStr(arField(2)) & "," & CStr(arLine(3))]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[							'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[							If pNm>1 then]]>
<![CDATA[
]]>
<![CDATA[								If Ucase(FileMgr.GetFileName(oNextLine.Variable("IMAGEFILE")))<>ucase(oCurPage.Variable(sMCCO & cstr(pNm))) then]]>
<![CDATA[
]]>
<![CDATA[									If Trim(oCurPage.Variable(sMCCO & cstr(pNm)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[                                        oNextLine.Variable("IMAGEFILE")=oCurPage.Variable(sMCCO & cstr(pNm))]]>
<![CDATA[
]]>
<![CDATA[                                    end if]]>
<![CDATA[
]]>
<![CDATA[								End if]]>
<![CDATA[
]]>
<![CDATA[								oCurrLine.Variable("IMAGEHEIGHT")=oLine.ImageHeight]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[																]]>
<![CDATA[
]]>
<![CDATA[							If bCreateFields = "TRUE" Then Call oNextLine.CreateFields]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[							ErrorHandler("FindZoneLineItems Position 400")	]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[							For k = 1 To (oNextLine.NumOfChildren - Len(oNextLine.text))				]]>
<![CDATA[
]]>
<![CDATA[								If oCurrLine is Nothing Then Exit For]]>
<![CDATA[
]]>
<![CDATA[													]]>
<![CDATA[
]]>
<![CDATA[								Set oSubChildField = oNextLine.GetChild(k-1)]]>
<![CDATA[
]]>
<![CDATA[								Set oSubRootChild = oCurrLine.GetChild(k-1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[								If oSubRootchild Is Nothing Then Exit For]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[								If oSubRootChild.Variable("Zone")<>"" Then]]>
<![CDATA[
]]>
<![CDATA[									arRoot = splitNumber(oSubRootChild.Variable("Zone"))]]>
<![CDATA[
]]>
<![CDATA[								Else]]>
<![CDATA[
]]>
<![CDATA[									arRoot = splitNumber("0,0,0,0")]]>
<![CDATA[
]]>
<![CDATA[								End if									]]>
<![CDATA[
]]>
<![CDATA[															]]>
<![CDATA[
]]>
<![CDATA[								sPos = CStr(arRoot(0)) & "," & CStr(arWord(1)) & "," & CStr(arRoot(2)) & "," & CStr(arWord(3))]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[								arSubChildField = splitnumber(oSubChildField.Variable(sPosName))]]>
<![CDATA[
]]>
<![CDATA[																							]]>
<![CDATA[
]]>
<![CDATA[								If ubound(arSubChildField)=3 Then				]]>
<![CDATA[
]]>
<![CDATA[									hDiff = arSubChildField(3)-arSubChildField(1)]]>
<![CDATA[
]]>
<![CDATA[								Else]]>
<![CDATA[
]]>
<![CDATA[									arSubChildField = splitnumber("0,0,0,0")]]>
<![CDATA[
]]>
<![CDATA[									hDiff = 0	]]>
<![CDATA[
]]>
<![CDATA[								End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[								'Adjust Zone Positions]]>
<![CDATA[
]]>
<![CDATA[                                If arSubChildField(2)>arSubChildField(0) then]]>
<![CDATA[
]]>
<![CDATA[								    arSubChildField(0) = arSubChildField(0) + CLng(nXoffset)]]>
<![CDATA[
]]>
<![CDATA[								    arSubChildField(2) = arSubChildField(2) + CLng(nXoffset)]]>
<![CDATA[
]]>
<![CDATA[                                End if]]>
<![CDATA[
]]>
<![CDATA[                                arSubChildField(1) = arCurrLine(1) + (arSubChildField(1) - CLng(zTop))]]>
<![CDATA[
]]>
<![CDATA[								arSubChildField(3) = arSubChildField(1) + CLng(hDiff)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[								If arSubChildField(0)<clng(0) then arSubChildField(0)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[								If arSubChildField(2)<clng(0) then arSubChildField(2)=clng(0)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[  								'Save Adjusted Position]]>
<![CDATA[
]]>
<![CDATA[								oSubChildField.Variable("Position") = CStr(arSubChildField(0)) & "," & CStr(arSubChildField(1)-clng(pHt)) & "," & CStr(arSubChildField(2)) & "," & CStr(arSubChildField(3)-clng(pHt))]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[								oSubChildField.Variable("Zone") = sPos]]>
<![CDATA[
]]>
<![CDATA[								oSubChildField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[								If pNm>1 then oSubChildField.Variable("IMAGEHEIGHT")=oLine.ImageHeight]]>
<![CDATA[
]]>
<![CDATA[																]]>
<![CDATA[
]]>
<![CDATA[							Next 'k]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[							Set oCurrLine = oNextLine							]]>
<![CDATA[
]]>
<![CDATA[							nLastLine = i]]>
<![CDATA[
]]>
<![CDATA[							nLines = nLines + 1]]>
<![CDATA[
]]>
<![CDATA[						Else]]>
<![CDATA[
]]>
<![CDATA[							Writelog(Space(5) & "WORD is in Previous Lineitem Area. Intersection Ratio=" & cint(IRatio*100)& "%")						]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					End If	]]>
<![CDATA[
]]>
<![CDATA[					'END of LINE CREATION SECTION		]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					Call ErrorHandler("FindZoneLineItems Position 500")]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					'** PLACE CCO VALUE FOR WORD INTO oCurrLine FIELD IF THEY INTERSECT: **]]>
<![CDATA[
]]>
<![CDATA[					arZone = splitNumber(oCurrLine.Variable("Zone"))]]>
<![CDATA[
]]>
<![CDATA[					If IntersectRatio(arZone, arWord) > .25 Then]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						'IF FIELD ALREADY HAS A VALUE MERGE POSITION INFO WITH NEW INTERSECT & SEPARATE VALUE WITH SPACE CHARACTER							]]>
<![CDATA[
]]>
<![CDATA[						If Len(oCurrLine.Text) > 0 Then]]>
<![CDATA[
]]>
<![CDATA[							Set cObj = oCurrLine.AddChild(4,"",-1)]]>
<![CDATA[
]]>
<![CDATA[							bRes = cObj.AddValue(CLng(32),CLng(9))]]>
<![CDATA[
]]>
<![CDATA[							arFieldAdj=splitNumber(oCurrLine.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[							bNew = False]]>
<![CDATA[
]]>
<![CDATA[						Else ]]>
<![CDATA[
]]>
<![CDATA[							'FIRST VALUE FOR FIELD, POSITION INFO IS CURRENT CCO POSITION]]>
<![CDATA[
]]>
<![CDATA[							bNEW = True]]>
<![CDATA[
]]>
<![CDATA[						End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[						'ADD CURRENT WORD CHARACTERS TO oCurrLine FIELD]]>
<![CDATA[
]]>
<![CDATA[						For M = 1 To oWord.Count]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[							Set oChar = oWord.Item(M)]]>
<![CDATA[
]]>
<![CDATA[							arChar = SplitNumber(oChar.Left & "," & oChar.Top & "," & oChar.Right & "," & oChar.Bottom)								]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[							'ADD CHARACTER TO FIELD IF IN ZONE AND FILLTYPE IS BY CHARACTER, OR ADD ALL CHARACTERS IF FILLTYPE IS BY WORD]]>
<![CDATA[
]]>
<![CDATA[							If (IntersectRatio(arZone, arChar)>.10 AND sFillType="2") or sFillType="1" Then ]]>
<![CDATA[
]]>
<![CDATA[								Set cObj = oCurrLine.AddChild(4,"",-1)]]>
<![CDATA[
]]>
<![CDATA[								bRes = cObj.AddValue(CLng(Ascw(oWord.Item(M).value)),CLng(oWord.Item(M).Confidence))]]>
<![CDATA[
]]>
<![CDATA[								bRes = cObj.SetPosition(CLng(oChar.Left),CLng(oChar.Top)-clng(pHt),CLng(oChar.Right),CLng(oChar.Bottom)-clng(pHt))]]>
<![CDATA[
]]>
<![CDATA[								arCharAdj = SplitNumber(oChar.Left & "," & oChar.Top-pHt & "," & oChar.Right & "," & oChar.Bottom-pHt)]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[								'MERGE EXISTING POSITION INFO WITH NEW CHAR POS]]>
<![CDATA[
]]>
<![CDATA[								If bNew = True Then arFieldAdj = arCharAdj]]>
<![CDATA[
]]>
<![CDATA[								arFieldAdj=CombineRect(arCharAdj,arFieldAdj)]]>
<![CDATA[
]]>
<![CDATA[								oCurrLine.Variable("Position")= Join(arFieldAdj,",")]]>
<![CDATA[
]]>
<![CDATA[								bNew = False				]]>
<![CDATA[
]]>
<![CDATA[							End If]]>
<![CDATA[
]]>
<![CDATA[						Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					ErrorHandler("FindZoneLineItems Position 600")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					'INSERT CCO TEXT INTO SUBFIELDS ON CURRENT LINE]]>
<![CDATA[
]]>
<![CDATA[					For k = 1 To (oCurrLine.NumOfChildren - Len(oCurrLine.Text))]]>
<![CDATA[
]]>
<![CDATA[						Set oChildField = oCurrLine.GetChild(k-1)]]>
<![CDATA[
]]>
<![CDATA[						If oChildField Is Nothing Then Exit For]]>
<![CDATA[
]]>
<![CDATA[												]]>
<![CDATA[
]]>
<![CDATA[						arZone = splitNumber(oChildField.Variable("Zone"))]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[						'IF CURRENT SUB FIELD ZONE INTERSECTS THE CURRENT CCO WORD]]>
<![CDATA[
]]>
<![CDATA[						If IntersectRatio(arZone, arWord) > .25 Then]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[							'IF FIELD HAS A VALUE, MERGE POSITION INFO WITH NEW INTERSECT							]]>
<![CDATA[
]]>
<![CDATA[							If Len(oChildField.Text) > 0 Then]]>
<![CDATA[
]]>
<![CDATA[								Set cObj = oChildField.AddChild(4,"",-1)]]>
<![CDATA[
]]>
<![CDATA[								bRes = cObj.AddValue(CLng(32),CLng(9))]]>
<![CDATA[
]]>
<![CDATA[								arFieldAdj=splitNumber(oChildField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[								bNew = False]]>
<![CDATA[
]]>
<![CDATA[							Else ]]>
<![CDATA[
]]>
<![CDATA[								'FIRST VALUE FOR FIELD, POSITION INFO IS CURRENT CCO POSITION]]>
<![CDATA[
]]>
<![CDATA[								bNEW = True]]>
<![CDATA[
]]>
<![CDATA[							End If]]>
<![CDATA[
]]>
<![CDATA[															]]>
<![CDATA[
]]>
<![CDATA[							'ADD CHARACTERS TO CURRENT SUBFIELD]]>
<![CDATA[
]]>
<![CDATA[							For M = 1 To oWord.Count]]>
<![CDATA[
]]>
<![CDATA[								'If Err.Number<>0 then writelog("ERR num:" & err.number):Err.clear]]>
<![CDATA[
]]>
<![CDATA[								Set oChar = oWord.Item(M)]]>
<![CDATA[
]]>
<![CDATA[								arChar = SplitNumber(oChar.Left & "," & oChar.Top & "," & oChar.Right & "," & oChar.Bottom)								]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[								'ADD CHARACTER TO FIELD IF IN ZONE]]>
<![CDATA[
]]>
<![CDATA[							    If (IntersectRatio(arZone, arChar)>.10 AND sFillType="2") or sFillType="1" Then ]]>
<![CDATA[
]]>
<![CDATA[									Set cObj = oChildField.AddChild(4,"",-1)]]>
<![CDATA[
]]>
<![CDATA[									bRes = cObj.AddValue(CLng(Ascw(oWord.Item(M).value)),CLng(oWord.Item(M).Confidence))]]>
<![CDATA[
]]>
<![CDATA[		  							bRes = cObj.SetPosition(CLng(oChar.Left),CLng(oChar.Top)-clng(pHt),CLng(oChar.Right),CLng(oChar.Bottom)-clng(pHt))]]>
<![CDATA[
]]>
<![CDATA[									arCharAdj = SplitNumber(oChar.Left & "," & oChar.Top-pHt & "," & oChar.Right & "," & oChar.Bottom-pHt)								]]>
<![CDATA[
]]>
<![CDATA[													]]>
<![CDATA[
]]>
<![CDATA[									'MERGE EXISTING POSITION INFO WITH NEW CHAR POS]]>
<![CDATA[
]]>
<![CDATA[									If bNew = True Then arFieldAdj = arCharAdj]]>
<![CDATA[
]]>
<![CDATA[									arFieldAdj=CombineRect(arCharAdj,arFieldAdj)]]>
<![CDATA[
]]>
<![CDATA[									oChildField.Variable("Position")= Join(arFieldAdj,",")]]>
<![CDATA[
]]>
<![CDATA[									bNew = False				]]>
<![CDATA[
]]>
<![CDATA[								End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[							Next]]>
<![CDATA[
]]>
<![CDATA[											]]>
<![CDATA[
]]>
<![CDATA[						    ErrorHandler("FindZoneLineItems Position 700")		]]>
<![CDATA[
]]>
<![CDATA[                        Else]]>
<![CDATA[
]]>
<![CDATA[                            Writelog("IntersectionRatio was " & cstr(IntersectRatio(arZone, arWord)) & " for field " & ochildfield.id)					]]>
<![CDATA[
]]>
<![CDATA[						End If						]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					Next 'k]]>
<![CDATA[
]]>
<![CDATA[				End If	]]>
<![CDATA[
]]>
<![CDATA[			Next 'j]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[	Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oSubField = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	Set oSubchildField = Nothing	]]>
<![CDATA[
]]>
<![CDATA[ 	Set oRootItem = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	Set oSubRootChild = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	Set ochildfield = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	Set oLine = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	Set oWord = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	Set oCurrLine = Nothing	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	FindZoneLineItems = True]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</f>
<af name="FindLineItems" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	FindLineItems = False]]>
<![CDATA[
]]>
<![CDATA[ ]]>
<![CDATA[
]]>
<![CDATA[	'Parse and Check Parameter Values]]>
<![CDATA[
]]>
<![CDATA[	StrParam = Ucase(StrParam)]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam & ",,,,", ",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  FindLineItems = FindZoneLineItems(aStrParam(0), aStrParam(1), aStrParam(2), aStrParam(3), aStrParam(4))	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="MCCOPositionAdjust" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim CurPgNm]]>
<![CDATA[
]]>
<![CDATA[	Dim AdjAmt]]>
<![CDATA[
]]>
<![CDATA[	Dim NextAdj]]>
<![CDATA[
]]>
<![CDATA[	Dim oMultiPageParent]]>
<![CDATA[
]]>
<![CDATA[	Dim sImageHeight]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oMultiPageParent = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  MCCOPositionAdjust=False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	While oMultiPageParent.ObjectType<>2 and oMultiPageParent.ObjectType>0]]>
<![CDATA[
]]>
<![CDATA[		Set oMultiPageParent = oMultiPageParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		If oMultiPageParent.ObjectType=0 Then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No Parent Page found.") ]]>
<![CDATA[
]]>
<![CDATA[			MCCOPositionAdjust=False]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CurPgNm = ucase(FileMgr.GetFileName(CurrentObj.Variable("IMAGEFILE")))]]>
<![CDATA[
]]>
<![CDATA[	AdjAmt = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	NextAdj = oMultiPageParent.Variable(Ucase(CurPgNm))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[  sImageHeight=trim(CurrentObj.Variable("IMAGEHEIGHT"))]]>
<![CDATA[
]]>
<![CDATA[	writelog("IMAGEHEIGHT:'" & sImageHeight & "'")]]>
<![CDATA[
]]>
<![CDATA[	If Len(sImageHeight)=0 Then ]]>
<![CDATA[
]]>
<![CDATA[    Writelog(" *** IMAGEHEIGHT is EMPTY or BLANK ***")]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	'Check For Document ]]>
<![CDATA[
]]>
<![CDATA[	If NOT IsNumeric(NextAdj) then]]>
<![CDATA[
]]>
<![CDATA[		While oMultiPageParent.ObjectType>1 ]]>
<![CDATA[
]]>
<![CDATA[			Set oMultiPageParent = oMultiPageParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[			If oMultiPageParent.ObjectType=0 Then]]>
<![CDATA[
]]>
<![CDATA[				Writelog("No Parent Document found.") ]]>
<![CDATA[
]]>
<![CDATA[				MCCOPositionAdjust=False]]>
<![CDATA[
]]>
<![CDATA[				Set oMultiPageParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[				Exit Function]]>
<![CDATA[
]]>
<![CDATA[			End if]]>
<![CDATA[
]]>
<![CDATA[		Wend ]]>
<![CDATA[
]]>
<![CDATA[		NextAdj = oMultiPageParent.Variable(Ucase(CurPgNm))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If trim(NextAdj) = "" then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No Multipage Variables could be found. Source was not a Multipage CCO! Exiting.")]]>
<![CDATA[
]]>
<![CDATA[			Set oMultiPageParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If Not isnumeric(NextAdj) then]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Multipage Variable must be numeric.")]]>
<![CDATA[
]]>
<![CDATA[		Set oMultiPageParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start Object Image:" & CurPgNm & ". Start Adjustment is:" & clng(AdjAmt))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	MCCOPositionAdjust =MCCOPositionAdjuster(oMultiPageParent, CurrentObj,CurPgNm, AdjAmt, NextAdj,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oMultiPageParent = Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="GetZoneText" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Clear]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call DCOFieldfromCCO(CurrentObj, CCO)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	GetZoneText = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="LoadBlockCCO" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	LoadBlockCCO = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Dim sFileName ]]>
<![CDATA[
]]>
<![CDATA[	sFileName = CurrentObj.Variable("CCOBlock")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Dim lbCCOCreator]]>
<![CDATA[
]]>
<![CDATA[	set lbCCOCreator = CreateObject("CCO._CCOCreator.1")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	if FileMgr.FileExists(sFileName) then ]]>
<![CDATA[
]]>
<![CDATA[		set CCO = lbCCOCreator.load(sFileName)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Loading BlockCCO '" & sFileName & "' ")]]>
<![CDATA[
]]>
<![CDATA[		LoadBlockCCO = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("BlockCCO '" & sFileName & "' does not Exist.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[ 	Set lbCCOCreator = nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AnchorPage" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim sName]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[	Dim RegExStr]]>
<![CDATA[
]]>
<![CDATA[	Dim nL, nW]]>
<![CDATA[
]]>
<![CDATA[	Dim ZoneCCO]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	Dim znField]]>
<![CDATA[
]]>
<![CDATA[	Dim znWidth]]>
<![CDATA[
]]>
<![CDATA[	Dim znHeight ]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosName]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	AnchorPage = False]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	sName=CurrentObj.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("AnchorPage " & sName)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	nChildren = CurrentObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For nChild = 0 to nChildren -1]]>
<![CDATA[
]]>
<![CDATA[		Set oField = CurrentObj.GetChild(nChild)]]>
<![CDATA[
]]>
<![CDATA[		Do While Not oField is Nothing		]]>
<![CDATA[
]]>
<![CDATA[			If oField Is Nothing Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			If Not left(oField.ID & Space(6),6) = "Anchor" Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			sWord=oField.Variable("Word" & sName)	]]>
<![CDATA[
]]>
<![CDATA[			If sWord="" Then Exit Do	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Anchor Word value : "  & sWord)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			sPosName = "Pos" & sName]]>
<![CDATA[
]]>
<![CDATA[			arField=SplitNumber(oField.Variable(sPosName))]]>
<![CDATA[
]]>
<![CDATA[			If UBound(arField)<3 Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			znField=arField]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			znWidth = znField(2)-znField(0)		]]>
<![CDATA[
]]>
<![CDATA[			znHeight = znField(3)-znField(1)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[			'Search area left position]]>
<![CDATA[
]]>
<![CDATA[			znField(0) = znField(0)-(2*znWidth)]]>
<![CDATA[
]]>
<![CDATA[			If znField(0) < 0 then znField(0) = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			'Search area right position]]>
<![CDATA[
]]>
<![CDATA[			znField(2) = znField(2)+(2*znWidth)]]>
<![CDATA[
]]>
<![CDATA[			if znField(2) > CCO.Right then znField(2) = CCO.Right]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			'Search area top position]]>
<![CDATA[
]]>
<![CDATA[			znField(1) = znField(1)-(4*znHeight)]]>
<![CDATA[
]]>
<![CDATA[			if znField(1) < 0 then znField(1) = 0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			'Search area bottom position]]>
<![CDATA[
]]>
<![CDATA[			znField(3) = znField(3)+(4*znHeight)]]>
<![CDATA[
]]>
<![CDATA[			if znField(3) > CCO.Bottom then znField(3) = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[			Set zoneCCO = CCOCreator.AnalyzeBlock(oCurPage.Imagename,znField(0),znField(1),znField(2),znField(3))	]]>
<![CDATA[
]]>
<![CDATA[			Call GetBlockChars(zoneCCO, znField(0),znField(1),znField(2),znField(3))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[			RegExStr = RegExBuild(bInteractive, bDebug, sWord)]]>
<![CDATA[
]]>
<![CDATA[			If not FindKey(bInter, bDebug, RegExStr) then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			nL=0]]>
<![CDATA[
]]>
<![CDATA[			nW=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Call CCO.GetCurrentPosition(nL, nW)]]>
<![CDATA[
]]>
<![CDATA[			Writelog("sName")]]>
<![CDATA[
]]>
<![CDATA[			Set oWord=CCO.Item(nL).Item(nW)]]>
<![CDATA[
]]>
<![CDATA[			If oWord Is Nothing Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			nXOffset=oWord.Left-arField(0)]]>
<![CDATA[
]]>
<![CDATA[			nYOffset=oWord.Top-arField(1)]]>
<![CDATA[
]]>
<![CDATA[			nCount=CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			writelog("X offset - " & CStr(nXOffset))]]>
<![CDATA[
]]>
<![CDATA[			writelog("Y offset - " & CStr(nYOffset))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			Call ZoneChildren(CurrentObj, sPosName,0,nXOffset,nYOffset)]]>
<![CDATA[
]]>
<![CDATA[			AnchorPage = True]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		loop]]>
<![CDATA[
]]>
<![CDATA[	Next 'nChild]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	writelog("Anchor Value not found...loading raw Zone positions. (non adjusted)")]]>
<![CDATA[
]]>
<![CDATA[	Call ZoneChildren(CurrentObj, sPosName,0,0,0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="RegisterPage" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	RegisterPage=True]]>
<![CDATA[
]]>
<![CDATA[	sName=CurrentObj.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Page Fingerprint number " & sName)]]>
<![CDATA[
]]>
<![CDATA[	Dim nChildren]]>
<![CDATA[
]]>
<![CDATA[	nChildren = CurrentObj.NumOfChildren]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	For nChild = 0 to nChildren -1]]>
<![CDATA[
]]>
<![CDATA[		Set oField = CurrentObj.GetChild(nChild)]]>
<![CDATA[
]]>
<![CDATA[		Do While Not oField is Nothing		]]>
<![CDATA[
]]>
<![CDATA[			If oField Is Nothing Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			If Not left(oField.ID & Space(6),6) = "Anchor" Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			sWord=oField.Variable("Word" & sName)	]]>
<![CDATA[
]]>
<![CDATA[			If sWord="" Then Exit Do	]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Searchword is '" & sWord & "' ")]]>
<![CDATA[
]]>
<![CDATA[			If Not FindKey(bInter, bDebug, sWord) Then ]]>
<![CDATA[
]]>
<![CDATA[				Dim tmpStr]]>
<![CDATA[
]]>
<![CDATA[				tmpStr = RegExBuild(bInteractive, bDebug, sWord)]]>
<![CDATA[
]]>
<![CDATA[				If not FindKey(bInter, bDebug, tmpStr) then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			end if]]>
<![CDATA[
]]>
<![CDATA[			nL=0]]>
<![CDATA[
]]>
<![CDATA[			nW=0]]>
<![CDATA[
]]>
<![CDATA[			Call CCO.GetCurrentPosition(nL, nW)]]>
<![CDATA[
]]>
<![CDATA[			Set oWord=CCO.Item(nL).Item(nW)]]>
<![CDATA[
]]>
<![CDATA[			If oWord Is Nothing Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			arField=SplitNumber(oField.Variable("Pos" & sName))]]>
<![CDATA[
]]>
<![CDATA[			If UBound(arField)<3 Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[			'nXOffset=oWord.Left-arField(0)]]>
<![CDATA[
]]>
<![CDATA[			nYOffset=oWord.Top-arField(1)]]>
<![CDATA[
]]>
<![CDATA[			nCount=CurrentObj.NumOfChildren()]]>
<![CDATA[
]]>
<![CDATA[			writelog("Y offset - " & CStr(nYOffset))]]>
<![CDATA[
]]>
<![CDATA[			For i=0 To nCount-1]]>
<![CDATA[
]]>
<![CDATA[				Set oField=CurrentObj.GetChild(i)]]>
<![CDATA[
]]>
<![CDATA[				Writelog(oField.Variable(sName))]]>
<![CDATA[
]]>
<![CDATA[				arField=SplitNumber(oField.Variable("Pos" & sName))]]>
<![CDATA[
]]>
<![CDATA[				If UBound(arField)=3 Then]]>
<![CDATA[
]]>
<![CDATA[					'arField(0)=arField(0)+nXOffset]]>
<![CDATA[
]]>
<![CDATA[					arField(1)=arField(1)+nYOffset]]>
<![CDATA[
]]>
<![CDATA[					'arField(2)=arField(2)+nXOffset]]>
<![CDATA[
]]>
<![CDATA[					arField(3)=arField(3)+nYOffset]]>
<![CDATA[
]]>
<![CDATA[					oField.Variable("Position")=CStr(arField(0)) & "," & CStr(arField(1)) & "," & CStr(arField(2)) & "," & CStr(arField(3))]]>
<![CDATA[
]]>
<![CDATA[				End If]]>
<![CDATA[
]]>
<![CDATA[			Next]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		loop]]>
<![CDATA[
]]>
<![CDATA[	Next 'nChild]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</af>
<af name="ZoneImage_SaveAs" access="public" bInter="bInter" bDebug="bDebug" strParam="StrFileName">
	<g>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	']]>
<![CDATA[
]]>
<![CDATA[	' 	Rule Manager Example: (Called on 'DETAILS' field)]]>
<![CDATA[
]]>
<![CDATA[	'		ZoneImage_SaveAs("SAMMY"+@TYPE+@DATE+JJJ) --> "..\SAMMYDETAILS243.tif" 		]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	Dim oParentPage]]>
<![CDATA[
]]>
<![CDATA[	Dim oDCImage]]>
<![CDATA[
]]>
<![CDATA[	Dim aCurrPos	]]>
<![CDATA[
]]>
<![CDATA[	Dim lx, ly, lw, lh]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oDCImage= Nothing]]>
<![CDATA[
]]>
<![CDATA[	ZoneImage_SaveAs = False]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParentPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	While oParentPage.ObjectType > 2 AND oParentPage.ObjectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParentPage=  oParentPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If oParentPage.ImageName <> "" then ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Set oDCImage= CreateObject("DCIMAGE.DCImageCtrl.1")]]>
<![CDATA[
]]>
<![CDATA[		If oDCImage is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Unable to Create DCImage Object!")]]>
<![CDATA[
]]>
<![CDATA[			Exit Function]]>
<![CDATA[
]]>
<![CDATA[		End if ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		oDCImage.FileName = oParentPage.ImageName]]>
<![CDATA[
]]>
<![CDATA[		If SetZoneImageName(bInter, bDebug, StrFileName) = False then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		sPosition = CurrentObj.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Zone Positions found: '" & sPosition & "' ")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		if sPosition = "" or sPosition = "0,0,0,0" or not(isnumeric(replace(sPosition,",",""))) then ]]>
<![CDATA[
]]>
<![CDATA[			Writelog("No Zone Position Information Found for Component '" & CurrentObj.ID & "', no area to save.")]]>
<![CDATA[
]]>
<![CDATA[			Set oDCImage= Nothing]]>
<![CDATA[
]]>
<![CDATA[			Exit Function ]]>
<![CDATA[
]]>
<![CDATA[		End if	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		aCurrPos = splitnumber(sPosition)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		lx = clng(aCurrPos(0))]]>
<![CDATA[
]]>
<![CDATA[		ly = clng(aCurrPos(1))]]>
<![CDATA[
]]>
<![CDATA[		lw = clng(aCurrPos(2)-aCurrPos(0))]]>
<![CDATA[
]]>
<![CDATA[		lh = clng(aCurrPos(3)-aCurrPos(1))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		g_ZoneImageName = g_ZoneImageName & ".tif"]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If Not FileMgr.FolderExists(g_ZoneImageName) then]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Parent folder Not found. Saving Image to Batch Directory.")]]>
<![CDATA[
]]>
<![CDATA[			g_ZoneImageName = Pilot.BatchDir & "\" & g_ZoneImageName]]>
<![CDATA[
]]>
<![CDATA[			Writelog("New full Path:'" & g_ZoneImageName & "'.")]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		writelog("Saving X:" & lx & " Y:" & ly & " Width:" & lw & " Height:" & lh & " ImageName:" & g_ZoneImageName)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		ZoneImage_SaveAs = oDCImage.SaveZone(lx,ly,lw,lh,g_ZoneImageName)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oDCImage= Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="AdjustZonesToImageOffset" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim sName	]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosName]]>
<![CDATA[
]]>
<![CDATA[	Dim sOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim aOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim nXoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim nYoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim oCurPage]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Writelog("AdjustZonesToImageOffset for " & CurrentObj.id)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	AdjustZonesToImageOffset=True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oCurPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	While oCurPage.ObjectType<>2 AND oCurPage.ObjectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oCurPage = oCurPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	sPosName = "Position"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sOffSet=CurrentObj.Variable("Image_Offset")]]>
<![CDATA[
]]>
<![CDATA[	if len(trim(sOffset))=0 then ]]>
<![CDATA[
]]>
<![CDATA[    writelog("Image_Offset variable not found. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[		AdjustZonesToImageOffset = False]]>
<![CDATA[
]]>
<![CDATA[		Exit Function]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aOffSet = Split(sOffSet & ",0" , ",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	nXoffset = (-1*aOffSet(0))]]>
<![CDATA[
]]>
<![CDATA[	nYoffset = (-1*aOffSet(1))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nXoffSet)) or len(trim(nXoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nXoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("X offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nYoffSet)) or len(trim(nYoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nYoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("Y offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Offsets : " & nXoffset & "," & nYoffset)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Call ZoneChildren(CurrentObj, sPosName, 0, clng(nXoffSet), clng(nYoffSet))]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetEOL" access="public" bInter="bInter" bDebug="bDebug" strParam="bParam">
	<g>
<![CDATA[
]]>
<![CDATA[	SetEOL = False]]>
<![CDATA[
]]>
<![CDATA[	g_SetEOL = bParam]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Setting End of Line character to: '" & bParam & "' ")]]>
<![CDATA[
]]>
<![CDATA[	If Err.number = 0 then SetEOL = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="SetEOL_CRLF" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[	SetEOL_CRLF = False]]>
<![CDATA[
]]>
<![CDATA[	g_SetEOL = cstr(Chrw(13) & Chrw(10))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Setting End of Line character to : Carrage Return Line Feed")]]>
<![CDATA[
]]>
<![CDATA[	If Err.number = 0 then SetEOL_CRLF = True]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindDataBlocks" access="public" bInter="bInter" bDebug="bDebug" strParam="Strparam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	Dim modStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim Match]]>
<![CDATA[
]]>
<![CDATA[	Dim tMatches]]>
<![CDATA[
]]>
<![CDATA[	Dim bMatches]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[	Dim oValueTop]]>
<![CDATA[
]]>
<![CDATA[	Dim oValueBtm]]>
<![CDATA[
]]>
<![CDATA[	Dim nLine, nWord, pLine]]>
<![CDATA[
]]>
<![CDATA[	Dim index, tindex, bindex]]>
<![CDATA[
]]>
<![CDATA[	Dim MatchCount]]>
<![CDATA[
]]>
<![CDATA[	Dim ileft]]>
<![CDATA[
]]>
<![CDATA[	Dim iRight]]>
<![CDATA[
]]>
<![CDATA[	Dim iTop]]>
<![CDATA[
]]>
<![CDATA[	Dim iBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim oPage]]>
<![CDATA[
]]>
<![CDATA[	Dim sBasename]]>
<![CDATA[
]]>
<![CDATA[	Dim osubfield]]>
<![CDATA[
]]>
<![CDATA[	Dim iName ]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sLine, sWord, sLine2, sWord2]]>
<![CDATA[
]]>
<![CDATA[	Dim xM, bM, cM]]>
<![CDATA[
]]>
<![CDATA[	Dim tLineAdj, bLineAdj]]>
<![CDATA[
]]>
<![CDATA[	Dim sMCCO	]]>
<![CDATA[
]]>
<![CDATA[	Dim nPage]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	Dim tval]]>
<![CDATA[
]]>
<![CDATA[	Dim nHeight	]]>
<![CDATA[
]]>
<![CDATA[	Dim tLine,tWord]]>
<![CDATA[
]]>
<![CDATA[	Dim prevLine]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  FindDataBlocks = FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	regEx.IgnoreCase = True]]>
<![CDATA[
]]>
<![CDATA[	regEx.Global = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Set Extremes]]>
<![CDATA[
]]>
<![CDATA[	iTop = clng(CCO.Bottom)]]>
<![CDATA[
]]>
<![CDATA[	iLeft = clng(CCO.Right)]]>
<![CDATA[
]]>
<![CDATA[	iRight = clng(CCO.Left)]]>
<![CDATA[
]]>
<![CDATA[	iBottom = clng(CCO.Top)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find CCO Limits]]>
<![CDATA[
]]>
<![CDATA[	For cM = 1 to CCO.Count]]>
<![CDATA[
]]>
<![CDATA[		If iTop > clng(CCO.Item(cM).Top) Then iTop = clng(CCO.Item(cM).Top)]]>
<![CDATA[
]]>
<![CDATA[		If iLeft > clng(CCO.Item(cM).Left) Then iLeft = clng(CCO.Item(cM).Left)]]>
<![CDATA[
]]>
<![CDATA[		If iRight < clng(CCO.Item(cM).Right) Then iRight = clng(CCO.Item(cM).Right)]]>
<![CDATA[
]]>
<![CDATA[		If iBottom < clng(CCO.Item(cM).Bottom) Then iBottom = clng(CCO.Item(cM).Bottom)]]>
<![CDATA[
]]>
<![CDATA[	Next 'cM]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Get Child Base Name]]>
<![CDATA[
]]>
<![CDATA[	sBaseName = CurrentObj.SetupNode().GetRule(0).Name]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set	oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While oPage.ObjectType>2 And Not(oPage.ObjectType<=1)]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Find Current Position limits]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If ubound(arField)<>3 then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[        if sPosition="" then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)]]>
<![CDATA[
]]>
<![CDATA[	If ubound(arField)=3 then ]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = clng(arField(0))]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = clng(arField(1))]]>
<![CDATA[
]]>
<![CDATA[		arField(2) = clng(arField(2))]]>
<![CDATA[
]]>
<![CDATA[		arField(3) = clng(arField(3))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = arField(0)-clng(10)]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = arField(1)-clng(10)]]>
<![CDATA[
]]>
<![CDATA[		If arField(2)>clng(0) then arField(2) = clng(arField(2))+clng(10)]]>
<![CDATA[
]]>
<![CDATA[		If arField(3)>clng(0) then arField(3) = clng(arField(3))+clng(10)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Establish Search Limits for ZEROED zone values]]>
<![CDATA[
]]>
<![CDATA[		If arField(0) <= clng(0) Then ]]>
<![CDATA[
]]>
<![CDATA[			arField(0) = clng(iLeft)]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If arField(1) <= clng(0) Then arField(1) = iTop]]>
<![CDATA[
]]>
<![CDATA[		If arField(2) > iRight Or arField(2) <= 0 Then arField(2) = iRight]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		'Find Lowest zoneCCO Position]]>
<![CDATA[
]]>
<![CDATA[		If arField(3) > iBottom Or arField(3) <= clng(0) Then arField(3) = iBottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If arField(0)>arField(2) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog("Swapping left and right zone positions")]]>
<![CDATA[
]]>
<![CDATA[			tval = arField(0)]]>
<![CDATA[
]]>
<![CDATA[			arField(0) = arField(2)]]>
<![CDATA[
]]>
<![CDATA[			arField(2) = tval]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If arField(1)>arField(3) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog("Swapping top and bottom zone positions")]]>
<![CDATA[
]]>
<![CDATA[			tval = arField(1)]]>
<![CDATA[
]]>
<![CDATA[			arField(1) = arField(3)]]>
<![CDATA[
]]>
<![CDATA[			arField(3) = tval]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		iLeft = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		iTop = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		iRight = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		arField=SplitNumber(cstr(iLeft & "," & iTop & "," & iRight & "," & iBottom))]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Find Search Zone Text & Start Index]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Setup Start CCO Position.]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(sLine, sWord, sLine2, sWord2)]]>
<![CDATA[
]]>
<![CDATA[	If sLine=0 then sLine=1]]>
<![CDATA[
]]>
<![CDATA[	If sWord=0 then sWord=1]]>
<![CDATA[
]]>
<![CDATA[	If sLine2=0 then sLine2=1]]>
<![CDATA[
]]>
<![CDATA[	If sWord2=0 then sWord2=1]]>
<![CDATA[
]]>
<![CDATA[	If sLine2>=sLine then ]]>
<![CDATA[
]]>
<![CDATA[		sLine=sLine2]]>
<![CDATA[
]]>
<![CDATA[		sWord=sWord2		]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start CCO Position: Line='" & sLine & "' Word='" & sWord & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.LocateLines(arField(1),arField(3),LTop,LBottom)]]>
<![CDATA[
]]>
<![CDATA[	If LTop = 0 or LBottom = 0 then ]]>
<![CDATA[
]]>
<![CDATA[	    Writelog("No Recognition Characters in Search Area.")]]>
<![CDATA[
]]>
<![CDATA[	    Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Adjust Search Area to Start CCO Position	]]>
<![CDATA[
]]>
<![CDATA[	If sLine>LTop and sLine<LBottom Then ]]>
<![CDATA[
]]>
<![CDATA[		LTop = sLine]]>
<![CDATA[
]]>
<![CDATA[		If CCO.item(LTop).Count > sWord Then ]]>
<![CDATA[
]]>
<![CDATA[		    sWord = sWord + 1]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[		    sLine = sLine + 1 ]]>
<![CDATA[
]]>
<![CDATA[			sWord = 1]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[    If sWord=0 then sWord=1]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'GET START INDEX		           ]]>
<![CDATA[
]]>
<![CDATA[    StartIndex = CCO.LocateCharIndex(LTop,sWord)]]>
<![CDATA[
]]>
<![CDATA[   	    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Ascending Search from Line:'" & Ltop & "' Word:'" & sWord & "' to Line:'" & LBottom & "' Word:'" & CCO.Item(LBottom).count & "'")	]]>
<![CDATA[
]]>
<![CDATA[	'adjust search text for mid line word location]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sWord>1 and LTop<LBottom Then]]>
<![CDATA[
]]>
<![CDATA[	    For y = sWord to CCO.Item(LTop).Count]]>
<![CDATA[
]]>
<![CDATA[	        str = str & CCO.Item(LTop).Item(y).Value & Space(1)]]>
<![CDATA[
]]>
<![CDATA[	    Next 'y]]>
<![CDATA[
]]>
<![CDATA[	    str = Trim(str) & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[	    LTop = LTop + 1]]>
<![CDATA[
]]>
<![CDATA[        sValue = sValue & str]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[ 	  		]]>
<![CDATA[
]]>
<![CDATA[	For x = LTop to LBottom	]]>
<![CDATA[
]]>
<![CDATA[   			str = Trim(CCO.Item(x).Value) ]]>
<![CDATA[
]]>
<![CDATA[   			If x<CCO.Count then str = str & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[   	        sValue = sValue & str]]>
<![CDATA[
]]>
<![CDATA[	Next 'x]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Initialize MCCO Page Counter]]>
<![CDATA[
]]>
<![CDATA[	sMCCO=oPage.Variable("CCOBlock")]]>
<![CDATA[
]]>
<![CDATA[	If sMCCO<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = FileMgr.GetFileName(sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("MCCO file loaded: " & sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = sMCCO & "_"]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oValueTop = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	If ubound(aStrParam)>=1 Then oValueBtm = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find Line Adjustments]]>
<![CDATA[
]]>
<![CDATA[	If ubound(aStrParam)>=2 Then tLineAdj = Trim(aStrParam(2))	]]>
<![CDATA[
]]>
<![CDATA[	If ubound(aStrParam)>=3 Then bLineAdj = Trim(aStrParam(3))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Remove Plus sign (its a positive number anyway...)]]>
<![CDATA[
]]>
<![CDATA[	tLineAdj = replace(tLineAdj,"+","")]]>
<![CDATA[
]]>
<![CDATA[	bLineAdj = replace(bLineAdj,"+","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Check for numeric value	]]>
<![CDATA[
]]>
<![CDATA[	If Not Isnumeric(tLineAdj) Then tLineadj = 0]]>
<![CDATA[
]]>
<![CDATA[	If Not Isnumeric(bLineAdj) Then bLineadj = 0]]>
<![CDATA[
]]>
<![CDATA[	tLineadj = clng(tLineadj)]]>
<![CDATA[
]]>
<![CDATA[	bLineAdj = clng(bLineadj)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	MatchCount = 1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	FindDataBlocks = False]]>
<![CDATA[
]]>
<![CDATA[	modStrParamT = ""]]>
<![CDATA[
]]>
<![CDATA[	modStrParamB = ""]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Find Values: '" & oValueTop & "' to '" & oValueBtm & "'. ")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(oValueTop)>0 And len(oValueBtm)>0 Then ]]>
<![CDATA[
]]>
<![CDATA[		'We have a top & bottom value to search for]]>
<![CDATA[
]]>
<![CDATA[		'Note build RegEx 'OR' string implicitly here...]]>
<![CDATA[
]]>
<![CDATA[		amodStrParamT = Split(oValueTop&"|","|")]]>
<![CDATA[
]]>
<![CDATA[		amodStrParamB = Split(oValueBtm&"|","|")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Argorithm 1")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		For T = 0 to ubound(amodStrParamT)-1]]>
<![CDATA[
]]>
<![CDATA[			modStrParamT = modStrParamT & RegExBuild(bInteractive, bDebug, amodStrParamT(T))]]>
<![CDATA[
]]>
<![CDATA[			If T < ubound(amodStrParamT)-1 then modStrParamT = modStrParamT & "|"]]>
<![CDATA[
]]>
<![CDATA[		Next 'T]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		For B = 0 to ubound(amodStrParamB)-1]]>
<![CDATA[
]]>
<![CDATA[			modStrParamB = modStrParamB & RegExBuild(bInteractive, bDebug, amodStrParamB(B))]]>
<![CDATA[
]]>
<![CDATA[			If B < ubound(amodStrParamB)-1 then modStrParamB = modStrParamB & "|"]]>
<![CDATA[
]]>
<![CDATA[		Next 'B]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'adding space here compensates for RegEx indexing being Zero based vs. CCO one based.]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = modStrParamT       ]]>
<![CDATA[
]]>
<![CDATA[		Set tMatches = regEx.Execute(space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[    'adding space here compensates for RegEx indexing being Zero based vs. CCO one based.]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = modStrParamB]]>
<![CDATA[
]]>
<![CDATA[		Set bMatches = regEx.Execute(space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		writelog("   Top Matches Count is :" & tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[		writelog("Bottom Matches Count is :" & bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[        'Set iBottom to 0]]>
<![CDATA[
]]>
<![CDATA[        iBottom = clng(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		For xM = 1 to (tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[			Set tMatch = tMatches(xM-1)]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Matched Value: '" & cstr(MatchedTextValue(tMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[			Index = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			If CCO.LocateChar(Index, nLine, nWord) Then]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				iTop = CCO.Item(nline).Top]]>
<![CDATA[
]]>
<![CDATA[				nPage = CCO.Item(nLine).ImageNum]]>
<![CDATA[
]]>
<![CDATA[				nHeight = CCO.Item(nLine).ImageHeight				]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				If tLineAdj<>clng(0) Then]]>
<![CDATA[
]]>
<![CDATA[					If CCO.Count >= (nLine + tLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Adjusting line Top up/down by " & tLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[						iTop = CCO.Item(nline+ tLineAdj).Top]]>
<![CDATA[
]]>
<![CDATA[						nPage= CCO.Item(nLine+ tLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[						nHeight= CCO.Item(nLine+ tLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[					End if				 ]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				'check that iTop is Below (>) last calculated iBottom.]]>
<![CDATA[
]]>
<![CDATA[				If iTop>iBottom Then 				]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[					'iBottom = CCO.Item(CCO.Count).Bottom]]>
<![CDATA[
]]>
<![CDATA[                    'iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[					'tIndex = len(sValue) + StartIndex]]>
<![CDATA[
]]>
<![CDATA[                    tIndex = CCO.LocateCharIndex(CCO.Count,CCO.Item(CCO.Count).Count) 				]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					'CCO Line before Next Top Becomes default Bottom					]]>
<![CDATA[
]]>
<![CDATA[					If xM < tMatches.Count then ]]>
<![CDATA[
]]>
<![CDATA[						Set tMatch = tMatches(xM)]]>
<![CDATA[
]]>
<![CDATA[						tIndex = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[						If CCO.LocateChar(tIndex, nLine, nWord) Then iBottom = CCO.Item(nline-1).Bottom                                                             ]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					'Look For Bottom Word match between Top word spans]]>
<![CDATA[
]]>
<![CDATA[					For bM = 1 to (bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[						Set bMatch = bMatches(bM-1)]]>
<![CDATA[
]]>
<![CDATA[						bIndex = bMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[                    ]]>
<![CDATA[
]]>
<![CDATA[						If (bIndex >= Index) And (bIndex <= tIndex) then]]>
<![CDATA[
]]>
<![CDATA[							If CCO.LocateChar(bIndex, nLine, nWord) Then ]]>
<![CDATA[
]]>
<![CDATA[								'Word Between span found]]>
<![CDATA[
]]>
<![CDATA[								iBottom = CCO.Item(nline).Bottom ]]>
<![CDATA[
]]>
<![CDATA[								WriteLog("Bottom Matched Value: '" & cstr(MatchedTextValue(bMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[								If bLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[									If CCO.Count >= (nLine + bLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[										Writelog("Adjusting line bottom up/down by " & bLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[										iBottom = CCO.Item(nline + bLineAdj).Bottom]]>
<![CDATA[
]]>
<![CDATA[									End if]]>
<![CDATA[
]]>
<![CDATA[								End if]]>
<![CDATA[
]]>
<![CDATA[								Exit For]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[					Next 'bM]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					if arField(1)<=itop and arField(3)>=itop then]]>
<![CDATA[
]]>
<![CDATA[						Set oSubField=CurrentObj.AddChild(3,"",-1)]]>
<![CDATA[
]]>
<![CDATA[						If oSubField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[							Writelog("No SubField Created for Match " & xM & ". ")]]>
<![CDATA[
]]>
<![CDATA[							Exit for]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[						oSubField.ID = sBaseName & CStr(MatchCount)]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Variable("Position") = cstr(iLeft) & "," & cstr(iTop) & "," & cstr(iRight) & "," & cstr(iBottom)]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Position:" & 	oSubField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[						'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[						If nPage>1 then]]>
<![CDATA[
]]>
<![CDATA[							If Ucase(FileMgr.GetFileName(oSubField.Variable("IMAGEFILE")))<>ucase(oPage.Variable(sMCCO & cstr(nPage))) then]]>
<![CDATA[
]]>
<![CDATA[								If Trim(oPage.Variable(sMCCO & cstr(nPage)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[                                    oSubField.Variable("IMAGEFILE")=oPage.Variable(sMCCO & cstr(nPage))]]>
<![CDATA[
]]>
<![CDATA[                                end if]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[							oSubField.Variable("IMAGEHEIGHT")=nHeight]]>
<![CDATA[
]]>
<![CDATA[						End if		]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						Call oSubField.CreateFields]]>
<![CDATA[
]]>
<![CDATA[						Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					MatchCount = MatchCount + 1	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					bFound = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	ElseIf len(oValueTop)>0 And len(oValueBtm)=0 Then]]>
<![CDATA[
]]>
<![CDATA[		'We have a top value to search for]]>
<![CDATA[
]]>
<![CDATA[		'modStrParamT = RegExBuild(bInteractive, bDebug, oValueTop)]]>
<![CDATA[
]]>
<![CDATA[		'Note build RegEx or string implicitly here...]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Argorithm 2.1")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		amodStrParamT = Split(oValueTop&"|","|")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		For T = 0 to ubound(amodStrParamT)-1]]>
<![CDATA[
]]>
<![CDATA[			modStrParamT = modStrParamT & RegExBuild(bInteractive, bDebug, amodStrParamT(T))]]>
<![CDATA[
]]>
<![CDATA[			If T < ubound(amodStrParamT)-1 then modStrParamT = modStrParamT & "|"]]>
<![CDATA[
]]>
<![CDATA[		Next 'T]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = modStrParamT]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Set tMatches = regEx.Execute(space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		writelog("Top Matches Count is :" & tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[		For xM = 1 to (tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[			Set tMatch = tMatches(xM-1)]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Matched Value: '" & cstr(MatchedTextValue(tMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[			Index = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			If CCO.LocateChar(Index, nLine, nWord) Then]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				iTop = CCO.Item(nline).Top]]>
<![CDATA[
]]>
<![CDATA[				nPage= CCO.Item(nLine).ImageNum]]>
<![CDATA[
]]>
<![CDATA[				nHeight= CCO.Item(nLine).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				If tLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[					If CCO.Count >= (nLine + tLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Adjusting line Top up/down by " & tLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[						iTop = CCO.Item(nline+ tLineAdj).Top]]>
<![CDATA[
]]>
<![CDATA[						nPage= CCO.Item(nLine+ tLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[						nHeight= CCO.Item(nLine+ tLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[					End if				 ]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				'iBottom = CCO.Item(CCO.Count).Bottom]]>
<![CDATA[
]]>
<![CDATA[				iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				'CCO Line before next match becomes bottom, cannot be same line or above]]>
<![CDATA[
]]>
<![CDATA[				Do While xM < tMatches.Count]]>
<![CDATA[
]]>
<![CDATA[					Set tMatch = tMatches(xM)]]>
<![CDATA[
]]>
<![CDATA[					Index = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[					If CCO.LocateChar(Index, nLineb, nWord) Then ]]>
<![CDATA[
]]>
<![CDATA[						iBottom = CCO.Item(nlineb-1).Bottom]]>
<![CDATA[
]]>
<![CDATA[						If bLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[							If CCO.Count >= (nLineb - 1 + bLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[								Writelog("Adjusting line bottom up/down by " & bLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[								iBottom = CCO.Item(nlineb - 1 + bLineAdj).Bottom							]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[						If iBottom>iTop And nLineb>nLine Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[					End if	]]>
<![CDATA[
]]>
<![CDATA[					xM = xM + 1		]]>
<![CDATA[
]]>
<![CDATA[                    iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[					'iBottom = CCO.Item(CCO.Count).Bottom]]>
<![CDATA[
]]>
<![CDATA[				loop	 ]]>
<![CDATA[
]]>
<![CDATA[				'Wend]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				if arField(1)<=itop and arField(3)>=itop then]]>
<![CDATA[
]]>
<![CDATA[					Set oSubField=CurrentObj.AddChild(3,"",-1)]]>
<![CDATA[
]]>
<![CDATA[					If oSubField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[						Writelog("No SubField Created for Match " & xM & ". ")]]>
<![CDATA[
]]>
<![CDATA[						Exit for]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					oSubField.ID = sBaseName & CStr(MatchCount)]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Variable("Position") = cstr(iLeft) & "," & cstr(iTop) & "," & cstr(iRight) & "," & cstr(iBottom)]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Position:" & 	oSubField.Variable("Position"))		]]>
<![CDATA[
]]>
<![CDATA[					'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[					If nPage>1 then			]]>
<![CDATA[
]]>
<![CDATA[						If Ucase(FileMgr.GetFileName(oSubField.Variable("IMAGEFILE")))<>ucase(oPage.Variable(sMCCO & cstr(nPage))) then]]>
<![CDATA[
]]>
<![CDATA[                            If Trim(oPage.Variable(sMCCO & cstr(nPage)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[							    oSubField.Variable("IMAGEFILE")=oPage.Variable(sMCCO & cstr(nPage))]]>
<![CDATA[
]]>
<![CDATA[					        End if]]>
<![CDATA[
]]>
<![CDATA[                    	End if]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Variable("IMAGEHEIGHT")=nHeight]]>
<![CDATA[
]]>
<![CDATA[					End if				]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[					Call oSubField.CreateFields]]>
<![CDATA[
]]>
<![CDATA[					Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			MatchCount = MatchCount + 1	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			bFound = True]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	ElseIf len(oValueTop)=0 And len(oValueBtm)>0 Then]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		'We have a bottom value to search for ]]>
<![CDATA[
]]>
<![CDATA[		'modStrParamB = RegExBuild(bInteractive, bDebug, oValueBtm)]]>
<![CDATA[
]]>
<![CDATA[		'Note build RegEx or string implicitly here...]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Argorithm 3")]]>
<![CDATA[
]]>
<![CDATA[		amodStrParamB = Split(oValueBtm&"|","|")]]>
<![CDATA[
]]>
<![CDATA[		Writelog("setup pattern")]]>
<![CDATA[
]]>
<![CDATA[		For B = 0 to ubound(amodStrParamB)-1]]>
<![CDATA[
]]>
<![CDATA[			modStrParamB = modStrParamB & RegExBuild(bInteractive, bDebug, amodStrParamB(B))]]>
<![CDATA[
]]>
<![CDATA[			If B < ubound(amodStrParamB)-1 then modStrParamB = modStrParamB & "|"]]>
<![CDATA[
]]>
<![CDATA[		Next 'B]]>
<![CDATA[
]]>
<![CDATA[		Writelog("set pattern")]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = modStrParamB]]>
<![CDATA[
]]>
<![CDATA[		Writelog("get matches")]]>
<![CDATA[
]]>
<![CDATA[		Set bMatches = regEx.Execute(space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		writelog("Bottom Matches Count is :" & bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'Start position is the Top of the current CCO Pointer location's Next Line - default is current line bottom ]]>
<![CDATA[
]]>
<![CDATA[        Call CCO.GetCurrentPosition(tLine, tWord)]]>
<![CDATA[
]]>
<![CDATA[		If tLine<=1 and tWord<=1 then ]]>
<![CDATA[
]]>
<![CDATA[            iTop = CCO.Item(sLine).top]]>
<![CDATA[
]]>
<![CDATA[	    Else]]>
<![CDATA[
]]>
<![CDATA[            iTop = CCO.Item(sLine).bottom]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[        ]]>
<![CDATA[
]]>
<![CDATA[    	nPage= CCO.Item(sLine).ImageNum]]>
<![CDATA[
]]>
<![CDATA[		nHeight= CCO.Item(sLine).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If CCO.Count>=sLine+1 and Not(tLine<=1 and tWord<=1) then ]]>
<![CDATA[
]]>
<![CDATA[			iTop = CCO.Item(sLine+1).Top			]]>
<![CDATA[
]]>
<![CDATA[			nPage= CCO.Item(sLine+1).ImageNum	]]>
<![CDATA[
]]>
<![CDATA[			nHeight= CCO.Item(sLine+1).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		For xM = 1 to (bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[			Set bMatch = bMatches(xM-1)]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Matched Value: '" & cstr(MatchedTextValue(bMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[			Index = bMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[			PrevLine=0]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[			If CCO.LocateChar(Index, nLine, nWord) Then]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[                If PrevLine<nLine Then]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				    iBottom = CCO.Item(nline).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				    If bLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[					    If CCO.Count >= (nLine + bLineAdj) and (nline + bLineAdj>0) Then]]>
<![CDATA[
]]>
<![CDATA[						    Writelog("Adjusting line bottom up/down by " & bLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[						    iBottom = CCO.Item(nline + bLineAdj).Bottom]]>
<![CDATA[
]]>
<![CDATA[					    End if				 ]]>
<![CDATA[
]]>
<![CDATA[				    End if]]>
<![CDATA[
]]>
<![CDATA[    				]]>
<![CDATA[
]]>
<![CDATA[				    if arField(1)<=itop and arField(3)>=itop then]]>
<![CDATA[
]]>
<![CDATA[					    Set oSubField=CurrentObj.AddChild(3,"",-1)]]>
<![CDATA[
]]>
<![CDATA[					    If oSubField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[						    Writelog("No SubField Created for Match " & xM & ". ")]]>
<![CDATA[
]]>
<![CDATA[						    Exit for]]>
<![CDATA[
]]>
<![CDATA[					    End if]]>
<![CDATA[
]]>
<![CDATA[    					]]>
<![CDATA[
]]>
<![CDATA[					    oSubField.ID = sBaseName & CStr(MatchCount)]]>
<![CDATA[
]]>
<![CDATA[					    oSubField.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[					    oSubField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[					    oSubField.Variable("Position") = cstr(iLeft) & "," & cstr(iTop) & "," & cstr(iRight) & "," & cstr(iBottom)]]>
<![CDATA[
]]>
<![CDATA[					    Writelog("Position:" & 	oSubField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[					    'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[					    If nPage>1 then]]>
<![CDATA[
]]>
<![CDATA[						    If Ucase(FileMgr.GetFileName(oSubField.Variable("IMAGEFILE")))<>ucase(oPage.Variable(sMCCO & cstr(nPage))) then]]>
<![CDATA[
]]>
<![CDATA[							    If Trim(oPage.Variable(sMCCO & cstr(nPage)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[                                    oSubField.Variable("IMAGEFILE")=oPage.Variable(sMCCO & cstr(nPage))]]>
<![CDATA[
]]>
<![CDATA[			                    end if]]>
<![CDATA[
]]>
<![CDATA[            			    End if]]>
<![CDATA[
]]>
<![CDATA[						    oSubField.Variable("IMAGEHEIGHT")=nHeight]]>
<![CDATA[
]]>
<![CDATA[					    End if	]]>
<![CDATA[
]]>
<![CDATA[    								]]>
<![CDATA[
]]>
<![CDATA[					    Call oSubField.CreateFields]]>
<![CDATA[
]]>
<![CDATA[					    Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[				    End if]]>
<![CDATA[
]]>
<![CDATA[    				]]>
<![CDATA[
]]>
<![CDATA[				    'Next Line Top after Last Bottom Line becomes next Top - default is current bottom ]]>
<![CDATA[
]]>
<![CDATA[				    iTop = iBottom]]>
<![CDATA[
]]>
<![CDATA[                    If nLine+bLineAdj>CCO.Count Then nLine=CCO.Count-bLineAdj]]>
<![CDATA[
]]>
<![CDATA[				    nPage= CCO.Item(nLine+ bLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[				    nHeight= CCO.Item(nLine + bLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[    				]]>
<![CDATA[
]]>
<![CDATA[				    If (CCO.Count>=(nline+1+ bLineAdj)) Then ]]>
<![CDATA[
]]>
<![CDATA[					    iTop = CCO.Item(nline + 1 + bLineAdj).Top]]>
<![CDATA[
]]>
<![CDATA[					    nPage= CCO.Item(nLine + 1 + bLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[					    nHeight= CCO.Item(nLine + 1 + bLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[					    If tLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[						    If CCO.Count >= (nLine + 1 + tLineAdj + bLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[							    Writelog("Adjusting line Top up/down by " & tLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[							    iTop = CCO.Item(nline + 1 + tLineAdj + bLineAdj).Top ]]>
<![CDATA[
]]>
<![CDATA[							    nPage= CCO.Item(nline + 1 + tLineAdj + bLineAdj).ImageNum ]]>
<![CDATA[
]]>
<![CDATA[							    nHeight= CCO.Item(nLine + 1 + tLineAdj + bLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[						    End if]]>
<![CDATA[
]]>
<![CDATA[					    End if				 ]]>
<![CDATA[
]]>
<![CDATA[				    End if]]>
<![CDATA[
]]>
<![CDATA[    				]]>
<![CDATA[
]]>
<![CDATA[			    End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			    MatchCount = MatchCount + 1	]]>
<![CDATA[
]]>
<![CDATA[            end if]]>
<![CDATA[
]]>
<![CDATA[            PrevLine=nLine]]>
<![CDATA[
]]>
<![CDATA[			bFound = True]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		If Not(Pilot is Nothing)  And Not IsAlive(LogWindow) then Pilot.ChildrenChanged(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[		FindDataBlocks = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Matches Found")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set bMatch = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set tMatch = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set bMatches = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set tMatches = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set ZoneCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindRegExBlocks" access="public" bInter="bInter" bDebug="bDebug" strParam="Strparam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[	Dim modStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim Match]]>
<![CDATA[
]]>
<![CDATA[	Dim tMatches]]>
<![CDATA[
]]>
<![CDATA[	Dim bMatches]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[	Dim oValueTop]]>
<![CDATA[
]]>
<![CDATA[	Dim oValueBtm]]>
<![CDATA[
]]>
<![CDATA[	Dim nLine, nWord, pLine]]>
<![CDATA[
]]>
<![CDATA[	Dim index, tindex, bindex]]>
<![CDATA[
]]>
<![CDATA[	Dim MatchCount]]>
<![CDATA[
]]>
<![CDATA[	Dim ileft]]>
<![CDATA[
]]>
<![CDATA[	Dim iRight]]>
<![CDATA[
]]>
<![CDATA[	Dim iTop]]>
<![CDATA[
]]>
<![CDATA[	Dim iBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim oPage]]>
<![CDATA[
]]>
<![CDATA[	Dim sBasename]]>
<![CDATA[
]]>
<![CDATA[	Dim osubfield]]>
<![CDATA[
]]>
<![CDATA[	Dim iName ]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sLine, sWord, sLine2, sWord2]]>
<![CDATA[
]]>
<![CDATA[	Dim xM, bM, cM]]>
<![CDATA[
]]>
<![CDATA[	Dim tLineAdj, bLineAdj]]>
<![CDATA[
]]>
<![CDATA[	Dim sMCCO	]]>
<![CDATA[
]]>
<![CDATA[	Dim nPage]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	Dim tval]]>
<![CDATA[
]]>
<![CDATA[	Dim nHeight	]]>
<![CDATA[
]]>
<![CDATA[	Dim tLine,tWord]]>
<![CDATA[
]]>
<![CDATA[    	]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    FindRegExBlocks=FALSE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = CreateObject("VBScript.RegExp")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	regEx.IgnoreCase = True]]>
<![CDATA[
]]>
<![CDATA[	regEx.Global = True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Set Extremes]]>
<![CDATA[
]]>
<![CDATA[	iTop = clng(CCO.Bottom)]]>
<![CDATA[
]]>
<![CDATA[	iLeft = clng(CCO.Right)]]>
<![CDATA[
]]>
<![CDATA[	iRight = clng(CCO.Left)]]>
<![CDATA[
]]>
<![CDATA[	iBottom = clng(CCO.Top)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    'Find CCO Limits]]>
<![CDATA[
]]>
<![CDATA[	For cM = 1 to CCO.Count]]>
<![CDATA[
]]>
<![CDATA[		If iTop > clng(CCO.Item(cM).Top) Then iTop = clng(CCO.Item(cM).Top)]]>
<![CDATA[
]]>
<![CDATA[		If iLeft > clng(CCO.Item(cM).Left) Then iLeft = clng(CCO.Item(cM).Left)]]>
<![CDATA[
]]>
<![CDATA[		If iRight < clng(CCO.Item(cM).Right) Then iRight = clng(CCO.Item(cM).Right)]]>
<![CDATA[
]]>
<![CDATA[		If iBottom < clng(CCO.Item(cM).Bottom) Then iBottom = clng(CCO.Item(cM).Bottom)]]>
<![CDATA[
]]>
<![CDATA[	Next 'cM]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Get Child Base Name]]>
<![CDATA[
]]>
<![CDATA[	sBaseName = CurrentObj.SetupNode().GetRule(0).Name]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Set	oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While oPage.ObjectType>2 And Not(oPage.ObjectType<=1)]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Find Current Position limits]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If ubound(arField)<>3 then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[        if sPosition="" then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)]]>
<![CDATA[
]]>
<![CDATA[	If ubound(arField)=3 then ]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = clng(arField(0))]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = clng(arField(1))]]>
<![CDATA[
]]>
<![CDATA[		arField(2) = clng(arField(2))]]>
<![CDATA[
]]>
<![CDATA[		arField(3) = clng(arField(3))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = arField(0)-clng(10)]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = arField(1)-clng(10)]]>
<![CDATA[
]]>
<![CDATA[		If arField(2)>clng(0) then arField(2) = clng(arField(2))+clng(10)]]>
<![CDATA[
]]>
<![CDATA[		If arField(3)>clng(0) then arField(3) = clng(arField(3))+clng(10)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Establish Search Limits for ZEROED zone values]]>
<![CDATA[
]]>
<![CDATA[		If arField(0) <= clng(0) Then ]]>
<![CDATA[
]]>
<![CDATA[			arField(0) = clng(iLeft)]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If arField(1) <= clng(0) Then arField(1) = iTop]]>
<![CDATA[
]]>
<![CDATA[		If arField(2) > iRight Or arField(2) <= 0 Then arField(2) = iRight]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		'Find Lowest zoneCCO Position]]>
<![CDATA[
]]>
<![CDATA[		If arField(3) > iBottom Or arField(3) <= clng(0) Then arField(3) = iBottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If arField(0)>arField(2) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog("Swapping left and right zone positions")]]>
<![CDATA[
]]>
<![CDATA[			tval = arField(0)]]>
<![CDATA[
]]>
<![CDATA[			arField(0) = arField(2)]]>
<![CDATA[
]]>
<![CDATA[			arField(2) = tval]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If arField(1)>arField(3) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog("Swapping top and bottom zone positions")]]>
<![CDATA[
]]>
<![CDATA[			tval = arField(1)]]>
<![CDATA[
]]>
<![CDATA[			arField(1) = arField(3)]]>
<![CDATA[
]]>
<![CDATA[			arField(3) = tval]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		iLeft = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		iTop = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		iRight = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		arField=SplitNumber(cstr(iLeft & "," & iTop & "," & iRight & "," & iBottom))]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	    'Find Search Zone Text & Start Index]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Setup Start CCO Position.]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(sLine, sWord, sLine2, sWord2)]]>
<![CDATA[
]]>
<![CDATA[	If sLine=0 then sLine=1]]>
<![CDATA[
]]>
<![CDATA[	If sWord=0 then sWord=1]]>
<![CDATA[
]]>
<![CDATA[	If sLine2=0 then sLine2=1]]>
<![CDATA[
]]>
<![CDATA[	If sWord2=0 then sWord2=1]]>
<![CDATA[
]]>
<![CDATA[	If sLine2>=sLine then ]]>
<![CDATA[
]]>
<![CDATA[		sLine=sLine2]]>
<![CDATA[
]]>
<![CDATA[		sWord=sWord2		]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start CCO Position: Line='" & sLine & "' Word='" & sWord & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.LocateLines(arField(1),arField(3),LTop,LBottom)]]>
<![CDATA[
]]>
<![CDATA[	If LTop = 0 or LBottom = 0 then ]]>
<![CDATA[
]]>
<![CDATA[	    Writelog("No Recognition Characters in Search Area.")]]>
<![CDATA[
]]>
<![CDATA[	    Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Adjust Search Area to Start CCO Position	]]>
<![CDATA[
]]>
<![CDATA[	If sLine>LTop and sLine<LBottom Then ]]>
<![CDATA[
]]>
<![CDATA[		LTop = sLine]]>
<![CDATA[
]]>
<![CDATA[		If CCO.item(LTop).Count > sWord Then ]]>
<![CDATA[
]]>
<![CDATA[		    sWord = sWord + 1]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[		    sLine = sLine + 1 ]]>
<![CDATA[
]]>
<![CDATA[			sWord = 1]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[    If sWord=0 then sWord=1]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[    'GET START INDEX		           ]]>
<![CDATA[
]]>
<![CDATA[    StartIndex = CCO.LocateCharIndex(LTop,sWord)]]>
<![CDATA[
]]>
<![CDATA[    	    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Ascending Search from Line:'" & Ltop & "' Word:'" & sWord & "' to Line:'" & LBottom & "' Word:'" & CCO.Item(LBottom).count & "'")	]]>
<![CDATA[
]]>
<![CDATA[	'adjust search text for mid line word location]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If sWord>1 and LTop<LBottom Then]]>
<![CDATA[
]]>
<![CDATA[	    For y = sWord to CCO.Item(LTop).Count]]>
<![CDATA[
]]>
<![CDATA[	        str = str & CCO.Item(LTop).Item(y).Value & Space(1)]]>
<![CDATA[
]]>
<![CDATA[	    Next 'y]]>
<![CDATA[
]]>
<![CDATA[	    str = Trim(str) & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[	    LTop = LTop + 1]]>
<![CDATA[
]]>
<![CDATA[        sValue = sValue & str]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	    	  		]]>
<![CDATA[
]]>
<![CDATA[   	For x = LTop to LBottom	]]>
<![CDATA[
]]>
<![CDATA[   			str = Trim(CCO.Item(x).Value) ]]>
<![CDATA[
]]>
<![CDATA[   			If x<CCO.Count then str = str & vbcrlf]]>
<![CDATA[
]]>
<![CDATA[   	        sValue = sValue & str]]>
<![CDATA[
]]>
<![CDATA[	Next 'x]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Initialize MCCO Page Counter]]>
<![CDATA[
]]>
<![CDATA[	sMCCO=oPage.Variable("CCOBlock")]]>
<![CDATA[
]]>
<![CDATA[	If sMCCO<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = FileMgr.GetFileName(sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("MCCO file loaded: " & sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = sMCCO & "_"]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aStrParam = Split(StrParam,",")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	oValueTop = Trim(aStrParam(0))]]>
<![CDATA[
]]>
<![CDATA[	If ubound(aStrParam)>=1 Then oValueBtm = Trim(aStrParam(1))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find Line Adjustments]]>
<![CDATA[
]]>
<![CDATA[	If ubound(aStrParam)>=2 Then tLineAdj = Trim(aStrParam(2))	]]>
<![CDATA[
]]>
<![CDATA[	If ubound(aStrParam)>=3 Then bLineAdj = Trim(aStrParam(3))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Remove Plus sign (its a positive number anyway...)]]>
<![CDATA[
]]>
<![CDATA[	tLineAdj = replace(tLineAdj,"+","")]]>
<![CDATA[
]]>
<![CDATA[	bLineAdj = replace(bLineAdj,"+","")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Check for numeric value	]]>
<![CDATA[
]]>
<![CDATA[	If Not Isnumeric(tLineAdj) Then tLineadj = 0]]>
<![CDATA[
]]>
<![CDATA[	If Not Isnumeric(bLineAdj) Then bLineadj = 0]]>
<![CDATA[
]]>
<![CDATA[	tLineadj = clng(tLineadj)]]>
<![CDATA[
]]>
<![CDATA[	bLineAdj = clng(bLineadj)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	MatchCount = 1]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	FindRegExblocks = False]]>
<![CDATA[
]]>
<![CDATA[	modStrParamT = ""]]>
<![CDATA[
]]>
<![CDATA[	modStrParamB = ""]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Find Values: '" & oValueTop & "' to '" & oValueBtm & "'. ")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If len(oValueTop)>0 And len(oValueBtm)>0 Then ]]>
<![CDATA[
]]>
<![CDATA[		'We have a top & bottom value to search for]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Argorithm 1")]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = oValueTop]]>
<![CDATA[
]]>
<![CDATA[		Set tMatches = regEx.Execute(space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = oValueBtm]]>
<![CDATA[
]]>
<![CDATA[		Set bMatches = regEx.Execute(space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		writelog("Top Matches Count is :" & tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[		writelog("Bottom Matches Count is :" & bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[        'Set iBottom to 0]]>
<![CDATA[
]]>
<![CDATA[        iBottom = clng(0)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		For xM = 1 to (tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[			Set tMatch = tMatches(xM-1)]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Matched Value: '" & cstr(MatchedTextValue(tMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[			Index = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			If CCO.LocateChar(Index, nLine, nWord) Then]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				iTop = CCO.Item(nline).Top]]>
<![CDATA[
]]>
<![CDATA[				nPage = CCO.Item(nLine).ImageNum]]>
<![CDATA[
]]>
<![CDATA[				nHeight = CCO.Item(nLine).ImageHeight				]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				If tLineAdj<>clng(0) Then]]>
<![CDATA[
]]>
<![CDATA[					If CCO.Count >= (nLine + tLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Adjusting line Top up/down by " & tLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[						iTop = CCO.Item(nline+ tLineAdj).Top]]>
<![CDATA[
]]>
<![CDATA[						nPage= CCO.Item(nLine+ tLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[						nHeight= CCO.Item(nLine+ tLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[					End if				 ]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				'check that iTop is Below (>) last calculated iBottom.]]>
<![CDATA[
]]>
<![CDATA[				If iTop>iBottom Then 				]]>
<![CDATA[
]]>
<![CDATA[									]]>
<![CDATA[
]]>
<![CDATA[                    tIndex = CCO.LocateCharIndex(CCO.count,CCO.Item(CCO.Count).Count)]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					'CCO Line before Next Top Becomes default Bottom					]]>
<![CDATA[
]]>
<![CDATA[					If xM < tMatches.Count then ]]>
<![CDATA[
]]>
<![CDATA[						Set tMatch = tMatches(xM)]]>
<![CDATA[
]]>
<![CDATA[						tIndex = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[						If CCO.LocateChar(tIndex, nLine, nWord) Then iBottom = CCO.Item(nline-1).Bottom]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					'Look For Bottom Word match between Top word spans]]>
<![CDATA[
]]>
<![CDATA[					For bM = 1 to (bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[						Set bMatch = bMatches(bM-1)]]>
<![CDATA[
]]>
<![CDATA[						bIndex = bMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[						If (bIndex >= Index) And (bIndex <= tIndex) then]]>
<![CDATA[
]]>
<![CDATA[							If CCO.LocateChar(bIndex, nLine, nWord) Then ]]>
<![CDATA[
]]>
<![CDATA[								'Word Between span found]]>
<![CDATA[
]]>
<![CDATA[								iBottom = CCO.Item(nline).Bottom ]]>
<![CDATA[
]]>
<![CDATA[								WriteLog("Bottom Matched Value: '" & cstr(MatchedTextValue(bMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[								If bLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[									If CCO.Count >= (nLine + bLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[										Writelog("Adjusting line bottom up/down by " & bLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[										iBottom = CCO.Item(nline + bLineAdj).Bottom]]>
<![CDATA[
]]>
<![CDATA[									End if]]>
<![CDATA[
]]>
<![CDATA[								End if]]>
<![CDATA[
]]>
<![CDATA[								Exit For]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[					Next 'bM]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					if arField(1)<=itop and arField(3)>=itop then]]>
<![CDATA[
]]>
<![CDATA[						Set oSubField=CurrentObj.AddChild(3,"",-1)]]>
<![CDATA[
]]>
<![CDATA[						If oSubField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[							Writelog("No SubField Created for Match " & xM & ". ")]]>
<![CDATA[
]]>
<![CDATA[							Exit for]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[						oSubField.ID = sBaseName & CStr(MatchCount)]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Variable("Position") = cstr(iLeft) & "," & cstr(iTop) & "," & cstr(iRight) & "," & cstr(iBottom)]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Position:" & 	oSubField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[						'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[						If nPage>1 then]]>
<![CDATA[
]]>
<![CDATA[							If Ucase(FileMgr.GetFileName(oSubField.Variable("IMAGEFILE")))<>ucase(oPage.Variable(sMCCO & cstr(nPage))) then]]>
<![CDATA[
]]>
<![CDATA[                                If Trim(oPage.Variable(sMCCO & cstr(nPage)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[								    oSubField.Variable("IMAGEFILE")=oPage.Variable(sMCCO & cstr(nPage))]]>
<![CDATA[
]]>
<![CDATA[                                end if]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[							oSubField.Variable("IMAGEHEIGHT")=nHeight]]>
<![CDATA[
]]>
<![CDATA[						End if		]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[						Call oSubField.CreateFields]]>
<![CDATA[
]]>
<![CDATA[						Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					MatchCount = MatchCount + 1	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[					bFound = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	ElseIf len(oValueTop)>0 And len(oValueBtm)=0 Then]]>
<![CDATA[
]]>
<![CDATA[		'We have a top value to search for]]>
<![CDATA[
]]>
<![CDATA[		'modStrParamT = RegExBuild(bInteractive, bDebug, oValueTop)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Argorithm 2.1")]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = oValueTop]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		Set tMatches = regEx.Execute(space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		writelog("Top Matches Count is :" & tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[		For xM = 1 to (tMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[			Set tMatch = tMatches(xM-1)]]>
<![CDATA[
]]>
<![CDATA[			WriteLog("Matched Value: '" & cstr(MatchedTextValue(tMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[			Index = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			If CCO.LocateChar(Index, nLine, nWord) Then]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				iTop = CCO.Item(nline).Top]]>
<![CDATA[
]]>
<![CDATA[				nPage= CCO.Item(nLine).ImageNum]]>
<![CDATA[
]]>
<![CDATA[				nHeight= CCO.Item(nLine).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				If tLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[					If CCO.Count >= (nLine + tLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Adjusting line Top up/down by " & tLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[						iTop = CCO.Item(nline+ tLineAdj).Top]]>
<![CDATA[
]]>
<![CDATA[						nPage= CCO.Item(nLine+ tLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[						nHeight= CCO.Item(nLine+ tLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[					End if				 ]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				'iBottom = CCO.Item(CCO.Count).Bottom]]>
<![CDATA[
]]>
<![CDATA[				iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				'CCO Line before next match becomes bottom, cannot be same line or above]]>
<![CDATA[
]]>
<![CDATA[				Do While xM < tMatches.Count]]>
<![CDATA[
]]>
<![CDATA[					Set tMatch = tMatches(xM)]]>
<![CDATA[
]]>
<![CDATA[					Index = tMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[					If CCO.LocateChar(Index, nLineb, nWord) Then ]]>
<![CDATA[
]]>
<![CDATA[						iBottom = CCO.Item(nlineb-1).Bottom]]>
<![CDATA[
]]>
<![CDATA[						If bLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[							If CCO.Count >= (nLineb - 1 + bLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[								Writelog("Adjusting line bottom up/down by " & bLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[								iBottom = CCO.Item(nlineb - 1 + bLineAdj).Bottom							]]>
<![CDATA[
]]>
<![CDATA[							End if]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[						If iBottom>iTop And nLineb>nLine Then Exit Do]]>
<![CDATA[
]]>
<![CDATA[					End if	]]>
<![CDATA[
]]>
<![CDATA[					xM = xM + 1		]]>
<![CDATA[
]]>
<![CDATA[					'iBottom = CCO.Item(CCO.Count).Bottom]]>
<![CDATA[
]]>
<![CDATA[                    iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[				loop	 ]]>
<![CDATA[
]]>
<![CDATA[				'Wend]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				if arField(1)<=itop and arField(3)>=itop then]]>
<![CDATA[
]]>
<![CDATA[					Set oSubField=CurrentObj.AddChild(3,"",-1)]]>
<![CDATA[
]]>
<![CDATA[					If oSubField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[						Writelog("No SubField Created for Match " & xM & ". ")]]>
<![CDATA[
]]>
<![CDATA[						Exit for]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[					oSubField.ID = sBaseName & CStr(MatchCount)]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Variable("Position") = cstr(iLeft) & "," & cstr(iTop) & "," & cstr(iRight) & "," & cstr(iBottom)]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Position:" & 	oSubField.Variable("Position"))		]]>
<![CDATA[
]]>
<![CDATA[					'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[					If nPage>1 then			]]>
<![CDATA[
]]>
<![CDATA[						If Ucase(FileMgr.GetFileName(oSubField.Variable("IMAGEFILE")))<>ucase(oPage.Variable(sMCCO & cstr(nPage))) then]]>
<![CDATA[
]]>
<![CDATA[                            If Trim(oPage.Variable(sMCCO & cstr(nPage)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[    							oSubField.Variable("IMAGEFILE")=oPage.Variable(sMCCO & cstr(nPage))]]>
<![CDATA[
]]>
<![CDATA[                            end if]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Variable("IMAGEHEIGHT")=nHeight]]>
<![CDATA[
]]>
<![CDATA[					End if				]]>
<![CDATA[
]]>
<![CDATA[							]]>
<![CDATA[
]]>
<![CDATA[					Call oSubField.CreateFields]]>
<![CDATA[
]]>
<![CDATA[					Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			MatchCount = MatchCount + 1	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			bFound = True]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	ElseIf len(oValueTop)=0 And len(oValueBtm)>0 Then]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		'We have a bottom value to search for ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Argorithm 3")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		regEx.Pattern = oValueBtm]]>
<![CDATA[
]]>
<![CDATA[		Writelog("get matches")]]>
<![CDATA[
]]>
<![CDATA[		Set bMatches = regEx.Execute(Space(1) & sValue)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Check for RegEx Error - usually due to invalid Pattern syntax]]>
<![CDATA[
]]>
<![CDATA[    If Err.number<>0 then ]]>
<![CDATA[
]]>
<![CDATA[      Writelog(Space(3) & "Invalid Pattern '" & sDeleteString & "'")]]>
<![CDATA[
]]>
<![CDATA[      Err.Clear]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		writelog("Bottom Matches Count is :" & bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		'Start position is the Top of the current CCO Pointer location's Next Line - default is current line bottom]]>
<![CDATA[
]]>
<![CDATA[        Call CCO.GetCurrentPosition(tLine, tWord)]]>
<![CDATA[
]]>
<![CDATA[		If tLine<=1 and tWord<=1 then ]]>
<![CDATA[
]]>
<![CDATA[            iTop = CCO.Item(sLine).top]]>
<![CDATA[
]]>
<![CDATA[	    Else]]>
<![CDATA[
]]>
<![CDATA[            iTop = CCO.Item(sLine).bottom]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[        pLine=0]]>
<![CDATA[
]]>
<![CDATA[		nPage= CCO.Item(sLine).ImageNum]]>
<![CDATA[
]]>
<![CDATA[		nHeight= CCO.Item(sLine).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[		If CCO.Count>=sLine+1  and Not(tLine<=1 and tWord<=1) then ]]>
<![CDATA[
]]>
<![CDATA[			iTop = CCO.Item(sLine+1).Top			]]>
<![CDATA[
]]>
<![CDATA[			nPage= CCO.Item(sLine+1).ImageNum	]]>
<![CDATA[
]]>
<![CDATA[			nHeight= CCO.Item(sLine+1).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[		For xM = 1 to (bMatches.Count)]]>
<![CDATA[
]]>
<![CDATA[			Set bMatch = bMatches(xM-1)]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[			Index = bMatch.FirstIndex + StartIndex]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			If CCO.LocateChar(Index-1, nLine, nWord) Then]]>
<![CDATA[
]]>
<![CDATA[				    ]]>
<![CDATA[
]]>
<![CDATA[				iBottom = CCO.Item(nline).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				If bLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[					If CCO.Count >= (nLine + bLineAdj) and (nLine+bLineAdj>0) Then]]>
<![CDATA[
]]>
<![CDATA[						Writelog("Adjusting line bottom up/down by " & bLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[						iBottom = CCO.Item(nline + bLineAdj).Bottom]]>
<![CDATA[
]]>
<![CDATA[					End if				 ]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[				if arField(1)<=itop and arField(3)>=itop and pLine<nLine then]]>
<![CDATA[
]]>
<![CDATA[                    WriteLog("Matched Value: '" & cstr(MatchedTextValue(bMatch.value)) & "' ")]]>
<![CDATA[
]]>
<![CDATA[					Set oSubField=CurrentObj.AddChild(3,"",-1)]]>
<![CDATA[
]]>
<![CDATA[					If oSubField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[						Writelog("No SubField Created for Match " & xM & ". ")]]>
<![CDATA[
]]>
<![CDATA[						Exit for]]>
<![CDATA[
]]>
<![CDATA[					End if]]>
<![CDATA[
]]>
<![CDATA[					]]>
<![CDATA[
]]>
<![CDATA[					oSubField.ID = sBaseName & CStr(MatchCount)]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Variable("Position") = cstr(iLeft) & "," & cstr(iTop) & "," & cstr(iRight) & "," & cstr(iBottom)]]>
<![CDATA[
]]>
<![CDATA[					Writelog("Position:" & 	oSubField.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[					'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[					If nPage>1 then]]>
<![CDATA[
]]>
<![CDATA[						If Ucase(FileMgr.GetFileName(oSubField.Variable("IMAGEFILE")))<>ucase(oPage.Variable(sMCCO & cstr(nPage))) then]]>
<![CDATA[
]]>
<![CDATA[                            If Trim(oPage.Variable(sMCCO & cstr(nPage)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[    							oSubField.Variable("IMAGEFILE")=oPage.Variable(sMCCO & cstr(nPage))]]>
<![CDATA[
]]>
<![CDATA[                    	    end if]]>
<![CDATA[
]]>
<![CDATA[					    End if]]>
<![CDATA[
]]>
<![CDATA[						oSubField.Variable("IMAGEHEIGHT")=nHeight]]>
<![CDATA[
]]>
<![CDATA[					End if	]]>
<![CDATA[
]]>
<![CDATA[								]]>
<![CDATA[
]]>
<![CDATA[					Call oSubField.CreateFields]]>
<![CDATA[
]]>
<![CDATA[					Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[                                   ]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[				'Next Line Top after Last Bottom Line becomes next Top - default is current bottom ]]>
<![CDATA[
]]>
<![CDATA[                pLine=nLine]]>
<![CDATA[
]]>
<![CDATA[				iTop = iBottom]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[                If nLine+bLineAdj>CCO.Count Then nLine=CCO.Count-bLineAdj]]>
<![CDATA[
]]>
<![CDATA[    			           	]]>
<![CDATA[
]]>
<![CDATA[                nPage= CCO.Item(nLine+ bLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[	    		nHeight= CCO.Item(nLine + bLineAdj).ImageHeight	]]>
<![CDATA[
]]>
<![CDATA[		        ]]>
<![CDATA[
]]>
<![CDATA[				If (CCO.Count>=(nline+1+ bLineAdj)) Then ]]>
<![CDATA[
]]>
<![CDATA[					iTop = CCO.Item(nline + 1 + bLineAdj).Top]]>
<![CDATA[
]]>
<![CDATA[                    nPage= CCO.Item(nLine + 1 + bLineAdj).ImageNum]]>
<![CDATA[
]]>
<![CDATA[					nHeight= CCO.Item(nLine + 1 + bLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[					If tLineAdj<>0 Then]]>
<![CDATA[
]]>
<![CDATA[						If CCO.Count >= (nLine + 1 + tLineAdj + bLineAdj) Then]]>
<![CDATA[
]]>
<![CDATA[							Writelog("Adjusting line Top up/down by " & tLineAdj & ". ")]]>
<![CDATA[
]]>
<![CDATA[							iTop = CCO.Item(nline + 1 + tLineAdj + bLineAdj).Top ]]>
<![CDATA[
]]>
<![CDATA[                            nPage= CCO.Item(nline + 1 + tLineAdj + bLineAdj).ImageNum ]]>
<![CDATA[
]]>
<![CDATA[							nHeight= CCO.Item(nLine + 1 + tLineAdj + bLineAdj).ImageHeight]]>
<![CDATA[
]]>
<![CDATA[						End if]]>
<![CDATA[
]]>
<![CDATA[					End if				 ]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[			End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			MatchCount = MatchCount + 1	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[			bFound = True]]>
<![CDATA[
]]>
<![CDATA[		Next]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		If Not(Pilot is Nothing) And Not IsAlive(LogWindow) then Pilot.ChildrenChanged(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[		FindRegExblocks = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Matches Found")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set regEx = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set bMatch = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set tMatch = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set bMatches = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set tMatches = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set ZoneCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CalculateLocalOffset" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[	Dim sName	]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosName]]>
<![CDATA[
]]>
<![CDATA[	Dim sOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim aOffSet]]>
<![CDATA[
]]>
<![CDATA[	Dim nXoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim nYoffset]]>
<![CDATA[
]]>
<![CDATA[	Dim oPage]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CalculateLocalOffset=False]]>
<![CDATA[
]]>
<![CDATA[	sOffSet = ""]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set	oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While oPage.ObjectType>2 And Not(oPage.ObjectType<=1)]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sName=oPage.Variable("TemplateID")]]>
<![CDATA[
]]>
<![CDATA[	If len(sName)=0 then Writelog("No fingerprint ID for this Image found. SetupDCO zone information will not be loaded.")]]>
<![CDATA[
]]>
<![CDATA[	sPosName = "Pos" & sName]]>
<![CDATA[
]]>
<![CDATA[	Writelog("ReadZones for " & sPosName)]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find Setup zone position]]>
<![CDATA[
]]>
<![CDATA[	sZonePos=CurrentObj.Variable(sPosName)]]>
<![CDATA[
]]>
<![CDATA[	If sZonePos = "" or sZonePos = "0,0,0,0" or not(isnumeric(replace(sZonePos,",",""))) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Setup Zone Position Information Found.")		]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	aZonePos = splitnumber(sZonePos)]]>
<![CDATA[
]]>
<![CDATA[	Zx = clng(aZonePos(0))]]>
<![CDATA[
]]>
<![CDATA[	Zy = clng(aZonePos(1))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Find current component position	]]>
<![CDATA[
]]>
<![CDATA[	sPosition=CurrentObj.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[	If sPosition = "" or sPosition = "0,0,0,0" or not(isnumeric(replace(sPosition,",",""))) then ]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Committed Component Position Information Found. Checking CCO Position.")	]]>
<![CDATA[
]]>
<![CDATA[		Exit Function ]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	aCurrPos = splitnumber(sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Cx = clng(aCurrPos(0))]]>
<![CDATA[
]]>
<![CDATA[	Cy = clng(aCurrPos(1))]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Calculate Local Offset(s)]]>
<![CDATA[
]]>
<![CDATA[	nXoffSet = -1*(Cx-Zx)	]]>
<![CDATA[
]]>
<![CDATA[	nYoffSet = -1*(Cy-Zy)	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Instr(ucase(StrParam),"X")=0 Then nXoffSet = clng(0)]]>
<![CDATA[
]]>
<![CDATA[	If Instr(ucase(StrParam),"Y")=0 Then nYoffSet = clng(0)	]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nXoffSet)) or len(trim(nXoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nXoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("X offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	If Not(Isnumeric(nYoffSet)) or len(trim(nYoffSet))=0 then ]]>
<![CDATA[
]]>
<![CDATA[		nYoffset = 0]]>
<![CDATA[
]]>
<![CDATA[		writelog("Y offset value was not numeric or empty. Setting value to Zero.")]]>
<![CDATA[
]]>
<![CDATA[	end if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Offset(s) : " & nXoffset & "," & nYoffset)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Parent.Variable("Image_Offset") = cstr(nXoffSet) & "," & cstr(nYoffSet)]]>
<![CDATA[
]]>
<![CDATA[	CalculateLocalOffset=True]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<af name="InheritParentPosition" access="public" bInter="bInter" bDebug="bDebug" strParam="StrParam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[	Dim sType]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	InheritParentPosition=False	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Current Position of Field '" & oParent.Id & "' = '" & sPosition & "'.")]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Search for specified Parent]]>
<![CDATA[
]]>
<![CDATA[	StrParam=Trim(StrParam)	]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Looking for parent node '" & StrParam & "'....")]]>
<![CDATA[
]]>
<![CDATA[	While (oParent.Type<>StrParam or oParent.ID<>StrParam) and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If oParent.Type=StrParam or oParent.ID=StrParam then]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[		arField=SplitNumber(sPosition)	]]>
<![CDATA[
]]>
<![CDATA[		If ubound(arField)=3 then ]]>
<![CDATA[
]]>
<![CDATA[			CurrentObj.Variable("Position")=sPosition]]>
<![CDATA[
]]>
<![CDATA[			If oParent.Variable("IMAGEFILE")<>CurrentObj.Variable("IMAGEFILE") then]]>
<![CDATA[
]]>
<![CDATA[                If Trim(oParent.Variable("IMAGEFILE"))<>"" then]]>
<![CDATA[
]]>
<![CDATA[    				CurrentObj.Variable("IMAGEFILE")=oParent.Variable("IMAGEFILE")]]>
<![CDATA[
]]>
<![CDATA[	            end if]]>
<![CDATA[
]]>
<![CDATA[    		End if]]>
<![CDATA[
]]>
<![CDATA[			InheritParentPosition=true]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[			Writelog("Invalid Position information found.")]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Node of Type or ID '" & StrParam & "' was not found as a Parent of the calling Node. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[
]]>
	</g>
</af>
<af name="CreateBlockCCO" access="public" bInter="bInter" bDebug="bDebug">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Dim oRootPage]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	Dim sPosition]]>
<![CDATA[
]]>
<![CDATA[  Dim zoneCCO]]>
<![CDATA[
]]>
<![CDATA[  Dim iName]]>
<![CDATA[
]]>
<![CDATA[  Dim oPage]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	CreateBlockCCO = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oRootPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	While oRootPage.ObjectType > 2 And Not(oRootPage.ObjectType<=1)]]>
<![CDATA[
]]>
<![CDATA[		Set oRootPage = oRootPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	sPosition = currentObj.variable("Position")]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Analyzing zone '" & sPosition & "'.")]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set zoneCCO = CCOCreator.AnalyzeBlock(oRootPage.Imagename,arField(0),arField(1),arField(2),arField(3))	]]>
<![CDATA[
]]>
<![CDATA[	Call GetBlockChars(zoneCCO, arField(0),arField(1),arField(2),arField(3))]]>
<![CDATA[
]]>
<![CDATA[	  ]]>
<![CDATA[
]]>
<![CDATA[  '**** SAVE BLOCK CCO ****]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  Set	oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While oPage.ObjectType>2 And Not(oPage.ObjectType<=1)]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  iName = oPage.Imagename ]]>
<![CDATA[
]]>
<![CDATA[	iName = Left(iName, Len(iName)-4) & "_"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  sfileName = iName & CurrentObj.ID & ".CCO"]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[  Writelog("Saving BlockCCO file '" & sfileName & "'.")]]>
<![CDATA[
]]>
<![CDATA[	Call zoneCCO.Save(sfileName)]]>
<![CDATA[
]]>
<![CDATA[	CurrentObj.Variable("CCOBlock") = sfileName]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Set CCO = zoneCCO]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	If Err.Number=0 then CreateBlockCCO = True	]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
	</g>
</af>
<af name="FindBlocks_WhiteSpace" access="public" bInter="bInter" bDebug="bDebug" strParam="Strparam">
	<g>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[				]]>
<![CDATA[
]]>
<![CDATA[	Dim modStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sValue]]>
<![CDATA[
]]>
<![CDATA[	Dim Match]]>
<![CDATA[
]]>
<![CDATA[	Dim tMatches]]>
<![CDATA[
]]>
<![CDATA[	Dim bMatches]]>
<![CDATA[
]]>
<![CDATA[	Dim bFound]]>
<![CDATA[
]]>
<![CDATA[	Dim oValueTop]]>
<![CDATA[
]]>
<![CDATA[	Dim oValueBtm]]>
<![CDATA[
]]>
<![CDATA[	Dim nLine, nWord, pLine]]>
<![CDATA[
]]>
<![CDATA[	Dim index, tindex, bindex]]>
<![CDATA[
]]>
<![CDATA[	Dim MatchCount]]>
<![CDATA[
]]>
<![CDATA[	Dim ileft]]>
<![CDATA[
]]>
<![CDATA[	Dim iRight]]>
<![CDATA[
]]>
<![CDATA[	Dim iTop]]>
<![CDATA[
]]>
<![CDATA[	Dim iBottom]]>
<![CDATA[
]]>
<![CDATA[	Dim oPage]]>
<![CDATA[
]]>
<![CDATA[	Dim sBasename]]>
<![CDATA[
]]>
<![CDATA[	Dim osubfield]]>
<![CDATA[
]]>
<![CDATA[	Dim iName ]]>
<![CDATA[
]]>
<![CDATA[	Dim aStrParam]]>
<![CDATA[
]]>
<![CDATA[	Dim sLine, sWord, sLine2, sWord2]]>
<![CDATA[
]]>
<![CDATA[	Dim xM, bM, cM]]>
<![CDATA[
]]>
<![CDATA[	Dim tLineAdj, bLineAdj]]>
<![CDATA[
]]>
<![CDATA[	Dim sMCCO	]]>
<![CDATA[
]]>
<![CDATA[	Dim nPage]]>
<![CDATA[
]]>
<![CDATA[	Dim oParent]]>
<![CDATA[
]]>
<![CDATA[	Dim arField]]>
<![CDATA[
]]>
<![CDATA[	Dim tval]]>
<![CDATA[
]]>
<![CDATA[	Dim nHeight	]]>
<![CDATA[
]]>
<![CDATA[	Dim tLine,tWord]]>
<![CDATA[
]]>
<![CDATA[	Dim prevLine]]>
<![CDATA[
]]>
<![CDATA[  Dim oSetupNode]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[	On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    FindBlocks_WhiteSpace = FALSE]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If zn_IsCCOEmpty Then Exit Function]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Set Extremes]]>
<![CDATA[
]]>
<![CDATA[	iTop = clng(CCO.Bottom)]]>
<![CDATA[
]]>
<![CDATA[	iLeft = clng(CCO.Right)]]>
<![CDATA[
]]>
<![CDATA[	iRight = clng(CCO.Left)]]>
<![CDATA[
]]>
<![CDATA[	iBottom = clng(CCO.Top)]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	'Find CCO Limits]]>
<![CDATA[
]]>
<![CDATA[	For cM = 1 to CCO.Count]]>
<![CDATA[
]]>
<![CDATA[		If iTop > clng(CCO.Item(cM).Top) Then iTop = clng(CCO.Item(cM).Top)]]>
<![CDATA[
]]>
<![CDATA[		If iLeft > clng(CCO.Item(cM).Left) Then iLeft = clng(CCO.Item(cM).Left)]]>
<![CDATA[
]]>
<![CDATA[		If iRight < clng(CCO.Item(cM).Right) Then iRight = clng(CCO.Item(cM).Right)]]>
<![CDATA[
]]>
<![CDATA[		If iBottom < clng(CCO.Item(cM).Bottom) Then iBottom = clng(CCO.Item(cM).Bottom)]]>
<![CDATA[
]]>
<![CDATA[	Next 'cM]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	'Get Child Base Name]]>
<![CDATA[
]]>
<![CDATA[	Set oSetupNode = CurrentObj.SetupNode()]]>
<![CDATA[
]]>
<![CDATA[  If oSetupNode is Nothing then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Field Setup Node not found. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  If oSetupNode.NumOfRules<>1 then]]>
<![CDATA[
]]>
<![CDATA[    Writelog("No Subfields exists in the setup DCO for this field. Action requires a Parent/Child field relationship. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[    Exit Function]]>
<![CDATA[
]]>
<![CDATA[  End if]]>
<![CDATA[
]]>
<![CDATA[  ]]>
<![CDATA[
]]>
<![CDATA[  sBaseName = oSetupNode.GetRule(0).Name]]>
<![CDATA[
]]>
<![CDATA[	Set oSetupNode = Nothing	]]>
<![CDATA[
]]>
<![CDATA[    ]]>
<![CDATA[
]]>
<![CDATA[	Set	oPage = CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	While oPage.ObjectType>2 And Not(oPage.ObjectType<=1)]]>
<![CDATA[
]]>
<![CDATA[		Set oPage = oPage.Parent()]]>
<![CDATA[
]]>
<![CDATA[	Wend	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Find Current Position limits]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=CurrentObj]]>
<![CDATA[
]]>
<![CDATA[	sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	If ubound(arField)<>3 then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	While (sPosition="" Or sPosition="0,0,0,0") and oParent.objectType>1]]>
<![CDATA[
]]>
<![CDATA[		Set oParent = oParent.Parent()]]>
<![CDATA[
]]>
<![CDATA[		sPosition=trim(oParent.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[        if sPosition="" then sPosition="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[		Writelog("Position of " & oParent.Id & " = " & sPosition)]]>
<![CDATA[
]]>
<![CDATA[	Wend]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Set oParent=Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	arField=SplitNumber(sPosition)]]>
<![CDATA[
]]>
<![CDATA[	If ubound(arField)=3 then ]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = clng(arField(0))]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = clng(arField(1))]]>
<![CDATA[
]]>
<![CDATA[		arField(2) = clng(arField(2))]]>
<![CDATA[
]]>
<![CDATA[		arField(3) = clng(arField(3))]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		arField(0) = arField(0)-clng(10)]]>
<![CDATA[
]]>
<![CDATA[		arField(1) = arField(1)-clng(10)]]>
<![CDATA[
]]>
<![CDATA[		If arField(2)>clng(0) then arField(2) = clng(arField(2))+clng(10)]]>
<![CDATA[
]]>
<![CDATA[		If arField(3)>clng(0) then arField(3) = clng(arField(3))+clng(10)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		'Establish Search Limits for ZEROED zone values]]>
<![CDATA[
]]>
<![CDATA[		If arField(0) <= clng(0) Then ]]>
<![CDATA[
]]>
<![CDATA[			arField(0) = clng(iLeft)]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		If arField(1) <= clng(0) Then arField(1) = iTop]]>
<![CDATA[
]]>
<![CDATA[		If arField(2) > iRight Or arField(2) <= 0 Then arField(2) = iRight]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[		'Find Lowest zoneCCO Position]]>
<![CDATA[
]]>
<![CDATA[		If arField(3) > iBottom Or arField(3) <= clng(0) Then arField(3) = iBottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If arField(0)>arField(2) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog("Swapping left and right zone positions")]]>
<![CDATA[
]]>
<![CDATA[			tval = arField(0)]]>
<![CDATA[
]]>
<![CDATA[			arField(0) = arField(2)]]>
<![CDATA[
]]>
<![CDATA[			arField(2) = tval]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		If arField(1)>arField(3) Then]]>
<![CDATA[
]]>
<![CDATA[			writelog("Swapping top and bottom zone positions")]]>
<![CDATA[
]]>
<![CDATA[			tval = arField(1)]]>
<![CDATA[
]]>
<![CDATA[			arField(1) = arField(3)]]>
<![CDATA[
]]>
<![CDATA[			arField(3) = tval]]>
<![CDATA[
]]>
<![CDATA[		End If]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[		iLeft = arField(0)]]>
<![CDATA[
]]>
<![CDATA[		iTop = arField(1)]]>
<![CDATA[
]]>
<![CDATA[		iRight = arField(2)]]>
<![CDATA[
]]>
<![CDATA[		iBottom = arField(3)]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		arField=SplitNumber(cstr(iLeft & "," & iTop & "," & iRight & "," & iBottom))]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[    'Find Search Zone Text & Start Index]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Setup Start CCO Position.]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.GetCurrentPosition(sLine, sWord, sLine2, sWord2)]]>
<![CDATA[
]]>
<![CDATA[	If sLine=0 then sLine=1]]>
<![CDATA[
]]>
<![CDATA[	If sWord=0 then sWord=1]]>
<![CDATA[
]]>
<![CDATA[	If sLine2=0 then sLine2=1]]>
<![CDATA[
]]>
<![CDATA[	If sWord2=0 then sWord2=1]]>
<![CDATA[
]]>
<![CDATA[	If sLine2>=sLine then ]]>
<![CDATA[
]]>
<![CDATA[		sLine=sLine2]]>
<![CDATA[
]]>
<![CDATA[		sWord=sWord2		]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Writelog("Start CCO Position: Line='" & sLine & "' Word='" & sWord & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	Call CCO.LocateLines(arField(1),arField(3),LTop,LBottom)]]>
<![CDATA[
]]>
<![CDATA[	If LTop = 0 or LBottom = 0 then ]]>
<![CDATA[
]]>
<![CDATA[	    Writelog("No Recognition Characters in Search Area.")]]>
<![CDATA[
]]>
<![CDATA[	    Exit Function]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Adjust Search Area to Start CCO Position	]]>
<![CDATA[
]]>
<![CDATA[	If sLine>LTop and sLine<LBottom Then ]]>
<![CDATA[
]]>
<![CDATA[		LTop = sLine]]>
<![CDATA[
]]>
<![CDATA[		If CCO.item(LTop).Count > sWord Then ]]>
<![CDATA[
]]>
<![CDATA[		    sWord = sWord + 1]]>
<![CDATA[
]]>
<![CDATA[		Else]]>
<![CDATA[
]]>
<![CDATA[		    sLine = sLine + 1 ]]>
<![CDATA[
]]>
<![CDATA[			sWord = 1]]>
<![CDATA[
]]>
<![CDATA[		End if]]>
<![CDATA[
]]>
<![CDATA[	End if]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[    If sWord=0 then sWord=1]]>
<![CDATA[
]]>
<![CDATA[    	    ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Ascending Search from Line:'" & Ltop & "' Word:'" & sWord & "' to Line:'" & LBottom & "' Word:'" & CCO.Item(LBottom).count & "'")	]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	'Initialize MCCO Page Counter]]>
<![CDATA[
]]>
<![CDATA[	sMCCO=oPage.Variable("CCOBlock")]]>
<![CDATA[
]]>
<![CDATA[	If sMCCO<>"" Then ]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = FileMgr.GetFileName(sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		Writelog("MCCO file loaded: " & sMCCO)]]>
<![CDATA[
]]>
<![CDATA[		sMCCO = sMCCO & "_"]]>
<![CDATA[
]]>
<![CDATA[	End if	]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    'Check Parameter	]]>
<![CDATA[
]]>
<![CDATA[	nWhiteSpace = Trim(StrParam)]]>
<![CDATA[
]]>
<![CDATA[    If Not isnumeric(nWhiteSpace) or len(nWhiteSpace)=0 then ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Parameter must be a Number.")]]>
<![CDATA[
]]>
<![CDATA[	    Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	MatchCount = 1]]>
<![CDATA[
]]>
<![CDATA[	bFound = False]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[	WriteLog("Divide by Whitespace '" & nWhiteSpace & "' pixels.") ]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[    Dim Blocktop]]>
<![CDATA[
]]>
<![CDATA[    Dim BlockBottom]]>
<![CDATA[
]]>
<![CDATA[    Dim bBlock]]>
<![CDATA[
]]>
<![CDATA[    dim nAvg]]>
<![CDATA[
]]>
<![CDATA[    Dim nCount]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    BlockTop=0]]>
<![CDATA[
]]>
<![CDATA[    BlockBottom=0						]]>
<![CDATA[
]]>
<![CDATA[    bBlock=False	]]>
<![CDATA[
]]>
<![CDATA[    nAvg=0]]>
<![CDATA[
]]>
<![CDATA[    ncount=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    For nLine = Ltop to LBottom]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[        iThisTop = CCO.Item(nline).Top]]>
<![CDATA[
]]>
<![CDATA[	    iThisBottom = CCO.Item(nLine).Bottom]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If nLine = CCO.Count then]]>
<![CDATA[
]]>
<![CDATA[            iNextTop = CCO.Bottom]]>
<![CDATA[
]]>
<![CDATA[        Else]]>
<![CDATA[
]]>
<![CDATA[            iNextTop = CCO.Item(nline+1).Top]]>
<![CDATA[
]]>
<![CDATA[	        iNextBottom = CCO.Item(nLine+1).Bottom]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        'Calc Avg Line Height (only if below param of MAX height)]]>
<![CDATA[
]]>
<![CDATA[        If clng(iThisBottom-iThisTop)<=clng(nWhiteSpace) then]]>
<![CDATA[
]]>
<![CDATA[            nAvg = clng(nAvg) + clng(iThisBottom-iThisTop)]]>
<![CDATA[
]]>
<![CDATA[            ncount=ncount+1]]>
<![CDATA[
]]>
<![CDATA[        Else]]>
<![CDATA[
]]>
<![CDATA[            If clng(nAvg)=clng(0) and clng(nWhiteSpace)>clng(0) then ]]>
<![CDATA[
]]>
<![CDATA[                nAvg=Clng(nWhiteSpace)]]>
<![CDATA[
]]>
<![CDATA[                nCount=1]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[        cAvg = clng(nAvg/ncount) ]]>
<![CDATA[
]]>
<![CDATA[        Writelog(cstr(nLine) & " to " & nLine+1 & " : " & cstr(iNextTop-iThisBottom) & "  Avg h '" & cstr(cAvg) & "'")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[        If clng(iNextTop-iThisBottom)>=clng(nWhitespace) Then        ]]>
<![CDATA[
]]>
<![CDATA[            'WhiteSpaceFound!]]>
<![CDATA[
]]>
<![CDATA[            If BlockTop=0 then ]]>
<![CDATA[
]]>
<![CDATA[                BlockTop=nLine+1]]>
<![CDATA[
]]>
<![CDATA[                Writelog("First Top Set to line " & BlockTop)]]>
<![CDATA[
]]>
<![CDATA[            Else]]>
<![CDATA[
]]>
<![CDATA[                BlockBottom=nLine]]>
<![CDATA[
]]>
<![CDATA[                ]]>
<![CDATA[
]]>
<![CDATA[                Writelog("Creating Block Line " & BlockTop & " to " & BlockBottom)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[                nPage= CCO.Item(BlockTop).ImageNum]]>
<![CDATA[
]]>
<![CDATA[				nHeight= CCO.Item(BlockTop).ImageHeight		]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[                'CREATE BLOCK         ]]>
<![CDATA[
]]>
<![CDATA[				Set oSubField=CurrentObj.AddChild(3,"",-1)]]>
<![CDATA[
]]>
<![CDATA[				If oSubField is Nothing then ]]>
<![CDATA[
]]>
<![CDATA[					Writelog("No SubField Created for Match " & xM & ". ")]]>
<![CDATA[
]]>
<![CDATA[					Exit for]]>
<![CDATA[
]]>
<![CDATA[				End if]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[				oSubField.ID = sBaseName & CStr(MatchCount)]]>
<![CDATA[
]]>
<![CDATA[				oSubField.Type = sBaseName ]]>
<![CDATA[
]]>
<![CDATA[				oSubField.Status = 0]]>
<![CDATA[
]]>
<![CDATA[				oSubField.Variable("Position") = cstr(iLeft) & "," & cstr(CCO.Item(BlockTop).Top) & "," & cstr(iRight) & "," & cstr(CCO.Item(BlockBottom).Bottom)]]>
<![CDATA[
]]>
<![CDATA[				Writelog("Position:" & 	oSubField.Variable("Position"))		]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[				'Check for Page Reference]]>
<![CDATA[
]]>
<![CDATA[				If nPage>1 then			]]>
<![CDATA[
]]>
<![CDATA[					If Ucase(FileMgr.GetFileName(oSubField.Variable("IMAGEFILE")))<>ucase(oPage.Variable(sMCCO & cstr(nPage))) then]]>
<![CDATA[
]]>
<![CDATA[                        If Trim(oPage.Variable(sMCCO & cstr(nPage)))<>"" then]]>
<![CDATA[
]]>
<![CDATA[						    oSubField.Variable("IMAGEFILE")=oPage.Variable(sMCCO & cstr(nPage))]]>
<![CDATA[
]]>
<![CDATA[				        End if]]>
<![CDATA[
]]>
<![CDATA[                	End if]]>
<![CDATA[
]]>
<![CDATA[					oSubField.Variable("IMAGEHEIGHT")=nHeight]]>
<![CDATA[
]]>
<![CDATA[				End if				]]>
<![CDATA[
]]>
<![CDATA[						]]>
<![CDATA[
]]>
<![CDATA[				Call oSubField.CreateFields]]>
<![CDATA[
]]>
<![CDATA[				Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[			]]>
<![CDATA[
]]>
<![CDATA[                MatchCount = MatchCount + 1	]]>
<![CDATA[
]]>
<![CDATA[                BlockTop=BlockBottom+1]]>
<![CDATA[
]]>
<![CDATA[                Writelog("Top Of Next Block is " & BlockTop)]]>
<![CDATA[
]]>
<![CDATA[                bFound = True]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[            End if]]>
<![CDATA[
]]>
<![CDATA[        End if]]>
<![CDATA[
]]>
<![CDATA[			 ]]>
<![CDATA[
]]>
<![CDATA[	Next 'CCO line]]>
<![CDATA[
]]>
<![CDATA[		]]>
<![CDATA[
]]>
<![CDATA[	If bFound = True Then]]>
<![CDATA[
]]>
<![CDATA[		If Not(Pilot is Nothing)  And Not IsAlive(LogWindow) then Pilot.ChildrenChanged(CurrentObj)]]>
<![CDATA[
]]>
<![CDATA[		FindBlocks_WhiteSpace = True]]>
<![CDATA[
]]>
<![CDATA[	Else]]>
<![CDATA[
]]>
<![CDATA[		Writelog("No Matches Found")]]>
<![CDATA[
]]>
<![CDATA[	End If]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[	Set oPage = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set oSubField = Nothing]]>
<![CDATA[
]]>
<![CDATA[	Set ZoneCCO = Nothing]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
	</g>
</af>
<f name="MergeZones" access="public">
	<p name="SmartParameters">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[	   Dim sRect]]>
<![CDATA[
]]>
<![CDATA[     Dim arField]]>
<![CDATA[
]]>
<![CDATA[     Dim bZero]]>
<![CDATA[
]]>
<![CDATA[     Dim aParams]]>
<![CDATA[
]]>
<![CDATA[     Dim posCurObj]]>
<![CDATA[
]]>
<![CDATA[     Dim oNode]]>
<![CDATA[
]]>
<![CDATA[     Dim arMerged]]>
<![CDATA[
]]>
<![CDATA[     Dim sCurRect]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[     On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[     MergeZones=TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     'Array of SmartParameters]]>
<![CDATA[
]]>
<![CDATA[     aParams=Split(Trim(SmartParameters)&",", ",")]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[     'Check for Valid Calling Position]]>
<![CDATA[
]]>
<![CDATA[     sCurRect=Trim(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[     If len(sCurRect)=0 then sCurRect="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[     arMerged=SplitNumber(sCurRect)]]>
<![CDATA[
]]>
<![CDATA[     arMergedZone=arMerged]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[     If zn_ValidatePosition(arMerged,False) = False then  ]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Calling object has invalid position value:'" & sCurRect & "'")]]>
<![CDATA[
]]>
<![CDATA[        MergeZones=False]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[     End if        ]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     Writelog("Start Position='" & sCurRect )]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     For i = 0 to (ubound(aParams)-1)]]>
<![CDATA[
]]>
<![CDATA[       bZero=True ]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[       Set oNode=DCONav(aParams(i))]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[       If Not IsAlive(oNode) then]]>
<![CDATA[
]]>
<![CDATA[          Writelog("SmartParameter:'" & aParams(i) & "' could not find the requested node. The Position for this node will not be Merged.")]]>
<![CDATA[
]]>
<![CDATA[       Else]]>
<![CDATA[
]]>
<![CDATA[          'Check for Valid Position]]>
<![CDATA[
]]>
<![CDATA[          sRect=oNode.Variable("Position")]]>
<![CDATA[
]]>
<![CDATA[          Writelog("Position:'" & sRect & "'") 	]]>
<![CDATA[
]]>
<![CDATA[          arField=SplitNumber(sRect)]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          If UBound(arField)=3 Then  ]]>
<![CDATA[
]]>
<![CDATA[  	        If arField(0)>0 or arField(1)>0 or arField(2)=0 or arField(3)=0 Then ]]>
<![CDATA[
]]>
<![CDATA[              	bZero=False]]>
<![CDATA[
]]>
<![CDATA[              End if]]>
<![CDATA[
]]>
<![CDATA[          End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[          If bZero=True then]]>
<![CDATA[
]]>
<![CDATA[             Writelog("Position for node '" & oNode.ID & "' is not complete or ZERO (0,0,0,0). The Position for this node will not be Merged.")]]>
<![CDATA[
]]>
<![CDATA[          Else]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[             If sCurRect="0,0,0,0" Then ]]>
<![CDATA[
]]>
<![CDATA[                'If calling field is zero then set zone to first 'merged' zone]]>
<![CDATA[
]]>
<![CDATA[                sCurRect=sRect]]>
<![CDATA[
]]>
<![CDATA[                arMergedZone=arField]]>
<![CDATA[
]]>
<![CDATA[             Else]]>
<![CDATA[
]]>
<![CDATA[               'merge zone]]>
<![CDATA[
]]>
<![CDATA[               arMergedzone = CombineRect(arMergedzone,arField)]]>
<![CDATA[
]]>
<![CDATA[             End if]]>
<![CDATA[
]]>
<![CDATA[             ]]>
<![CDATA[
]]>
<![CDATA[          End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[       End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     Next 'i]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[     CurrentObj.variable("Position")=arMergedzone(0)& "," & arMergedzone(1) & "," & arMergedzone(2) & "," & arMergedzone(3)]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[     Writelog("New Position='" & CurrentObj.variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Call ErrorHandler("Function MergeZones")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<f name="PadZone" access="public">
	<p name="SmartParameters">
	</p>
	<g>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[  Dim aParams]]>
<![CDATA[
]]>
<![CDATA[  Dim L,T,R,B]]>
<![CDATA[
]]>
<![CDATA[  Dim arPaddedRect]]>
<![CDATA[
]]>
<![CDATA[  Dim arRect]]>
<![CDATA[
]]>
<![CDATA[  Dim sRect ]]>
<![CDATA[
]]>
<![CDATA[  Dim nParams]]>
<![CDATA[
]]>
<![CDATA[  Dim sPrimaryParse]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    On Error Resume Next]]>
<![CDATA[
]]>
<![CDATA[      ]]>
<![CDATA[
]]>
<![CDATA[    PadZone=TRUE]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Check for Valid Calling Position]]>
<![CDATA[
]]>
<![CDATA[    sRect=Trim(CurrentObj.Variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    If len(sRect)=0 then sRect="0,0,0,0"]]>
<![CDATA[
]]>
<![CDATA[    arRect=SplitNumber(sRect)]]>
<![CDATA[
]]>
<![CDATA[    arPaddedRect=arRect]]>
<![CDATA[
]]>
<![CDATA[	]]>
<![CDATA[
]]>
<![CDATA[    If zn_ValidatePosition(arRect,False) = False then  ]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Calling object has invalid position value:'" & sCurRect & "'")]]>
<![CDATA[
]]>
<![CDATA[      PadZone=False]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if ]]>
<![CDATA[
]]>
<![CDATA[           ]]>
<![CDATA[
]]>
<![CDATA[    If len(Trim(SmartParameters))=0 then]]>
<![CDATA[
]]>
<![CDATA[	      Writelog("No parameters value found. Exiting.")]]>
<![CDATA[
]]>
<![CDATA[	      PadZone=False]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Writelog("Start Position='" & sRect )]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    sPrimaryParse = Trim(MetaWord(SmartParameters))]]>
<![CDATA[
]]>
<![CDATA[    If len(sPrimaryParse)>0 then SmartParameters = sPrimaryParse]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    'Array of Parameters]]>
<![CDATA[
]]>
<![CDATA[    aParams=Split(Trim(SmartParameters) & "," , ",")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    nParams=cstr((Ubound(aParams)))]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    Select Case nParams]]>
<![CDATA[
]]>
<![CDATA[      Case "1"]]>
<![CDATA[
]]>
<![CDATA[        'One parameter - pad all LTRB by this value (i.e. expand if positive)]]>
<![CDATA[
]]>
<![CDATA[        L=MetaWord(aParams(0))]]>
<![CDATA[
]]>
<![CDATA[        T=L]]>
<![CDATA[
]]>
<![CDATA[        R=L]]>
<![CDATA[
]]>
<![CDATA[        B=L]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Number of Parameters '1'.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Case "2"]]>
<![CDATA[
]]>
<![CDATA[        'Two parameters - pad as X,Y (X: apply to L & R, Y: apply to T & B)]]>
<![CDATA[
]]>
<![CDATA[        L=MetaWord(aParams(0))]]>
<![CDATA[
]]>
<![CDATA[        T=MetaWord(aParams(1))]]>
<![CDATA[
]]>
<![CDATA[        R=L]]>
<![CDATA[
]]>
<![CDATA[        B=T]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Number of Parameters '2'.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Case "3","4"]]>
<![CDATA[
]]>
<![CDATA[        'Multi parameter - pad as L,T,R,B : missing values will be treated as zero.]]>
<![CDATA[
]]>
<![CDATA[        L=MetaWord(aParams(0))]]>
<![CDATA[
]]>
<![CDATA[        T=MetaWord(aParams(1))]]>
<![CDATA[
]]>
<![CDATA[        R=MetaWord(aParams(2))]]>
<![CDATA[
]]>
<![CDATA[        B=MetaWord(aParams(3))]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Number of Parameters '3'.")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[      Case Else]]>
<![CDATA[
]]>
<![CDATA[        'More than 4 parameters]]>
<![CDATA[
]]>
<![CDATA[        Writelog("Invalid Number of Parameters:'" & nParams & "'. Expecting 1-4")]]>
<![CDATA[
]]>
<![CDATA[        PadZone=False]]>
<![CDATA[
]]>
<![CDATA[        Exit Function]]>
<![CDATA[
]]>
<![CDATA[         ]]>
<![CDATA[
]]>
<![CDATA[	End Select]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If len(Trim(L))=0 then L=0]]>
<![CDATA[
]]>
<![CDATA[    If len(Trim(T))=0 then T=0]]>
<![CDATA[
]]>
<![CDATA[    If len(Trim(R))=0 then R=0]]>
<![CDATA[
]]>
<![CDATA[    If len(Trim(B))=0 then B=0]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    If Not(IsNumeric(L)) or Not(IsNumeric(T)) or Not(IsNumeric(R)) or Not(IsNumeric(B)) then]]>
<![CDATA[
]]>
<![CDATA[      Writelog("Non Numeric Pad Value. Exiting")]]>
<![CDATA[
]]>
<![CDATA[      PadZone=False]]>
<![CDATA[
]]>
<![CDATA[      Exit Function]]>
<![CDATA[
]]>
<![CDATA[    End if]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    arPaddedRect = PadRect(arRect,L,T,R,B)]]>
<![CDATA[
]]>
<![CDATA[    CurrentObj.variable("Position")=arPaddedRect(0)& "," & arPaddedRect(1) & "," & arPaddedRect(2) & "," & arPaddedRect(3)]]>
<![CDATA[
]]>
<![CDATA[     ]]>
<![CDATA[
]]>
<![CDATA[    Writelog("New Position='" & CurrentObj.variable("Position"))]]>
<![CDATA[
]]>
<![CDATA[    Call ErrorHandler("Function PadZone")]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[
]]>
<![CDATA[    ]]>
	</g>
</f>
<help>
  <![CDATA[
'************************************************************
' help.xml for Zones 

' Licensed Materials - Property of IBM
' “Restricted Materials of IBM”
' 5725-C15 5725-C69
'
' © Copyright IBM Corp. 1994, 2015 All Rights Reserved
'
' US Government Users Restricted Rights - Use, duplication or
' disclosure restricted by GSA ADP Schedule Contract with
' IBM Corp.
'
'************************************************************
]]>
  
<ref id="PopulateZNField" >
  <ap>None.</ap>
  <h>
    This action populates the field value with the full-page recognition results 
    (in the CCO) that fall within the field's zone boundaries.<br/><br/>
    
    <e>
      <b>PopulateZNField()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if a value is found. Otherwise, <b>False.</b></ret>
</ref>
  
<ref id="PopulateZNLineItemField" >
  <ap>None.</ap>
  <h>
    This action populates the field value with the full-page recognition results
    (in the CCO) that fall within a child field's zone boundaries of a LINEITEM parent field.<br/><br/>

    <e>
      <b>PopulateZNLineItemField()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if a value is found or if the calling field has no position information. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="RegisterPage" >
  <ap>None.</ap>
  <h>
    RegisterPage adjusts the y positions of special fields to 'dial in' zones to the current
    fingerprint's word locations. Searches the calling page object for run time field names beginning
    with the word 'Anchor' (case sensitive). Of these fields a search is performed for variables named
    'Word' followed by the calling fingerprint ID (example: 'Word555').  The value of the variable
    retrieved is search for in the current pages CCO, and if found the field's
    zone position is 'y' axis adjusted for any word 'drift' for the given field value.
    <e>
      <b>RegisterPage()</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ScanDetails" >
  <ap>None.</ap>
  <h>
    Searches the DETAILS Field object’s zone for instances of a LINEITEM Field object.
    Captures the data in the rows of a Line Item table, row by row.<br/><br/>
    
    This action will capture all potential LINEITEM rows within the parent DETAILS field – 
    even rows that may not fit your criteria for content.<br/><br/>
    
    Note: You will need to run additional RuleSets to delete ineligible Line Items.
    (In the <i>APT</i> application, these are the <b>Clean</b> and <b>Filter</b> RuleSets.)
    <e>
      <b>ScanDetails()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the bound <b>Field</b> object contains lines of data. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="ScanDetailsByLines" >
  <ap>Number of lines in each lineitem.</ap>
  <h>
    Searches the DETAILS Field object’s zone for instances of a LINEITEM Field object.  
    Captures the data based on the number of lines (parameter) in a Line Item table, row by row.<br/><br/>
    
    This action will capture all potential LINEITEM rows (consisting of 2 lines each) 
    within the parent DETAILS field – even rows that may not fit your criteria for content.<br/><br/>
    
    Note: You will need to run additional RuleSets to delete ineligible Line Items. 
    (In the <i>Invoices</i> application, these are the <b>Clean</b> and <b>Filter </b>RuleSets.)

    <e>
      <b>ScanDetailsByLines("2")</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the bound <b>Field</b> object contains lines of data. Otherwise, <b>False.</b>
  </ret>  
</ref>
  
<ref id="ScanDetailsByVSpace" >
  <ap>Number of vertical pixels in each lineitem.</ap>
  <h>
    Searches the DETAILS Field object’s zone for instances of a LINEITEM Field object.
    Captures the data based on the number of vertical pixels(parameter) in a Line Item table, row by row.
    <e>
      <b>ScanDetailsByLines("45")</b><br/><br/>
      
      This action will capture all potential LINEITEM rows (consisting of 45 pixels lines each) 
      within the parent DETAILS field – even rows that may not
      fit your criteria for content. <br/><br/>
      
      Note: You will need to run additional RuleSets to delete ineligible Line Items.
      (In the <i>Invoices</i> application, these are the <b>Clean</b> and <b>Filter </b>RuleSets.)
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    <b>True</b> if the bound <b>Field</b> object contains lines of data. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="ScanLineItem" >
  <ap>None.</ap>
  <h>
    This action will capture each sub-field within the <i>parent</i> LINEITEM row.
    <e>
      <b>ScanLineItem()</b>      
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret><b>False</b> if not called from a Field. Otherwise, <b>True.</b>
</ret>
</ref>
  
<ref id="ZoneTOP_UpperBound" >
  <ap>None.</ap>  
  <h>
    This action is helpful when experience shows that a certain number of values in 
    this field will be measurably shorter than the zone's height. A follow-up 
    <b>Locate</b> rule with this action will find those values.
    <e>
      <b>ZoneTOP_UpperBound()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneTOP_LowerBound" >
  <ap>None.</ap>  
  <h>
    This action uses the upper boundary of the current field's <b>zone</b> to indicate the bottom of 
    the field's <b>word.</b><br/><br/>
    
    <b><i>Important!</i></b>This action can expand or contract the zone's height, depending on the placement 
    of the word's lower boundary within the current page.<br/>
   <e>
     ZoneTOP_LowerBound()<br/>
     <br/>
     If you find that an unacceptably high percentage of values for a particular field are entered 
     a line too high, consider the use of this action in a follow-up <b>Locate</b> rule to search for 
     the misplaced value.
   </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneBOTTOM_UpperBound" >
  <ap>None.</ap>
  <h>
    Uses the lower boundary of the current field's ZONE to specify the top of the field's WORD. 
    This can result in a taller or shorter word, depending on the location of the zone's lower boundary.
    <e>
      ZoneBOTTOM_UpperBound()<br/>
      <br/>
      This action is helpful when experience shows that a certain number of values 
      in this field extend beyond the word's upper limit. A follow-up <b>Locate</b>
      rule with this action can find those values.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneBOTTOM_LowerBound" >
  <ap>None.</ap>
  <h>
    Uses the lower boundary of the current field's ZONE to specify the bottom of 
    the field's WORD. This can result in a taller or shorter word, depending on the 
    location of the zone's boundary.
    <e>
      <b>ZoneBOTTOM_LowerBound()</b><br/>
      <br/>
      If you find that an unacceptably high percentage of values for a particular field 
      are entered a line too high, consider the use of this action in a follow-up <b>Locate</b>
      rule to search for the misplaced value.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneLEFT_LeftBound" >
  <ap>None.</ap>
  <h>
    Uses the left boundary of the current field’s WORD to define the left edge of the field’s ZONE.  
    This extends the zone’s width to accommodate the current word.
    <e>
      <b>ZoneLEFT_LeftBound()</b><br/>
      <br/>
      If the field's <i>recognized</i> values occasionally reach beyond the zone's limits, 
      use this action to expand the zone appropriately.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneLEFT_RightBound" >
  <ap>None.</ap>
  <h>
    Uses the right boundary of the current field’s WORD to designate the left edge of the field’s ZONE. 
    This extends the zone’s width to accommodate the current word.
    <e>
      <b>ZoneLEFT_RightBound()</b><br/>
      <br/>
      <b><i>Note:</i></b> The image of a field is often larger than the field's zone, 
      and almost always larger than the field's word.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneRIGHT_LeftBound" >
  <ap>None.</ap>
  <h>
    Uses the left boundary of the current field’s WORD to designate the right edge of the field’s ZONE.
    Note: This action also excludes the word from the zone.
    <e>
      <b>ZoneRight_LeftBound()</b><br/>
      <br/>
      This action can clean the zone by eliminating the word it contains.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneRIGHT_RightBound" >
  <ap>None.</ap>
  <h>
    Uses the right boundary of the current field’s WORD to designate the right edge of the field’s ZONE.<br/><br/>
    This is a convenient action if you find that a certain percentage of 
    the field's entered values extend beyond, to the zone's right edge.
    <e>
      <b>ZoneRIGHT_RightBound()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneRIGHT_ImageRight" >
  <ap>None.</ap>
  <h>
    Uses the right boundary of the current field’s IMAGE to define the right edge of 
    the field’s ZONE. This can extend or contract the zone’s width, depending on the 
    placement of the image’s right side.<br/><br/>
    
    <b><i>Note:</i></b>A field's image is often larger than the field's zone, and
    almost always larger than the field's word.
  <e>
    <b>ZoneRight_ImageRight()</b>
  </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneLEFT_ImageLeft" >
  <ap>None.</ap>  
  <h>
    Uses the left boundary of the current field’s IMAGE to define the left edge of the field’s ZONE.  
    This can extend or contract the zone’s width, depending on the placement of the image’s left side.<br/><br/>
    
    <b><i>Note:</i></b> A field's image is often larger than a field's zone, 
    and almost always larger than the field's word.
  <e>
    <b>ZoneLEFT_ImageLeft()</b>
  </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneBOTTOM_ImageBottom" >
  <ap>None.</ap>
  <h>
    Uses the bottom boundary of the current field’s IMAGE to define the bottom edge of the field’s ZONE.<br/>
    <br/>
    <b><i>Note:</i></b> A field's image is often larger than a field's zone, 
    and almost always larger than the field's word.
  <e>
      <b>ZoneBOTTOM_ImageBottom()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="ZoneTOP_ImageTop" >
  <ap>None.</ap>
  <h>
    Uses the upper boundary of the current field’s IMAGE to designate the top edge of the field’s ZONE.
    This can extend or contract the zone’s width, depending on the placement of the image’s left side
    <e>
      <b>ZoneTOP_ImageTop()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="ReadZones" >
  <ap>None.</ap>  
  <h>
    Loads position information for each node in the calling object and it's children. Pre-adjusts 
    these values based on offset information stored in an 'Image_Offset' variable at any node level.<br/>
    Position information is based on the setup DCO position for the parent page's fingerprint ID.<br/> 
    The offset value is applied to all child objects of a node where an 'Image_Offset' variable is found; 
    unless overwritten by a child node also having an Image_Offset value to apply.
  </h>
  <lvl>Page or Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="LoadZones" >
  <ap>Fingerprint ID.</ap>
  <h>
    Loads position information for each node in the calling object and children. Pre-adjusts these
    values based on offset information stored in an 'Image_Offset' variable at any node level.<br/>
    Position information is based on the setup DCO position for the fingerprint ID passed as a parameter.<br/>
    The offset value is applied to all child objects of a node where an 'Image_Offset' variable is found;
    unless overwritten by a child node also having an Image_Offset value to apply.
  </h>
  <lvl>Page or Field level.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>

<ref id="FindZoneLineItems" >
  <ap>
    1. True or False<br/>
    <i>True</i> if the action is to create Line-item fields and their sub-fields.<br/><i>False</i> if
    the action is to create Line-item fields only.<br/>
    <br/>
    2. True or False (OPTIONAL: defaults to True)<br/>
    <i>True</i> if the action is to Analyze the calling zone and analyze word and line relationships based on the
    zone contents only for the search.<br/>
    <i>False</i> if the action is to use the existing word and line relationships (CCO for image).<br/>
    <br/>
    3. 1 or 2 (OPTIONAL: Fill Sub fields option - defaults to 1)<br/>
    1 - fill by CCO word; if the CCO words overlap by a certain intersection value then fill sub
    field with its value. Also has sub setting of a colon followed by a group words value. i.e.
    "1:1.5" (treat words 1.5 character spaces apart or closer as one word)<br/>
    2 - fill by CCO character; if the CCO characters overlap by a certain intersection value then
    fill sub field with the character value.<br/><br/>
    4. 0 to 100 (OPTIONAL: Percent offset adjustment - defaults to 0)<br/>
    Moderates the flexibility for the left offset based on the overall length of the line. Use larger
    values for shorter line items.<br/><br/>
    5. .01 to .99 (OPTIONAL: Intersection Ratio - defaults to .25)<br/>
    Changes the intersection ratio of Words and Lines used to determine creation and value of Lineitems
    and their subfields.<br/>
  </ap>
  <h>
    Uses settings for a previously-established zone covering a block of Line Item Detail, 
    and zones for individual Line Items, to assemble a portion of the current page, limited to Line Item Detail.
    <e>
      FindLineItems("True","","","","")<br/><br/>This action retrieves zonal information from the fingerprint
      about a block of Line Item Detail, individual rows, and their fields and sub-fields.
      <br/><br/>
      The action applies this data to the full-length current page. It will create a file with an extension of 
      cco (fingerprint format file) containing just Line Item Detail for use during batch processing. This file can 
      be discarded after batch processing has finished.
    </e>
  </h>
  <lvl>
    Field having 1 child field.
  </lvl>
  <ret>
    <b>False</b> if there is no zone or position information for the Line Item block and its sub-fields,
    or if the parent block does not contain Line Item children. Otherwise, <B>True.</B>
  </ret>
</ref>

<ref id="FindLineItems">
  <ap>
    5 comma separated parameters.  See the help for FindZoneLineItems for details.    
  </ap>
  <h>
    This action should not be used, as it is scheduled to be removed in future versions. It has been replaced by FindZoneLineItems.
  </h>
  <see>FindZoneLineItems</see>
</ref>
  
<ref id="MCCOPositionAdjust">
  <ap>None.</ap>
  <h>
    <b>MCCOPositionAdjust</b> is an important action for applications using merged multiple
    page documents. It normalizes position coordinates populated to the DCO when the data is
    generated from a document using a merged CCO. The coordinates are adjusted relative to 
    the page and also sets the DCO ImageFile property to the name of the TIFF that the data was 
    found on.<br/><br/>
    
    Note: All files to be merged MUST have an associated CCO file.
    
    Used in conjunction with action <b>MergeCCO_ByType</b> from the <b>Autodoc</b> library in a prior ruleset.<br/>
    <br/>
    <e>
      <b>MCCOPositionAdjust()</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if the current document does not consist of more than one source page, or if
    a page to be merged did not have an associated CCO file created. 
    Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="GetZoneText" qi="Retrieves the text in a zoned object of the current page.">
  <ap>None.</ap>
  <h>
    Retrieves the text in a zoned object of the current page.
    <e>
      <b>GetZoneText()</b><br/>
      <br/>
      This action assumes that you have established zone parameters for this <b>Field</b>
      object of the Document Hierarchy.
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="LoadBlockCCO" qi="Loads the CCOBlock set up by a previous CreateBlockCCO action. That action assigns the block's location to the current Page object's CCOBlock variable.">
  <ap>None.</ap>
  <ret>False if the block cannot be found. Otherwise, True.</ret>
  <h>
    Loads the CCOBlock set up by a previous CreateBlockCCO action. That action assigns
    the block's location to the current Page object's CCOBlock variable.
    <e>
      CreateBlockCCO()<br/>
      <b>LoadBlock()</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
</ref>
  
<ref id="AnchorPage" qi="Finds the Anchor field on a source page, and uses the Anchor field's coordinates to locate and offset the page's other zoned fields.">
  <ap>None.</ap>
  <h>
    Searches fields set as Anchor fields on a page, and uses the first matched field's coordinates to locate and offset all the page's other zoned fields. 
    Searches the calling page object for run time field names beginning with the word 'Anchor' (case sensitive).
    Of these fields a search is performed for dco variables named 'Word' followed by the calling fingerprint ID (example: 'Word555').
    The value of the variable is used to generate a search for the value within the Anchor field's zone in the page's CCO; and if found the page's
    zone positions are adjusted. <br/>  
    
    <e>AnchorPage()</e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if the action cannot find the page's Anchor field. Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="ZoneImage_SaveAs" qi="Saves the current Objects Zone area of an image as a separate Image file.">
  <ap>
    A string that defines the file name.<br/><br/>
    You can use these options to format the file name:<br/><br/>

    <b>+@BATCHID</b>   Adds the BatchID to the Zone Image File Name<br/>
    <b>+@ID</b>   Adds the Object ID to the Zone Image File Name"<br/>
    <b>+@STATUS</b>   Adds the Object Status to the Zone Image File Name<br/>
    <b>+@TYPE</b>   Adds the Object Type to Zone Image File Name<br/>
    <b>+@DATE+mm/dd/yyyy</b>   Adds a Date Stamp to the Zone Image File Name - the required trailing date format argument shows as the default, also '+*' can be used<br/>
    <b>+@TIME+HH:MM:SS</b>    Adds a Time Stamp Value to the Zone Image File Name name	- the required trailing time format argument shows as the default, also '+*' can be used<br/>
    <b>+@VALUE</b>   Adds Object Text to Zone Image File Name<br/>
    <b>+#name</b>   Appends the value of a child name to the Image File Name<br/><br/><b>Note:</b>+#name` appends the value of child name to the image name.
  </ap>

  <h>
    Saves the current Objects Zone area of an image as a separate Image file. 
    The Zone Image file is always placed in the Batches directory; saving to the 
    current page will create a multi-page TIFF file with the additional image as its zone.
    <e>
      <b>ZoneImage_SaveAs("SAMMY+@TYPE+@DATE+JJJ")</b><br/><br/>
      As part of a rule bound to the <i>Details</i> <b>Field</b> object 
      of the Document Hierarchy, the action produces this Image File Name: "...\SAMMYDETAILS243.tif"
    </e>
  </h>
  <lvl>Page or Field level.</lvl>
  <ret>
    <b>False</b> if an image cannot be saved. Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="AdjustZonesToImageOffset" qi="Offsets fields on the current image in response to zone criteria in the CCO file of the source page - after the image has been offset.">
  <ap>None.</ap>
  <h>
    Offsets fields on the current image in response to zone criteria in the CCO 
    file of the source page - after the image has been offset.
    <e>AdjustZonesToImageOffset()</e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>False</b> if the action cannot locate the CCO file of the current page or an image offset value does not exist for the current page. Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="SetEOL" qi="Sets the End of Line character that will be used to separate data from a zone with multiple lines of text. If this action is not used, the default character is a space.">
  <ap>The End of Line separator character.</ap>
  <h>
    Sets the End of Line character that will be used to separate data from a zone 
    with multiple lines of text. If this action is not used, the default character is a space.
    <e>
      <b>SetEOL("|")</b><br/>
      <br/>
      This example sets the End of Line character to the ‘|’ (pipe) character.  
      A capture zone with two lines of text will have the captured value separated 
      by this new character.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="SetEOL_CRLF" qi="Sets the End Of Line character that will be used to separate data from a zone with multiple lines of text.">
  <ap>None.</ap>
  <h>
    Sets the “End Of Line” character that will be used to separate data 
    from a zone with multiple lines of text to the carriage return and 
    Line Feed characters:  ASCII values 13 and 10.
    <e>
      <b>SetEOL_Crlf()</b><br/>
      <br/>
      This sets the End of Line character to the Carriage Return and Line 
      Feed characters.  A capture zone with two lines of text will have 
      the captured value separated by these characters.
    </e>
  </h>
  <lvl>All.</lvl>
  <ret>Always True</ret>
</ref>
  
<ref id="FindDataBlocks" qi="Uses Start and End key words to find blocks of data within the current source page.">
  <ap>Key word Start Value, and its End Value.</ap>
  <h>
    Uses Start and End key words to find blocks of data within the current source page. Returns each block's position assigned to a series of repeating fields based on the first child field of the calling object.
    If the page's Fingerprint file (.cco) has a Line position be sure to use action 'GoFirstLine()' to set the Line position to the first word on the first line in the current zone.
    <e>
      <b>GoFirstLine()</b><br/>
      <b>FindDataBlocks("FROM,THRU")</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True</b> if the action can locate the Data block indicated by the parameter. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="FindRegExBlocks" qi="Uses a Regular Expression to find blocks of data within the current source page. Returns each block's position assigned to a series of repeating fields based on the first child field of the calling object.">
  <ap>
    Regular Expression that contains the data block's Start Value, and its End Value. Parameter is a two part comma separated value of the Values to look for in the current CCO<br/><br/>
    
    1)StartValue<br/>
    2)EndValue<br/><br/>
    
    Start and End value's can be Adjusted up or down by xLines using the 3rd (adj top)
    and 4th (adj bottom) CSV positions.
  </ap>
  <h>
    Uses a Regular Expression to find blocks of data within the current source page. 
    Returns each block's position assigned to a series of repeating fields based 
    on the first child field of the calling object.
    Note: Locate.rra is required for this Action
    <e>
      <b>FindRegExBlocks("/bFROM/b,/bTHRU/b")</b>
    </e>
  </h>
  <lvl>Page level.</lvl>
  <ret>
    <b>True</b> if the action can locate the Data block indicated by the parameter. Otherwise, <b>False.</b>
  </ret>
</ref>
  
<ref id="CalculateLocalOffset" qi="Calculates the X and/or Y offset amount for the calling field.">
  <ap>
    X and/or Y<br/><br/>
    The action uses these parameters to calculate a new parent page Image_Offset 
    value by comparing the fingerprint zone for the calling field against the current field zone.
  </ap>
  <h>
    Calculates the X and/or Y offset amount for the calling field.
    <e>
      <b>CalculateLocalOffset("XY")</b>
    </e>
  </h>
  <lvl>Field only.</lvl>
  <ret>Always <b>True.</b></ret>
</ref>
  
<ref id="InheritParentPosition" qi="Provides the bound child object of the Document Hierarchy with the zone parameters of a parent object identified by the parameter.">
  <ap>
    Case-senstive string value of the parent object's name. <i>Details</i>, 
    for example, is the name of a parent <b>Field</b> object in the 
    <i>Invoices</i> application. If the bound object is <i>LINEITEM</i>, 
    the action will provide this child object with the zone parameters of the parent.
  </ap>
  <h>
    Provides the bound child object (a subfield of another field) of the Document Hierarchy with the zone 
    parameters of a parent object identified by the parameter.
    <e>
      <b>InheritParentPosition("Details")</b>
    </e>
  </h>
  <ret>
      <b>False</b> if the action cannot locate the parent field. Otherwise, <b>True.</b>
  </ret>
  <lvl>Field level.</lvl>
</ref>
  
<ref id="CreateBlockCCO" qi="Creates a temporary in memory CCO object, containing only the words and lines in the calling fields zone position - using the source page's CCO file.">
  <ap>None.</ap>  
  <h>
    Useful when searching images where the data is located asymmetrically across the page. Using this
    action focuses the CCO to only look at the words and lines within the defining zone for all future
    searches for this page.<br/>
    This does not affect the run time CCO. Reloading the page will reload the CCO bound to the page, 
    releasing this temporary CCO.
    <e>
      <b>CreateBlockCCO()</b>
    </e>
  </h>
  <lvl>Field level.</lvl>
  <ret>
    Always <b>True.</b>
  </ret>
</ref>
  
<ref id="FindBlocks_WhiteSpace" strParam="Strparam" qi="Uses a vertical white space (pixels) to find blocks of data within the current source page. Returns each block's position assigned to a series of repeating fields based on the first child field of the calling object.">
  <ap>A single parameter indicating the number of pixel between lines.</ap>
  <h>
    Creates a child field with the position of each zone divided out of the calling page's CCO.
    <e>
      <b>FindBlocks_WhiteSpace("27")</b>
    </e>
  </h>
  <lvl>Field having 1 child field.</lvl>
  <ret>
    <b>False</b> if the action cannot divide create any child field/zones. Otherwise, <b>True.</b>
  </ret>
</ref>
  
<ref id="MergeZones" qi="Merges the zone from calling field with zone of dco fields passed as smartparameters.">
    <ap>A CSV of SmartParameter strings indicating the DCO fields to merge zones with.</ap>
    <h>
      Merges calling field's position with each passed dco position.
      <e>
        <b>MergeZones("@P\5PAddTel,@P\5PAddZip,@P\2PatName")</b>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the calling field does not have a valid position value. Otherwise, <b>True.</b>
    </ret>
</ref>
  
<ref id="PadZone" qi="Pads the zone by the value passed. Number of CSV passed values varies padding value by vector.">
    <ap>A CSV of SmartParameter strings indicating the pixels value to pad the calling field by.</ap>
    <h>
      Pads calling field's position with each value passed. Number of passed values varies padding vector as follows:<br/>
      1) Pads Left, Top, Right, and Bottom by this value (i.e. expand if positive)<br/>
      2) Pads as X,Y (X: pad to Left and Right, Y: pad to Top and Bottom)<br/>
      3) Pads as Left, Top, Right, and Bottom. (missing values will be treated as zero).
      4) Pads as Left, Top, Right, and Bottom.
      <e>
        <b>PadZone("15")</b> Pads 15 pixels to the Left, Right, Top and Bottom position.<br/>
        <b>PadZone("5,10")</b> Pads 5 pixels to the Left and Right position, and 10 to the Top and Bottom position.<br/>
        <b>PadZone("-5,0,12,25")</b> Pads -5 pixels to the Left, 0 to the Right, 12 to the Top and 25 to the Bottom position.<br/>
      </e>
    </h>
    <lvl>Field level.</lvl>
    <ret>
      <b>False</b> if the calling field does not have a valid non zero position.<br/>
      <b>False</b> if there are zero or more than four CSV parameters.<br/>
      <b>False</b> if the SmartParameter value returns as a non-numeric.<br/>
      Otherwise, <b>True.</b>
    </ret>
</ref>
</help></rrx>
</rrx4all></rrxdescription>